<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="51795f05b21ad02430b19a88cef2e202a8914a5b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36552915" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="384f5-101">Implementa l'interfaccia dei socket Berkeley.</span>
      <span class="sxs-lookup">
        <span data-stu-id="384f5-101">Implements the Berkeley sockets interface.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-102">Il <xref:System.Net.Sockets.Socket> classe fornisce un ampio set di metodi e proprietà per le comunicazioni di rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="384f5-103">Il <xref:System.Net.Sockets.Socket> classe consente di eseguire sia sincrona e trasferimento asincrono dei dati utilizzando uno dei protocolli di comunicazione elencati nel <xref:System.Net.Sockets.ProtocolType> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="384f5-104">Il <xref:System.Net.Sockets.Socket> classe segua il modello di denominazione di .NET Framework per i metodi asincroni.</span><span class="sxs-lookup"><span data-stu-id="384f5-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="384f5-105">Ad esempio, sincroni <xref:System.Net.Sockets.Socket.Receive%2A> metodo corrisponde a asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> e <xref:System.Net.Sockets.Socket.EndReceive%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="384f5-106">Se l'applicazione richiede solo un thread durante l'esecuzione, utilizzare i metodi seguenti, che sono progettati per la modalità di funzionamento sincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="384f5-107">Se si utilizza un protocollo orientato alla connessione quali TCP, il server può restare in ascolto per le connessioni che utilizzano il <xref:System.Net.Sockets.Socket.Listen%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="384f5-108">Il <xref:System.Net.Sockets.Socket.Accept%2A> metodo elabora tutte le connessioni in entrata delle richieste e restituisce un <xref:System.Net.Sockets.Socket> che è possibile utilizzare per comunicare i dati con l'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="384f5-109">Utilizzare l'oggetto restituito <xref:System.Net.Sockets.Socket> per chiamare il <xref:System.Net.Sockets.Socket.Send%2A> o <xref:System.Net.Sockets.Socket.Receive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="384f5-110">Chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo prima di chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo se si desidera specificare il numero di porta e indirizzo IP locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="384f5-111">Se si desidera che il provider del servizio sottostante per assegnare una porta disponibile per l'utente, utilizzare un numero di porta pari a zero.</span><span class="sxs-lookup"><span data-stu-id="384f5-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="384f5-112">Se si desidera connettersi a un host in attesa, chiamare il <xref:System.Net.Sockets.Socket.Connect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="384f5-113">Per la comunicazione dati, chiamare il <xref:System.Net.Sockets.Socket.Send%2A> o <xref:System.Net.Sockets.Socket.Receive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="384f5-114">Se si utilizza un protocollo senza connessione, ad esempio UDP, è necessario per l'ascolto per le connessioni affatto.</span><span class="sxs-lookup"><span data-stu-id="384f5-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="384f5-115">Chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo per accettare i datagrammi in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="384f5-116">Utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo per l'invio di datagrammi a un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="384f5-117">Per elaborare le comunicazioni tramite un thread separato durante l'esecuzione, utilizzare i metodi seguenti, che sono progettati per la modalità operativa asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="384f5-118">Se si utilizza un protocollo orientato alla connessione quali TCP, utilizzare il <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, e <xref:System.Net.Sockets.Socket.EndConnect%2A> metodi per la connessione con un host in attesa.</span><span class="sxs-lookup"><span data-stu-id="384f5-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="384f5-119">Usare la <xref:System.Net.Sockets.Socket.BeginSend%2A> e <xref:System.Net.Sockets.Socket.EndSend%2A> oppure <xref:System.Net.Sockets.Socket.BeginReceive%2A> e <xref:System.Net.Sockets.Socket.EndReceive%2A> metodi per comunicare in modo asincrono i dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="384f5-120">Le richieste di connessione in ingresso possono essere elaborate tramite <xref:System.Net.Sockets.Socket.BeginAccept%2A> e <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="384f5-121">Se si utilizza un protocollo senza connessione, ad esempio UDP, è possibile utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> e <xref:System.Net.Sockets.Socket.EndSendTo%2A> per l'invio di datagrammi, e <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> e <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> per ricevere datagrammi.</span><span class="sxs-lookup"><span data-stu-id="384f5-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="384f5-122">Se si eseguono più operazioni asincrone in un socket, non necessariamente completati nell'ordine in cui sono state avviate.</span><span class="sxs-lookup"><span data-stu-id="384f5-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="384f5-123">Dopo avere completato l'invio e ricezione di dati, usare il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo per disabilitare il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-124">Dopo la chiamata <xref:System.Net.Sockets.Socket.Shutdown%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo per rilasciare tutte le risorse associate il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="384f5-125">Il <xref:System.Net.Sockets.Socket> classe consente di configurare il <xref:System.Net.Sockets.Socket> utilizzando il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="384f5-126">Recuperare le impostazioni utilizzando il <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-127">Se si sta scrivendo un'applicazione relativamente semplice e non richiedono le massime prestazioni, è consigliabile utilizzare <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, e <xref:System.Net.Sockets.UdpClient>.</span><span class="sxs-lookup"><span data-stu-id="384f5-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="384f5-128">Queste classi forniscono un'interfaccia semplice e intuitiva per <xref:System.Net.Sockets.Socket> le comunicazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-129">Nell'esempio di codice riportato di seguito viene illustrato il modo in cui <xref:System.Net.Sockets.Socket> classe può essere utilizzata per inviare dati a un server HTTP e ricevere la risposta.</span><span class="sxs-lookup"><span data-stu-id="384f5-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="384f5-130">Questo esempio si blocca fino a quando non viene ricevuto l'intera pagina.</span><span class="sxs-lookup"><span data-stu-id="384f5-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">
      <span data-ttu-id="384f5-131">per stabilire una connessione in uscita o accettare una richiesta in ingresso.</span>
      <span class="sxs-lookup">
        <span data-stu-id="384f5-131">To establish an outgoing connection or accept an incoming request.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="384f5-132">Le istanze di questa classe sono thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="384f5-132">Instances of this class are thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-133">Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-133">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">
          <span data-ttu-id="384f5-134">Le informazioni sul socket restituite da <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-134">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-135">Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.Socket" /> utilizzando il valore specificato restituito da <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-135">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-136">Se si chiama il <xref:System.Net.Sockets.Socket.%23ctor%2A> costruttore più volte con la stessa matrice di byte come argomento per ogni chiamata, si creeranno più gestito <xref:System.Net.Sockets.Socket>s con lo stesso socket sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-136">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="384f5-137">Questa pratica è fortemente sconsigliata.</span><span class="sxs-lookup"><span data-stu-id="384f5-137">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <span data-ttu-id="384f5-138">Uno dei valori di <see cref="T:System.Net.Sockets.SocketType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-138">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </param>
        <param name="protocolType">
          <span data-ttu-id="384f5-139">Uno dei valori di <see cref="T:System.Net.Sockets.ProtocolType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-139">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-140">Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.Socket" /> utilizzando il tipo di socket e il protocollo specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-140">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-141">Il `socketType` parametro specifica il tipo del <xref:System.Net.Sockets.Socket> classe e il `protocolType` parametro specifica il protocollo utilizzato dal <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-141">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-142">I due parametri non sono indipendenti.</span><span class="sxs-lookup"><span data-stu-id="384f5-142">The two parameters are not independent.</span></span> <span data-ttu-id="384f5-143">Spesso il <xref:System.Net.Sockets.Socket> tipo è implicita nel protocollo.</span><span class="sxs-lookup"><span data-stu-id="384f5-143">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="384f5-144">Se la combinazione di <xref:System.Net.Sockets.Socket> tipo e il protocollo tipo causa un valido <xref:System.Net.Sockets.Socket>, questo costruttore genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-144">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-145">Se il costruttore genera un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-145">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-146">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-146">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-147">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-147">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-148">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-148">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-149">Il risultato della combinazione di <paramref name="socketType" /> e <paramref name="protocolType" /> è un socket non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-149">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">
          <span data-ttu-id="384f5-150">Uno dei valori di <see cref="T:System.Net.Sockets.AddressFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-150">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span>
          </span>
        </param>
        <param name="socketType">
          <span data-ttu-id="384f5-151">Uno dei valori di <see cref="T:System.Net.Sockets.SocketType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-151">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </param>
        <param name="protocolType">
          <span data-ttu-id="384f5-152">Uno dei valori di <see cref="T:System.Net.Sockets.ProtocolType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-152">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-153">Inizializza una nuova istanza della classe <see cref="T:System.Net.Sockets.Socket" /> utilizzando la famiglia di indirizzi, il tipo di socket e il protocollo specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-153">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-154">Il `addressFamily` parametro specifica lo schema di indirizzamento che il <xref:System.Net.Sockets.Socket> classe viene utilizzato, il `socketType` parametro specifica il tipo del <xref:System.Net.Sockets.Socket> (classe) e il `protocolType` parametro specifica il protocollo utilizzato dal <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-154">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-155">I tre parametri non sono indipendenti.</span><span class="sxs-lookup"><span data-stu-id="384f5-155">The three parameters are not independent.</span></span> <span data-ttu-id="384f5-156">Alcune famiglie di indirizzi limitano e spesso è possono utilizzare i protocolli di <xref:System.Net.Sockets.Socket> tipo è implicita nel protocollo.</span><span class="sxs-lookup"><span data-stu-id="384f5-156">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="384f5-157">Se la combinazione della famiglia di indirizzi <xref:System.Net.Sockets.Socket> tipo e digitare i risultati in un oggetto non valido di protocollo <xref:System.Net.Sockets.Socket>, questo costruttore genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-157">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-158">Se il costruttore genera un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-158">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-159">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-159">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-160">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-160">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-161">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-161">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-162">Esempio di codice seguente viene illustrato come creare un'istanza di <xref:System.Net.Sockets.Socket> classe.</span><span class="sxs-lookup"><span data-stu-id="384f5-162">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-163">Il risultato della combinazione di <paramref name="addressFamily" />, <paramref name="socketType" /> e <paramref name="protocolType" /> è un socket non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-163">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="384f5-164">Crea un nuovo oggetto <see cref="T:System.Net.Sockets.Socket" /> per una nuova connessione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-164">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-165">
            <see cref="T:System.Net.Sockets.Socket" /> per una nuova connessione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-165">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-166"><xref:System.Net.Sockets.Socket.Accept%2A> in modo sincrono estrae la prima richiesta di connessione in sospeso dalla coda di richieste di connessione del socket in attesa, quindi crea e restituisce un nuovo <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-166"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-167">Non è possibile utilizzare l'oggetto restituito <xref:System.Net.Sockets.Socket> per accettare tutte le connessioni aggiuntive dalla coda di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-167">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="384f5-168">Tuttavia, è possibile chiamare il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> metodo dell'oggetto restituito <xref:System.Net.Sockets.Socket> per identificare il numero porta e indirizzo di rete dell'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-168">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="384f5-169">In modalità di blocco, <xref:System.Net.Sockets.Socket.Accept%2A> blocca fino a quando non viene accodato un tentativo di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-169">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="384f5-170">Una volta una connessione viene accettata, originale <xref:System.Net.Sockets.Socket> continua Accodamento connessione in ingresso finché non si chiude lo richiede.</span><span class="sxs-lookup"><span data-stu-id="384f5-170">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="384f5-171">Se si chiama questo metodo utilizza un non bloccante <xref:System.Net.Sockets.Socket>e nessuna connessione richieste vengono accodate, <xref:System.Net.Sockets.Socket.Accept%2A> genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-171">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-172">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-172">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-173">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-173">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-174">Prima di chiamare il <xref:System.Net.Sockets.Socket.Accept%2A> metodo, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per attendere e mettere in coda le richieste di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-174">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-175">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-175">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-176">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-176">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-177">Esempio di codice seguente accetta un semplice <xref:System.Net.Sockets.Socket> connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-177">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-178">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-178">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-179">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-179">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-180">Il socket preposto ad accettare la connessione non è in attesa di connessioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-180">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="384f5-181">È necessario chiamare i metodi <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-181">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-182">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-182">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-183">Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-183">Begins an asynchronous operation to accept an incoming connection attempt.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-184">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-184">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-185">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-185">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-186">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-186">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-187">L'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> nel parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo ha restituito il risultato, per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-187">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-188">I protocolli orientati alla connessione possono utilizzare il <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Cerca metodo in modo asincrono elaborare connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-188">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="384f5-189">Accettare le connessioni in modo asincrono offre la possibilità di inviare e ricevere dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-189">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="384f5-190">Prima di chiamare il <xref:System.Net.Sockets.Socket.AcceptAsync%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per attendere e mettere in coda le richieste di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-190">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="384f5-191">Per ricevere una notifica di completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegare e associarlo al <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="384f5-191">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="384f5-192">Le seguenti proprietà e gli eventi di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari:</span><span class="sxs-lookup"><span data-stu-id="384f5-192">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="384f5-193">Il chiamante può specificare facoltativamente un oggetto esistente <xref:System.Net.Sockets.Socket> da utilizzare per la connessione in ingresso, specificando il <xref:System.Net.Sockets.Socket> da utilizzare con il <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-193">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="384f5-194">Se il <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> proprietà è null, un nuovo <xref:System.Net.Sockets.Socket> costruito con lo stesso <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, e <xref:System.Net.Sockets.Socket.ProtocolType%2A> corrente <xref:System.Net.Sockets.Socket> e impostare come il <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-194">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="384f5-195">Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà per qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.AcceptAsync%2A> (metodo), in modo che le informazioni possano essere recuperate nel metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-195">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="384f5-196">Se il callback richiede più informazioni rispetto a un singolo oggetto, una classe piccola può essere creata per contenere le altre informazioni sullo stato necessarie come membri.</span><span class="sxs-lookup"><span data-stu-id="384f5-196">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="384f5-197">Facoltativamente, può fornire un buffer in cui ricevere il blocco iniziale dei dati sul socket dopo il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="384f5-197">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="384f5-198">In questo caso, il <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> proprietà deve essere impostata per il buffer che contiene i dati per la ricezione e la <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> proprietà deve essere impostata per il numero massimo di byte di dati per la ricezione nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-198">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="384f5-199">Queste proprietà possono essere impostate utilizzando il <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-199">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="384f5-200">Parte del buffer passato verrà utilizzate internamente per l'utilizzo dalla chiamata Winsock AcceptEx sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-200">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="384f5-201">Ciò significa che la quantità di dati restituiti sarà sempre inferiore al valore del <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> proprietà di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> istanza fornita.</span><span class="sxs-lookup"><span data-stu-id="384f5-201">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="384f5-202">La quantità di buffer utilizzato internamente varia in base alla famiglia di indirizzi del socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-202">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="384f5-203">Le dimensioni minime del buffer richieste sono 288 byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-203">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="384f5-204">Se viene specificata una dimensione del buffer più grande, il <xref:System.Net.Sockets.Socket> si aspetta di ricevere alcuni dati aggiuntivi diversi dai dati indirizzo ricevuti dalla chiamata Winsock AcceptEx e attenderà fino alla ricezione di tali dati aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="384f5-204">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="384f5-205">Se si verifica un timeout, la connessione viene reimpostata.</span><span class="sxs-lookup"><span data-stu-id="384f5-205">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="384f5-206">Pertanto se sono previsti dati aggiuntivi di una quantità specifica, le dimensioni del buffer devono essere impostate per le dimensioni minime del buffer più la quantità di memoria.</span><span class="sxs-lookup"><span data-stu-id="384f5-206">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="384f5-207">Il metodo di callback di completamento deve esaminare la <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> proprietà per determinare se il <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operazione ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="384f5-207">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="384f5-208">Il <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventi possono verificarsi in alcuni casi quando nessuna connessione è stata accettata, portando le <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> proprietà da impostare <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span><span class="sxs-lookup"><span data-stu-id="384f5-208">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="384f5-209">Ciò può verificarsi in seguito all'analisi delle porte tramite un'analisi di tipo SYN semiaperto (un SYN -> SYN ACK-> sequenza RST).</span><span class="sxs-lookup"><span data-stu-id="384f5-209">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="384f5-210">Applicazioni che utilizzano il <xref:System.Net.Sockets.Socket.AcceptAsync%2A> (metodo) deve essere preparato a gestire questa condizione.</span><span class="sxs-lookup"><span data-stu-id="384f5-210">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-211">Un argomento non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-211">An argument is not valid.</span>
          </span>
          <span data-ttu-id="384f5-212">Questa eccezione si verifica se il buffer fornito non è abbastanza grande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-212">This exception occurs if the buffer provided is not large enough.</span>
          </span>
          <span data-ttu-id="384f5-213">Il buffer deve essere di almeno 2 \* (sizeof(SOCKADDR_STORAGE + 16) byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-213">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span>
          </span>
          <span data-ttu-id="384f5-214">Questa eccezione si verifica anche se sono specificati più buffer e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> non è null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-214">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-215">Un argomento non è compreso nell'intervallo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-215">An argument is out of range.</span>
          </span>
          <span data-ttu-id="384f5-216">L'eccezione si verifica se l'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-216">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-217">È stata richiesta un'operazione non valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-217">An invalid operation was requested.</span>
          </span>
          <span data-ttu-id="384f5-218">Questa eccezione si verifica se l'oggetto <see cref="T:System.Net.Sockets.Socket" /> preposto ad accettare la connessione non è in attesa di connessioni o se il socket accettato è associato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-218">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span>
          </span>
          <span data-ttu-id="384f5-219">È necessario chiamare il metodo <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-219">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span>
          </span>
          <span data-ttu-id="384f5-220">Questa eccezione si verifica anche se il socket è già connesso o se un'operazione socket era già in corso utilizzando il parametro <paramref name="e" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-220">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-221">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-221">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-222">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-222">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-223">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-223">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-224">Ottiene la famiglia di indirizzi del <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-224">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-225">Uno dei valori di <see cref="T:System.Net.Sockets.AddressFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-225">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-226">Il <xref:System.Net.Sockets.AddressFamily> specifica lo schema di indirizzamento che un'istanza del <xref:System.Net.Sockets.Socket> classe può utilizzare.</span><span class="sxs-lookup"><span data-stu-id="384f5-226">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="384f5-227">Questa proprietà è di sola lettura e viene impostata quando il <xref:System.Net.Sockets.Socket> viene creato.</span><span class="sxs-lookup"><span data-stu-id="384f5-227">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-228">Consente di visualizzare esempio di codice seguente il <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> nella console.</span><span class="sxs-lookup"><span data-stu-id="384f5-228">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-229">Ottiene la quantità dei dati ricevuti dalla rete e disponibili per essere letti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-229">Gets the amount of data that has been received from the network and is available to be read.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-230">Numero di byte di dati ricevuti dalla rete e disponibili per essere letti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-230">The number of bytes of data received from the network and available to be read.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-231">Se si utilizza un non bloccante <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> è un buon metodo per stabilire se i dati sono in coda per la lettura, prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-231">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="384f5-232">I dati disponibili sono che la quantità totale di dati in coda nel buffer di rete per la lettura.</span><span class="sxs-lookup"><span data-stu-id="384f5-232">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="384f5-233">Se non sono accodati dati nel buffer di rete, <xref:System.Net.Sockets.Socket.Available%2A> restituisce 0.</span><span class="sxs-lookup"><span data-stu-id="384f5-233">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="384f5-234">Se l'host remoto viene arrestato o chiude la connessione <xref:System.Net.Sockets.Socket.Available%2A> può generare un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-234">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-235">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-235">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-236">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-236">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-237">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-237">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-238">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-238">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-239">Esempio di codice seguente vengono confrontati i risultati della chiamata di IOControl con FIONREAD e le proprietà disponibili.</span><span class="sxs-lookup"><span data-stu-id="384f5-239">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-240">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-240">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-241">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-241">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-242">Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-242">Begins an asynchronous operation to accept an incoming connection attempt.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="384f5-243">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-243">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-244">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-244">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-245">Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-245">Begins an asynchronous operation to accept an incoming connection attempt.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-246">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla creazione asincrona di <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-246">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-247">I protocolli orientati alla connessione possono utilizzare il <xref:System.Net.Sockets.Socket.BeginAccept%2A> Cerca metodo in modo asincrono elaborare connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-247">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="384f5-248">Accettare le connessioni in modo asincrono offre la possibilità di inviare e ricevere dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-248">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="384f5-249">Prima di chiamare il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per attendere e mettere in coda le richieste di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-249">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="384f5-250">È necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-250">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="384f5-251">A tale scopo, nel caso minimo, è necessario passare l'ascolto <xref:System.Net.Sockets.Socket> l'oggetto in <xref:System.Net.Sockets.Socket.BeginAccept%2A> tramite il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-251">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="384f5-252">Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-252">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-253">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-253">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-254">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-254">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="384f5-255">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, il sistema in genere utilizza un thread separato per eseguire il metodo di callback specificato e blocca il <xref:System.Net.Sockets.Socket.EndAccept%2A> fino a quando non viene recuperata una connessione in sospeso.</span><span class="sxs-lookup"><span data-stu-id="384f5-255">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="384f5-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> Restituisce un nuovo <xref:System.Net.Sockets.Socket> che è possibile utilizzare per inviare e ricevere dati con l'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="384f5-257">Non è possibile utilizzare l'oggetto restituito <xref:System.Net.Sockets.Socket> per accettare tutte le connessioni aggiuntive dalla coda di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-257">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="384f5-258">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, utilizzare <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-258">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-259">Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-259">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="384f5-260">Il sistema può utilizzare anche il thread chiamante per richiamare il metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-260">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="384f5-261">In questo caso, il <xref:System.IAsyncResult.CompletedSynchronously%2A> proprietà sull'oggetto restituito <xref:System.IAsyncResult> verrà impostata per indicare che il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo completato in modo sincrono.</span><span class="sxs-lookup"><span data-stu-id="384f5-261">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="384f5-262">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-262">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-263">Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo), chiudere il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-263">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-264">Quando il <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="384f5-264">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="384f5-265">Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.</span><span class="sxs-lookup"><span data-stu-id="384f5-265">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-266">È possibile usare il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà dell'oggetto restituito <xref:System.Net.Sockets.Socket> per identificare il numero porta e indirizzo di rete dell'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-266">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-267">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-267">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-268">Dopo aver ottenuto il codice, fare riferimento alla documentazione relativa ai codici di errore dell'API Windows Sockets versione 2 disponibile in MSDN per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-268">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-269">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-269">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-270">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-270">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-271">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-271">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-272">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-272">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-273">Esempio di codice seguente tenta di ricevere una connessione in ingresso in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="384f5-273">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-274">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-274">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-275">Per questo metodo è richiesto Windows NT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-275">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-276">Il socket preposto ad accettare la connessione non è in attesa di connessioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-276">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="384f5-277">È necessario chiamare i metodi <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-277">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
          <span data-ttu-id="384f5-278">- oppure - Il socket accettato è associato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-278">-or-  The accepted socket is bound.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-279">
            <paramref name="receiveSize" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-279">
              <paramref name="receiveSize" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-280">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-280">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">
          <span data-ttu-id="384f5-281">Numero di byte da accettare dal mittente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-281">The number of bytes to accept from the sender.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-282">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-282">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-283">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-283">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-284">Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso e riceve il primo blocco di dati inviato dall'applicazione client.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-284">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-285">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla creazione asincrona di <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-285">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-286">I protocolli orientati alla connessione possono utilizzare il <xref:System.Net.Sockets.Socket.BeginAccept%2A> Cerca metodo in modo asincrono elaborare connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-286">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="384f5-287">Accettare le connessioni in modo asincrono consente di inviare e ricevere dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-287">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="384f5-288">Questo overload consente di specificare il numero di byte da accettare durante il trasferimento iniziale nel `receiveSize` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-288">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="384f5-289">Prima di chiamare il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per attendere e mettere in coda le richieste di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-289">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="384f5-290">È necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-290">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="384f5-291">A tale scopo, nel caso minimo, è necessario passare l'ascolto <xref:System.Net.Sockets.Socket> l'oggetto in <xref:System.Net.Sockets.Socket.BeginAccept%2A> tramite il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-291">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="384f5-292">Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-292">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-293">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-293">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-294">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-294">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="384f5-295">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, il sistema in genere utilizza un thread separato per eseguire il metodo di callback specificato e blocca il <xref:System.Net.Sockets.Socket.EndAccept%2A> fino a quando non viene recuperata una connessione in sospeso.</span><span class="sxs-lookup"><span data-stu-id="384f5-295">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="384f5-296"><xref:System.Net.Sockets.Socket.EndAccept%2A> Restituisce un nuovo <xref:System.Net.Sockets.Socket> che è possibile utilizzare per inviare e ricevere dati con l'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-296"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="384f5-297">Non è possibile utilizzare l'oggetto restituito <xref:System.Net.Sockets.Socket> per accettare tutte le connessioni aggiuntive dalla coda di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-297">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="384f5-298">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, utilizzare <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-298">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-299">Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-299">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="384f5-300">Il sistema può utilizzare anche il thread chiamante per richiamare il metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-300">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="384f5-301">In questo caso, il <xref:System.IAsyncResult.CompletedSynchronously%2A> proprietà sull'oggetto restituito <xref:System.IAsyncResult> verrà impostata per indicare che il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo completato in modo sincrono.</span><span class="sxs-lookup"><span data-stu-id="384f5-301">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="384f5-302">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-302">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-303">Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo), chiudere il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-303">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="384f5-304">Quando il <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="384f5-304">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="384f5-305">Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.</span><span class="sxs-lookup"><span data-stu-id="384f5-305">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-306">È possibile chiamare usare il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà dell'oggetto restituito <xref:System.Net.Sockets.Socket> oggetto per identificare il numero porta e indirizzo di rete dell'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-306">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-307">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-307">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-308">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-308">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-309">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-309">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-310">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-310">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-311">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-311">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-312">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-312">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-313">Esempio di codice seguente consente di aprire un socket e accetta una connessione asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-313">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="384f5-314">In questo esempio, il socket accetta i primi 10 byte di dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-314">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="384f5-315">Il numero di byte ricevuti e i dati vengono visualizzati nella console per il delegato di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-315">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="384f5-316">Vedere <xref:System.Net.Sockets.Socket.BeginReceive%2A> per una descrizione di come viene ricevuti i dati rimanenti.</span><span class="sxs-lookup"><span data-stu-id="384f5-316">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-317">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-317">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-318">Per questo metodo è richiesto Windows NT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-318">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-319">Il socket preposto ad accettare la connessione non è in attesa di connessioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-319">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="384f5-320">È necessario chiamare i metodi <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-320">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
          <span data-ttu-id="384f5-321">- oppure - Il socket accettato è associato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-321">-or-  The accepted socket is bound.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-322">
            <paramref name="receiveSize" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-322">
              <paramref name="receiveSize" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-323">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-323">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">
          <span data-ttu-id="384f5-324">Oggetto <see cref="T:System.Net.Sockets.Socket" /> accettato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-324">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
          <span data-ttu-id="384f5-325">Questo valore può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-325">This value may be <see langword="null" />.</span>
          </span>
        </param>
        <param name="receiveSize">
          <span data-ttu-id="384f5-326">Il numero massimo dei byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-326">The maximum number of bytes to receive.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-327">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-327">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-328">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-328">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-329">Avvia un'operazione asincrona per accettare un tentativo di connessione in ingresso da un socket specificato e riceve il primo blocco di dati inviato dall'applicazione client.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-329">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-330">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla creazione asincrona dell'oggetto <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-330">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-331">I protocolli orientati alla connessione possono utilizzare il <xref:System.Net.Sockets.Socket.BeginAccept%2A> Cerca metodo in modo asincrono elaborare connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-331">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="384f5-332">Accettare le connessioni in modo asincrono offre la possibilità di inviare e ricevere dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-332">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="384f5-333">Questo overload consente di specificare il socket accettato nel `acceptSocket` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-333">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="384f5-334">Se questo parametro è `null`, viene creato il socket accettato dal <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-334">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="384f5-335">È possibile specificare il numero di byte da accettare durante il trasferimento iniziale nel `receiveSize` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-335">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="384f5-336">Prima di chiamare il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Listen%2A> metodo per attendere e mettere in coda le richieste di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-336">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="384f5-337">È necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-337">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="384f5-338">A tale scopo, nel caso minimo, è necessario passare l'ascolto <xref:System.Net.Sockets.Socket> l'oggetto in <xref:System.Net.Sockets.Socket.BeginAccept%2A> tramite il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-338">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="384f5-339">Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-339">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-340">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-340">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-341">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-341">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="384f5-342">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, il sistema in genere utilizza un thread separato per eseguire il metodo di callback specificato e blocca il <xref:System.Net.Sockets.Socket.EndAccept%2A> fino a quando non viene recuperata una connessione in sospeso.</span><span class="sxs-lookup"><span data-stu-id="384f5-342">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="384f5-343"><xref:System.Net.Sockets.Socket.EndAccept%2A> Restituisce un nuovo <xref:System.Net.Sockets.Socket> che è possibile utilizzare per inviare e ricevere dati con l'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-343"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="384f5-344">Non è possibile utilizzare l'oggetto restituito <xref:System.Net.Sockets.Socket> per accettare tutte le connessioni aggiuntive dalla coda di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-344">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="384f5-345">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, utilizzare <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-345">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-346">Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-346">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="384f5-347">Il sistema può utilizzare anche il thread chiamante per richiamare il metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-347">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="384f5-348">In questo caso, il <xref:System.IAsyncResult.CompletedSynchronously%2A> proprietà sull'oggetto restituito <xref:System.IAsyncResult> verrà impostata per indicare che il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo completato in modo sincrono.</span><span class="sxs-lookup"><span data-stu-id="384f5-348">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="384f5-349">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-349">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-350">Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo), chiudere il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-350">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-351">Quando il <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="384f5-351">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="384f5-352">Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.</span><span class="sxs-lookup"><span data-stu-id="384f5-352">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-353">È possibile usare il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà dell'oggetto restituito <xref:System.Net.Sockets.Socket> oggetto per identificare il numero porta e indirizzo di rete dell'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-353">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-354">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-354">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-355">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-355">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-356">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-356">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-357">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-357">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-358">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-358">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-359">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-359">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-360">Esempio di codice seguente consente di aprire un socket e accetta una connessione asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-360">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="384f5-361">In questo esempio, il socket accetta i primi 10 byte di dati e il `acceptSocket` parametro `null`, che impone il <xref:System.Net.Sockets.Socket.BeginAccept%2A> i metodi per creare il socket accettato.</span><span class="sxs-lookup"><span data-stu-id="384f5-361">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="384f5-362">Il numero di byte ricevuti e i dati vengono visualizzati nella console per il delegato di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-362">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="384f5-363">Vedere <xref:System.Net.Sockets.Socket.BeginReceive%2A> per una descrizione di come viene ricevuti i dati rimanenti.</span><span class="sxs-lookup"><span data-stu-id="384f5-363">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-364">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-364">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-365">Per questo metodo è richiesto Windows NT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-365">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-366">Il socket preposto ad accettare la connessione non è in attesa di connessioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-366">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="384f5-367">È necessario chiamare i metodi <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> prima di chiamare il metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-367">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
          <span data-ttu-id="384f5-368">- oppure - Il socket accettato è associato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-368">-or-  The accepted socket is bound.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-369">
            <paramref name="receiveSize" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-369">
              <paramref name="receiveSize" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-370">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-370">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-371">Avvia una richiesta asincrona di una connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-371">Begins an asynchronous request for a remote host connection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">To be added.</param>
        <param name="end_point">To be added.</param>
        <param name="callback">
          <span data-ttu-id="384f5-372">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-372">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-373">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-373">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-374">Avvia una richiesta asincrona di una connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-374">Begins an asynchronous request for a remote host connection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-375">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla connessione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-375">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-376">Se si utilizza un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo avvia una richiesta asincrona di una connessione per il `remoteEP` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-376">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="384f5-377">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.BeginConnect%2A> stabilisce un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-377">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="384f5-378">La connessione o l'impostazione in modo asincrono l'host remoto predefinito offre la possibilità di inviare e ricevere dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-378">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="384f5-379">È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-379">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="384f5-380">Nel caso minimo, è necessario passare il <xref:System.Net.Sockets.Socket> al <xref:System.Net.Sockets.Socket.BeginConnect%2A> tramite il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-380">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="384f5-381">Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket>e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-381">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="384f5-382">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-382">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-383">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-383">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="384f5-384">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, il sistema utilizzerà un thread separato per eseguire il metodo di callback specificato e verrà bloccata sul <xref:System.Net.Sockets.Socket.EndConnect%2A> fino a quando non la <xref:System.Net.Sockets.Socket> si connette correttamente o genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-384">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="384f5-385">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo, utilizzare <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-385">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="384f5-386">Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-386">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="384f5-387">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-387">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-388">Se si utilizza un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.BeginConnect%2A> prima di inviare e ricevere dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-388">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="384f5-389">È possibile utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> e <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> per comunicare con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-389">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="384f5-390">Se si chiama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-390">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="384f5-391">Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è prima necessario chiamare <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e impostare Broadcast su `true`.</span><span class="sxs-lookup"><span data-stu-id="384f5-391">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="384f5-392">Se non puoi <xref:System.Net.Sockets.Socket.BeginConnect%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-392">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-393">Se si utilizza un protocollo orientato alla connessione e non chiamare <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.BeginConnect%2A>, il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale più appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-393">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="384f5-394">Se si utilizza un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non si chiama il <xref:System.Net.Sockets.Socket.BeginSend%2A> o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-394">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-395">Se si desidera modificare l'host remoto predefinito, chiamare il <xref:System.Net.Sockets.Socket.BeginConnect%2A> nuovamente metodo con l'endpoint desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-395">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="384f5-396">Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> (metodo), chiudere il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-396">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-397">Quando il <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="384f5-397">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="384f5-398">Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.</span><span class="sxs-lookup"><span data-stu-id="384f5-398">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-399">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-399">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-400">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-400">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-401">Se questo socket è stato disconnesso in precedenza, quindi <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve essere chiamato su un thread che si chiuderà fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-401">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="384f5-402">Si tratta di una limitazione del provider sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-402">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-403">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-403">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-404">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-404">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-405">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-405">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-406">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-406">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-407">Esempio di codice seguente avvia un tentativo di connessione asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-407">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-408">
            <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-408">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-409">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-409">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-410">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-410">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-411">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-411">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-412">
            <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o è già in corso un'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-412">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="384f5-413">
            <see cref="T:System.Net.IPAddress" /> dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-413">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="384f5-414">Numero di porta dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-414">The port number of the remote host.</span>
          </span>
        </param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">
          <span data-ttu-id="384f5-415">Oggetto definito dall'utente che contiene informazioni sull'operazione di connessione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-415">A user-defined object that contains information about the connect operation.</span>
          </span>
          <span data-ttu-id="384f5-416">Questo oggetto viene passato al delegato <c>requestCallback</c> al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-416">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-417">Avvia una richiesta asincrona di una connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-417">Begins an asynchronous request for a remote host connection.</span>
          </span>
          <span data-ttu-id="384f5-418">L'host remoto viene specificato da un <see cref="T:System.Net.IPAddress" /> e da un numero di porta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-418">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-419">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla connessione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-419">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-420">Asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-420">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="384f5-421">Dopo aver interrotto un' `requestCallback` dell'oggetto, è possibile utilizzare il  metodo per riavviarlo.</span><span class="sxs-lookup"><span data-stu-id="384f5-421">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="384f5-422">Questo metodo non è bloccata fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-422">This method does not block until the operation is complete.</span></span> <span data-ttu-id="384f5-423">Per il blocco fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Connect%2A> overload del metodo o <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-423">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="384f5-424">Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> (metodo), chiudere il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-424">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-425">Quando il <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="384f5-425">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="384f5-426">Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.</span><span class="sxs-lookup"><span data-stu-id="384f5-426">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="384f5-427">Il gestore di timeout definisce i limiti di timeout di connessione per questo oggetto [ istanza.](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="384f5-427">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-428">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-428">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-429">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-429">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-430">Se questo socket è stato disconnesso in precedenza, quindi <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve essere chiamato su un thread che si chiuderà fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-430">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="384f5-431">Si tratta di una limitazione del provider sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-431">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="384f5-432">Anche il <xref:System.Net.EndPoint> vale a dire utilizzato deve essere diverso.</span><span class="sxs-lookup"><span data-stu-id="384f5-432">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-433">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-433">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-434">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-434">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-435">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-435">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-436">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-436">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-437">Esempio di codice seguente avvia un tentativo di connessione asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-437">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-438">
            <paramref name="address" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-438">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-439">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-439">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-440">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-440">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-441">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è incluso nella famiglia di socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-441">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-442">Il numero di porta non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-442">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-443">La lunghezza di <paramref name="address" /> è zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-443">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-444">
            <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o è già in corso un'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-444">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">
          <span data-ttu-id="384f5-445">Almeno un <see cref="T:System.Net.IPAddress" />, che specifica l'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-445">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="384f5-446">Numero di porta dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-446">The port number of the remote host.</span>
          </span>
        </param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">
          <span data-ttu-id="384f5-447">Oggetto definito dall'utente che contiene informazioni sull'operazione di connessione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-447">A user-defined object that contains information about the connect operation.</span>
          </span>
          <span data-ttu-id="384f5-448">Questo oggetto viene passato al delegato <c>requestCallback</c> al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-448">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-449">Avvia una richiesta asincrona di una connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-449">Begins an asynchronous request for a remote host connection.</span>
          </span>
          <span data-ttu-id="384f5-450">L'host viene specificato da una matrice di <see cref="T:System.Net.IPAddress" /> e un numero di porta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-450">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-451">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alle connessioni asincrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-451">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-452">Asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-452">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="384f5-453">Dopo aver interrotto un' `requestCallback` dell'oggetto, è possibile utilizzare il  metodo per riavviarlo.</span><span class="sxs-lookup"><span data-stu-id="384f5-453">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="384f5-454">Questo metodo non è bloccata fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-454">This method does not block until the operation is complete.</span></span> <span data-ttu-id="384f5-455">Per il blocco fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Connect%2A> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-455">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="384f5-456">Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> (metodo), chiudere il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-456">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-457">Quando il <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="384f5-457">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="384f5-458">Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.</span><span class="sxs-lookup"><span data-stu-id="384f5-458">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="384f5-459">Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-459">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-460">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-460">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-461">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-461">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-462">Se questo socket è stato disconnesso in precedenza, quindi <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve essere chiamato su un thread che si chiuderà fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-462">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="384f5-463">Si tratta di una limitazione del provider sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-463">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="384f5-464">Anche il <xref:System.Net.EndPoint> vale a dire utilizzato deve essere diverso.</span><span class="sxs-lookup"><span data-stu-id="384f5-464">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-465">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-465">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-466">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-466">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-467">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-467">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-468">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-468">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-469">Esempio di codice seguente avvia un tentativo di connessione asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-469">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-470">
            <paramref name="addresses" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-470">
              <paramref name="addresses" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-471">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-471">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-472">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-472">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-473">Questo metodo è valido per i socket che utilizzano <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-473">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-474">Il numero di porta non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-474">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-475">La lunghezza di <paramref name="address" /> è zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-475">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-476">
            <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o è già in corso un'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-476">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="384f5-477">Il nome dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-477">The name of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="384f5-478">Numero di porta dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-478">The port number of the remote host.</span>
          </span>
        </param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">
          <span data-ttu-id="384f5-479">Oggetto definito dall'utente che contiene informazioni sull'operazione di connessione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-479">A user-defined object that contains information about the connect operation.</span>
          </span>
          <span data-ttu-id="384f5-480">Questo oggetto viene passato al delegato <c>requestCallback</c> al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-480">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-481">Avvia una richiesta asincrona di una connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-481">Begins an asynchronous request for a remote host connection.</span>
          </span>
          <span data-ttu-id="384f5-482">L'host viene specificato da un nome host e da un numero di porta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-482">The host is specified by a host name and a port number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-483">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla connessione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-483">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-484">Asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-484">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="384f5-485">Dopo aver interrotto un' `requestCallback` dell'oggetto, è possibile utilizzare il  metodo per riavviarlo.</span><span class="sxs-lookup"><span data-stu-id="384f5-485">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="384f5-486">Questo metodo non è bloccata fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-486">This method does not block until the operation is complete.</span></span> <span data-ttu-id="384f5-487">Per il blocco fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Connect%2A> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-487">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="384f5-488">Per annullare una chiamata in sospeso per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> (metodo), chiudere il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-488">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-489">Quando il <xref:System.Net.Sockets.Socket.Close%2A> metodo viene chiamato mentre è in corso un'operazione asincrona, il callback fornito per il <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="384f5-489">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="384f5-490">Una chiamata successiva per la <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo genererà un' <xref:System.ObjectDisposedException> per indicare che l'operazione è stata annullata.</span><span class="sxs-lookup"><span data-stu-id="384f5-490">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="384f5-491">Il gestore di timeout definisce i limiti di timeout di connessione per questo oggetto [ istanza.](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="384f5-491">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-492">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-492">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-493">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-493">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-494">Se questo socket è stato disconnesso in precedenza, quindi <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve essere chiamato su un thread che si chiuderà fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-494">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="384f5-495">Si tratta di una limitazione del provider sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-495">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="384f5-496">Anche il <xref:System.Net.EndPoint> vale a dire utilizzato deve essere diverso.</span><span class="sxs-lookup"><span data-stu-id="384f5-496">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-497">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-497">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-498">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-498">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-499">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-499">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-500">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-500">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-501">Esempio di codice seguente avvia un tentativo di connessione asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-501">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-502">
            <paramref name="host" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-502">
              <paramref name="host" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-503">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-503">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-504">Questo metodo è valido per i socket della famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-504">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-505">Il numero di porta non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-505">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-506">
            <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o è già in corso un'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-506">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="384f5-507">
            <see langword="true" /> se il socket può essere riutilizzato una volta chiusa la connessione; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-507">
              <see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-508">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-508">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-509">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-509">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-510">Avvia una richiesta asincrona di disconnessione da un endpoint remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-510">Begins an asynchronous request to disconnect from a remote endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-511">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-511">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-512">Se si utilizza un protocollo orientato alla connessione, è possibile chiamare il <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> metodo per la richiesta di disconnessione da un endpoint remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-512">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="384f5-513">Se `reuseSocket` è `true`, è possibile riutilizzare il socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-513">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="384f5-514">Il <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> metodo utilizza un thread separato per richiamare il metodo di callback specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-514">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="384f5-515">Il <xref:System.Net.Sockets.Socket.EndDisconnect%2A> metodo si blocca finché la disconnessione in sospeso è stata completata.</span><span class="sxs-lookup"><span data-stu-id="384f5-515">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="384f5-516">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-516">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-517">Se si riceve un <xref:System.Net.Sockets.SocketException> eccezione, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-517">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-518">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-518">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-519">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-519">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-520">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-520">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-521">Esempio di codice seguente crea un socket per la comunicazione asincrona e vengono inviati dati a un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-521">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="384f5-522">Quando i dati sono stati inviati, <xref:System.Net.Sockets.Socket.Shutdown%2A> viene chiamato per arrestare l'invio e ricezione attività.</span><span class="sxs-lookup"><span data-stu-id="384f5-522">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="384f5-523">Quindi <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> viene chiamato per avviare una richiesta di disconnessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-523">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="384f5-524">Al completamento della richiesta, il <xref:System.Net.Sockets.Socket.Connected%2A> viene eseguita una query sulla proprietà per verificare se il socket è disconnesso.</span><span class="sxs-lookup"><span data-stu-id="384f5-524">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-525">Il sistema operativo è Windows 2000 o versioni precedenti e il metodo richiede Windows XP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-525">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-526">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-526">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-527">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-527">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-528">Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-528">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-529">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-529">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-530">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-530">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-531">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-531">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-532">Oggetto definito dall'utente contenente informazioni sull'operazione di ricezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-532">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="384f5-533">Questo oggetto viene passato al delegato <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-533">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-534">Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-534">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-535">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-535">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-536">Asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-536">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="384f5-537">Dopo aver interrotto un' `callback` dell'oggetto, è possibile utilizzare il  metodo per riavviarlo.</span><span class="sxs-lookup"><span data-stu-id="384f5-537">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="384f5-538">Questo metodo non è bloccata fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-538">This method does not block until the operation is complete.</span></span> <span data-ttu-id="384f5-539">Per il blocco fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Receive%2A> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-539">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="384f5-540">Per annullare un in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-540">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-541">Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-541">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-542">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-542">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-543">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-543">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-544">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-544">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-545">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-545">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-546">`state` rappresenta un'istanza di una classe definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="384f5-546">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-547">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-547">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-548">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-548">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-549">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-549">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-550">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-550">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-551">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-551">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-552">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-552">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-553">Il <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-553">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-554">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-554">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-555">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-555">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="384f5-556">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-556">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-557">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-557">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-558">Oggetto definito dall'utente contenente informazioni sull'operazione di ricezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-558">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="384f5-559">Questo oggetto viene passato al delegato <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-559">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-560">Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-560">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-561">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-561">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-562">Asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-562">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="384f5-563">Dopo aver interrotto un' `callback` dell'oggetto, è possibile utilizzare il  metodo per riavviarlo.</span><span class="sxs-lookup"><span data-stu-id="384f5-563">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="384f5-564">Questo metodo non è bloccata fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-564">This method does not block until the operation is complete.</span></span> <span data-ttu-id="384f5-565">Per il blocco fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Receive%2A> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-565">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="384f5-566">Per annullare un in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-566">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-567">Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-567">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-568">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-568">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-569">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-569">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-570">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-570">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-571">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-571">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-572">`state` rappresenta un'istanza di una classe definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="384f5-572">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-573">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-573">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-574">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-574">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-575">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-575">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-576">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-576">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-577">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-577">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-578">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-578">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-579">Il <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-579">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-580">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-580">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-581">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale archiviare i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-581">The zero-based position in the <c>buffer</c> parameter at which to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-582">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-582">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">
          <span data-ttu-id="384f5-583">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-583">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-584">Oggetto definito dall'utente contenente informazioni sull'operazione di ricezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-584">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="384f5-585">Questo oggetto viene passato al delegato <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-585">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-586">Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-586">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-587">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-587">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-588">Asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-588">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="384f5-589">Dopo aver interrotto un' `callback` dell'oggetto, è possibile utilizzare il  metodo per riavviarlo.</span><span class="sxs-lookup"><span data-stu-id="384f5-589">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="384f5-590">Questo metodo non è bloccata fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-590">This method does not block until the operation is complete.</span></span> <span data-ttu-id="384f5-591">Per il blocco fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Receive%2A> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-591">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="384f5-592">Per annullare un in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-592">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-593">Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-593">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-594">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-594">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-595">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-595">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-596">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-596">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-597">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-597">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-598">`state` rappresenta un'istanza di una classe definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="384f5-598">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-599">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-599">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-600">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-600">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-601">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-601">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-602">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-602">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-603">Esempio di codice seguente inizia a ricevere in modo asincrono i dati da un oggetto connesso <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-603">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-604">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-604">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-605">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-605">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-606">Il <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-606">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-607">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-607">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-608">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-608">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-609">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-609">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-610">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-610">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-611">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-611">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-612">Posizione in <c>buffer</c> per archiviare i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-612">The location in <c>buffer</c> to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-613">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-613">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">
          <span data-ttu-id="384f5-614">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-614">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-615">Oggetto definito dall'utente contenente informazioni sull'operazione di ricezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-615">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="384f5-616">Questo oggetto viene passato al delegato <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-616">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-617">Inizia a ricevere dati in modalità asincrona da un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-617">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-618">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-618">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-619">Asincrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operazione deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-619">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="384f5-620">Dopo aver interrotto un' `callback` dell'oggetto, è possibile utilizzare il  metodo per riavviarlo.</span><span class="sxs-lookup"><span data-stu-id="384f5-620">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="384f5-621">Questo metodo non è bloccata fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-621">This method does not block until the operation is complete.</span></span> <span data-ttu-id="384f5-622">Per il blocco fino al completamento dell'operazione, usare uno del <xref:System.Net.Sockets.Socket.Receive%2A> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-622">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="384f5-623">Per annullare un in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-623">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-624">Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-624">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-625">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-625">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-626">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-626">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-627">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-627">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-628">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-628">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-629">`state` rappresenta un'istanza di una classe definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="384f5-629">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-630">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-630">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-631">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-631">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-632">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-632">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-633">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-633">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-634">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-634">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-635">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-635">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-636">Il <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-636">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-637">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-637">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-638">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-638">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-639">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-639">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-640">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-640">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-641">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-641">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-642">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale archiviare i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-642">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-643">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-643">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <span data-ttu-id="384f5-644">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-644">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-645">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-645">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-646">Inizia a ricevere dati in modalità asincrona da un dispositivo di rete specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-646">Begins to asynchronously receive data from a specified network device.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-647">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-647">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-648">Il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo avvia la lettura asincrona di datagrammi senza connessione da un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-648">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="384f5-649">La chiamata di <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo offre la possibilità di ricevere i dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-649">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="384f5-650">È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-650">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-651">A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> utilizzato per la comunicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-651">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="384f5-652">Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-652">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-653">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-653">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-654">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-654">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-655">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, il sistema utilizzerà un thread separato per eseguire il metodo di callback specificato e verrà bloccata sul <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> fino a quando non la <xref:System.Net.Sockets.Socket> legge i dati o genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-655">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="384f5-656">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo, utilizzare <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-656">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-657">Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-657">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="384f5-658">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-658">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-659">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale utilizzando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-659">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-660">Questo metodo legge i dati nel `buffer` parametro e acquisizioni remoto ospitare endpoint da cui i dati vengono inviati.</span><span class="sxs-lookup"><span data-stu-id="384f5-660">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="384f5-661">Per informazioni su come recuperare questo endpoint, fare riferimento a <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-661">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="384f5-662">Questo metodo è particolarmente utile se si prevede di ricevere in modo asincrono datagrammi senza connessione da un host sconosciuto o più host.</span><span class="sxs-lookup"><span data-stu-id="384f5-662">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="384f5-663">In questi casi, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-663">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="384f5-664">Se il datagramma ricevuto è più grande della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo compilerà `buffer` con le informazioni del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-664">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-665">Se si utilizza un protocollo non affidabile, i dati in eccesso andranno persi.</span><span class="sxs-lookup"><span data-stu-id="384f5-665">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="384f5-666">Se si utilizza un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperare tramite una chiamata di <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo con un buffer sufficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="384f5-666">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="384f5-667">Per garantire che l'endpoint dell'host remoto viene sempre restituito, un'applicazione deve associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale utilizzando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo e quindi chiamare il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo con il `optionLevel` parametro impostato su <xref:System.Net.Sockets.SocketOptionLevel.IP>o <xref:System.Net.Sockets.SocketOptionLevel.IPv6> come appropriato, il `optionName` parametro impostato su <xref:System.Net.Sockets.SocketOptionName.PacketInformation>e il `optionValue` parametro per abilitare questa opzione prima di chiamare il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-667">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-668">In caso contrario, è possibile che l'endpoint dell'host remoto non venga restituito quando il mittente ha inviato un numero di datagrammi prima che il destinatario ha chiamato la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-668">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-669">Anche se <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile utilizzare anche un protocollo orientato alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-669">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="384f5-670">Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo oppure accettare una richiesta di connessione in ingresso chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-670">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="384f5-671">Se si chiama il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo prima di stabilire o accettare una connessione, si otterrà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-671">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-672">È inoltre possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-672">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-673">In entrambi i casi, il <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e solo ricevere dati da connesso o l'host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-673">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="384f5-674">Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> leggerà tutti i dati disponibili fino al numero di byte specificati dal `size` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-674">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="384f5-675">Per annullare un in sospeso <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-675">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-676">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-676">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-677">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-677">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-678">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-678">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-679">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-679">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-680">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-680">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-681">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-681">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-682">Esempio di codice seguente in modo asincrono riceve datagrammi senza connessione da un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-682">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-683">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-683">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-684">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-684">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-685">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-685">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-686">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-686">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-687">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-687">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-688">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-688">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-689">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-689">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-690">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-690">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-691">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-691">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-692">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-692">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-693">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale archiviare i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-693">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-694">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-694">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-695">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-695">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-696">
            <see cref="T:System.Net.EndPoint" /> che rappresenta l'origine dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-696">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-697">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-697">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-698">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-698">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-699">Avvia la ricezione asincrona del numero di byte specificato in una posizione specificata del buffer di dati, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e memorizza l'endpoint e le informazioni sui pacchetti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-699">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information..</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-700">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-700">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-701">Operazione di ricezione asincrona deve essere completata chiamando il <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-701">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="384f5-702">Dopo aver interrotto un' `asyncCallback` dell'oggetto, è possibile utilizzare il  metodo per riavviarlo.</span><span class="sxs-lookup"><span data-stu-id="384f5-702">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="384f5-703">Questo metodo non è bloccata fino al completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-703">This method does not block until the operation completes.</span></span> <span data-ttu-id="384f5-704">Per il blocco fino al completamento dell'operazione, utilizzare il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-704">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-705">Per annullare un in sospeso <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-705">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-706">Il gestore di timeout definisce i limiti di timeout di connessione per questo oggetto [ istanza.](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="384f5-706">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="384f5-707">Questo metodo legge i dati nel `buffer` parametro acquisizioni remoto ospitare endpoint da cui vengono inviati i dati, nonché informazioni sul pacchetto ricevuto.</span><span class="sxs-lookup"><span data-stu-id="384f5-707">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="384f5-708">Per informazioni su come recuperare questo endpoint, fare riferimento a <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-708">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="384f5-709">Questo metodo è particolarmente utile se si prevede di ricevere in modo asincrono datagrammi senza connessione da un host sconosciuto o più host.</span><span class="sxs-lookup"><span data-stu-id="384f5-709">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-710">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-710">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-711">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-711">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-712">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-712">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-713">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-713">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-714">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-714">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-715">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-715">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-716">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-716">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-717">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-717">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-718">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-718">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-719">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-719">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-720">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-720">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-721">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-721">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-722">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-722">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-723">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-723">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-724">Il sistema operativo è Windows 2000 o versioni precedenti e il metodo richiede Windows XP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-724">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-725">Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-725">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-726">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-726">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-727">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-727">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-728">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-728">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-729">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-729">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-730">Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-730">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-731">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-731">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-732">Il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo avvia un'operazione asincrona di invio all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-732">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="384f5-733"><xref:System.Net.Sockets.Socket.BeginSend%2A> verrà generata un'eccezione se non si chiama innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-733"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-734">La chiamata di <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo consente di inviare i dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-734">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="384f5-735">È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-735">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="384f5-736">A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> utilizzato per la comunicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-736">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="384f5-737">Se il callback richiede ulteriori informazioni, è possibile creare una classe o struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-737">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-738">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-738">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-739">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-739">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="384f5-740">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSend%2A>, il sistema utilizzerà un thread separato per eseguire il metodo di callback specificato e verrà bloccata sul <xref:System.Net.Sockets.Socket.EndSend%2A> fino a quando il <xref:System.Net.Sockets.Socket> invia il numero di byte richiesti o genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-740">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="384f5-741">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo, utilizzare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-741">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="384f5-742">Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-742">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="384f5-743">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-743">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-744">Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSend%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-744">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="384f5-745">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-745">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="384f5-746">È possibile utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-746">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-747">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-747">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-748">Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-748">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-749">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.BeginSend%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-749">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-750">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-750">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-751">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-751">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-752">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-752">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-753">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-753">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-754">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-754">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-755">`state` rappresenta un'istanza di una classe definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="384f5-755">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-756">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-756">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-757">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-757">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-758">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-758">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-759">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-759">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-760">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-760">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-761">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-761">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-762">
            <paramref name="buffers" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-762">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-763">
            <paramref name="buffers" /> è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-763">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-764">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-764">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-765">Vedere la sezione Osservazioni riportata di seguito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-765">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-766">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-766">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-767">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-767">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-768">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-768">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="384f5-769">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-769">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-770">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-770">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-771">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-771">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-772">Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-772">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-773">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-773">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-774">Il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo avvia un'operazione asincrona di invio all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-774">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="384f5-775"><xref:System.Net.Sockets.Socket.BeginSend%2A> verrà generata un'eccezione se non si chiama innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-775"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-776">La chiamata di <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo consente di inviare i dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-776">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="384f5-777">È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-777">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="384f5-778">A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> utilizzato per la comunicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-778">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="384f5-779">Se il callback richiede ulteriori informazioni, è possibile creare una classe o struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-779">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-780">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-780">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-781">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-781">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="384f5-782">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSend%2A>, il sistema utilizzerà un thread separato per eseguire il metodo di callback specificato e verrà bloccata sul <xref:System.Net.Sockets.Socket.EndSend%2A> fino a quando il <xref:System.Net.Sockets.Socket> invia il numero di byte richiesti o genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-782">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="384f5-783">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo, utilizzare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-783">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="384f5-784">Chiamare il metodo Set su un <xref:System.Threading.ManualResetEvent> nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-784">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="384f5-785">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-785">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-786">Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSend%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-786">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="384f5-787">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-787">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="384f5-788">È possibile utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-788">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-789">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-789">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-790">Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-790">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-791">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.BeginSend%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-791">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-792">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-792">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-793">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-793">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-794">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-794">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-795">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-795">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-796">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-796">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-797">`state` rappresenta un'istanza di una classe definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="384f5-797">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-798">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-798">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-799">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-799">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-800">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-800">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-801">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-801">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-802">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-802">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-803">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-803">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-804">
            <paramref name="buffers" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-804">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-805">
            <paramref name="buffers" /> è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-805">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-806">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-806">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-807">Vedere la sezione Osservazioni riportata di seguito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-807">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-808">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-808">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-809">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-809">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-810">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale iniziare a inviare i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-810">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-811">Numero di byte da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-811">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-812">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-812">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="384f5-813">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-813">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-814">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-814">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-815">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-815">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-816">Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-816">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-817">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-817">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-818">Il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo avvia un'operazione asincrona di invio all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-818">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="384f5-819"><xref:System.Net.Sockets.Socket.BeginSend%2A> verrà generata un'eccezione se non si chiama innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-819"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-820">La chiamata di <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo consente di inviare i dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-820">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="384f5-821">È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-821">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="384f5-822">A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> utilizzato per la comunicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-822">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="384f5-823">Se il callback richiede ulteriori informazioni, è possibile creare una classe o struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-823">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-824">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-824">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-825">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-825">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="384f5-826">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSend%2A>, il sistema utilizzerà un thread separato per eseguire il metodo di callback specificato e verrà bloccata sul <xref:System.Net.Sockets.Socket.EndSend%2A> fino a quando il <xref:System.Net.Sockets.Socket> invia il numero di byte richiesti o genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-826">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="384f5-827">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo, utilizzare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-827">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="384f5-828">Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-828">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="384f5-829">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-829">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-830">Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSend%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-830">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="384f5-831">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-831">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="384f5-832">È possibile utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-832">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-833">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-833">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-834">Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-834">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-835">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.BeginSend%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-835">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-836">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-836">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-837">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-837">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-838">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-838">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-839">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-839">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-840">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-840">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-841">`state` rappresenta un'istanza di una classe definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="384f5-841">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-842">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-842">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-843">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-843">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-844">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-844">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-845">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-845">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-846">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-846">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-847">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-847">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-848">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-848">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-849">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-849">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-850">Vedere la sezione Osservazioni riportata di seguito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-850">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-851">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-851">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-852">- oppure - <paramref name="offset" /> è minore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-852">-or-  <paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-853">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-853">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-854">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-854">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-855">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-855">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-856">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-856">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-857">Posizione in base zero nel parametro <c>buffer</c> in corrispondenza della quale iniziare a inviare i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-857">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-858">Numero di byte da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-858">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">
          <span data-ttu-id="384f5-859">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-859">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-860">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-860">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-861">Invia dati in modo asincrono a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-861">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-862">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-862">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-863">Il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo avvia un'operazione asincrona di invio all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-863">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="384f5-864"><xref:System.Net.Sockets.Socket.BeginSend%2A> verrà generata un'eccezione se non si chiama innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-864"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-865">La chiamata di <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo consente di inviare i dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-865">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="384f5-866">È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-866">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="384f5-867">A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> utilizzato per la comunicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-867">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="384f5-868">Se il callback richiede ulteriori informazioni, è possibile creare una classe o struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-868">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-869">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-869">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-870">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-870">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="384f5-871">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSend%2A>, il sistema utilizzerà un thread separato per eseguire il metodo di callback specificato e verrà bloccata sul <xref:System.Net.Sockets.Socket.EndSend%2A> fino a quando il <xref:System.Net.Sockets.Socket> invia il numero di byte richiesti o genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-871">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="384f5-872">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo, utilizzare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-872">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="384f5-873">Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-873">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="384f5-874">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-874">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-875">Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSend%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-875">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="384f5-876">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-876">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="384f5-877">È possibile utilizzare <xref:System.Net.Sockets.Socket.BeginSendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-877">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-878">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-878">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-879">Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-879">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-880">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.BeginSend%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-880">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-881">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-881">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-882">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-882">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-883">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-883">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-884">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-884">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-885">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-885">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-886">`state` rappresenta un'istanza di una classe definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="384f5-886">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-887">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-887">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-888">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-888">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-889">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-889">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-890">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-890">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-891">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-891">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-892">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-892">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-893">Esempio di codice seguente avvia in modo asincrono l'invio dei dati a un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-893">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-894">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-894">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-895">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-895">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-896">Vedere la sezione Osservazioni riportata di seguito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-896">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-897">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-897">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-898">- oppure - <paramref name="offset" /> è minore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-898">-or-  <paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-899">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-899">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-900">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-900">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-901">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-901">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-902">Invia un file in modo asincrono a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-902">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="384f5-903">Stringa contenente il percorso e il nome del file da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-903">A string that contains the path and name of the file to send.</span>
          </span>
          <span data-ttu-id="384f5-904">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-904">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-905">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-905">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-906">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-906">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-907">Invia il file <paramref name="fileName" /> a un oggetto connesso <see cref="T:System.Net.Sockets.Socket" /> utilizzando il flag <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-907">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-908">Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta l'invio asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-908">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-909">Questo overload invia il file `fileName` al socket connesso.</span><span class="sxs-lookup"><span data-stu-id="384f5-909">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="384f5-910">Se `fileName` è nella directory locale, può essere identificato utilizzando solo il nome del file; in caso contrario, è necessario specificare il percorso completo e nome del file.</span><span class="sxs-lookup"><span data-stu-id="384f5-910">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="384f5-911">I caratteri jolly ("... \\\myfile.txt ") e i nomi di condivisione UNC ("\\\\\\directory \shared\\\myfile.txt ") sono supportati.</span><span class="sxs-lookup"><span data-stu-id="384f5-911">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="384f5-912">Se il file non viene trovato, l'eccezione <xref:System.IO.FileNotFoundException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-912">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="384f5-913">Questo metodo Usa il `TransmitFile` trovare una funzione nell'API di Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="384f5-913">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="384f5-914">Per ulteriori informazioni sul `TransmitFile` (funzione) e i relativi flag, vedere la documentazione di Windows Sockets in MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="384f5-914">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="384f5-915">Il <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo avvia un'operazione asincrona di invio all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-915">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="384f5-916"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> genera un'eccezione se non si chiama innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-916"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-917">La chiamata di <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo consente di inviare un file all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-917">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="384f5-918">Per completare l'operazione, è possibile creare un metodo di callback che viene richiamato usando il <xref:System.AsyncCallback> parametro delegato.</span><span class="sxs-lookup"><span data-stu-id="384f5-918">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="384f5-919">A tale scopo, nel caso minimo, il `state` parametro deve contenere il <xref:System.Net.Sockets.Socket> dell'oggetto utilizzato per la comunicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-919">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="384f5-920">Se il callback richiede ulteriori informazioni, è possibile creare una classe o struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-920">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-921">Passare un'istanza dell'oggetto personalizzato per il <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-921">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-922">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSendFile%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-922">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="384f5-923">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, il sistema utilizza un thread separato per eseguire il metodo di callback specificato e blocca il <xref:System.Net.Sockets.Socket.EndSendFile%2A> fino a quando il <xref:System.Net.Sockets.Socket> invia l'intero file o genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-923">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="384f5-924">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-924">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-925">Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-925">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="384f5-926">Protocolli senza connessione, è necessario assicurarsi che le dimensioni del file non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-926">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-927">In caso affermativo, il datagramma non verrà inviato e <xref:System.Net.Sockets.Socket.BeginSendFile%2A> genera un <xref:System.Net.Sockets.SocketException> (eccezione).</span><span class="sxs-lookup"><span data-stu-id="384f5-927">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-928">Se si riceve un <xref:System.Net.Sockets.SocketException> eccezione, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-928">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-929">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-929">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-930">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-930">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-931">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-931">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-932">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-932">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-933">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-933">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-934">Esempio di codice seguente crea e si connette un socket per la comunicazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-934">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="384f5-935">In primo luogo, il file "txt" viene inviato in modo asincrono all'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-935">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="384f5-936">Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndSendFile%2A> per completare la trasmissione.</span><span class="sxs-lookup"><span data-stu-id="384f5-936">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-937">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-937">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-938">Il socket non è connesso a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-938">The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="384f5-939">Il parametro <paramref name="fileName" /> del file non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-939">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-940">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-940">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-941">Vedere la sezione Osservazioni riportata di seguito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-941">See remarks section below.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="384f5-942">Stringa contenente il percorso e il nome del file da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-942">A string that contains the path and name of the file to be sent.</span>
          </span>
          <span data-ttu-id="384f5-943">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-943">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="preBuffer">
          <span data-ttu-id="384f5-944">Oggetto matrice <see cref="T:System.Byte" /> che contiene i dati da inviare prima dell'invio del file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-944">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span>
          </span>
          <span data-ttu-id="384f5-945">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-945">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="postBuffer">
          <span data-ttu-id="384f5-946">Oggetto matrice <see cref="T:System.Byte" /> che contiene i dati da inviare dopo l'invio del file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-946">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span>
          </span>
          <span data-ttu-id="384f5-947">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-947">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="384f5-948">Combinazione bit per bit di valori di <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-948">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="384f5-949">Delegato di <see cref="T:System.AsyncCallback" /> da chiamare al completamento dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-949">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span>
          </span>
          <span data-ttu-id="384f5-950">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-950">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-951">Oggetto definito dall'utente contenente le informazioni di stato per la richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-951">A user-defined object that contains state information for this request.</span>
          </span>
          <span data-ttu-id="384f5-952">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-952">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-953">Invia un file e buffer di dati in modo asincrono a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-953">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-954">Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta l'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-954">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-955">Questo overload richiede il nome del file da inviare e una combinazione bit per bit di <xref:System.Net.Sockets.TransmitFileOptions> valori.</span><span class="sxs-lookup"><span data-stu-id="384f5-955">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="384f5-956">Il `preBuffer` parametro conterrà tutti i dati che si desidera anteporre al file.</span><span class="sxs-lookup"><span data-stu-id="384f5-956">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="384f5-957">`postBuffer` contiene dati che si desidera eseguire il file.</span><span class="sxs-lookup"><span data-stu-id="384f5-957">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="384f5-958">Se `fileName` è nella directory locale, può essere identificato utilizzando solo il nome del file; in caso contrario, è necessario specificare il percorso completo e nome del file.</span><span class="sxs-lookup"><span data-stu-id="384f5-958">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="384f5-959">I caratteri jolly ("... \\\myfile.txt ") e i nomi di condivisione UNC ("\\\\\\directory \shared\\\myfile.txt ") sono supportati.</span><span class="sxs-lookup"><span data-stu-id="384f5-959">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="384f5-960">Se il file non viene trovato, l'eccezione <xref:System.IO.FileNotFoundException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-960">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="384f5-961">Il `flags` parametro fornisce il provider di servizi Windows Sockets con ulteriori informazioni sul trasferimento dei file.</span><span class="sxs-lookup"><span data-stu-id="384f5-961">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="384f5-962">Per ulteriori informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="384f5-962">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="384f5-963">Questo metodo Usa il `TransmitFile` trovare una funzione nell'API di Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="384f5-963">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="384f5-964">Per ulteriori informazioni sul `TransmitFile` (funzione) e i relativi flag, vedere la documentazione di Windows Sockets in MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="384f5-964">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="384f5-965">Il <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo avvia un'operazione asincrona di invio all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-965">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="384f5-966"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> genera un'eccezione se non si chiama innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-966"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="384f5-967">La chiamata di <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo offre la possibilità di inviare un file all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-967">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="384f5-968">Per completare l'operazione, è possibile creare un metodo di callback che viene richiamato usando il <xref:System.AsyncCallback> parametro delegato.</span><span class="sxs-lookup"><span data-stu-id="384f5-968">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="384f5-969">A tale scopo, nel caso minimo, il `state` parametro deve contenere il <xref:System.Net.Sockets.Socket> dell'oggetto utilizzato per la comunicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-969">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="384f5-970">Se il callback richiede ulteriori informazioni, è possibile creare una classe o struttura per contenere il <xref:System.Net.Sockets.Socket> e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-970">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="384f5-971">Passare un'istanza dell'oggetto personalizzato per il <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-971">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-972">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSendFile%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-972">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="384f5-973">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, il sistema utilizza un thread separato per eseguire il metodo di callback specificato e blocca il <xref:System.Net.Sockets.Socket.EndSendFile%2A> fino a quando il <xref:System.Net.Sockets.Socket> invia l'intero file o genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-973">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="384f5-974">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-974">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-975">Sebbene sia destinato ai protocolli orientati alla connessione, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo per stabilire un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-975">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="384f5-976">Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del file non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-976">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-977">In caso affermativo, il datagramma non verrà inviato e <xref:System.Net.Sockets.Socket.BeginSendFile%2A> genera un <xref:System.Net.Sockets.SocketException> (eccezione).</span><span class="sxs-lookup"><span data-stu-id="384f5-977">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-978">Se si riceve un <xref:System.Net.Sockets.SocketException> eccezione, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-978">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-979">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-979">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-980">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-980">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-981">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-981">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-982">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-982">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-983">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-983">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-984">Esempio di codice seguente crea e si connette un socket per la comunicazione asincrona e inizia a inviare il file "txt" in modo asincrono all'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-984">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="384f5-985">In questo esempio, un `preBuffer` e un `postBuffer` dei dati viene creata per l'invio con il file e il valore predefinito <xref:System.Net.Sockets.TransmitFileOptions> valore viene utilizzato.</span><span class="sxs-lookup"><span data-stu-id="384f5-985">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="384f5-986">Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndSendFile%2A> per completare la trasmissione.</span><span class="sxs-lookup"><span data-stu-id="384f5-986">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-987">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-987">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-988">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-988">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-989">Vedere la sezione Osservazioni riportata di seguito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-989">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-990">Il sistema operativo non è Windows NT o versioni successive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-990">The operating system is not Windows NT or later.</span>
          </span>
          <span data-ttu-id="384f5-991">\- oppure - Il socket non è connesso a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-991">\- or -  The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="384f5-992">Il parametro <paramref name="fileName" /> del file non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-992">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-993">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-993">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-994">Posizione in base zero in <c>buffer</c> in corrispondenza della quale iniziare a inviare i dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-994">The zero-based position in <c>buffer</c> at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-995">Numero di byte da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-995">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <span data-ttu-id="384f5-996">Delegato <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-996">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="384f5-997">Oggetto che contiene informazioni sullo stato per questa richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-997">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-998">Invia i dati in modo asincrono a un host remoto specifico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-998">Sends data asynchronously to a specific remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-999">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'invio asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-999">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1000">Il <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo avvia un'operazione asincrona di invio all'host remoto specificato nella `remoteEP` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1000">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="384f5-1001">La chiamata di <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo consente di inviare i dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1001">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="384f5-1002">Sebbene sia destinato ai protocolli senza connessione, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> funziona con protocolli senza connessione e orientati alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1002">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="384f5-1003">È possibile creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegato e passare il nome per il <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1003">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="384f5-1004">A tale scopo, nel caso minimo, il `state` parametro deve contenere connesso o default <xref:System.Net.Sockets.Socket> utilizzato per la comunicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1004">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="384f5-1005">Se il callback richiede ulteriori informazioni, è possibile creare una classe per contenere il <xref:System.Net.Sockets.Socket>e le altre informazioni richieste.</span><span class="sxs-lookup"><span data-stu-id="384f5-1005">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="384f5-1006">Passare un'istanza di questa classe per la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo attraverso il `state` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1006">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="384f5-1007">Il metodo di callback deve richiamare il <xref:System.Net.Sockets.Socket.EndSendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1007">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="384f5-1008">Quando l'applicazione chiama <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, il sistema utilizzerà un thread separato per eseguire il metodo di callback specificato e verrà bloccata sul <xref:System.Net.Sockets.Socket.EndSendTo%2A> fino a quando il <xref:System.Net.Sockets.Socket> invia il numero di byte richiesti o genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1008">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="384f5-1009">Se si desidera che il thread originale viene bloccato dopo aver chiamato il <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo, utilizzare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1009">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="384f5-1010">Chiamare il metodo Set su un: System.Threading.ManualResetEvent nel metodo di callback quando si desidera che il thread originale per continuare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1010">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="384f5-1011">Per ulteriori informazioni sulla scrittura di metodi di callback, vedere [marshalling di un delegato come metodo di Callback](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1011">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="384f5-1012">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oppure <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo, o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1012">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-1013"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> ignorerà la `remoteEP` parametro e invierà i dati per il <xref:System.Net.EndPoint> stabilite nel <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1013"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1014">Se si utilizza un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> oppure <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1014">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="384f5-1015">È sufficiente eseguire questa operazione se si intende chiamare il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1015">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="384f5-1016">Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> oppure <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro sostituiranno l'host remoto predefinito specificato per tale operazione solo di invio.</span><span class="sxs-lookup"><span data-stu-id="384f5-1016">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="384f5-1017">Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1017">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="384f5-1018">In questo caso, il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale più appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1018">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="384f5-1019">Se si desidera che il provider del servizio sottostante per selezionare una porta disponibile, utilizzare un numero di porta pari a zero.</span><span class="sxs-lookup"><span data-stu-id="384f5-1019">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="384f5-1020">Se è necessario identificare il numero di porta e indirizzo di rete locale assegnato, è possibile usare il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo il <xref:System.Net.Sockets.Socket.EndSendTo%2A> metodo viene completato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1020">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="384f5-1021">Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1021">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-1022">-È inoltre necessario assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-1022">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-1023">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.EndSendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1023">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-1024">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1024">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1025">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1025">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1026">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1026">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1027">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1027">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1028">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1028">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1029">Il contesto di esecuzione (il contesto di sicurezza, l'utente rappresentato e il contesto di chiamata) viene memorizzato nella cache per asincrona <xref:System.Net.Sockets.Socket> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-1029">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="384f5-1030">Dopo il primo utilizzo di un particolare contesto (uno specifico asincrono <xref:System.Net.Sockets.Socket> metodo, uno specifico <xref:System.Net.Sockets.Socket> istanza e un callback specifico), gli utilizzi successivi di tale contesto verranno visualizzato un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-1030">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1031">Esempio di codice seguente invia in modo asincrono i dati nell'host remoto specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1031">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1032">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1032">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-1033">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1033">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1034">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1034">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-1035">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1035">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-1036">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1036">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-1037">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1037">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-1038">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1038">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1039">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1039">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-1040">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1040">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <span data-ttu-id="384f5-1041">
            <see cref="T:System.Net.EndPoint" /> locale da associare al <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1041">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1042">Associa un <see cref="T:System.Net.Sockets.Socket" /> a un endpoint locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1042">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1043">Utilizzare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo se è necessario usare uno specifico endpoint.</span><span class="sxs-lookup"><span data-stu-id="384f5-1043">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="384f5-1044">Per impostare il <xref:System.Net.Sockets.Socket.Bind%2A> opzione di socket <xref:System.Net.Sockets.Socket.Listen%2A>, creare un , impostare la proprietà enabled e impostare il  proprietà per il periodo di timeout desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1044">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="384f5-1045">Utilizzare questa <xref:System.Net.Sockets.Socket.Bind%2A> lungo con il <xref:System.Net.Sockets.Socket.Connect%2A> socket possibilità di chiamare il  (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1045">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="384f5-1046">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo su protocolli senza connessione e orientati alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1046">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="384f5-1047">Prima di chiamare <xref:System.Net.Sockets.Socket.Bind%2A>, è innanzitutto necessario creare locale <xref:System.Net.IPEndPoint> da cui si vuole comunicare i dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1047">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="384f5-1048">Se non si desidera eseguire viene assegnato l'indirizzo locale, è possibile creare un <xref:System.Net.IPEndPoint> utilizzando <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> come il parametro indirizzo e il servizio sottostante provider assegnerà l'indirizzo di rete più appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1048">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="384f5-1049">In questo modo è possibile semplificare l'applicazione se si dispongono di più interfacce di rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-1049">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="384f5-1050">Se non si desidera eseguire la porta locale utilizzata, è possibile creare un <xref:System.Net.IPEndPoint> utilizzando 0 per il numero di porta.</span><span class="sxs-lookup"><span data-stu-id="384f5-1050">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="384f5-1051">In questo caso, il provider del servizio verrà assegnato un numero di porta disponibile tra 1024 e 5000.</span><span class="sxs-lookup"><span data-stu-id="384f5-1051">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="384f5-1052">Se si utilizza l'approccio precedente, è possibile individuare il numero di porta e indirizzo di rete locale è stato assegnato chiamando il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1052">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="384f5-1053">Se si utilizza un protocollo orientato alla connessione <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> non restituirà l'indirizzo di rete locale assegnato fino a dopo aver effettuato una chiamata per il <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1053">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="384f5-1054">Se si utilizza un protocollo senza connessione, non sarà possibile accedere a queste informazioni fino a quando non è stata completata una trasmissione o ricevere messaggi.</span><span class="sxs-lookup"><span data-stu-id="384f5-1054">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="384f5-1055">Se un socket UDP desidera ricevere informazioni sull'interfaccia sui pacchetti ricevuti, il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo deve essere chiamato in modo esplicito con l'opzione di socket impostata su <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediatamente dopo la chiamata di <xref:System.Net.Sockets.Socket.Bind%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1055">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1056">Se si prevede di ricevere datagrammi multicast, è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo con un numero di porta multicast.</span><span class="sxs-lookup"><span data-stu-id="384f5-1056">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1057">È necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo se si prevede di ricevere datagrammi senza connessione utilizzando il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1057">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1058">Se si riceve un <xref:System.Net.Sockets.SocketException> quando si chiama il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1058">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1059">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1059">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1060">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1060">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1061">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1061">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1062">Associazioni di esempio di codice seguente un <xref:System.Net.Sockets.Socket> utilizzando l'endpoint locale specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1062">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1063">
            <paramref name="localEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1063">
              <paramref name="localEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1064">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1064">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1065">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1065">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-1066">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1066">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-1067">per accettare connessioni dall'host definito dal <paramref name="localEP" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1067">for accepting connections from the host defined by <paramref name="localEP" />.</span>
          </span>
          <span data-ttu-id="384f5-1068">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1068">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1069">Ottiene o imposta un valore che indica se il <see cref="T:System.Net.Sockets.Socket" /> è in modalità blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1069">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1070">
            <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> verrà bloccato, in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1070">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="384f5-1071">Il valore predefinito è <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1071">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1072">Il <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà indica se un <xref:System.Net.Sockets.Socket> è in modalità di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-1072">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="384f5-1073">Se si è in modalità di blocco e si esegue un metodo di chiamata che non viene completata immediatamente, l'applicazione verrà bloccata l'esecuzione fino a quando non viene completata l'operazione richiesta.</span><span class="sxs-lookup"><span data-stu-id="384f5-1073">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="384f5-1074">Se si desidera l'esecuzione continua anche se l'operazione richiesta non è stata completata, modificare il <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà `false`.</span><span class="sxs-lookup"><span data-stu-id="384f5-1074">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="384f5-1075">Il <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà non ha alcun effetto sui metodi asincroni.</span><span class="sxs-lookup"><span data-stu-id="384f5-1075">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="384f5-1076">Se l'invio e ricezione di dati in modo asincrono si desidera bloccare l'esecuzione, utilizzare il <xref:System.Threading.ManualResetEvent> classe.</span><span class="sxs-lookup"><span data-stu-id="384f5-1076">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1077">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1077">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1078">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1078">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1079">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1079">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1080">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1080">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1081">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1081">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1082">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1082">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-1083">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> utilizzato per richiedere la connessione all'host remoto chiamando uno dei metodi <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1083">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1084">Annulla una richiesta asincrona di una connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1084">Cancels an asynchronous request for a remote host connection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1085">Il <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> metodo annulla una richiesta asincrona di una connessione all'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1085">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1086">Il parametro <paramref name="e" /> non può essere Null e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1086">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1087">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1087">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1088">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1088">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-1089">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1089">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1090">Chiude la connessione all'oggetto <see cref="T:System.Net.Sockets.Socket" /> e rilascia tutte le risorse associate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1090">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1091">Chiude la connessione all'oggetto <see cref="T:System.Net.Sockets.Socket" /> e rilascia tutte le risorse associate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1091">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1092">Il <xref:System.Net.Sockets.Socket.Close%2A> metodo chiude la connessione all'host remoto e rilascia tutte le risorse gestite e associate i <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1092">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1093">Al momento della chiusura, il <xref:System.Net.Sockets.Socket.Connected%2A> è impostata su `false`.</span><span class="sxs-lookup"><span data-stu-id="384f5-1093">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="384f5-1094">Per i protocolli orientati alla connessione, è consigliabile chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A> prima di chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1094">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="384f5-1095">Ciò garantisce che tutti i dati inviati e ricevuti su socket connesso prima che venga chiuso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1095">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="384f5-1096">Se è necessario chiamare <xref:System.Net.Sockets.Socket.Close%2A> senza prima chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A>, è possibile garantire che i dati in coda per la trasmissione in uscita vengano inviata impostando il <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opzione `false` e specificando un intervallo di timeout diverso da zero.</span><span class="sxs-lookup"><span data-stu-id="384f5-1096">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="384f5-1097"><xref:System.Net.Sockets.Socket.Close%2A> verrà quindi bloccata fino a quando questi dati vengono inviati o fino alla scadenza del timeout specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1097"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="384f5-1098">Se si imposta <xref:System.Net.Sockets.SocketOptionName.DontLinger> al `false` e specificare un intervallo pari a zero timeout <xref:System.Net.Sockets.Socket.Close%2A> rilascia la connessione ed elimina automaticamente i dati in coda in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-1098">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1099">Per impostare il <xref:System.Net.Sockets.SocketOptionName.DontLinger> opzione di socket `false`, creare un <xref:System.Net.Sockets.LingerOption>, impostare la proprietà enabled `true`e impostare il <xref:System.Net.Sockets.LingerOption.LingerTime%2A> proprietà per il periodo di timeout desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1099">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="384f5-1100">Utilizzare questa <xref:System.Net.Sockets.LingerOption> lungo con il <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket possibilità di chiamare il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1100">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1101">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1101">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1102">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1102">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1103">Nell'esempio di codice riportato di seguito viene chiuso un <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1103">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="384f5-1104">Attendere fino al numero di secondi specificato in <c>timeout</c> per inviare eventuali dati rimanenti, quindi chiudere il socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1104">Wait up to <c>timeout</c> seconds to send any remaining data, then close the socket.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1105">Chiude la connessione <see cref="T:System.Net.Sockets.Socket" /> e rilascia tutte le risorse associate con un timeout specificato in modo da consentire l'invio dei dati in coda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1105">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1106">Il <xref:System.Net.Sockets.Socket.Close%2A> metodo chiude la connessione all'host remoto e rilascia tutte le risorse gestite e associate i <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1106">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1107">Al momento della chiusura, il <xref:System.Net.Sockets.Socket.Connected%2A> è impostata su `false`.</span><span class="sxs-lookup"><span data-stu-id="384f5-1107">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="384f5-1108">Per i protocolli orientati alla connessione, è consigliabile chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1108">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="384f5-1109">Ciò garantisce che tutti i dati inviati e ricevuti su socket connesso prima che venga chiuso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1109">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="384f5-1110">Se è necessario chiamare <xref:System.Net.Sockets.Socket.Close%2A> senza prima chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A>, è possibile garantire che i dati in coda per la trasmissione in uscita vengano inviata impostando il <xref:System.Net.Sockets.SocketOptionName.DontLinger> opzione `false` e specificando un intervallo di timeout diverso da zero.</span><span class="sxs-lookup"><span data-stu-id="384f5-1110">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="384f5-1111"><xref:System.Net.Sockets.Socket.Close%2A> verrà quindi bloccata fino a quando questi dati vengono inviati o fino alla scadenza del timeout specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1111"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="384f5-1112">Se si imposta <xref:System.Net.Sockets.SocketOptionName.DontLinger> al `false` e specificare un intervallo pari a zero timeout <xref:System.Net.Sockets.Socket.Close%2A> rilascia la connessione ed elimina automaticamente i dati in coda in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-1112">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1113">Per impostare il <xref:System.Net.Sockets.SocketOptionName.DontLinger> opzione di socket `false`, creare un <xref:System.Net.Sockets.LingerOption>, impostare la proprietà enabled `true`e impostare il <xref:System.Net.Sockets.LingerOption.LingerTime%2A> proprietà per il periodo di timeout desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1113">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="384f5-1114">Utilizzare questa <xref:System.Net.Sockets.LingerOption> lungo con il <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket possibilità di chiamare il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1114">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1115">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1115">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1116">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1116">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1117">Esempio di codice riportato di seguito viene illustrato come chiudere un <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1117">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1118">Stabilisce una connessione a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1118">Establishes a connection to a remote host.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <span data-ttu-id="384f5-1119">Oggetto <see cref="T:System.Net.EndPoint" /> che rappresenta il dispositivo remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1119">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1120">Stabilisce una connessione a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1120">Establishes a connection to a remote host.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1121">Se si utilizza un protocollo orientato alla connessione quali TCP, il <xref:System.Net.Sockets.Socket.Connect%2A> metodo in modo sincrono stabilisce una connessione di rete tra <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e l'endpoint remoto specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1121">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="384f5-1122">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.Connect%2A> stabilisce un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1122">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="384f5-1123">Dopo aver chiamato <xref:System.Net.Sockets.Socket.Connect%2A>, è possibile inviare dati al dispositivo remoto con il <xref:System.Net.Sockets.Socket.Send%2A> metodo, o ricevere dati dal dispositivo remoto con il <xref:System.Net.Sockets.Socket.Receive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1123">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1124">Se si utilizza un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di inviare e ricevere dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1124">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="384f5-1125">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> per comunicare in maniera sincrona con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1125">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="384f5-1126">Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A>, verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1126">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="384f5-1127">Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1127">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-1128">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1128">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1129">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1129">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="384f5-1130">Il <xref:System.Net.Sockets.Socket.Connect%2A> metodo verrà bloccata, a meno che non si imposti la <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà `false` prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1130">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-1131">Se si utilizza un protocollo orientato alla connessione quali TCP e si disattiva il blocco, <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException> perché richiede un tempo per stabilire la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1131">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="384f5-1132">Protocolli senza connessione non verranno generata un'eccezione perché semplicemente stabilito un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1132">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="384f5-1133">È possibile utilizzare <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1133">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1134">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1134">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="384f5-1135">Se l'errore WSAEWOULDBLOCK, la connessione all'host remoto è stata avviata da un orientato alla connessione <xref:System.Net.Sockets.Socket>, ma non è ancora stata completata correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1135">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="384f5-1136">Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo per determinare quando il <xref:System.Net.Sockets.Socket> al termine della connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1136">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1137">Se si utilizza un protocollo orientato alla connessione e non ha chiamato <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>, il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-1137">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="384f5-1138">Se si utilizza un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non viene completata una trasmissione oppure l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1138">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="384f5-1139">Se si desidera modificare l'host remoto predefinito, chiamare <xref:System.Net.Sockets.Socket.Connect%2A> nuovamente con l'endpoint desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1139">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1140">Se il socket è stato disconnesso in precedenza, è possibile utilizzare questo metodo ripristinare la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1140">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="384f5-1141">Utilizzare uno dei asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodi per ristabilire la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1141">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="384f5-1142">Si tratta di una limitazione del provider sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-1142">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1143">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1143">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1144">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1144">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1145">Esempio di codice seguente si connette a un endpoint remoto e quindi si verifica la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1145">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1146">
            <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1146">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1147">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1147">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1148">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1148">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-1149">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1149">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1150">
            <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1150">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-1151">per la connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1151">for connecting to the remote host.</span>
          </span>
          <span data-ttu-id="384f5-1152">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Connect" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1152">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="384f5-1153">L'indirizzo IP dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1153">The IP address of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="384f5-1154">Numero di porta dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1154">The port number of the remote host.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1155">Stabilisce una connessione a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1155">Establishes a connection to a remote host.</span>
          </span>
          <span data-ttu-id="384f5-1156">L'host è specificato da un indirizzo IP e da un numero di porta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1156">The host is specified by an IP address and a port number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1157">Se si utilizza un protocollo orientato alla connessione quali TCP, il <xref:System.Net.Sockets.Socket.Connect%2A> metodo in modo sincrono stabilisce una connessione di rete tra <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e l'endpoint remoto specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1157">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="384f5-1158">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.Connect%2A> stabilisce un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1158">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="384f5-1159">Dopo aver chiamato <xref:System.Net.Sockets.Socket.Connect%2A> è possibile inviare dati al dispositivo remoto con il <xref:System.Net.Sockets.Socket.Send%2A> metodo, o ricevere dati dal dispositivo remoto con il <xref:System.Net.Sockets.Socket.Receive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1159">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1160">Se si utilizza un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di inviare e ricevere dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1160">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="384f5-1161">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> per comunicare in maniera sincrona con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1161">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="384f5-1162">Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A> verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1162">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="384f5-1163">Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1163">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-1164">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1164">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1165">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1165">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="384f5-1166"><xref:System.Net.Sockets.Socket.Connect%2A> metodo verrà bloccata, a meno che non si imposti la <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà da `false` prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1166"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-1167">Se si utilizza un protocollo orientato alla connessione quali TCP e si disattiva il blocco, <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException> perché richiede un tempo per stabilire la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1167">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="384f5-1168">Protocolli senza connessione non verranno generata un'eccezione perché semplicemente stabilito un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1168">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="384f5-1169">È possibile utilizzare <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1169">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1170">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1170">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="384f5-1171">Se l'errore WSAEWOULDBLOCK, la connessione all'host remoto è stata avviata da un orientato alla connessione <xref:System.Net.Sockets.Socket>, ma non è ancora stata completata correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1171">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="384f5-1172">Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo per determinare quando il <xref:System.Net.Sockets.Socket> al termine della connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1172">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1173">Se si utilizza un protocollo orientato alla connessione e non ha chiamato <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>, il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-1173">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="384f5-1174">Se si utilizza un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non viene completata una trasmissione oppure l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1174">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="384f5-1175">Se si desidera modificare l'host remoto predefinito, chiamare <xref:System.Net.Sockets.Socket.Connect%2A> nuovamente con l'endpoint desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1175">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1176">Se il socket è stato disconnesso in precedenza, è possibile utilizzare questo metodo ripristinare la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1176">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="384f5-1177">Utilizzare uno dei asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodi per ristabilire la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1177">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="384f5-1178">Si tratta di una limitazione del provider sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-1178">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1179">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1179">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1180">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1180">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1181">Esempio di codice seguente si connette a un endpoint remoto e quindi si verifica la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1181">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1182">
            <paramref name="address" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1182">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-1183">Il numero di porta non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1183">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1184">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1184">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1185">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1185">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1186">Questo metodo è valido per i socket della famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1186">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1187">La lunghezza di <paramref name="address" /> è zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1187">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1188">
            <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1188">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">
          <span data-ttu-id="384f5-1189">L'indirizzo IP dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1189">The IP addresses of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="384f5-1190">Numero di porta dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1190">The port number of the remote host.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1191">Stabilisce una connessione a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1191">Establishes a connection to a remote host.</span>
          </span>
          <span data-ttu-id="384f5-1192">L'host è specificato da una matrice di indirizzi IP e da un numero di porta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1192">The host is specified by an array of IP addresses and a port number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1193">Questo metodo viene in genere utilizzato immediatamente dopo una chiamata a <xref:System.Net.Dns.GetHostAddresses%2A>, che può restituire più indirizzi IP per un singolo host.</span><span class="sxs-lookup"><span data-stu-id="384f5-1193">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="384f5-1194">Se si utilizza un protocollo orientato alla connessione quali TCP, il <xref:System.Net.Sockets.Socket.Connect%2A> metodo in modo sincrono stabilisce una connessione di rete tra <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e l'endpoint remoto specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1194">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="384f5-1195">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.Connect%2A> stabilisce un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1195">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="384f5-1196">Dopo aver chiamato <xref:System.Net.Sockets.Socket.Connect%2A> è possibile inviare dati al dispositivo remoto con il <xref:System.Net.Sockets.Socket.Send%2A> metodo, o ricevere dati dal dispositivo remoto con il <xref:System.Net.Sockets.Socket.Receive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1196">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1197">Se si utilizza un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di inviare e ricevere dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1197">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="384f5-1198">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> per comunicare in maniera sincrona con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1198">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="384f5-1199">Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A> verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1199">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="384f5-1200">Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1200">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-1201">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1201">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1202">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1202">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="384f5-1203"><xref:System.Net.Sockets.Socket.Connect%2A> metodo verrà bloccata, a meno che non si imposti la <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà da `false` prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1203"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-1204">Se si utilizza un protocollo orientato alla connessione quali TCP e si disattiva il blocco, <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException> perché richiede un tempo per stabilire la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1204">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="384f5-1205">Protocolli senza connessione non verranno generata un'eccezione perché semplicemente stabilito un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1205">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="384f5-1206">È possibile utilizzare <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1206">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1207">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1207">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="384f5-1208">Se l'errore WSAEWOULDBLOCK, la connessione all'host remoto è stata avviata da un orientato alla connessione <xref:System.Net.Sockets.Socket>, ma non è ancora stata completata correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1208">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="384f5-1209">Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo per determinare quando il <xref:System.Net.Sockets.Socket> al termine della connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1209">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1210">Se si utilizza un protocollo orientato alla connessione e non ha chiamato <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>, il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-1210">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="384f5-1211">Se si utilizza un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non viene completata una trasmissione oppure l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1211">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="384f5-1212">Se si desidera modificare l'host remoto predefinito, chiamare <xref:System.Net.Sockets.Socket.Connect%2A> nuovamente con l'endpoint desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1212">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1213">Se il socket è stato disconnesso in precedenza, è possibile utilizzare questo metodo ripristinare la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1213">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="384f5-1214">Utilizzare uno dei asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodi per ristabilire la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1214">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="384f5-1215">Si tratta di una limitazione del provider sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-1215">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1216">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1216">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1217">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1217">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1218">Esempio di codice seguente si connette a un endpoint remoto e quindi si verifica la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1218">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1219">
            <paramref name="addresses" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1219">
              <paramref name="addresses" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-1220">Il numero di porta non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1220">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1221">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1221">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1222">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1222">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1223">Questo metodo è valido per i socket della famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1223">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1224">La lunghezza di <paramref name="address" /> è zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1224">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1225">
            <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1225">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="384f5-1226">Il nome dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1226">The name of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="384f5-1227">Numero di porta dell'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1227">The port number of the remote host.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1228">Stabilisce una connessione a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1228">Establishes a connection to a remote host.</span>
          </span>
          <span data-ttu-id="384f5-1229">L'host viene specificato da un nome host e da un numero di porta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1229">The host is specified by a host name and a port number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1230">Se si utilizza un protocollo orientato alla connessione quali TCP, il <xref:System.Net.Sockets.Socket.Connect%2A> metodo in modo sincrono stabilisce una connessione di rete tra <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e l'host remoto specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1230">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="384f5-1231">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.Connect%2A> stabilisce un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1231">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="384f5-1232">Dopo aver chiamato <xref:System.Net.Sockets.Socket.Connect%2A> è possibile inviare dati al dispositivo remoto con il <xref:System.Net.Sockets.Socket.Send%2A> metodo, o ricevere dati dal dispositivo remoto con il <xref:System.Net.Sockets.Socket.Receive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1232">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1233">Se si utilizza un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di inviare e ricevere dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1233">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="384f5-1234">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> per comunicare in maniera sincrona con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1234">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="384f5-1235">Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A> verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1235">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="384f5-1236">Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1236">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-1237">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1237">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1238">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1238">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="384f5-1239"><xref:System.Net.Sockets.Socket.Connect%2A> metodo verrà bloccata, a meno che non si imposti la <xref:System.Net.Sockets.Socket.Blocking%2A> proprietà da `false` prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1239"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-1240">Se si utilizza un protocollo orientato alla connessione quali TCP e si disattiva il blocco, <xref:System.Net.Sockets.Socket.Connect%2A> genererà un <xref:System.Net.Sockets.SocketException> perché richiede un tempo per stabilire la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1240">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="384f5-1241">Protocolli senza connessione non verranno generata un'eccezione perché semplicemente stabilito un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1241">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="384f5-1242">È possibile utilizzare <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1242">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1243">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1243">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="384f5-1244">Se l'errore WSAEWOULDBLOCK, la connessione all'host remoto è stata avviata da un orientato alla connessione <xref:System.Net.Sockets.Socket>, ma non è ancora stata completata correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1244">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="384f5-1245">Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo per determinare quando il <xref:System.Net.Sockets.Socket> al termine della connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1245">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="384f5-1246">Se IPv6 è abilitato e <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> metodo viene chiamato per connettersi a un host che si risolve in IPv6 e gli indirizzi IPv4, la connessione all'indirizzo IPv6 verrà tentata prima l'indirizzo IPv4.</span><span class="sxs-lookup"><span data-stu-id="384f5-1246">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="384f5-1247">Ciò può avere l'effetto di ritardare il tempo necessario per stabilire la connessione se l'host non è in ascolto sull'indirizzo IPv6.</span><span class="sxs-lookup"><span data-stu-id="384f5-1247">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1248">Se si utilizza un protocollo orientato alla connessione e non ha chiamato <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.Connect%2A>, il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-1248">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="384f5-1249">Se si utilizza un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo di rete locale finché non viene completata una trasmissione oppure l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1249">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="384f5-1250">Se si desidera modificare l'host remoto predefinito, chiamare <xref:System.Net.Sockets.Socket.Connect%2A> nuovamente con l'endpoint desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1250">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1251">Se il socket è stato disconnesso in precedenza, è possibile utilizzare questo metodo ripristinare la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1251">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="384f5-1252">Utilizzare uno dei asincrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodi per ristabilire la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1252">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="384f5-1253">Si tratta di una limitazione del provider sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-1253">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1254">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1254">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1255">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1255">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1256">Esempio di codice seguente si connette a un endpoint remoto e quindi si verifica la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1256">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1257">
            <paramref name="host" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1257">
              <paramref name="host" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-1258">Il numero di porta non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1258">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1259">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1259">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1260">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1260">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1261">Questo metodo è valido per i socket della famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1261">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1262">
            <see cref="T:System.Net.Sockets.Socket" /> è stato collocato in uno stato di ascolto mediante la chiamata di <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1262">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1263">Avvia una richiesta asincrona di una connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1263">Begins an asynchronous request for a connection to a remote host.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-1264">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1264">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1265">Avvia una richiesta asincrona di una connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1265">Begins an asynchronous request for a connection to a remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1266">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1266">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-1267">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1267">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-1268">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1268">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-1269">In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1269">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1270">Se si utilizza un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo avvia una richiesta asincrona di una connessione all'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1270">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="384f5-1271">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.ConnectAsync%2A> stabilisce un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1271">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="384f5-1272">Per ricevere una notifica di completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegare e collegare il callback di <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="384f5-1272">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="384f5-1273">Il chiamante deve impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà per il <xref:System.Net.IPEndPoint> dell'host remoto a cui connettersi.</span><span class="sxs-lookup"><span data-stu-id="384f5-1273">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="384f5-1274">Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà per qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (metodo), in modo che le informazioni possano essere recuperate nel metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-1274">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="384f5-1275">Se il callback richiede più informazioni rispetto a un singolo oggetto, una classe piccola può essere creata per contenere le altre informazioni sullo stato necessarie come membri.</span><span class="sxs-lookup"><span data-stu-id="384f5-1275">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="384f5-1276">Se si utilizza un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.ConnectAsync%2A> prima di inviare e ricevere dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1276">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="384f5-1277">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendToAsync%2A> e <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> per comunicare con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1277">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="384f5-1278">Se si chiama <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1278">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="384f5-1279">Se si desidera modificare l'host remoto predefinito, chiamare il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> nuovamente metodo con l'endpoint desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1279">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="384f5-1280">Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è prima necessario chiamare <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e impostare Broadcast su `true`.</span><span class="sxs-lookup"><span data-stu-id="384f5-1280">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="384f5-1281">Se non viene eseguita, il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1281">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-1282">Le seguenti proprietà e gli eventi di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari:</span><span class="sxs-lookup"><span data-stu-id="384f5-1282">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="384f5-1283">Facoltativamente, fornire un buffer da cui verrà inviato in modo atomico nel socket dopo il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1283">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="384f5-1284">In questo caso, il <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> proprietà deve essere impostata per il buffer che contiene i dati per l'invio e la <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> proprietà deve essere impostata per il numero di byte di dati da inviare dal buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-1284">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="384f5-1285">Una volta stabilita una connessione, viene inviato il buffer di dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1285">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="384f5-1286">Se si utilizza un protocollo orientato alla connessione e non chiamare <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale più appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1286">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="384f5-1287">Se si utilizza un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo IP rete locale finché non si chiama il <xref:System.Net.Sockets.Socket.SendAsync%2A> o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-1287">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="384f5-1288">Il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo genera eccezioni <xref:System.NotSupportedException> se la famiglia di indirizzi del <xref:System.Net.Sockets.Socket> e il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> non sono la stessa famiglia di indirizzi.</span><span class="sxs-lookup"><span data-stu-id="384f5-1288">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1289">Se si riceve un <xref:System.Net.Sockets.SocketException> quando si chiama questo metodo, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1289">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1290">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1290">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1291">Un argomento non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1291">An argument is not valid.</span>
          </span>
          <span data-ttu-id="384f5-1292">Questa eccezione si verifica se sono specificati più buffer e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> non è null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1292">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1293">Il parametro <paramref name="e" /> non può essere Null e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1293">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1294">
            <see cref="T:System.Net.Sockets.Socket" /> è in attesa o era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1294">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1295">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1295">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1296">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1296">Windows XP or later is required for this method.</span>
          </span>
          <span data-ttu-id="384f5-1297">Questa eccezione si verifica anche se l'endpoint locale e l'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non appartengono alla stessa famiglia di indirizzi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1297">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1298">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1298">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-1299">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1299">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <span data-ttu-id="384f5-1300">Uno dei valori di <see cref="T:System.Net.Sockets.SocketType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1300">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </param>
        <param name="protocolType">
          <span data-ttu-id="384f5-1301">Uno dei valori di <see cref="T:System.Net.Sockets.ProtocolType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1301">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </param>
        <param name="e">
          <span data-ttu-id="384f5-1302">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1302">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1303">Avvia una richiesta asincrona di una connessione all'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1303">Begins an asynchronous request for a connection to a remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1304">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1304">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-1305">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1305">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-1306">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1306">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-1307">In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1307">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1308">Se si utilizza un protocollo orientato alla connessione, il metodo ProtocolType avvia una richiesta asincrona di una connessione all'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1308">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="384f5-1309">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.ConnectAsync%2A> stabilisce un host remoto predefinito specificato per il `socketType` e `protocolType` parametri.</span><span class="sxs-lookup"><span data-stu-id="384f5-1309">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="384f5-1310">Per ricevere una notifica di completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegare e collegare il callback di <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="384f5-1310">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="384f5-1311">Il chiamante deve impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà per il <xref:System.Net.IPEndPoint> dell'host remoto a cui connettersi.</span><span class="sxs-lookup"><span data-stu-id="384f5-1311">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="384f5-1312">Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà per qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> (metodo), in modo che le informazioni possano essere recuperate nel metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-1312">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="384f5-1313">Se il callback richiede più informazioni rispetto a un singolo oggetto, una classe piccola può essere creata per contenere le altre informazioni sullo stato necessarie come membri.</span><span class="sxs-lookup"><span data-stu-id="384f5-1313">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="384f5-1314">Se si utilizza un protocollo senza connessione, ad esempio UDP, non è necessario chiamare <xref:System.Net.Sockets.Socket.ConnectAsync%2A> prima di inviare e ricevere dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1314">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="384f5-1315">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendToAsync%2A> e <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> per comunicare con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1315">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="384f5-1316">Se si chiama <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, verranno eliminati tutti i datagrammi provenienti da un indirizzo diverso da quello predefinito specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1316">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="384f5-1317">Se si desidera modificare l'host remoto predefinito, chiamare il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> nuovamente metodo con l'endpoint desiderato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1317">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="384f5-1318">Se si desidera impostare l'host remoto predefinito per un indirizzo di broadcast, è prima necessario chiamare <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e impostare Broadcast su `true`.</span><span class="sxs-lookup"><span data-stu-id="384f5-1318">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="384f5-1319">Se non viene eseguita, il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1319">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-1320">Le seguenti proprietà e gli eventi di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari:</span><span class="sxs-lookup"><span data-stu-id="384f5-1320">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="384f5-1321">Facoltativamente, fornire un buffer da cui verrà inviato in modo atomico nel socket dopo il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1321">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="384f5-1322">In questo caso, il <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> proprietà deve essere impostata per il buffer che contiene i dati per l'invio e la <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> proprietà deve essere impostata per il numero di byte di dati da inviare dal buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-1322">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="384f5-1323">Una volta stabilita una connessione, viene inviato il buffer di dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1323">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="384f5-1324">Se si utilizza un protocollo orientato alla connessione e non chiamare <xref:System.Net.Sockets.Socket.Bind%2A> prima di chiamare <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale più appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1324">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="384f5-1325">Se si utilizza un protocollo senza connessione, il provider di servizi non assegnerà un numero di porta e indirizzo IP rete locale finché non si chiama il <xref:System.Net.Sockets.Socket.SendAsync%2A> o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-1325">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="384f5-1326">Il <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo genera eccezioni <xref:System.NotSupportedException> se la famiglia di indirizzi del <xref:System.Net.Sockets.Socket> e il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> non sono la stessa famiglia di indirizzi.</span><span class="sxs-lookup"><span data-stu-id="384f5-1326">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1327">Se si riceve un <xref:System.Net.Sockets.SocketException> quando si chiama questo metodo, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1327">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1328">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1328">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1329">Un argomento non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1329">An argument is not valid.</span>
          </span>
          <span data-ttu-id="384f5-1330">Questa eccezione si verifica se sono specificati più buffer e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> non è null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1330">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1331">Il parametro <paramref name="e" /> non può essere Null e la proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1331">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1332">
            <see cref="T:System.Net.Sockets.Socket" /> è in attesa o era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1332">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1333">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1333">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1334">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1334">Windows XP or later is required for this method.</span>
          </span>
          <span data-ttu-id="384f5-1335">Questa eccezione si verifica anche se l'endpoint locale e l'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non appartengono alla stessa famiglia di indirizzi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1335">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1336">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1336">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-1337">Un chiamante di livello superiore nello stack di chiamate non ha l'autorizzazione per l'operazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1337">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1338">Ottiene un valore che indica se un <see cref="T:System.Net.Sockets.Socket" /> si è connesso a un host remoto dall'ultima operazione <see cref="Overload:System.Net.Sockets.Socket.Send" /> o <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1338">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1339">
            <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> è connesso a una risorsa remota nel corso dell'operazione più recente, in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1339">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1340">Il `Connected` proprietà ottiene lo stato della connessione di <xref:System.Net.Sockets.Socket> nel corso dell'ultima operazione dei / o.</span><span class="sxs-lookup"><span data-stu-id="384f5-1340">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="384f5-1341">Quando viene restituito `false`, il <xref:System.Net.Sockets.Socket> non si era mai connesso o non è più connesso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1341">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="384f5-1342">Il valore di <xref:System.Net.Sockets.Socket.Connected%2A> proprietà riflette lo stato della connessione nel corso dell'operazione più recente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1342">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="384f5-1343">Se è necessario determinare lo stato corrente della connessione, effettuare una trasmissione non bloccante a zero byte chiamata.</span><span class="sxs-lookup"><span data-stu-id="384f5-1343">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="384f5-1344">Se la chiamata ha esito positivo o genera un errore WAEWOULDBLOCK (10035), è ancora connesso al socket; in caso contrario, il socket non è più connesso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1344">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="384f5-1345">Se si chiama <xref:System.Net.Sockets.Socket.Connect%2A> su un socket di datagramma protocollo UDP (User), il <xref:System.Net.Sockets.Socket.Connected%2A> proprietà restituisce sempre `true`; tuttavia, questa azione non modifica la natura senza connessione inerente di UDP.</span><span class="sxs-lookup"><span data-stu-id="384f5-1345">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1346">Esempio di codice seguente si connette a un endpoint remoto, controlla la <xref:System.Net.Sockets.Socket.Connected%2A> proprietà e controlla lo stato corrente della connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1346">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="384f5-1347">
            <see langword="true" /> se il socket può essere riutilizzato una volta chiusa la connessione in corso; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1347">
              <see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1348">Chiude la connessione al socket consentendo di riutilizzare il socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1348">Closes the socket connection and allows reuse of the socket.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1349">Se si utilizza un protocollo orientato alla connessione, è possibile utilizzare questo metodo per chiudere il socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-1349">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="384f5-1350">Questo metodo termina la connessione e imposta il <xref:System.Net.Sockets.Socket.Connected%2A> proprietà `false`.</span><span class="sxs-lookup"><span data-stu-id="384f5-1350">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="384f5-1351">Tuttavia, se `reuseSocket` è `true`, è possibile riutilizzare il socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-1351">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="384f5-1352">Per garantire che tutti i dati viene inviato e ricevuto prima della chiusura del socket, è necessario chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A> prima di chiamare il <xref:System.Net.Sockets.Socket.Disconnect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1352">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1353">Se è necessario chiamare <xref:System.Net.Sockets.Socket.Disconnect%2A> senza prima chiamare <xref:System.Net.Sockets.Socket.Shutdown%2A>, è possibile impostare il <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opzione `false` e specificare un intervallo di timeout diverso da zero per assicurarsi che i dati in coda per la trasmissione in uscita viene inviata.</span><span class="sxs-lookup"><span data-stu-id="384f5-1353">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="384f5-1354"><xref:System.Net.Sockets.Socket.Disconnect%2A> quindi si blocca fino a quando i dati vengono inviati o fino alla scadenza del timeout specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1354"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="384f5-1355">Se si imposta <xref:System.Net.Sockets.SocketOptionName.DontLinger> al `false` e specificare un intervallo pari a zero timeout <xref:System.Net.Sockets.Socket.Close%2A> rilascia la connessione ed elimina automaticamente i dati in coda in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-1355">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1356">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1356">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1357">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1357">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1358">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1358">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1359">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1359">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1360">Esempio di codice seguente crea un socket per la comunicazione sincrona e vengono inviati dati a un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1360">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="384f5-1361">Chiama poi <xref:System.Net.Sockets.Socket.Shutdown%2A>per arrestare l'invio e ricezione attività, e <xref:System.Net.Sockets.Socket.Disconnect%2A>per chiudere la connessione socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-1361">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="384f5-1362">Questo metodo richiede Windows 2000 o versioni precedenti; in caso contrario sarà generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1362">This method requires Windows 2000 or earlier, or the exception will be thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1363">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1363">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1364">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1364">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-1365">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1365">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1366">Avvia una richiesta asincrona di disconnessione da un endpoint remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1366">Begins an asynchronous request to disconnect from a remote endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1367">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1367">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-1368">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1368">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-1369">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1369">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-1370">In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1370">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1371">Quando si utilizza un protocollo orientato alla connessione, chiamare il <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> metodo richiede una disconnessione da un endpoint remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1371">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="384f5-1372">Se si imposta <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> al `true` nel `e` parametro, il socket può essere riutilizzato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1372">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1373">Il parametro <paramref name="e" /> non può essere null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1373">The <paramref name="e" /> parameter cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1374">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1374">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1375">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1375">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1376">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1376">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1377">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1377">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1378">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1378">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1379">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1379">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1380">Chiamare il metodo `Dispose` dopo aver terminato di utilizzare l'oggetto <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1380">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1381">Il metodo `Dispose` lascia l'oggetto <xref:System.Net.Sockets.Socket> in una condizione di inutilizzabilità.</span><span class="sxs-lookup"><span data-stu-id="384f5-1381">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="384f5-1382">Dopo la chiamata `Dispose`, è necessario rilasciare tutti i riferimenti per il <xref:System.Net.Sockets.Socket> consentire al garbage collector di recuperare la memoria che il <xref:System.Net.Sockets.Socket> occupata.</span><span class="sxs-lookup"><span data-stu-id="384f5-1382">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="384f5-1383">Per altre informazioni, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1383">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1384">Chiamare sempre il metodo `Dispose` prima di rilasciare l'ultimo riferimento a <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1384">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1385">In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Net.Sockets.Socket> dell'oggetto `Finalize` non viene richiamato dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="384f5-1385">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="384f5-1386">
            <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1386">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1387">Rilascia le risorse non gestite usate da <see cref="T:System.Net.Sockets.Socket" /> e, facoltativamente, elimina le risorse gestite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1387">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1388">Questo metodo viene chiamato dal metodo pubblico `Dispose()` metodo e il <xref:System.Object.Finalize%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1388">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="384f5-1389">`Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`.</span><span class="sxs-lookup"><span data-stu-id="384f5-1389">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="384f5-1390"><xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.</span><span class="sxs-lookup"><span data-stu-id="384f5-1390"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="384f5-1391">Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.Net.Sockets.Socket> fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="384f5-1391">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="384f5-1392">Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.</span><span class="sxs-lookup"><span data-stu-id="384f5-1392">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1393">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1393">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1394">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1394">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="384f5-1395">
            <para>
              <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. In caso di override di <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, non fare riferimento a oggetti già eliminati in una chiamata precedente a <see langword="Dispose" />. Per ulteriori informazioni su come implementare <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, vedere [implementazione di un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Per ulteriori informazioni <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia backup Resources](~/docs/standard/garbage-collection/unmanaged.md) non gestito e [override del metodo Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1395">
              <para>
                <see langword="Dispose" /> can be called multiple times by other objects. When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />. For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1396">Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se il <see cref="T:System.Net.Sockets.Socket" /> consente la frammentazione dei datagrammi IP (Internet Protocol).</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1396">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1397">
            <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> consente la frammentazione dei datagrammi; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1397">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="384f5-1398">Il valore predefinito è <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1398">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1399">I datagrammi richiedono la frammentazione quando le dimensioni superano le unità MTU (Maximum Transfer) di mezzo di trasmissione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1399">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="384f5-1400">Essi possono essere frammentati tramite l'host di invio (tutte le versioni di Internet Protocol) o un router intermedio (solo Internet Protocol versione 4).</span><span class="sxs-lookup"><span data-stu-id="384f5-1400">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="384f5-1401">Se un datagramma deve essere frammentato e il <xref:System.Net.Sockets.Socket.DontFragment%2A> opzione è impostata, il datagramma viene eliminato e viene inviato un messaggio di errore di controllo messaggio protocollo ICMP (Internet) al mittente del datagramma.</span><span class="sxs-lookup"><span data-stu-id="384f5-1401">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="384f5-1402">Impostazione di questa proprietà su un socket di protocollo TCP (Transmission Control) avrà alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1402">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1403">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.DontFragment%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-1403">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1404">È possibile impostare questa proprietà solo per i socket inclusi nella famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1404">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1405">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1405">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1406">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1406">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1407">Ottiene o imposta un valore di <see cref="T:System.Boolean" /> che specifica se <see cref="T:System.Net.Sockets.Socket" /> è un socket dual mode usato per IPv4 e IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1407">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1408">
            <see langword="true" /> se <see cref="T:System.Net.Sockets.Socket" /> è un socket dual mode; in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1408">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="384f5-1409">Il valore predefinito è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1409">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">
          <span data-ttu-id="384f5-1410">L'ID del processo di destinazione in cui viene creato un duplicato del riferimento al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1410">The ID of the target process where a duplicate of the socket reference is created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1411">Duplica il riferimento al socket per il processo di destinazione e chiude il socket per tale processo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1411">Duplicates the socket reference for the target process, and closes the socket for this process.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1412">Il riferimento al socket da passare al processo di destinazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1412">The socket reference to be passed to the target process.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1413">Il processo di destinazione deve utilizzare <xref:System.Net.Sockets.Socket.%23ctor%2A> per creare l'istanza di socket duplicato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1413">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="384f5-1414">Se si chiama il <xref:System.Net.Sockets.Socket.%23ctor%2A> costruttore più volte con la stessa matrice di byte come argomento per ogni chiamata, si creeranno più gestito <xref:System.Net.Sockets.Socket> istanze con lo stesso socket sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-1414">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="384f5-1415">Questa pratica è fortemente sconsigliata.</span><span class="sxs-lookup"><span data-stu-id="384f5-1415">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="384f5-1416">Se il processo di creazione del socket utilizza i metodi asincroni (<xref:System.Net.Sockets.Socket.BeginReceive%2A> o <xref:System.Net.Sockets.Socket.BeginSend%2A>), il processo è necessario prima impostare il <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> proprietà su true; in caso contrario, il socket è associato alla porta di completamento del processo di creazione, causando un <xref:System.ArgumentNullException> generata nel processo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1416">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1417">
            <paramref name="targetProcessID" /> non è un ID processo valido.  - oppure - La duplicazione del riferimento al socket non è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1417">
              <paramref name="targetProcessID" /> is not a valid process id.  -or-  Duplication of the socket reference failed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1418">Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se il <see cref="T:System.Net.Sockets.Socket" /> può inviare o ricevere pacchetti broadcast.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1418">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1419">
            <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> consente lo scambio di pacchetti broadcast; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1419">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="384f5-1420">Il valore predefinito è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1420">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1421">La trasmissione è limitata a una subnet specifica e deve utilizzare User Datagram Protocol (UDP). Per protocollo Internet versione 4, è possibile trasmettere alla subnet locale mediante l'invio di un pacchetto all'indirizzo 255.255.255.255; oppure è possibile usare l'indirizzo di broadcast, ovvero la parte di rete di un indirizzo IP (Internet Protocol) con tutti i bit impostati nella sezione host.</span><span class="sxs-lookup"><span data-stu-id="384f5-1421">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="384f5-1422">Ad esempio, se l'indirizzo IP è 192.168.1.40 (un indirizzo di classe C, con una subnet mask 255.255.255.0, la parte di rete è i primi tre ottetti e la parte host è l'ultimo ottetto), l'indirizzo broadcast è 192.168.1.255.</span><span class="sxs-lookup"><span data-stu-id="384f5-1422">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="384f5-1423">Impostazione di questa proprietà su un socket di protocollo TCP (Transmission Control) avrà alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1423">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1424">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-1424">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1425">Questa opzione è valida solo per i socket di datagrammi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1425">This option is valid for a datagram socket only.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1426">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1426">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1427">Accetta un tentativo di connessione in ingresso in modalità asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1427">Asynchronously accepts an incoming connection attempt.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-1428">Matrice di tipo <see cref="T:System.Byte" /> contenente i byte trasferiti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1428">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span>
          </span>
        </param>
        <param name="asyncResult">
          <span data-ttu-id="384f5-1429">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1429">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1430">Accetta in modo asincrono una connessione in ingresso e crea un nuovo oggetto <see cref="T:System.Net.Sockets.Socket" /> per gestire la comunicazione con l'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1430">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span>
          </span>
          <span data-ttu-id="384f5-1431">Questo metodo restituisce un buffer contenente i dati iniziali trasferiti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1431">This method returns a buffer that contains the initial data transferred.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1432">Oggetto <see cref="T:System.Net.Sockets.Socket" /> che gestisce la comunicazione con l'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1432">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1433"><xref:System.Net.Sockets.Socket.EndAccept%2A> completa una chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1433"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="384f5-1434">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginAccept%2A>, è necessario creare un metodo di callback che viene richiamato usando il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1434">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1435">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1435">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="384f5-1436">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il `asyncResult` parametro per ottenere il <xref:System.Net.Sockets.Socket> su cui viene effettuato il tentativo di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1436">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="384f5-1437">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo per completare il tentativo di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1437">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="384f5-1438">Il `buffer` parametro di questo overload contiene i dati ricevuti nella chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A> e il `bytesTransferred` parametro contiene il numero di byte che sono stati trasferiti nella chiamata.</span><span class="sxs-lookup"><span data-stu-id="384f5-1438">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="384f5-1439">Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo si blocca fino a quando non è una connessione in sospeso nella coda di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1439">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="384f5-1440">Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo accetta la connessione in ingresso e restituisce un nuovo <xref:System.Net.Sockets.Socket> che può essere utilizzato per inviare e ricevere i dati dall'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1440">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1441">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1441">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1442">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1442">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1443">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1443">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1444">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1444">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1445">Nell'esempio di codice viene illustrato come utilizzare <xref:System.Net.Sockets.Socket.BeginAccept%2A> per creare e collegare un socket e accettare i primi 10 byte di dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1445">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="384f5-1446">Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndAccept%2A> per terminare la richiesta asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-1446">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="384f5-1447">Il numero di byte trasmessi e i dati vengono restituiti nel `buffer` e `bytesTransferred` parametri di questo metodo e vengono visualizzati nella console.</span><span class="sxs-lookup"><span data-stu-id="384f5-1447">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1448">Per questo metodo è richiesto Windows NT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1448">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1449">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1449">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1450">
            <paramref name="asyncResult" /> è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1450">
              <paramref name="asyncResult" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1451">
            <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1451">
              <paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1452">Il metodo <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> è stato chiamato precedentemente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1452">
              <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1453">Si è verificato un errore durante il tentativo di accesso al <see cref="T:System.Net.Sockets.Socket" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1453">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>
          <span data-ttu-id="384f5-1454">Accetta in modo asincrono una connessione in ingresso e crea un nuovo oggetto <see cref="T:System.Net.Sockets.Socket" /> per gestire la comunicazione con l'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1454">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1455">
            <see cref="T:System.Net.Sockets.Socket" /> che gestisce la comunicazione con l'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1455">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1456"><xref:System.Net.Sockets.Socket.EndAccept%2A> completa una chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1456"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="384f5-1457">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginAccept%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1457">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1458">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1458">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="384f5-1459">Deve accettare il `asyncResult` restituito dal parametro di <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1459">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1460">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il `asyncResult` parametro per ottenere il <xref:System.Net.Sockets.Socket> su cui viene effettuato il tentativo di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1460">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="384f5-1461">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo per completare il tentativo di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1461">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="384f5-1462">Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo si blocca fino a quando non è una connessione in sospeso nella coda di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1462">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="384f5-1463">Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo accetta la connessione in ingresso e restituisce un nuovo <xref:System.Net.Sockets.Socket> che può essere utilizzato per inviare e ricevere i dati dall'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1463">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1464">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1464">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1465">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1465">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1466">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1466">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1467">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1467">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1468">Esempio di codice seguente termina una richiesta asincrona e crea un nuovo <xref:System.Net.Sockets.Socket> ad accettare una richiesta di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1468">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="384f5-1469">Per un esempio completo che illustri le comunicazioni asincrone con i socket, vedere [esempi di codice Socket](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1469">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1470">
            <paramref name="asyncResult" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1470">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1471">
            <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1471">
              <paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1472">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1472">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-1473">Per altre informazioni, vedere la sezione Osservazioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1473">See the Remarks section for more information.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1474">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1474">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1475">Il metodo <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> è stato chiamato precedentemente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1475">
              <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1476">Per questo metodo è richiesto Windows NT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1476">Windows NT is required for this method.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-1477">Matrice di tipo <see cref="T:System.Byte" /> contenente i byte trasferiti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1477">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span>
          </span>
        </param>
        <param name="bytesTransferred">
          <span data-ttu-id="384f5-1478">Il numero di byte trasferiti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1478">The number of bytes transferred.</span>
          </span>
        </param>
        <param name="asyncResult">
          <span data-ttu-id="384f5-1479">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1479">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1480">Accetta in modo asincrono una connessione in ingresso e crea un nuovo oggetto <see cref="T:System.Net.Sockets.Socket" /> per gestire la comunicazione con l'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1480">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span>
          </span>
          <span data-ttu-id="384f5-1481">Questo metodo restituisce un buffer contenente i dati iniziali e il numero di byte trasferiti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1481">This method returns a buffer that contains the initial data and the number of bytes transferred.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1482">Oggetto <see cref="T:System.Net.Sockets.Socket" /> che gestisce la comunicazione con l'host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1482">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1483"><xref:System.Net.Sockets.Socket.EndAccept%2A> completa una chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1483"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="384f5-1484">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginAccept%2A>, è necessario creare un metodo di callback che viene richiamato usando il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1484">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1485">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo il <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1485">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="384f5-1486">Deve accettare il `asyncResult` restituito dal parametro di <xref:System.Net.Sockets.Socket.BeginAccept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1486">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1487">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il `asyncResult` parametro per ottenere il <xref:System.Net.Sockets.Socket> su cui viene effettuato il tentativo di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1487">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="384f5-1488">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo per completare il tentativo di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1488">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="384f5-1489">Il `buffer` parametro di questo overload contiene i dati ricevuti nella chiamata a <xref:System.Net.Sockets.Socket.BeginAccept%2A> e il `bytesTransferred` parametro contiene il numero di byte che sono stati trasferiti nella chiamata.</span><span class="sxs-lookup"><span data-stu-id="384f5-1489">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="384f5-1490">Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo si blocca fino a quando non è una connessione in sospeso nella coda di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1490">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="384f5-1491">Il <xref:System.Net.Sockets.Socket.EndAccept%2A> metodo accetta la connessione in ingresso e restituisce un nuovo <xref:System.Net.Sockets.Socket> che può essere utilizzato per inviare e ricevere i dati dall'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1491">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1492">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1492">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1493">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1493">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1494">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1494">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1495">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1495">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1496">Nell'esempio di codice viene illustrato come utilizzare <xref:System.Net.Sockets.Socket.BeginAccept%2A> per creare e collegare un socket e accettare i primi 10 byte di dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1496">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="384f5-1497">Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndAccept%2A> per terminare la richiesta asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-1497">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="384f5-1498">Il numero di byte trasmessi e i dati vengono restituiti nel `buffer` e `bytesTransferred` parametri di questo metodo e vengono visualizzati nella console.</span><span class="sxs-lookup"><span data-stu-id="384f5-1498">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1499">Per questo metodo è richiesto Windows NT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1499">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1500">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1500">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1501">
            <paramref name="asyncResult" /> è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1501">
              <paramref name="asyncResult" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1502">
            <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1502">
              <paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1503">Il metodo <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> è stato chiamato precedentemente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1503">
              <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1504">Si è verificato un errore durante il tentativo di accesso al <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1504">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>
          <span data-ttu-id="384f5-1505">Termina una richiesta di connessione sincrona in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1505">Ends a pending asynchronous connection request.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1506"><xref:System.Net.Sockets.Socket.EndConnect%2A> è stato avviato un metodo di blocco che viene completata la richiesta di connessione asincrona host remoto nel <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1506"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1507">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginConnect%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1507">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1508">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginConnect%2A> restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1508">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="384f5-1509">Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginConnect%2A> metodo come parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1509">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="384f5-1510">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere il <xref:System.Net.Sockets.Socket> su cui viene effettuato il tentativo di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1510">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="384f5-1511">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndConnect%2A> metodo per completare il tentativo di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1511">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1512">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1512">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1513">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1513">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1514">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1514">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1515">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1515">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1516">Esempio di codice seguente termina il tentativo di connessione asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-1516">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="384f5-1517">Per un esempio completo che illustri le comunicazioni asincrone con i socket, vedere [esempi di codice Socket](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1517">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1518">
            <paramref name="asyncResult" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1518">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1519">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1519">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1520">
            <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> è stato precedentemente chiamato per la connessione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1520">
              <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1521">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1521">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1522">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1522">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="384f5-1523">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1523">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1524">Termina una richiesta di disconnessione asincrona in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1524">Ends a pending asynchronous disconnect request.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1525"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completa una chiamata a <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1525"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="384f5-1526">Il <xref:System.Net.Sockets.Socket.EndDisconnect%2A> metodo mantiene il blocco fino al completamento della disconnessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1526">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="384f5-1527">Per informazioni sulle operazioni asincrone, vedere l'argomento Cenni preliminari sulla programmazione asincrona in MSDN library.</span><span class="sxs-lookup"><span data-stu-id="384f5-1527">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1528">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1528">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1529">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1529">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1530">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1530">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1531">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1531">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1532">Esempio di codice seguente crea un socket per la comunicazione asincrona e vengono inviati dati a un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1532">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="384f5-1533">Quando i dati sono stati inviati, <xref:System.Net.Sockets.Socket.Shutdown%2A> viene chiamato per arrestare l'invio e ricezione attività.</span><span class="sxs-lookup"><span data-stu-id="384f5-1533">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="384f5-1534">Quindi <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> viene chiamato per avviare una richiesta di disconnessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1534">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="384f5-1535">Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndDisconnect%2A> per terminare la richiesta asincrona.</span><span class="sxs-lookup"><span data-stu-id="384f5-1535">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="384f5-1536">Al completamento della richiesta, il <xref:System.Net.Sockets.Socket.Connected%2A> viene eseguita una query sulla proprietà per verificare se il socket è disconnesso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1536">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1537">Il sistema operativo è Windows 2000 o versioni precedenti e il metodo richiede Windows XP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1537">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1538">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1538">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1539">
            <paramref name="asyncResult" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1539">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1540">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1540">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1541">
            <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> è stato precedentemente chiamato per la connessione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1541">
              <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1542">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1542">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.WebException">
          <span data-ttu-id="384f5-1543">Timeout della richiesta di disconnessione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1543">The disconnect request has timed out.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1544">Termina una lettura asincrona in attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1544">Ends a pending asynchronous read.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>
          <span data-ttu-id="384f5-1545">Termina una lettura asincrona in attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1545">Ends a pending asynchronous read.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1546">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1546">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1547">Il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo completa l'operazione di lettura asincrona avviata nel <xref:System.Net.Sockets.Socket.BeginReceive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1547">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1548">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginReceive%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1548">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1549">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginReceive%2A> restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1549">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="384f5-1550">Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginReceive%2A> metodo come parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1550">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="384f5-1551">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> per ottenere l'oggetto di stato passato al <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1551">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="384f5-1552">Estrarre la ricezione <xref:System.Net.Sockets.Socket> dall'oggetto di stato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1552">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="384f5-1553">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo per completare l'operazione di lettura e restituire il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-1553">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="384f5-1554">Il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo verrà bloccati finché non sono disponibili dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1554">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="384f5-1555">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.EndReceive%2A> leggerà il primo datagramma disponibile nel buffer di rete in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1555">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="384f5-1556">Se si utilizza un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo leggerà tutti i dati disponibili fino al numero di byte specificato il `size` parametro del <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1556">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="384f5-1557">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-1557">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-1558">Per ottenere i dati ricevuti, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo il <xref:System.IAsyncResult>ed estrarre il buffer contenuto nell'oggetto di stato risultante.</span><span class="sxs-lookup"><span data-stu-id="384f5-1558">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="384f5-1559">Per annullare un in sospeso <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1559">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1560">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1560">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1561">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1561">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1562">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-1562">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-1563">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1563">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1564">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1564">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1565">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1565">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1566">Esempio di codice seguente termina una lettura asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1566">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="384f5-1567">Per un esempio completo che illustri le comunicazioni asincrone con i socket, vedere [esempi di codice Socket](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1567">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1568">
            <paramref name="asyncResult" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1568">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1569">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1569">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1570">
            <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> è stato precedentemente chiamato per la lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1570">
              <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1571">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1571">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1572">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1572">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="384f5-1573">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1573">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="384f5-1574">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1574">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1575">Termina una lettura asincrona in attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1575">Ends a pending asynchronous read.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1576">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1576">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1577">Il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo completa l'operazione di lettura asincrona avviata nel <xref:System.Net.Sockets.Socket.BeginReceive%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1577">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1578">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginReceive%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1578">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1579">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginReceive%2A> restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1579">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="384f5-1580">Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginReceive%2A> metodo come parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1580">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="384f5-1581">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> per ottenere l'oggetto di stato passato al <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1581">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="384f5-1582">Estrarre la ricezione <xref:System.Net.Sockets.Socket> dall'oggetto di stato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1582">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="384f5-1583">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo per completare l'operazione di lettura e restituire il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-1583">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="384f5-1584">Il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo verrà bloccati finché non sono disponibili dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1584">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="384f5-1585">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.EndReceive%2A> leggerà il primo datagramma disponibile nel buffer di rete in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1585">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="384f5-1586">Se si utilizza un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo leggerà tutti i dati disponibili fino al numero di byte specificato il `size` parametro del <xref:System.Net.Sockets.Socket.BeginReceive%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1586">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="384f5-1587">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.EndReceive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-1587">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-1588">Per ottenere i dati ricevuti, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo il <xref:System.IAsyncResult>ed estrarre il buffer contenuto nell'oggetto di stato risultante.</span><span class="sxs-lookup"><span data-stu-id="384f5-1588">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1589">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1589">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1590">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1590">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1591">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-1591">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-1592">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1592">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1593">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1593">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1594">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1594">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1595">
            <paramref name="asyncResult" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1595">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1596">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1596">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1597">
            <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> è stato precedentemente chiamato per la lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1597">
              <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1598">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1598">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1599">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1599">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <param name="endPoint">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>
          <span data-ttu-id="384f5-1600">Termina una lettura asincrona in sospeso da uno specifico endpoint.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1600">Ends a pending asynchronous read from a specific endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1601">Se ha esito positivo, numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1601">If successful, the number of bytes received.</span>
          </span>
          <span data-ttu-id="384f5-1602">Se ha esito negativo restituisce 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1602">If unsuccessful, returns 0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1603">Il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo completa l'operazione di lettura asincrona avviata nel <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1603">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1604">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1604">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1605">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1605">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="384f5-1606">Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> metodo come parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1606">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="384f5-1607">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> per ottenere l'oggetto di stato passato al <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1607">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-1608">Estrarre la ricezione <xref:System.Net.Sockets.Socket> dall'oggetto di stato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1608">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="384f5-1609">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo per completare l'operazione di lettura e restituire il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-1609">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="384f5-1610">Il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo verrà bloccati finché non sono disponibili dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1610">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="384f5-1611">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> leggerà il primo datagramma disponibile nel buffer di rete in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1611">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="384f5-1612">Se si utilizza un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo leggerà tutti i dati disponibili fino al numero di byte specificato il `size` parametro del <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-1612">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-1613">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-1613">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="384f5-1614">Per ottenere i dati ricevuti, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo il <xref:System.IAsyncResult> oggetto ed estrarre il buffer contenuto nell'oggetto di stato risultante.</span><span class="sxs-lookup"><span data-stu-id="384f5-1614">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="384f5-1615">Per identificare l'host di origine, estrarre il <xref:System.Net.EndPoint> e di eseguirne il cast su un <xref:System.Net.IPEndPoint>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1615">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="384f5-1616">Usare la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodo per ottenere l'indirizzo IP e il <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodo per ottenere il numero di porta.</span><span class="sxs-lookup"><span data-stu-id="384f5-1616">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1617">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1617">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1618">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1618">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1619">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1619">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1620">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1620">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1621">Esempio di codice seguente termina una lettura asincrona in sospeso da uno specifico <xref:System.Net.EndPoint>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1621">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1622">
            <paramref name="asyncResult" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1622">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1623">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1623">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1624">
            <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> è stato precedentemente chiamato per la lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1624">
              <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1625">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1625">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1626">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1626">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="384f5-1627">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza informazioni sullo stato e qualsiasi dato definito dall'utente per l'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1627">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-1628">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" /> relativi al pacchetto ricevuto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1628">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span>
          </span>
        </param>
        <param name="endPoint">
          <span data-ttu-id="384f5-1629">Il <see cref="T:System.Net.EndPoint" /> di origine.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1629">The source <see cref="T:System.Net.EndPoint" />.</span>
          </span>
        </param>
        <param name="ipPacketInformation">
          <span data-ttu-id="384f5-1630">L'<see cref="T:System.Net.IPAddress" /> e l'interfaccia del pacchetto ricevuto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1630">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1631">Termina una lettura asincrona in sospeso da uno specifico endpoint.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1631">Ends a pending asynchronous read from a specific endpoint.</span>
          </span>
          <span data-ttu-id="384f5-1632">Questo metodo fornisce inoltre ulteriori informazioni sul pacchetto rispetto a <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1632">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1633">Se ha esito positivo, numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1633">If successful, the number of bytes received.</span>
          </span>
          <span data-ttu-id="384f5-1634">Se ha esito negativo restituisce 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1634">If unsuccessful, returns 0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1635">Se l'operazione non è stata completata, questo metodo si blocca fino a quando non avviene.</span><span class="sxs-lookup"><span data-stu-id="384f5-1635">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="384f5-1636">Per eseguire questa operazione in modo sincrono, utilizzare il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1636">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-1637">Esaminare `ipPacketInformation` se è necessario sapere se il datagramma è stato inviato tramite un indirizzo multicast o broadcast unicast,.</span><span class="sxs-lookup"><span data-stu-id="384f5-1637">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1638">
            <paramref name="asyncResult" /> è <see langword="null" />  - oppure - <paramref name="endPoint" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1638">
              <paramref name="asyncResult" /> is <see langword="null" />  -or-  <paramref name="endPoint" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1639">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1639">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1640">
            <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> è stato precedentemente chiamato per la lettura asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1640">
              <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1641">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1641">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1642">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1642">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1643">Termina un invio asincrono in attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1643">Ends a pending asynchronous send.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>
          <span data-ttu-id="384f5-1644">Termina un invio asincrono in attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1644">Ends a pending asynchronous send.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1645">Se ha esito positivo, numero di byte inviati al <see cref="T:System.Net.Sockets.Socket" />. In caso contrario, errore di <see cref="T:System.Net.Sockets.Socket" /> non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1645">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1646"><xref:System.Net.Sockets.Socket.EndSend%2A> completa l'operazione di invio asincrono avviata in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1646"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="384f5-1647">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1647">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1648">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginSend%2A> restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1648">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="384f5-1649">Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo come parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1649">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="384f5-1650">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere l'invio <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1650">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1651">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> metodo per completare l'operazione di invio e restituire il numero di byte inviati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1651">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="384f5-1652">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.EndSend%2A> verranno bloccati finché non viene inviato il datagramma.</span><span class="sxs-lookup"><span data-stu-id="384f5-1652">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="384f5-1653">Se si utilizza un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.EndSend%2A> verranno bloccati finché non alcuni del buffer è stato inviato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1653">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="384f5-1654">Se il valore restituito da <xref:System.Net.Sockets.Socket.EndSend%2A> indica che il buffer non è stato inviato completamente, chiamare il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo nuovamente, modificando il buffer per contenere i dati non inviati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1654">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="384f5-1655">Non è garantito che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-1655">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-1656">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-1656">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-1657">Il completamento del <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-1657">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1658">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1658">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1659">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1659">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1660">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-1660">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-1661">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1661">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1662">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1662">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-1663">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-1663">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1664">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1664">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1665">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1665">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1666">Esempio di codice seguente termina una trasmissione asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1666">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1667">
            <paramref name="asyncResult" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1667">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1668">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1668">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1669">
            <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> è stato precedentemente chiamato per l'invio asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1669">
              <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1670">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1670">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1671">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1671">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="384f5-1672">
            <see cref="T:System.IAsyncResult" /> che memorizza le informazioni di stato per l'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1672">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="384f5-1673">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1673">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1674">Termina un invio asincrono in attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1674">Ends a pending asynchronous send.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1675">Se ha esito positivo, numero di byte inviati al <see cref="T:System.Net.Sockets.Socket" />. In caso contrario, errore di <see cref="T:System.Net.Sockets.Socket" /> non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1675">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1676"><xref:System.Net.Sockets.Socket.EndSend%2A> completa l'operazione di invio asincrono avviata in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1676"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="384f5-1677">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginSend%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1677">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1678">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginSend%2A> restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1678">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="384f5-1679">Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo come parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1679">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="384f5-1680">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere l'invio <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1680">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1681">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndSend%2A> metodo per completare l'operazione di invio e restituire il numero di byte inviati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1681">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="384f5-1682">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.EndSend%2A> verranno bloccati finché non viene inviato il datagramma.</span><span class="sxs-lookup"><span data-stu-id="384f5-1682">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="384f5-1683">Se si utilizza un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.EndSend%2A> verranno bloccati finché non alcuni del buffer è stato inviato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1683">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="384f5-1684">Se il valore restituito da <xref:System.Net.Sockets.Socket.EndSend%2A> indica che il buffer non è stato inviato completamente, chiamare il <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo nuovamente, modificando il buffer per contenere i dati non inviati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1684">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="384f5-1685">Non è garantito che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-1685">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-1686">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-1686">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-1687">Il completamento del <xref:System.Net.Sockets.Socket.BeginSend%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-1687">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1688">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1688">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1689">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1689">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1690">Tutti i/o avviata da un determinato thread viene annullato all'uscita dal thread.</span><span class="sxs-lookup"><span data-stu-id="384f5-1690">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="384f5-1691">Un'operazione asincrona in sospeso può non riuscire se il thread venga chiuso prima del completamento dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1691">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1692">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1692">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-1693">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-1693">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1694">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1694">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1695">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1695">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1696">
            <paramref name="asyncResult" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1696">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1697">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1697">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1698">
            <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> è stato precedentemente chiamato per l'invio asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1698">
              <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1699">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1699">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1700">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1700">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="384f5-1701">Oggetto <see cref="T:System.IAsyncResult" /> che memorizza le informazioni di stato per l'operazione asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1701">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1702">Termina l'invio asincrono di un file in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1702">Ends a pending asynchronous send of a file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1703"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completa l'operazione di invio asincrono avviata in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1703"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="384f5-1704">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1704">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1705">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginSendFile%2A> restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1705">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="384f5-1706">Il metodo di callback deve accettare il <xref:System.IAsyncResult> oggetto restituito dal <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo come parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1706">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="384f5-1707">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere l'invio <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1707">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1708">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndSendFile%2A> metodo per completare l'operazione di invio.</span><span class="sxs-lookup"><span data-stu-id="384f5-1708">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="384f5-1709">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocca fino a quando non viene inviato il datagramma.</span><span class="sxs-lookup"><span data-stu-id="384f5-1709">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="384f5-1710">Se si utilizza un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocca fino a quando non viene inviato l'intero file.</span><span class="sxs-lookup"><span data-stu-id="384f5-1710">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="384f5-1711">Non è garantito che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-1711">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-1712">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-1712">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-1713">Il completamento del <xref:System.Net.Sockets.Socket.BeginSendFile%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-1713">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1714">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1714">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1715">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1715">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1716">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1716">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1717">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1717">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1718">Esempio di codice seguente crea e si connette un socket per la comunicazione asincrona e inizia a inviare il file "txt" in modo asincrono all'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1718">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="384f5-1719">Il delegato di callback chiama <xref:System.Net.Sockets.Socket.EndSendFile%2A> per completare la trasmissione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1719">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1720">Per questo metodo è richiesto Windows NT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1720">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1721">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1721">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1722">
            <paramref name="asyncResult" /> è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1722">
              <paramref name="asyncResult" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1723">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1723">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1724">
            <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> è stato precedentemente chiamato il <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1724">
              <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1725">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1725">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-1726">Vedere la sezione Osservazioni riportata di seguito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1726">See remarks section below.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>
          <span data-ttu-id="384f5-1727">Termina un invio asincrono in sospeso a una posizione specifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1727">Ends a pending asynchronous send to a specific location.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1728">Se ha esito positivo, numero di byte trasmessi. In caso contrario, errore di <see cref="T:System.Net.Sockets.Socket" /> non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1728">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1729"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completa l'operazione di invio asincrono avviata in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1729"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="384f5-1730">Prima di chiamare <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, è necessario creare un metodo di callback che implementa il <xref:System.AsyncCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1730">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="384f5-1731">Questo metodo di callback viene eseguito in un thread separato e viene chiamato dal sistema dopo <xref:System.Net.Sockets.Socket.BeginReceive%2A> restituisce.</span><span class="sxs-lookup"><span data-stu-id="384f5-1731">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="384f5-1732">Il metodo di callback deve accettare il <xref:System.IAsyncResult> restituito dal <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo come parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1732">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="384f5-1733">All'interno del metodo di callback, chiamare il <xref:System.IAsyncResult.AsyncState%2A> metodo per il <xref:System.IAsyncResult> parametro per ottenere l'invio <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1733">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1734">Dopo aver ottenuto il <xref:System.Net.Sockets.Socket>, è possibile chiamare il <xref:System.Net.Sockets.Socket.EndSendTo%2A> metodo per completare l'operazione di invio e restituire il numero di byte inviati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1734">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="384f5-1735">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.EndSendTo%2A> verranno bloccati finché non viene inviato il datagramma.</span><span class="sxs-lookup"><span data-stu-id="384f5-1735">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="384f5-1736">Se si utilizza un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.EndSendTo%2A> verranno bloccati finché non viene inviato il numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1736">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="384f5-1737">Non è garantito che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-1737">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-1738">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-1738">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-1739">Il completamento del <xref:System.Net.Sockets.Socket.BeginSendTo%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-1739">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1740">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1740">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1741">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1741">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1742">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1742">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1743">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1743">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1744">Esempio di codice seguente termina un'operazione di invio asincrono in un percorso specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1744">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-1745">
            <paramref name="asyncResult" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1745">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-1746">
            <paramref name="asyncResult" /> non è stato restituito da una chiamata al metodo <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1746">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1747">
            <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> è stato precedentemente chiamato per l'invio asincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1747">
              <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1748">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1748">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1749">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1749">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1750">Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se il <see cref="T:System.Net.Sockets.Socket" /> consente di associare a una porta un unico processo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1750">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1751">
            <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> consente a un solo socket di essere associato a una porta specifica; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1751">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="384f5-1752">Il valore predefinito è <see langword="true" /> per Windows Server 2003 e Windows XP Service Pack 2 e <see langword="false" /> per tutte le altre versioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1752">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1753">Se <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> viene `false`, più socket possono utilizzare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo da associare a una porta specifica; tuttavia, solo uno dei socket può eseguire operazioni sul traffico di rete inviato alla porta.</span><span class="sxs-lookup"><span data-stu-id="384f5-1753">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="384f5-1754">Se più di un socket prova a usare il <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> metodo da associare a una porta specifica quindi una con l'indirizzo IP più specifico gestirà il traffico di rete inviato alla porta.</span><span class="sxs-lookup"><span data-stu-id="384f5-1754">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="384f5-1755">Se <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> viene `true`, il primo utilizzo del <xref:System.Net.Sockets.Socket.Bind%2A> metodo nel tentativo di associare a una porta specifica, indipendentemente dall'indirizzo IP (Internet Protocol), avrà esito positivo, vengono utilizzati tutti i successivi del <xref:System.Net.Sockets.Socket.Bind%2A> metodo tenta di associare a tale porta verrà esito negativo fino a quando il socket associato originale viene eliminato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-1755">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="384f5-1756">Questa proprietà deve essere impostata prima <xref:System.Net.Sockets.Socket.Bind%2A> chiamato; in caso contrario un <xref:System.InvalidOperationException> verrà generata.</span><span class="sxs-lookup"><span data-stu-id="384f5-1756">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1757">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-1757">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1758">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1758">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1759">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1759">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1760">
            <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> è stato chiamato per questo <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1760">
              <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1761">Rilascia le risorse usate dalla classe <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1761">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1762">Il <xref:System.Net.Sockets.Socket> classe chiamate finalizzatore il <xref:System.Net.Sockets.Socket.Close%2A> metodo per chiudere la <xref:System.Net.Sockets.Socket> e rilasciare le risorse associate il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1762">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1763">Restituisce il valore di un'opzione di <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1763">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="384f5-1764">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1764">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="384f5-1765">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1765">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1766">Restituisce il valore di un'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata, rappresentata da un oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1766">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1767">Oggetto che rappresenta il valore dell'opzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1767">An object that represents the value of the option.</span>
          </span>
          <span data-ttu-id="384f5-1768">Quando il parametro <paramref name="optionName" /> è impostato su <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, il valore restituito è un'istanza della classe <see cref="T:System.Net.Sockets.LingerOption" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1768">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span>
          </span>
          <span data-ttu-id="384f5-1769">Quando <paramref name="optionName" /> è impostato su <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> o <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, il valore restituito è un'istanza della classe <see cref="T:System.Net.Sockets.MulticastOption" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1769">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span>
          </span>
          <span data-ttu-id="384f5-1770">Quando <paramref name="optionName" /> è qualsiasi altro valore, il valore restituito è un intero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1770">When <paramref name="optionName" /> is any other value, the return value is an integer.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1771"><xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1771"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1772">Utilizzare questo overload per ottenere il <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, e <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opzioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-1772">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="384f5-1773">Per il <xref:System.Net.Sockets.SocketOptionName.Linger> opzione, usare <xref:System.Net.Sockets.Socket> per il `optionLevel` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-1773">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="384f5-1774">Per <xref:System.Net.Sockets.SocketOptionName.AddMembership> e <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilizzare <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1774">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="384f5-1775">Se si desidera impostare il valore di una delle opzioni elencate in precedenza, utilizzare il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1775">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1776">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1776">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1777">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1777">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1778">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1778">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1779">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1779">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1780">Nell'esempio di codice riportato di seguito viene recuperato il <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> timeout valori e li visualizza nella console.</span><span class="sxs-lookup"><span data-stu-id="384f5-1780">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1781">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1781">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-1782">- oppure - <paramref name="optionName" /> è stato impostato su un valore di <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> non supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1782">-or-  <paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1783">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1783">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="384f5-1784">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1784">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="384f5-1785">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1785">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="384f5-1786">Matrice di tipo <see cref="T:System.Byte" /> che deve ricevere l'impostazione dell'opzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1786">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1787">Restituisce l'impostazione dell'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata, rappresentata come una matrice di byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1787">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1788"><xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1788"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1789">Al completamento di questo metodo, la matrice specificata per il `optionValue` parametro contiene il valore dell'oggetto specificato <xref:System.Net.Sockets.Socket> opzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1789">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="384f5-1790">Quando la lunghezza del `optionValue` matrice è inferiore al numero di byte necessari per archiviare il valore dell'oggetto specificato <xref:System.Net.Sockets.Socket> opzione <xref:System.Net.Sockets.Socket.GetSocketOption%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1790">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-1791">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1791">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1792">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1792">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="384f5-1793">Utilizzare questo overload per qualsiasi socket che sono rappresentati da numeri interi o valori booleani.</span><span class="sxs-lookup"><span data-stu-id="384f5-1793">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1794">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1794">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1795">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1795">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1796">Nell'esempio di codice riportato di seguito viene recuperato il <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> timeout valori e li visualizza nella console.</span><span class="sxs-lookup"><span data-stu-id="384f5-1796">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1797">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1797">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-1798">\- oppure - Nelle applicazioni di .NET Compact Framework, lo spazio di buffer predefinito per Windows CE è impostato su 32768 byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1798">\- or -  In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span>
          </span>
          <span data-ttu-id="384f5-1799">È possibile modificare lo spazio di buffer per ciascun socket chiamando <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1799">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1800">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1800">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="384f5-1801">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1801">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="384f5-1802">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1802">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionLength">
          <span data-ttu-id="384f5-1803">Lunghezza in byte del valore restituito previsto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1803">The length, in bytes, of the expected return value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1804">Restituisce in una matrice il valore dell'opzione di <see cref="T:System.Net.Sockets.Socket" /> specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1804">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1805">Matrice di tipo <see cref="T:System.Byte" /> che contiene il valore dell'opzione di socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1805">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1806">Il `optionLength` parametro imposta la dimensione massima della matrice di byte restituita.</span><span class="sxs-lookup"><span data-stu-id="384f5-1806">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="384f5-1807">Se il valore dell'opzione richiede un minor numero di byte, la matrice conterrà solo tale numero di byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-1807">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="384f5-1808">Se il valore dell'opzione richiede più byte <xref:System.Net.Sockets.Socket.GetSocketOption%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1808">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-1809">Utilizzare questo overload per qualsiasi socket che sono rappresentati da numeri interi o valori booleani.</span><span class="sxs-lookup"><span data-stu-id="384f5-1809">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1810">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1810">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1811">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1811">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1812">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1812">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1813">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1813">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1814">Nell'esempio di codice riportato di seguito viene recuperato il <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> timeout valori e li visualizza nella console.</span><span class="sxs-lookup"><span data-stu-id="384f5-1814">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1815">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1815">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-1816">\- oppure - Nelle applicazioni di .NET Compact Framework, lo spazio di buffer predefinito per Windows CE è impostato su 32768 byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1816">\- or -  In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span>
          </span>
          <span data-ttu-id="384f5-1817">È possibile modificare lo spazio di buffer per ciascun socket chiamando <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1817">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1818">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1818">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1819">Ottiene l'handle del sistema operativo per il <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1819">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1820">Valore <see cref="T:System.IntPtr" /> che rappresenta l'handle del sistema operativo per il <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1820">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1821">Imposta le modalità operative di basso livello per il <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1821">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <span data-ttu-id="384f5-1822">Valore di <see cref="T:System.Int32" /> che specifica il codice di controllo dell'operazione da eseguire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1822">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span>
          </span>
        </param>
        <param name="optionInValue">
          <span data-ttu-id="384f5-1823">Matrice <see cref="T:System.Byte" /> che contiene i dati di input richiesti dall'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1823">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span>
          </span>
        </param>
        <param name="optionOutValue">
          <span data-ttu-id="384f5-1824">Matrice <see cref="T:System.Byte" /> che contiene i dati di output richiesti dall'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1824">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1825">Imposta le modalità operative di basso livello per il <see cref="T:System.Net.Sockets.Socket" /> utilizzando codici di controllo numerici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1825">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1826">Numero di byte nel parametro <paramref name="optionOutValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1826">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1827">Il <xref:System.Net.Sockets.Socket.IOControl%2A> metodo fornisce l'accesso di basso livello per il sistema operativo <xref:System.Net.Sockets.Socket> sottostante l'istanza corrente della <xref:System.Net.Sockets.Socket> classe.</span><span class="sxs-lookup"><span data-stu-id="384f5-1827">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="384f5-1828">Per altre informazioni, vedere la documentazione WSAIoctl in MSDN library.</span><span class="sxs-lookup"><span data-stu-id="384f5-1828">For more information, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1829">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1829">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1830">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1830">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1831">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1831">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1832">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1832">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1833">Esempio di codice seguente vengono confrontati i risultati di FIONREAD e le proprietà disponibili.</span><span class="sxs-lookup"><span data-stu-id="384f5-1833">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1834">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1834">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1835">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1835">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1836">È stato effettuato un tentativo di modificare la modalità di blocco senza utilizzare la proprietà <see cref="P:System.Net.Sockets.Socket.Blocking" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1836">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-1837">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1837">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="384f5-1838">Per eseguire codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1838">to execute unmanaged code.</span>
          </span>
          <span data-ttu-id="384f5-1839">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1839">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <span data-ttu-id="384f5-1840">Valore di <see cref="T:System.Net.Sockets.IOControlCode" /> che specifica il codice di controllo dell'operazione da eseguire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1840">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span>
          </span>
        </param>
        <param name="optionInValue">
          <span data-ttu-id="384f5-1841">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati di input richiesti dall'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1841">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span>
          </span>
        </param>
        <param name="optionOutValue">
          <span data-ttu-id="384f5-1842">Matrice di tipo <see cref="T:System.Byte" /> che contiene i dati di output restituiti dall'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1842">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1843">Imposta le modalità operative di basso livello per il <see cref="T:System.Net.Sockets.Socket" /> utilizzando l'enumerazione <see cref="T:System.Net.Sockets.IOControlCode" /> per specificare i codici di controllo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1843">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1844">Numero di byte nel parametro <paramref name="optionOutValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1844">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1845">Questo metodo fornisce l'accesso di basso livello per il sistema operativo <xref:System.Net.Sockets.Socket> sottostante l'istanza corrente della <xref:System.Net.Sockets.Socket> classe.</span><span class="sxs-lookup"><span data-stu-id="384f5-1845">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="384f5-1846">Per altre informazioni, vedere la documentazione WSAIoctl in MSDN library.</span><span class="sxs-lookup"><span data-stu-id="384f5-1846">For more, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1847">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1847">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1848">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1848">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1849">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1849">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1850">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1850">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1851">Esempio di codice seguente vengono confrontati i risultati della chiamata al metodo <xref:System.Net.Sockets.Socket.IOControl%2A> con <xref:System.Net.Sockets.IOControlCode.DataToRead> e il <xref:System.Net.Sockets.Socket.Available%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-1851">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1852">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1852">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1853">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1853">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-1854">È stato effettuato un tentativo di modificare la modalità di blocco senza utilizzare la proprietà <see cref="P:System.Net.Sockets.Socket.Blocking" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1854">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="384f5-1855">Per eseguire codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1855">to execute unmanaged code.</span>
          </span>
          <span data-ttu-id="384f5-1856">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1856">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1857">Ottiene un valore che indica se il <see cref="T:System.Net.Sockets.Socket" /> è associato a una porta locale specifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1857">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1858">
            <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> è associato a una porta locale; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1858">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1859">Un socket è considerato associato a una porta locale se è associato in modo esplicito chiamando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, o in modo implicito chiamando i membri, ad esempio <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, che utilizzano una porta locale temporanea (una porta disponibile maggiore di 1024, selezionata per il sistema operativo.) I server usano il <xref:System.Net.Sockets.Socket.Bind%2A> metodo da associare a una porta ben nota in modo che i client possono connettersi a essi.</span><span class="sxs-lookup"><span data-stu-id="384f5-1859">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1860">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.IsBound%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-1860">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1861">Ottiene o imposta un valore che specifica se il <see cref="T:System.Net.Sockets.Socket" /> ritarderà la chiusura di un socket durante un tentativo di invio di tutti i dati in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1861">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1862">
            <see cref="T:System.Net.Sockets.LingerOption" /> che specifica la modalità di attivazione del ritardo durante la chiusura di un socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1862">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1863">Il <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà cambia la modalità <xref:System.Net.Sockets.Socket.Close%2A> comportamento del metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1863">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="384f5-1864">Questa proprietà quando è impostata Modifica le condizioni in cui la connessione può essere reimpostata Winsock.</span><span class="sxs-lookup"><span data-stu-id="384f5-1864">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="384f5-1865">Reimpostazioni di connessioni possono ancora verificarsi in base al comportamento del protocollo IP.</span><span class="sxs-lookup"><span data-stu-id="384f5-1865">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="384f5-1866">Questa proprietà controlla il periodo di tempo che una connessione orientato alla connessione rimarrà aperta dopo una chiamata a <xref:System.Net.Sockets.Socket.Close%2A> quando rimangono dati da inviare.</span><span class="sxs-lookup"><span data-stu-id="384f5-1866">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="384f5-1867">Quando si chiamano metodi per inviare dati a un peer, questi dati viene posizionati nel buffer di rete in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-1867">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="384f5-1868">Questa proprietà può essere utilizzata per garantire che questi dati viene inviati all'host remoto prima di <xref:System.Net.Sockets.TcpClient.Close%2A> metodo elimina la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1868">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="384f5-1869">Per abilitare il tempo di ritardo, creare una <xref:System.Net.Sockets.LingerOption> istanza contenente i valori desiderati, quindi impostare il <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà a questa istanza.</span><span class="sxs-lookup"><span data-stu-id="384f5-1869">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="384f5-1870">Nella tabella seguente viene descritto il comportamento del <xref:System.Net.Sockets.Socket.Close%2A> metodo per i valori possibili del <xref:System.Net.Sockets.LingerOption.Enabled%2A> proprietà e il <xref:System.Net.Sockets.LingerOption.LingerTime%2A> proprietà archiviata nel <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-1870">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="384f5-1871">LingerState.Enabled</span><span class="sxs-lookup"><span data-stu-id="384f5-1871">LingerState.Enabled</span></span>|<span data-ttu-id="384f5-1872">LingerState.LingerTime</span><span class="sxs-lookup"><span data-stu-id="384f5-1872">LingerState.LingerTime</span></span>|<span data-ttu-id="384f5-1873">Comportamento</span><span class="sxs-lookup"><span data-stu-id="384f5-1873">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="384f5-1874">`false` (disabilitato), il valore predefinito</span><span class="sxs-lookup"><span data-stu-id="384f5-1874">`false` (disabled), the default value</span></span>|<span data-ttu-id="384f5-1875">Non è applicabile, il timeout (impostazione predefinita).</span><span class="sxs-lookup"><span data-stu-id="384f5-1875">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="384f5-1876">Tenta di inviare dati in sospeso fino alla scadenza del timeout del protocollo IP predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-1876">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="384f5-1877">`true` (abilitata)</span><span class="sxs-lookup"><span data-stu-id="384f5-1877">`true` (enabled)</span></span>|<span data-ttu-id="384f5-1878">Un timeout diverso da zero</span><span class="sxs-lookup"><span data-stu-id="384f5-1878">A nonzero time-out</span></span>|<span data-ttu-id="384f5-1879">Tenta di inviare dati in sospeso finché non scade il timeout specificato, e se il tentativo non riesce, Winsock reimposta la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1879">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="384f5-1880">`true` (abilitata)</span><span class="sxs-lookup"><span data-stu-id="384f5-1880">`true` (enabled)</span></span>|<span data-ttu-id="384f5-1881">Un timeout zero.</span><span class="sxs-lookup"><span data-stu-id="384f5-1881">A zero timeout.</span></span>|<span data-ttu-id="384f5-1882">Ignora tutti i dati in sospeso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1882">Discards any pending data.</span></span> <span data-ttu-id="384f5-1883">Per il socket orientati alla connessione (ad esempio, TCP), Winsock reimposta la connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1883">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="384f5-1884">Lo stack IP calcola il periodo di timeout predefinito protocollo IP da utilizzare in base al tempo di round trip della connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1884">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="384f5-1885">Nella maggior parte dei casi, il timeout calcolato da parte dello stack è più utile rispetto a quello definito da un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1885">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="384f5-1886">Si tratta del comportamento predefinito per un socket quando il <xref:System.Net.Sockets.Socket.LingerState%2A> non è impostata.</span><span class="sxs-lookup"><span data-stu-id="384f5-1886">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="384f5-1887">Quando il <xref:System.Net.Sockets.LingerOption.LingerTime%2A> proprietà archiviata nel <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà è maggiore del timeout del protocollo IP predefinito, il timeout del protocollo IP predefinito verrà comunque applicare ed eseguire l'override.</span><span class="sxs-lookup"><span data-stu-id="384f5-1887">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1888">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.LingerState%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-1888">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1889">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1889">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1890">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1890">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">
          <span data-ttu-id="384f5-1891">Lunghezza massima della coda delle connessioni in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1891">The maximum length of the pending connections queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1892">Colloca un <see cref="T:System.Net.Sockets.Socket" /> in uno stato di attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1892">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1893"><xref:System.Net.Sockets.Socket.Listen%2A> fa sì che un orientato alla connessione <xref:System.Net.Sockets.Socket> per restare in ascolto per i tentativi di connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1893"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="384f5-1894">Il `backlog` parametro specifica il numero di connessioni in ingresso che possono essere inseriti nella coda per l'accettazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1894">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="384f5-1895">Per determinare il numero massimo di connessioni è possibile specificare, recuperare il <xref:System.Net.Sockets.SocketOptionName.MaxConnections> valore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1895">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="384f5-1896"><xref:System.Net.Sockets.Socket.Listen%2A> non è bloccata.</span><span class="sxs-lookup"><span data-stu-id="384f5-1896"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="384f5-1897">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1897">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1898">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1898">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="384f5-1899">Uso <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.BeginAccept%2A> ad accettare una connessione dalla coda.</span><span class="sxs-lookup"><span data-stu-id="384f5-1899">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1900">È necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.Listen%2A>, o <xref:System.Net.Sockets.Socket.Listen%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1900">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1901">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1901">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1902">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1902">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1903">Il parametro backlog è limitato a valori diversi a seconda del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1903">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="384f5-1904">È possibile specificare un valore più elevato, ma il backlog sarà limitato in base al sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1904">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1905">Nell'esempio di codice viene illustrato come utilizzare <xref:System.Net.Sockets.Socket> per restare in ascolto delle connessioni in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1905">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1906">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1906">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1907">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1907">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1908">Ottiene l'endpoint locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1908">Gets the local endpoint.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1909">L'oggetto <see cref="T:System.Net.EndPoint" /> utilizzato dall'oggetto <see cref="T:System.Net.Sockets.Socket" /> per le comunicazioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1909">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1910">Il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà ottiene un <xref:System.Net.EndPoint> che contiene il locale IP indirizzo e numero porta a cui il <xref:System.Net.Sockets.Socket> è associato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1910">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="384f5-1911">È necessario eseguire il cast di questo <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint> prima di recuperare tutte le informazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-1911">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="384f5-1912">È quindi possibile chiamare il <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodo per recuperare locale <xref:System.Net.IPAddress>e il <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodo per recuperare il numero di porta locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-1912">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="384f5-1913">Il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà è impostata in genere dopo aver apportato una chiamata al <xref:System.Net.Sockets.Socket.Bind%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1913">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="384f5-1914">Se si consente al sistema di assegnare l'indirizzo IP locale del socket e numero di porta, il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà verrà impostata dopo la prima operazione dei / o.</span><span class="sxs-lookup"><span data-stu-id="384f5-1914">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="384f5-1915">Per i protocolli orientati alla connessione, la prima operazione dei / o sarebbe una chiamata ai <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1915">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-1916">Per protocolli senza connessione, la prima operazione dei / o è uno di trasmissione o ricezione chiamate.</span><span class="sxs-lookup"><span data-stu-id="384f5-1916">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1917">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1917">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1918">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1918">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1919">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1919">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1920">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1920">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1921">Esempio di codice seguente recupera e visualizza gli endpoint locali e remoti.</span><span class="sxs-lookup"><span data-stu-id="384f5-1921">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1922">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1922">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1923">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1923">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1924">Ottiene o imposta un valore che specifica se i pacchetti multicast in uscita devono essere recapitati all'applicazione mittente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1924">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1925">
            <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> riceve pacchetti multicast; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1925">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1926">Il multicast è un metodo scalabile per la comunicazione di molti-a-molti su Internet.</span><span class="sxs-lookup"><span data-stu-id="384f5-1926">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="384f5-1927">Un processo esegue la sottoscrizione a un indirizzo multicast. quindi, tutti i pacchetti inviati da un processo sottoscritto vengono ricevuti da un altro tipo di processo ha sottoscritto l'indirizzo multicast.</span><span class="sxs-lookup"><span data-stu-id="384f5-1927">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="384f5-1928">Impostazione di questa proprietà su un socket di protocollo TCP (Transmission Control) avrà alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1928">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1929">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-1929">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1930">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1930">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1931">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1931">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1932">Ottiene o imposta un valore <see cref="T:System.Boolean" /> che specifica se il <see cref="T:System.Net.Sockets.Socket" /> di flusso utilizza l'algoritmo Nagle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1932">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1933">
            <see langword="false" /> se il <see cref="T:System.Net.Sockets.Socket" /> utilizza l'algoritmo Nagle; in caso contrario, <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1933">
              <see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span>
          </span>
          <span data-ttu-id="384f5-1934">Il valore predefinito è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1934">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1935">L'algoritmo Nagle è progettato per ridurre il traffico di rete, di conseguenza il socket a pacchetti di piccole dimensioni del buffer e quindi combinare e inviarli in un pacchetto in determinate circostanze.</span><span class="sxs-lookup"><span data-stu-id="384f5-1935">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="384f5-1936">Un pacchetto TCP è costituito da 40 byte di intestazione più i dati inviati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1936">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="384f5-1937">Quando vengono inviati pacchetti di dati di piccole dimensioni con TCP, il sovraccarico risultante dall'intestazione TCP può diventare una parte significativa del traffico di rete. Sulle reti di sovraccarico la congestione risultante da questo overhead può comportare la perdita di datagrammi e tra le ritrasmissioni, nonché propagazione eccessivo tempo di.</span><span class="sxs-lookup"><span data-stu-id="384f5-1937">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="384f5-1938">L'algoritmo Nagle impedisce l'invio di nuove TCP segmentswhen nuovi dati in uscita arrivano da parte dell'utente se tutti i dati trasmessi in precedenza per la connessione rimangano non riconosciuti.</span><span class="sxs-lookup"><span data-stu-id="384f5-1938">The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="384f5-1939">La maggior parte delle applicazioni di rete deve utilizzare l'algoritmo Nagle.</span><span class="sxs-lookup"><span data-stu-id="384f5-1939">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="384f5-1940">Impostazione di questa proprietà su un socket di datagramma protocollo UDP (User) avrà alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="384f5-1940">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1941">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.NoDelay%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-1941">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1942">Si è verificato un errore durante il tentativo di accesso al <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1942">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1943">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1943">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1944">Indica se il sistema operativo sottostante e gli adattatori di rete supportano il protocollo IPv4.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1944">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1945">
            <see langword="true" /> se il sistema operativo e gli adattatori di rete supportano il protocollo IPv4. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1945">
              <see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1946">Il sistema operativo supporti i protocolli IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="384f5-1946">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1947">Indica se il sistema operativo sottostante e gli adattatori di rete supportano il protocollo IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1947">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1948">
            <see langword="true" /> se il sistema operativo e gli adattatori di rete supportano il protocollo IPv6; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1948">
              <see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1949">Il sistema operativo supporti i protocolli IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="384f5-1949">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">
          <span data-ttu-id="384f5-1950">Tempo di attesa per una risposta, espresso in microsecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1950">The time to wait for a response, in microseconds.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="384f5-1951">Uno dei valori di <see cref="T:System.Net.Sockets.SelectMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1951">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1952">Determina lo stato del <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1952">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1953">Stato dell'oggetto <see cref="T:System.Net.Sockets.Socket" /> in base al valore della modalità di polling passato nel parametro <paramref name="mode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1953">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span>
          </span>
          <span data-ttu-id="384f5-1954">
            <list type="table">
              <listheader>
                <term> Modalità  </term>
                <description> Valore restituito  </description>
              </listheader>
              <item>
                <term>
                  <see cref="F:System.Net.Sockets.SelectMode.SelectRead" />
                </term>
                <description>
                  <see langword="true" /> se è stato chiamato <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> e una connessione è in sospeso;  - oppure - <see langword="true" /> se i dati sono disponibili per la lettura;  - oppure - <see langword="true" /> se la connessione è stata chiusa, reimpostata o terminata;  in caso contrario, restituisce <see langword="false" />.  </description>
              </item>
              <item>
                <term>
                  <see cref="F:System.Net.Sockets.SelectMode.SelectWrite" />
                </term>
                <description>
                  <see langword="true" />, se viene eseguita l'elaborazione di <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> e la connessione è riuscita;  - oppure -  <see langword="true" /> se i dati possono essere inviati;  in caso contrario, restituisce <see langword="false" />.  </description>
              </item>
              <item>
                <term>
                  <see cref="F:System.Net.Sockets.SelectMode.SelectError" />
                </term>
                <description>
                  <see langword="true" /> se viene elaborato <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> che non esegue un blocco e la connessione non è riuscita;  - oppure - <see langword="true" /> se <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> non è impostato e sono disponibili dati fuori banda;  in caso contrario, restituisce <see langword="false" />.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1954">
              <list type="table">
                <listheader>
                  <term> Mode  </term>
                  <description> Return Value  </description>
                </listheader>
                <item>
                  <term>
                    <see cref="F:System.Net.Sockets.SelectMode.SelectRead" />
                  </term>
                  <description>
                    <see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;  -or-  <see langword="true" /> if data is available for reading;  -or-  <see langword="true" /> if the connection has been closed, reset, or terminated;  otherwise, returns <see langword="false" />.  </description>
                </item>
                <item>
                  <term>
                    <see cref="F:System.Net.Sockets.SelectMode.SelectWrite" />
                  </term>
                  <description>
                    <see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;  -or-  <see langword="true" /> if data can be sent;  otherwise, returns <see langword="false" />.  </description>
                </item>
                <item>
                  <term>
                    <see cref="F:System.Net.Sockets.SelectMode.SelectError" />
                  </term>
                  <description>
                    <see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;  -or-  <see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;  otherwise, returns <see langword="false" />.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1955">Il <xref:System.Net.Sockets.Socket.Poll%2A> metodo controllerà lo stato del <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1955">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-1956">Specificare <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> per il `selectMode` parametro per determinare se il <xref:System.Net.Sockets.Socket> è leggibile.</span><span class="sxs-lookup"><span data-stu-id="384f5-1956">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="384f5-1957">Specificare <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> per determinare se il <xref:System.Net.Sockets.Socket> sia accessibile in scrittura.</span><span class="sxs-lookup"><span data-stu-id="384f5-1957">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="384f5-1958">Utilizzare <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> per rilevare una condizione di errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1958">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="384f5-1959"><xref:System.Net.Sockets.Socket.Poll%2A> verrà bloccata l'esecuzione fino al periodo di tempo specificato, misurata in `microseconds`, scade.</span><span class="sxs-lookup"><span data-stu-id="384f5-1959"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="384f5-1960">Impostare il `microSeconds` parametro a un numero intero negativo se si desidera attendere una risposta per un periodo illimitato.</span><span class="sxs-lookup"><span data-stu-id="384f5-1960">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="384f5-1961">Se si desidera controllare lo stato di più socket, è preferibile usare il <xref:System.Net.Sockets.Socket.Select%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1961">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1962">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1962">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1963">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1963">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1964">Questo metodo non è in grado di rilevare determinati tipi di problemi di connessione, ad esempio un cavo di rete danneggiato o che l'host remoto è stato arrestato in modo anomalo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1964">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="384f5-1965">Deve tentare di inviare o ricevere dati che consente di rilevare questi tipi di errori.</span><span class="sxs-lookup"><span data-stu-id="384f5-1965">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1966">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-1966">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-1967">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-1967">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1968">Esempio di codice seguente crea un socket, si connette a un server e utilizza <xref:System.Net.Sockets.Socket.Poll%2A> per controllare lo stato del socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-1968">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-1969">Il parametro <paramref name="mode" /> non è uno dei valori di <see cref="T:System.Net.Sockets.SelectMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1969">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-1970">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1970">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-1971">Vedere la sezione Note riportata di seguito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1971">See remarks below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-1972">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1972">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1973">Ottiene il tipo di protocollo del <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1973">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-1974">Uno dei valori di <see cref="T:System.Net.Sockets.ProtocolType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1974">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1975">Il <xref:System.Net.Sockets.Socket.ProtocolType%2A> viene impostata quando il <xref:System.Net.Sockets.Socket> viene creato e specifica il protocollo utilizzato da tale <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1975">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-1976">Consente di visualizzare esempio di codice seguente il <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> nella console.</span><span class="sxs-lookup"><span data-stu-id="384f5-1976">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-1977">Riceve dati da un oggetto <see cref="T:System.Net.Sockets.Socket" /> associato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1977">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-1978">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1978">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-1979">Riceve dati in un buffer di ricezione da un oggetto <see cref="T:System.Net.Sockets.Socket" /> associato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1979">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-1980">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-1980">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-1981">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo legge i dati nel parametro buffer e restituisce il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-1981">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="384f5-1982">È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1982">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="384f5-1983">Questo overload è sufficiente fornire un buffer di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1983">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="384f5-1984">Valore predefinito è 0, le impostazioni predefinite delle dimensioni per la lunghezza del parametro buffer, l'offset del buffer e il <xref:System.Net.Sockets.SocketFlags> valore predefinito di <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1984">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="384f5-1985">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1985">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="384f5-1986">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilito nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1986">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-1987">Se si utilizza un protocollo senza connessione, è inoltre possibile utilizzare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1987">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-1988"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.</span><span class="sxs-lookup"><span data-stu-id="384f5-1988"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="384f5-1989">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà bloccati finché non sono disponibili dati, a meno che non è stato impostato un valore di timeout utilizzando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1989">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-1990">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1990">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-1991">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-1991">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-1992">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-1992">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-1993">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1993">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-1994">Se si utilizza un orientato alla connessione <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà tutti i dati disponibili, fino alle dimensioni del buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-1994">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="384f5-1995">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-1995">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-1996">Se si utilizza un oggetto senza connessione <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma in coda dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-1996">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="384f5-1997">Se il datagramma ricevuto è più grande della dimensione del `buffer` parametro, `buffer` verrà riempito con la prima parte del messaggio, i dati in eccesso vengono persi e <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-1997">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-1998">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-1998">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-1999">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-1999">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2000">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2000">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2001">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2001">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2002">Esempio di codice seguente riceve i dati in un oggetto connesso <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2002">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2003">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2003">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2004">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2004">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2005">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2005">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-2006">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2006">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2007">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2007">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2008">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2008">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-2009">Elenco di <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> contenente i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2009">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2010">Riceve dati da un <see cref="T:System.Net.Sockets.Socket" /> associato nell'elenco dei buffer di ricezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2010">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2011">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2011">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2012">Questo metodo legge i dati nel parametro del buffer e restituisce il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2012">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="384f5-2013">È possibile chiamare dal socket orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2013">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="384f5-2014">Questo overload richiede di specificare uno o più buffer di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2014">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="384f5-2015">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2015">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="384f5-2016">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dalla connessione all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2016">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2017">Se si utilizza un protocollo senza connessione, è inoltre possibile utilizzare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2017">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2018"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2018"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="384f5-2019">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà bloccati finché non sono disponibili dati, a meno che non è stato impostato un valore di timeout utilizzando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2019">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2020">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2020">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2021">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2021">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2022">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2022">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2023">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2023">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2024">Se si utilizza un orientato alla connessione <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà tutti i dati disponibili, fino alle dimensioni del buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2024">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="384f5-2025">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2025">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-2026">Se si utilizza un oggetto senza connessione <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2026">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="384f5-2027">Se il datagramma ricevuto è più grande della dimensione del `buffers` parametro, `buffers` verrà riempito con la prima parte del messaggio, i dati in eccesso vengono persi e <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2027">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2028">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2028">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2029">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2029">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="384f5-2030">**Nota** questo membro genera informazioni di traccia quando si abilita la tracciatura della rete nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2030">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2031">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2031">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2032">Il valore del parametro <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2032">The <paramref name="buffer" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2033">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2033">An error occurred while attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2034">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2034">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2035">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2035">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2036">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2036">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2037">Riceve dati in un buffer di ricezione da un <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2037">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2038">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2038">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2039">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo legge i dati nel parametro buffer e restituisce il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2039">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="384f5-2040">È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2040">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="384f5-2041">Questo overload solo è necessario fornire un buffer di ricezione e le necessarie <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2041">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="384f5-2042">Valore predefinito è 0 l'offset del buffer e le dimensioni del valore predefinito è la lunghezza del parametro byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2042">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="384f5-2043">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2043">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="384f5-2044">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilito nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2044">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2045">Se si utilizza un protocollo senza connessione, è inoltre possibile utilizzare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2045">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2046"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2046"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="384f5-2047">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà bloccati finché non sono disponibili dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2047">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="384f5-2048">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2048">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2049">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2049">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2050">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2050">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2051">Se si utilizza un orientato alla connessione <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà tutti i dati disponibili fino alle dimensioni del buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2051">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="384f5-2052">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2052">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-2053">Se si utilizza un oggetto senza connessione <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2053">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="384f5-2054">Se il datagramma ricevuto è più grande della dimensione del `buffer` parametro, `buffer` verrà riempito con la prima parte del messaggio, i dati in eccesso vengono persi e <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2054">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2055">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2055">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2056">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2056">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2057">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2057">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2058">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2058">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2059">Esempio di codice seguente specifica un buffer di dati, e <xref:System.Net.Sockets.SocketFlags> per la ricezione di dati in un oggetto connesso <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2059">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2060">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2060">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2061">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2061">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2062">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2062">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-2063">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2063">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2064">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2064">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2065">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2065">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-2066">Elenco di <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> contenente i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2066">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2067">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2067">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2068">Riceve dati in un elenco di buffer di ricezione da un <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2068">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2069">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2069">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2070">Questo metodo legge i dati nel `buffers` parametro e restituisce il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2070">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="384f5-2071">È possibile chiamare dal socket orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2071">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="384f5-2072">Questo overload richiede di specificare uno o più buffer di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2072">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="384f5-2073">Il <xref:System.Net.Sockets.SocketFlags> valore predefinito di <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2073">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="384f5-2074">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2074">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="384f5-2075">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dalla connessione all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2075">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2076">Se si utilizza un protocollo senza connessione, è inoltre possibile utilizzare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2076">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2077"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2077"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="384f5-2078">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà bloccati finché non sono disponibili dati, a meno che non è stato impostato un valore di timeout utilizzando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2078">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2079">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamare genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2079">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2080">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2080">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2081">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2081">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2082">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2082">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2083">Se si utilizza un orientato alla connessione <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà tutti i dati disponibili, fino alle dimensioni del buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2083">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="384f5-2084">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2084">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-2085">Se si utilizza un oggetto senza connessione <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2085">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="384f5-2086">Se il datagramma ricevuto è più grande della dimensione del `buffers` parametro, `buffers` verrà riempito con la prima parte del messaggio, i dati in eccesso vengono persi e <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2086">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2087">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2087">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2088">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2088">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2089">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2089">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2090">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2090">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2091">Esempio di codice riportato di seguito viene illustrato come ricevere i dati in un oggetto connesso <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2091">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2092">
            <paramref name="buffers" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2092">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-2093">- oppure - <paramref name="buffers" />.Count è zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2093">-or-  <paramref name="buffers" />.Count is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2094">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2094">An error occurred while attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2095">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2095">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2096">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2096">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2097">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2097">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2098">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2098">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-2099">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2099">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2100">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2100">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2101">Riceve in un buffer di ricezione il numero specificato di byte di dati da un oggetto <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2101">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2102">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2102">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2103">Il <xref:System.Net.Sockets.Socket.Receive%2A> legge i dati nel metodo il `buffer` parametro e restituisce il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2103">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="384f5-2104">È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2104">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="384f5-2105">Questo overload solo è necessario fornire un buffer di ricezione, il numero di byte che si desidera ricevere e il necessaria <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2105">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="384f5-2106">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2106">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="384f5-2107">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilito nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2107">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2108">Se si utilizza un protocollo senza connessione, è inoltre possibile utilizzare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2108">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2109"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2109"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="384f5-2110">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà bloccati finché non sono disponibili dati, a meno che non è stato impostato un valore di timeout utilizzando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2110">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2111">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2111">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2112">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2112">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2113">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2113">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2114">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2114">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2115">Se si utilizza un orientato alla connessione <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà tutti i dati disponibili, fino al numero di byte specificati dal `size` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-2115">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="384f5-2116">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2116">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-2117">Se si utilizza un oggetto senza connessione <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma in coda dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2117">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="384f5-2118">Se il datagramma ricevuto è più grande della dimensione del `buffer` parametro, `buffer` verrà riempito con la prima parte del messaggio, i dati in eccesso vengono persi e <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2118">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2119">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2119">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2120">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2120">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2121">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2121">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2122">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2122">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2123">Nell'esempio riceve i dati presenti nelle `buffer`e specifica <xref:System.Net.Sockets.SocketFlags.None> per <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2123">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2124">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2124">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2125">
            <paramref name="size" /> supera la dimensione di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2125">
              <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2126">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2126">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2127">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2127">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-2128">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2128">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2129">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2129">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2130">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2130">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-2131">Elenco di <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> contenente i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2131">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2132">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2132">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="384f5-2133">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2133">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2134">Riceve dati in un elenco di buffer di ricezione da un <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2134">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2135">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2135">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2136">Questo metodo legge i dati nel `buffers` parametro e restituisce il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2136">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="384f5-2137">È possibile chiamare dal socket orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2137">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="384f5-2138">Questo overload richiede di specificare uno o più buffer di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2138">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="384f5-2139">Il <xref:System.Net.Sockets.SocketFlags> valore predefinito di <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2139">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="384f5-2140">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2140">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="384f5-2141">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dalla connessione all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2141">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2142">Se si utilizza un protocollo senza connessione, è inoltre possibile utilizzare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2142">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2143"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2143"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="384f5-2144">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà bloccati finché non sono disponibili dati, a meno che non è stato impostato un valore di timeout utilizzando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2144">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2145">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamare genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2145">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2146">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2146">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2147">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2147">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2148">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2148">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2149">Se si utilizza un orientato alla connessione <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà tutti i dati disponibili, fino alle dimensioni del buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2149">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="384f5-2150">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2150">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-2151">Se si utilizza un oggetto senza connessione <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma in coda dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2151">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="384f5-2152">Se il datagramma ricevuto è più grande della dimensione del `buffers` parametro, `buffers` verrà riempito con la prima parte del messaggio, i dati in eccesso vengono persi e <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2152">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2153">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2153">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2154">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2154">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2155">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2155">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2156">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2156">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2157">
            <paramref name="buffers" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2157">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-2158">- oppure - <paramref name="buffers" />.Count è zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2158">-or-  <paramref name="buffers" />.Count is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2159">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2159">An error occurred while attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2160">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2160">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2161">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2161">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2162">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2162">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2163">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2163">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-2164">Posizione in <c>buffer</c> per archiviare i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2164">The location in <c>buffer</c> to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-2165">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2165">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2166">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2166">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2167">Riceve il numero specificato di byte da un <see cref="T:System.Net.Sockets.Socket" /> associato nella posizione di offset predefinita del buffer di ricezione, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2167">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2168">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2168">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2169">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo legge i dati nel parametro buffer e restituisce il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2169">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="384f5-2170">È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2170">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="384f5-2171">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2171">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="384f5-2172">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilito nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2172">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2173">Se si utilizza un protocollo senza connessione, è inoltre possibile utilizzare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2173">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2174"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2174"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="384f5-2175">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà bloccati finché non sono disponibili dati, a meno che non è stato impostato un valore di timeout utilizzando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2175">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2176">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2176">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2177">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2177">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2178">Si è verificato un errore durante il tentativo di accesso al socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-2178">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="384f5-2179">Vedere la sezione Osservazioni seguente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2179">See Remarks below.</span></span> <span data-ttu-id="384f5-2180">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2180">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2181">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2181">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2182">Se si utilizza un orientato alla connessione <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà tutti i dati disponibili, fino al numero di byte specificato dal parametro di dimensione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2182">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="384f5-2183">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2183">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-2184">Se si utilizza un oggetto senza connessione <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma in coda dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2184">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="384f5-2185">Se il datagramma ricevuto è più grande della dimensione del `buffer` parametro, `buffer` verrà riempito con la prima parte del messaggio, i dati in eccesso vengono persi e <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2185">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2186">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2186">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2187">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2187">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2188">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2188">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2189">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2189">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2190">Esempio di codice seguente specifica un buffer di dati, un offset, una dimensione e un flag socket prima della ricezione di dati in un oggetto connesso <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2190">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2191">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2191">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2192">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2192">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2193">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2193">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-2194">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2194">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2195">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2195">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2196">
            <paramref name="socketFlags" /> non è una combinazione valida di valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2196">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="384f5-2197">- oppure - La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è stata impostata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2197">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="384f5-2198">- oppure - Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2198">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2199">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2199">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-2200">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2200">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2201">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2201">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2202">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2202">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2203">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2203">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-2204">Posizione nel parametro <c>buffer</c> per archiviare i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2204">The position in the <c>buffer</c> parameter to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-2205">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2205">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2206">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2206">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="384f5-2207">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2207">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2208">Riceve dati in un buffer di ricezione da un <see cref="T:System.Net.Sockets.Socket" /> associato, utilizzando il <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2208">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2209">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2209">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2210">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo legge i dati nel parametro buffer e restituisce il numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2210">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="384f5-2211">È possibile chiamare <xref:System.Net.Sockets.Socket.Receive%2A> dal socket orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2211">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="384f5-2212">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto, oppure <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso prima di chiamare <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2212">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="384f5-2213">Il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà solo i dati provenienti dall'host remoto stabilito nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2213">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2214">Se si utilizza un protocollo senza connessione, è inoltre possibile utilizzare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2214">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2215"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Consente di ricevere i dati provenienti da qualsiasi host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2215"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="384f5-2216">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà bloccati finché non sono disponibili dati, a meno che non è stato impostato un valore di timeout utilizzando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2216">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2217">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Receive%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2217">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2218">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2218">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2219">Si è verificato un errore durante il tentativo di accesso al socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-2219">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="384f5-2220">Vedere la sezione Osservazioni seguente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2220">See Remarks below.</span></span> <span data-ttu-id="384f5-2221">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2221">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2222">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2222">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2223">Se si utilizza un orientato alla connessione <xref:System.Net.Sockets.Socket>, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo leggerà tutti i dati disponibili, fino al numero di byte specificato dal parametro di dimensione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2223">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="384f5-2224">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2224">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="384f5-2225">Se si utilizza un oggetto senza connessione <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leggerà il primo datagramma in coda dall'indirizzo di destinazione specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2225">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="384f5-2226">Se il datagramma ricevuto è più grande della dimensione del `buffer` parametro, `buffer` verrà riempito con la prima parte del messaggio, i dati in eccesso vengono persi e <xref:System.Net.Sockets.SocketException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2226">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2227">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2227">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2228">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2228">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2229">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2229">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2230">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2230">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2231">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2231">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2232">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2232">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2233">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2233">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-2234">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2234">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2235">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2235">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2236">
            <paramref name="socketFlags" /> non è una combinazione valida di valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2236">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="384f5-2237">- oppure - La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è impostata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2237">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span>
          </span>
          <span data-ttu-id="384f5-2238">- oppure - Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2238">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2239">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2239">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-2240">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2240">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2241">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2241">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2242">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2242">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-2243">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2243">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2244">Avvia una richiesta asincrona per ricevere dati da un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2244">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2245">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2245">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-2246">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2246">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-2247">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2247">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-2248">In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2248">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2249">Il <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> viene utilizzato il metodo sui socket connessi o socket orientati associati e viene utilizzato per leggere i dati in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2249">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="384f5-2250">Indirizzo locale del socket deve essere noto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2250">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="384f5-2251">Per socket orientati associati, questa funzione consente di limitare gli indirizzi da cui vengono accettati i messaggi ricevuti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2251">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="384f5-2252">La funzione restituisce solo i messaggi dall'indirizzo remoto specificato nella connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2252">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="384f5-2253">I messaggi provenienti da altri indirizzi vengono scartati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2253">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="384f5-2254">Il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> proprietà di `e` parametro fornisce il provider di servizi Windows Sockets con ulteriori informazioni sulla richiesta di lettura.</span><span class="sxs-lookup"><span data-stu-id="384f5-2254">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="384f5-2255">Per ulteriori informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2255">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="384f5-2256">Le seguenti proprietà e gli eventi di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:</span><span class="sxs-lookup"><span data-stu-id="384f5-2256">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="384f5-2257"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> o <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="384f5-2257"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="384f5-2258"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> è impostato</span><span class="sxs-lookup"><span data-stu-id="384f5-2258"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="384f5-2259"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> è impostato</span><span class="sxs-lookup"><span data-stu-id="384f5-2259"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="384f5-2260">Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà per qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> (metodo), in modo che le informazioni possano essere recuperate nel metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-2260">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="384f5-2261">Se il callback richiede più informazioni rispetto a un singolo oggetto, una classe piccola può essere creata per contenere le altre informazioni sullo stato necessarie come membri.</span><span class="sxs-lookup"><span data-stu-id="384f5-2261">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="384f5-2262">Per i socket di flusso di tipo byte, i dati in entrata viene inseriti nel buffer fino a quando non viene riempito il buffer, la connessione viene chiusa o i dati memorizzati nel buffer internamente sono esauriti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2262">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="384f5-2263">Per i socket orientato ai messaggi, un messaggio in arrivo viene inserito nel buffer fino alle dimensioni totali del buffer associati con la `e` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-2263">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="384f5-2264">Se il messaggio è maggiore del buffer, viene riempito il buffer con la prima parte del messaggio.</span><span class="sxs-lookup"><span data-stu-id="384f5-2264">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="384f5-2265">Per i socket orientati alla connessione, il <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> metodo può indicare la chiusura del circuito virtuale in uno dei due modi che dipendono dal fatto che sia il socket di flusso di byte o orientato ai messaggi.</span><span class="sxs-lookup"><span data-stu-id="384f5-2265">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="384f5-2266">Per i flussi di byte, zero byte letti indica la chiusura e che non verranno letti mai alcun più byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2266">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="384f5-2267">Per i socket orientato ai messaggi, in cui un messaggio a zero byte è spesso consentito, una <xref:System.Net.Sockets.SocketException> con il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> insieme al codice di errore Winsock WSAEDISCON nativo (10101) viene utilizzato per indicare la chiusura.</span><span class="sxs-lookup"><span data-stu-id="384f5-2267">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="384f5-2268">In ogni caso, un <xref:System.Net.Sockets.SocketException> con il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> impostato su Winsock WSAECONNRESET nativo il codice di errore (10054) indica una chiusura anomala si è verificata.</span><span class="sxs-lookup"><span data-stu-id="384f5-2268">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-2269">Un argomento non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2269">An argument was invalid.</span>
          </span>
          <span data-ttu-id="384f5-2270">Le proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> sul parametro <paramref name="e" /> devono fare riferimento a buffer validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2270">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span>
          </span>
          <span data-ttu-id="384f5-2271">È possibile impostare una di queste due proprietà, ma non entrambe contemporaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2271">One or the other of these properties may be set, but not both at the same time.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-2272">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2272">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-2273">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2273">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2274">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2274">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2275">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2275">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-2276">Ottiene o imposta un valore che specifica le dimensioni del buffer di ricezione del <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2276">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-2277">
            <see cref="T:System.Int32" /> contenente le dimensioni, in byte, del buffer di ricezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2277">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span>
          </span>
          <span data-ttu-id="384f5-2278">Il valore predefinito è 8192.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2278">The default is 8192.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2279">Dimensioni maggiori del buffer potenzialmente riducono il numero di acknowledgement vuoti (pacchetti TCP con nessuna parte di dati), ma potrebbero anche ritardare il riconoscimento di problemi di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2279">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="384f5-2280">È consigliabile aumentare le dimensioni del buffer il trasferimento di file di grandi dimensioni, se si utilizza una larghezza di banda elevata, la connessione con latenza elevata (ad esempio un satellite a banda larga provider.)</span><span class="sxs-lookup"><span data-stu-id="384f5-2280">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2281">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-2281">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2282">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2282">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2283">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2283">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2284">Il valore specificato per un'operazione di impostazione è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2284">The value specified for a set operation is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-2285">Riceve un datagramma e memorizza l'endpoint di origine.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2285">Receives a datagram and stores the source endpoint.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2286">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2286">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-2287">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2287">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2288">Riceve un datagramma nel buffer di dati e memorizza l'endpoint.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2288">Receives a datagram into the data buffer and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2289">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2289">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2290">Il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui i dati sono stati inviati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2290">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="384f5-2291">Questo metodo è utile se si prevede di ricevere datagrammi senza connessione da un host sconosciuto o più host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2291">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="384f5-2292">Questo overload solo è necessario fornire un'istruzione receive `buffer`e un <xref:System.Net.EndPoint> che rappresenta l'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2292">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="384f5-2293">L'offset del buffer valore predefinito è 0.</span><span class="sxs-lookup"><span data-stu-id="384f5-2293">The buffer offset defaults to 0.</span></span> <span data-ttu-id="384f5-2294">Alla lunghezza del valore predefinito è la dimensione di `buffer` parametro e il `socketFlags` valore predefinito di <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2294">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2295">Prima di chiamare <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale utilizzando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2295">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="384f5-2296">In caso contrario, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2296">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-2297">Protocolli senza connessione, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-2297">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="384f5-2298">Se il datagramma ricevuto è più grande della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo compilerà `buffer` con le informazioni del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2298">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2299">Se si utilizza un protocollo non affidabile, i dati in eccesso andranno persi.</span><span class="sxs-lookup"><span data-stu-id="384f5-2299">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="384f5-2300">Se si utilizza un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperare tramite una chiamata di <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo con un buffer sufficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="384f5-2300">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="384f5-2301">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà bloccati finché non sono disponibili dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2301">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="384f5-2302">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2302">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2303">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2303">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2304">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2304">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2305">Anche se <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile utilizzare anche un protocollo orientato alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2305">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="384f5-2306">Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare un remoto in ingresso connessione all'host chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-2306">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2307">Se non si stabilire o accettare la connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo, si otterrà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2307">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2308">È inoltre possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2308">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2309">In entrambi i casi, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e solo ricevere dati da connesso o l'host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-2309">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="384f5-2310">Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà tutti i dati disponibili fino alle dimensioni di `buffer`.</span><span class="sxs-lookup"><span data-stu-id="384f5-2310">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="384f5-2311">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2311">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2312">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2312">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2313">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2313">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2314">Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzato nella <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzata in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2314">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2315">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2315">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2316">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2316">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2317">Esempio di codice seguente riceve un datagramma senza connessione da un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2317">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2318">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2318">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-2319">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2319">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2320">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2320">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2321">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2321">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-2322">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2322">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2323">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2323">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2324">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2324">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2325">Matrice di tipo <see cref="T:System.Byte" /> che costituisce la posizione di archiviazione per i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2325">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2326">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2326">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-2327">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2327">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2328">Riceve un datagramma nel buffer di dati, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e memorizza l'endpoint.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2328">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2329">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2329">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2330">Il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui i dati sono stati inviati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2330">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="384f5-2331">Questo metodo è utile se si prevede di ricevere datagrammi senza connessione da un host sconosciuto o più host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2331">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="384f5-2332">Questo overload solo è necessario fornire un buffer di ricezione, necessarie <xref:System.Net.Sockets.SocketFlags>e un <xref:System.Net.EndPoint> che rappresenta l'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2332">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="384f5-2333">L'offset il valore predefinito 0 e le impostazioni predefinite delle dimensioni per la lunghezza del parametro buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2333">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2334">Prima di chiamare <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale utilizzando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2334">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="384f5-2335">In caso contrario, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2335">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-2336">Protocolli senza connessione, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-2336">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="384f5-2337">Se il datagramma ricevuto è più grande della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo compilerà `buffer` con le informazioni del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2337">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2338">Se si utilizza un protocollo non affidabile, i dati in eccesso andranno persi.</span><span class="sxs-lookup"><span data-stu-id="384f5-2338">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="384f5-2339">Se si utilizza un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperare tramite una chiamata di <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo con un buffer sufficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="384f5-2339">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="384f5-2340">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà bloccati finché non sono disponibili dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2340">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="384f5-2341">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2341">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2342">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2342">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2343">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2343">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2344">Anche se <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile utilizzare anche un protocollo orientato alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2344">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="384f5-2345">Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare un remoto in ingresso connessione all'host chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-2345">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2346">Se non si stabilire o accettare la connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo, si otterrà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2346">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2347">È inoltre possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2347">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2348">In entrambi i casi, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e solo ricevere dati da connesso o l'host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-2348">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="384f5-2349">Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà tutti i dati disponibili fino alle dimensioni di `buffer`.</span><span class="sxs-lookup"><span data-stu-id="384f5-2349">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="384f5-2350">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2350">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2351">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2351">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2352">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2352">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2353">Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzato nella <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzata in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2353">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2354">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2354">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2355">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2355">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2356">Esempio di codice seguente riceve un datagramma senza connessione da un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2356">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="384f5-2357"><xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2357"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2358">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2358">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-2359">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2359">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2360">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2360">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2361">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2361">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-2362">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2362">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2363">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2363">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2364">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2364">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2365">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2365">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-2366">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2366">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2367">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2367">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-2368">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2368">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2369">Riceve il numero di byte specificato nel buffer di dati, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e memorizza l'endpoint.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2369">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2370">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2370">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2371">Il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui i dati sono stati inviati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2371">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="384f5-2372">Questo metodo è utile se si prevede di ricevere datagrammi senza connessione da un host sconosciuto o più host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2372">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="384f5-2373">Questo overload solo è necessario fornire un buffer di ricezione, il numero di byte che si desidera ricevere, necessarie <xref:System.Net.Sockets.SocketFlags>e un <xref:System.Net.EndPoint> che rappresenta l'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2373">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="384f5-2374">L'offset del buffer valore predefinito è 0.</span><span class="sxs-lookup"><span data-stu-id="384f5-2374">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="384f5-2375">Protocolli senza connessione, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-2375">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="384f5-2376">Se il datagramma ricevuto è più grande della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo compilerà `buffer` con le informazioni del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2376">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2377">Se si utilizza un protocollo non affidabile, i dati in eccesso andranno persi.</span><span class="sxs-lookup"><span data-stu-id="384f5-2377">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="384f5-2378">Se si utilizza un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperare tramite una chiamata di <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo con un buffer sufficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="384f5-2378">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="384f5-2379">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà bloccati finché non sono disponibili dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2379">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="384f5-2380">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2380">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2381">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2381">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2382">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2382">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2383">Anche se <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile utilizzare anche un protocollo orientato alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2383">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="384f5-2384">Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare un remoto in ingresso connessione all'host chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-2384">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2385">Se non si stabilire o accettare la connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo, si otterrà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2385">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2386">È inoltre possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2386">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2387">In entrambi i casi, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e solo ricevere dati da connesso o l'host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-2387">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="384f5-2388">Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà tutti i dati disponibili fino al numero di byte specificati dal `size` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-2388">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="384f5-2389">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2389">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2390">Prima di chiamare <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale utilizzando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2390">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="384f5-2391">In caso contrario, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2391">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2392">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2392">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2393">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2393">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2394">Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzato nella <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzata in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2394">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2395">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2395">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2396">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2396">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2397">Esempio di codice seguente riceve un datagramma senza connessione da un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2397">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="384f5-2398">Le dimensioni del buffer, e <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2398">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2399">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2399">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-2400">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2400">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2401">
            <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2401">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2402">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2402">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2403">
            <paramref name="socketFlags" /> non è una combinazione valida di valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2403">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="384f5-2404">- oppure - La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è stata impostata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2404">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="384f5-2405">- oppure - Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2405">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2406">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2406">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-2407">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2407">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2408">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2408">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2409">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2409">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2410">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2410">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-2411">Posizione nel parametro <c>buffer</c> per archiviare i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2411">The position in the <c>buffer</c> parameter to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-2412">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2412">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2413">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2413">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-2414">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2414">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2415">Riceve il numero specificato di byte di dati nella posizione specificata del buffer di dati usando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e archivia l'endpoint.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2415">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2416">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2416">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2417">Il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui i dati sono stati inviati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2417">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="384f5-2418">Questo metodo è utile se si prevede di ricevere datagrammi senza connessione da un host sconosciuto o più host.</span><span class="sxs-lookup"><span data-stu-id="384f5-2418">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="384f5-2419">Protocolli senza connessione, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà il primo datagramma ricevuto nel buffer di rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-2419">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="384f5-2420">Se il datagramma ricevuto è più grande della dimensione di `buffer`, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo compilerà `buffer` con le informazioni del messaggio come è possibile e genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2420">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2421">Se si utilizza un protocollo non affidabile, i dati in eccesso andranno persi.</span><span class="sxs-lookup"><span data-stu-id="384f5-2421">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="384f5-2422">Se si utilizza un protocollo affidabile, i dati in eccesso vengono conservati dai provider di servizi ed è possibile recuperare tramite una chiamata di <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo con un buffer sufficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="384f5-2422">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="384f5-2423">Se nessun dato è disponibile per la lettura, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà bloccati finché non sono disponibili dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2423">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="384f5-2424">Se si è in modalità non bloccanti e non sono presenti dati nel buffer di stack del protocollo, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo verrà completato immediatamente e genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2424">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2425">È possibile utilizzare il <xref:System.Net.Sockets.Socket.Available%2A> proprietà per determinare se sono disponibili per la lettura dei dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2425">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="384f5-2426">Quando <xref:System.Net.Sockets.Socket.Available%2A> è diverso da zero, quindi ripetere l'operazione di ricezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2426">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="384f5-2427">Anche se <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> è destinato ai protocolli senza connessione, è possibile utilizzare anche un protocollo orientato alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2427">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="384f5-2428">Se si sceglie di eseguire questa operazione, è necessario innanzitutto stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare un remoto in ingresso connessione all'host chiamando il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-2428">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2429">Se non si stabilire o accettare la connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo, si otterrà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2429">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2430">È inoltre possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2430">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="384f5-2431">In entrambi i casi, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo ignorerà il `remoteEP` parametro e solo ricevere dati da connesso o l'host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-2431">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="384f5-2432">Con i socket orientati alla connessione <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leggerà tutti i dati disponibili fino alla quantità di byte specificato dal `size` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-2432">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="384f5-2433">Se l'host remoto viene arrestato il <xref:System.Net.Sockets.Socket> connessione con il <xref:System.Net.Sockets.Socket.Shutdown%2A> (metodo) e tutti i dati disponibili è stato ricevuto, il <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo viene completato immediatamente e restituisce zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2433">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2434">Prima di chiamare <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, è necessario associare in modo esplicito il <xref:System.Net.Sockets.Socket> a un endpoint locale utilizzando il <xref:System.Net.Sockets.Socket.Bind%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2434">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="384f5-2435">In caso contrario, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2435">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2436">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2436">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2437">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2437">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2438">Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzato nella <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzata in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2438">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2439">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2439">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2440">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2440">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2441">Esempio di codice seguente riceve un datagramma senza connessione da un host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2441">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="384f5-2442">L'offset, la dimensione del buffer, e <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2442">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2443">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2443">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-2444">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2444">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2445">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2445">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2446">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2446">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-2447">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2447">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2448">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro di offset.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2448">-or-  <paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2449">
            <paramref name="socketFlags" /> non è una combinazione valida di valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2449">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="384f5-2450">- oppure - La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è stata impostata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2450">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="384f5-2451">- oppure - Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2451">-or-  An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2452">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2452">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2453">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2453">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2454">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2454">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-2455">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2455">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2456">Inizia a ricevere dati in modalità asincrona da un dispositivo di rete specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2456">Begins to asynchronously receive data from a specified network device.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2457">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2457">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-2458">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2458">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-2459">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2459">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-2460">In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2460">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2461">Il <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> metodo viene utilizzato principalmente per ricevere i dati su un socket senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2461">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="384f5-2462">Indirizzo locale del socket deve essere noto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2462">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="384f5-2463">Il chiamante deve impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà per il <xref:System.Net.IPEndPoint> dell'host remoto da cui è possibile ricevere i dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2463">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="384f5-2464">Il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> proprietà di `e` parametro fornisce il provider di servizi Windows Sockets con ulteriori informazioni sulla richiesta di lettura.</span><span class="sxs-lookup"><span data-stu-id="384f5-2464">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="384f5-2465">Per ulteriori informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2465">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="384f5-2466">Le seguenti proprietà e gli eventi di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:</span><span class="sxs-lookup"><span data-stu-id="384f5-2466">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="384f5-2467">Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà per qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> (metodo), in modo che le informazioni possano essere recuperate nel metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-2467">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="384f5-2468">Se il callback richiede più informazioni rispetto a un singolo oggetto, una classe piccola può essere creata per contenere le altre informazioni sullo stato necessarie come membri.</span><span class="sxs-lookup"><span data-stu-id="384f5-2468">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="384f5-2469">Per i socket orientato ai messaggi, un messaggio in arrivo viene inserito nel buffer fino alle dimensioni totali del buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2469">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="384f5-2470">Il <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> determinano dove vengono inseriti i dati nel buffer e la quantità di dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2470">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="384f5-2471">Per i socket di flusso di tipo byte, i dati in entrata viene inseriti nel buffer fino a quando non viene riempito il buffer, la connessione viene chiusa o i dati memorizzati nel buffer internamente sono esauriti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2471">For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="384f5-2472">Il <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> determinano dove vengono inseriti i dati nel buffer e la quantità di dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2472">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2473">L'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2473">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-2474">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2474">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-2475">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2475">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2476">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2476">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2477">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2477">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2478">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta la posizione di archiviazione dei dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2478">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-2479">Posizione nel parametro <c>buffer</c> per archiviare i dati ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2479">The position in the <c>buffer</c> parameter to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-2480">Numero di byte da ricevere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2480">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2481">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2481">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-2482">Oggetto <see cref="T:System.Net.EndPoint" />, passato per riferimento, che rappresenta il server remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2482">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <param name="ipPacketInformation">
          <span data-ttu-id="384f5-2483">
            <see cref="T:System.Net.Sockets.IPPacketInformation" /> contenente informazioni sull'indirizzo e sull'interfaccia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2483">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2484">Riceve il numero specificato di byte di dati nella posizione specificata del buffer dei dati usando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato e archivia le informazioni dell'endpoint e del pacchetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2484">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2485">Numero di byte ricevuti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2485">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2486">Il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> legge i dati nel metodo il `buffer` parametro, restituisce il numero di byte letti e acquisisce l'endpoint dell'host remoto da cui è stati inviati i dati, nonché informazioni sul pacchetto ricevuto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2486">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="384f5-2487">Il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo viene utilizzato principalmente per ricevere i dati del messaggio su un socket senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2487">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="384f5-2488">Indirizzo locale del socket deve essere noto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2488">The socket's local address must be known.</span></span> <span data-ttu-id="384f5-2489">Questo metodo può essere utilizzato solo con datagramma e socket non elaborati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2489">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="384f5-2490">Il socket deve essere inizializzato con il tipo di socket impostato su <xref:System.Net.Sockets.SocketType.Dgram> o <xref:System.Net.Sockets.SocketType.Raw> prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2490">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="384f5-2491">Ciò può essere eseguita quando il socket viene costruito usando <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2491">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2492">Per i socket orientato ai messaggi, un messaggio in arrivo viene inserito nel `buffer` parametro fino alle dimensioni totali nel `size` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-2492">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="384f5-2493">Il `offset` parametro determina in che punto il `buffer` vengono inseriti i dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2493">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="384f5-2494">La quantità effettiva di dati inseriti nel `buffer` restituito dal <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2494">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-2495">Il <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo imposta automaticamente il <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opzione di socket `true` la prima volta che viene chiamato per un determinato <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2495">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-2496">Tuttavia, l'oggetto restituito <xref:System.Net.Sockets.IPPacketInformation> oggetto sarà valido solo per i pacchetti che arrivano al computer locale dopo aver impostato l'opzione di socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-2496">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="384f5-2497">Se un socket viene inviato i pacchetti tra quando è associato a un endpoint locale (in modo esplicito dal <xref:System.Net.Sockets.Socket.Bind%2A> metodo o in modo implicito da una del <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodi) e la prima chiamata al <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo, le chiamate a <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> metodo restituirà valido <xref:System.Net.Sockets.IPPacketInformation> oggetti per tali pacchetti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2497">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="384f5-2498">Per garantire che tutti i <xref:System.Net.Sockets.IPPacketInformation> gli oggetti sono validi, un'applicazione deve impostare la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opzione di socket `true` prima che venga associato a un endpoint locale utilizzando il <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2498">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="384f5-2499">Un'applicazione può esaminare il `ipPacketInformation` parametro se è necessario sapere se il datagramma è stato inviato tramite un indirizzo multicast o broadcast unicast,.</span><span class="sxs-lookup"><span data-stu-id="384f5-2499">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2500">Il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzato nella <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corrispondere il <xref:System.Net.Sockets.AddressFamily> del <xref:System.Net.EndPoint> utilizzata in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2500">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2501">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2501">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2502">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2502">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2503">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2503">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-2504">\- oppure - <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2504">\- or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2505">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2505">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2506">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2506">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-2507">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2507">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2508">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro di offset.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2508">-or-  <paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2509">
            <paramref name="socketFlags" /> non è una combinazione valida di valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2509">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="384f5-2510">- oppure - La proprietà <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> non è stata impostata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2510">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="384f5-2511">- oppure - .NET Framework viene eseguito in un processore AMD a 64 bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2511">-or-  The .NET Framework is running on an AMD 64-bit processor.</span>
          </span>
          <span data-ttu-id="384f5-2512">- oppure - Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2512">-or-  An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2513">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2513">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-2514">Il sistema operativo è Windows 2000 o versioni precedenti e il metodo richiede Windows XP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2514">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="384f5-2515">per accettare connessioni dalla rete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2515">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="384f5-2516">Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2516">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-2517">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2517">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2518">Avvia la ricezione asincrona del numero di byte specificato in una posizione specificata nel buffer di dati, utilizzando l'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> specificato, e memorizza l'endpoint e le informazioni sui pacchetti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2518">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2519">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2519">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-2520">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2520">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-2521">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2521">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-2522">In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2522">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2523">Il <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metodo viene utilizzato principalmente per ricevere i dati del messaggio su un socket senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2523">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="384f5-2524">Indirizzo locale del socket deve essere noto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2524">The socket's local address must be known.</span></span> <span data-ttu-id="384f5-2525">Questo metodo può essere utilizzato solo con datagramma e socket non elaborati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2525">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="384f5-2526">Il socket deve essere inizializzato con il tipo di socket impostato su <xref:System.Net.Sockets.SocketType.Dgram> o <xref:System.Net.Sockets.SocketType.Raw> prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2526">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="384f5-2527">Ciò può essere eseguita quando il socket viene costruito usando <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2527">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2528">Il chiamante deve impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà per il <xref:System.Net.IPEndPoint> dell'host remoto da cui è possibile ricevere i dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2528">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="384f5-2529">Le seguenti proprietà e gli eventi di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:</span><span class="sxs-lookup"><span data-stu-id="384f5-2529">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="384f5-2530">Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà per qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> (metodo), in modo che le informazioni possano essere recuperate nel metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-2530">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="384f5-2531">Se il callback richiede più informazioni rispetto a un singolo oggetto, una classe piccola può essere creata per contenere le altre informazioni sullo stato necessarie come membri.</span><span class="sxs-lookup"><span data-stu-id="384f5-2531">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="384f5-2532">Per i socket orientato ai messaggi, un messaggio in arrivo viene inserito nel buffer fino alle dimensioni totali del buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2532">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="384f5-2533">Il <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> determinano dove vengono inseriti i dati nel buffer e la quantità di dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2533">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="384f5-2534">Il <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metodo imposta automaticamente il <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opzione di socket `true` la prima volta che viene chiamato per un determinato <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2534">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-2535">Tuttavia, il <xref:System.Net.Sockets.IPPacketInformation> oggetto sarà valido solo per i pacchetti che arrivano al computer locale dopo aver impostato l'opzione di socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-2535">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="384f5-2536">Se vengono inviati i pacchetti tra un socket quando il socket viene associato a un endpoint locale (in modo esplicito dal <xref:System.Net.Sockets.Socket.Bind%2A> metodo o in modo implicito da una del <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodi) e la prima chiamata ai <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>(metodo), le chiamate a <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> metodo comporterà valido <xref:System.Net.Sockets.IPPacketInformation> oggetti per tali pacchetti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2536">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="384f5-2537">Per garantire che tutti i <xref:System.Net.Sockets.IPPacketInformation> gli oggetti sono validi, un'applicazione deve impostare la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opzione di socket`true` prima che venga associato a un endpoint locale utilizzando il <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2537">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="384f5-2538">Un'applicazione può esaminare il valore risultante <xref:System.Net.Sockets.IPPacketInformation> oggetti se è necessario sapere se il datagramma è stato inviato tramite un indirizzo multicast o broadcast unicast,.</span><span class="sxs-lookup"><span data-stu-id="384f5-2538">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2539">L'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2539">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-2540">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2540">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2541">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2541">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2542">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2542">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-2543">Ottiene o imposta un valore che specifica l'intervallo di tempo dopo il quale si verifica il timeout di una chiamata <see cref="Overload:System.Net.Sockets.Socket.Receive" /> sincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2543">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-2544">Valore di timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2544">The time-out value, in milliseconds.</span>
          </span>
          <span data-ttu-id="384f5-2545">Il valore predefinito è 0, che indica un periodo di timeout indeterminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2545">The default value is 0, which indicates an infinite time-out period.</span>
          </span>
          <span data-ttu-id="384f5-2546">Anche il valore -1 indica un periodo di timeout indeterminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2546">Specifying -1 also indicates an infinite time-out period.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2547">Questa opzione si applica a sincrono <xref:System.Net.Sockets.Socket.Receive%2A> solo le chiamate.</span><span class="sxs-lookup"><span data-stu-id="384f5-2547">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="384f5-2548">Se il periodo di timeout viene superato, il <xref:System.Net.Sockets.Socket.Receive%2A> metodo genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2548">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2549">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-2549">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2550">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2550">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2551">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2551">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2552">Il valore specificato per un'operazione set è minore di -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2552">The value specified for a set operation is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-2553">Ottiene l'endpoint remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2553">Gets the remote endpoint.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-2554">
            <see cref="T:System.Net.EndPoint" /> con cui comunica il <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2554">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2555">Se si utilizza un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> proprietà ottiene il <xref:System.Net.EndPoint> che contiene il remoto IP indirizzo e numero porta a cui il <xref:System.Net.Sockets.Socket> è connesso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2555">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="384f5-2556">Se si utilizza un protocollo senza connessione <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contiene l'indirizzo IP remoto e il numero di porta a cui il <xref:System.Net.Sockets.Socket> comunicherà.</span><span class="sxs-lookup"><span data-stu-id="384f5-2556">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="384f5-2557">È necessario eseguire il cast di questo <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint> prima di recuperare tutte le informazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-2557">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="384f5-2558">È quindi possibile chiamare il <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> metodo per recuperare remoto <xref:System.Net.IPAddress>e il <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> metodo per recuperare il numero di porta remota.</span><span class="sxs-lookup"><span data-stu-id="384f5-2558">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="384f5-2559">Il <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> viene impostato dopo una chiamata a <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2559">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-2560">Se si tenta di accedere a questa proprietà in precedenza <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2560">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2561">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2561">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2562">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2562">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2563">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2563">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2564">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2564">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2565">Esempio di codice seguente recupera e visualizza gli endpoint locali e remoti.</span><span class="sxs-lookup"><span data-stu-id="384f5-2565">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2566">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2566">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2567">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2567">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">
          <span data-ttu-id="384f5-2568">Oggetto <see cref="T:System.Collections.IList" /> delle istanze di <see cref="T:System.Net.Sockets.Socket" /> di cui verificare la possibilità di lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2568">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span>
          </span>
        </param>
        <param name="checkWrite">
          <span data-ttu-id="384f5-2569">Oggetto <see cref="T:System.Collections.IList" /> delle istanze di <see cref="T:System.Net.Sockets.Socket" /> di cui verificare la possibilità di scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2569">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span>
          </span>
        </param>
        <param name="checkError">
          <span data-ttu-id="384f5-2570">Oggetto <see cref="T:System.Collections.IList" /> delle istanze di <see cref="T:System.Net.Sockets.Socket" /> in cui verificare la presenza di errori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2570">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span>
          </span>
        </param>
        <param name="microSeconds">
          <span data-ttu-id="384f5-2571">Valore di timeout in microsecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2571">The time-out value, in microseconds.</span>
          </span>
          <span data-ttu-id="384f5-2572">Il valore -1 indica un periodo di timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2572">A -1 value indicates an infinite time-out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2573">Determina lo stato di uno o più socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2573">Determines the status of one or more sockets.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2574"><xref:System.Net.Sockets.Socket.Select%2A> è un metodo statico che determina lo stato di uno o più <xref:System.Net.Sockets.Socket> istanze.</span><span class="sxs-lookup"><span data-stu-id="384f5-2574"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="384f5-2575">È necessario inserire uno o più socket in un <xref:System.Collections.IList> prima di poter usare il <xref:System.Net.Sockets.Socket.Select%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2575">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="384f5-2576">Verificare la leggibilità chiamando <xref:System.Net.Sockets.Socket.Select%2A> con il <xref:System.Collections.IList> come il `checkRead` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-2576">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="384f5-2577">Per controllare la leggibilità dei socket, utilizzare il `checkWrite` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-2577">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="384f5-2578">Per il rilevamento di condizioni di errore, utilizzare `checkError`.</span><span class="sxs-lookup"><span data-stu-id="384f5-2578">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="384f5-2579">Dopo la chiamata <xref:System.Net.Sockets.Socket.Select%2A>, il <xref:System.Collections.IList> verrà compilata solo con i socket che soddisfano le condizioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-2579">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="384f5-2580">Se trovano in uno stato di attesa, la leggibilità significa che una chiamata a <xref:System.Net.Sockets.Socket.Accept%2A> avrà esito positivo senza bloccare.</span><span class="sxs-lookup"><span data-stu-id="384f5-2580">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="384f5-2581">Se è già stato accettato la connessione, la leggibilità significa che i dati sono disponibili per la lettura.</span><span class="sxs-lookup"><span data-stu-id="384f5-2581">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="384f5-2582">In questi casi, tutte le operazioni di ricezione avranno esito positivo senza bloccare.</span><span class="sxs-lookup"><span data-stu-id="384f5-2582">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="384f5-2583">Migliorare la leggibilità può anche indicare se remoto <xref:System.Net.Sockets.Socket> ha interrotto l'esecuzione verso il basso la connessione; in questo caso una chiamata a <xref:System.Net.Sockets.Socket.Receive%2A> restituirà immediatamente il controllo con zero byte.</span><span class="sxs-lookup"><span data-stu-id="384f5-2583">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="384f5-2584"><xref:System.Net.Sockets.Socket.Select%2A> restituito quando almeno uno dei socket di interesse (il socket nel `checkRead`, `checkWrite`, e `checkError` Elenca) soddisfa i criteri specificati, o il `microSeconds` parametro viene superato, quest'ultima giunge prima.</span><span class="sxs-lookup"><span data-stu-id="384f5-2584"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="384f5-2585">Impostazione `microSeconds` su -1 specifica un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-2585">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="384f5-2586">Se si effettua una chiamata non bloccante a <xref:System.Net.Sockets.Socket.Connect%2A>, leggibilità dei significa che è stata stabilita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2586">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="384f5-2587">Se già stata stabilita una connessione, leggibilità dei indica che tutte invio operazioni avrà esito positivo senza bloccare.</span><span class="sxs-lookup"><span data-stu-id="384f5-2587">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="384f5-2588">Se è stata effettuata una chiamata non bloccante per <xref:System.Net.Sockets.Socket.Connect%2A>, il `checkerror` parametro identifica i socket che non sono stati connessi correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2588">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2589">Usare la <xref:System.Net.Sockets.Socket.Poll%2A> metodo se si desidera determinare lo stato di una singola <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2589">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2590">Questo metodo non è in grado di rilevare determinati tipi di problemi di connessione, ad esempio un cavo di rete danneggiato o che l'host remoto è stato arrestato in modo anomalo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2590">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="384f5-2591">Deve tentare di inviare o ricevere dati che consente di rilevare questi tipi di errori.</span><span class="sxs-lookup"><span data-stu-id="384f5-2591">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2592">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2592">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2593">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2593">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2594">Nell'esempio di codice viene illustrato come utilizzare <xref:System.Net.Sockets.Socket.Select%2A> per determinare quali socket in attesa una richiesta di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2594">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2595">Il parametro <paramref name="checkRead" /> è <see langword="null" /> o vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2595">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span>
          </span>
          <span data-ttu-id="384f5-2596">-  e - Il parametro <paramref name="checkWrite" /> è <see langword="null" /> o vuoto  - e -  Il parametro <paramref name="checkError" /> è <see langword="null" /> o vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2596">-and-  The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty  -and-  The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2597">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2597">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-2598">Invia dati a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2598">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2599">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2599">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2600">Invia dati a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2600">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2601">Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2601">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2602"><xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dati all'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo) e restituisce il numero di byte inviato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2602"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="384f5-2603"><xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2603"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="384f5-2604">Questo overload richiede un buffer che contiene i dati da inviare.</span><span class="sxs-lookup"><span data-stu-id="384f5-2604">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="384f5-2605">Il <xref:System.Net.Sockets.SocketFlags> valore predefinito 0, l'offset del buffer valore predefinito è 0 e il numero di byte da inviare i valori predefiniti per le dimensioni del buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2605">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="384f5-2606">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2606">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2607">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2607">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2608">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2608">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-2609">Se non si utilizza il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2609">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="384f5-2610">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2610">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-2611">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2611">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2612">Se si utilizza un protocollo orientato alla connessione <xref:System.Net.Sockets.Socket.Send%2A> verranno bloccati finché non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2612">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2613">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2613">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2614">In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> venga completato correttamente, anche se invia inferiore al numero di byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2614">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="384f5-2615">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia i byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2615">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="384f5-2616">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2616">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2617">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2617">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2618">Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2618">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2619">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2619">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2620">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2620">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2621">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2621">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-2622">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-2622">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2623">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2623">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2624">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2624">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2625">L'esempio di codice seguente illustra l'invio dei dati in un oggetto connesso <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2625">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2626">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2626">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2627">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2627">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2628">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2628">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-2629">Elenco di oggetti <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> in cui sono contenuti i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2629">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2630">Invia l'insieme di buffer dell'elenco a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2630">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2631">Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2631">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2632"><xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2632"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="384f5-2633">Questo overload richiede almeno un buffer che contiene i dati da inviare.</span><span class="sxs-lookup"><span data-stu-id="384f5-2633">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="384f5-2634">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2634">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2635">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2635">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2636">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2636">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-2637">Se non si utilizza il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2637">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="384f5-2638">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2638">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-2639">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2639">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2640">Se si utilizza un protocollo orientato alla connessione <xref:System.Net.Sockets.Socket.Send%2A> verranno bloccati finché non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2640">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2641">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2641">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2642">In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> venga completato correttamente, anche se invia inferiore al numero di byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2642">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="384f5-2643">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia i byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2643">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="384f5-2644">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2644">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2645">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2645">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2646">Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2646">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2647">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2647">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2648">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2648">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2649">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2649">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-2650">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-2650">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2651">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2651">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2652">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2652">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2653">
            <paramref name="buffers" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2653">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-2654">
            <paramref name="buffers" /> è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2654">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2655">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2655">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-2656">Vedere la sezione Osservazioni riportata di seguito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2656">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2657">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2657">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2658">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2658">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2659">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2659">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2660">Invia dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2660">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2661">Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2661">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2662"><xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dati all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo) e restituisce il numero di byte inviato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2662"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="384f5-2663">Il <xref:System.Net.Sockets.Socket.Send%2A> metodo può essere utilizzato per i protocolli orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2663">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="384f5-2664">Questo overload richiede un buffer che contiene i dati desiderati per l'invio e una combinazione bit per bit di <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2664">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="384f5-2665">L'offset del buffer valore predefinito è 0 e il numero di byte da inviare i valori predefiniti per le dimensioni del buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2665">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="384f5-2666">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` valore del parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2666">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-2667">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2667">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2668">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2668">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2669">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2669">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-2670">Se non si utilizza il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata al metodo <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2670">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="384f5-2671">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2671">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-2672">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2672">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2673">Se si utilizza un protocollo orientato alla connessione <xref:System.Net.Sockets.Socket.Send%2A> verranno bloccati finché non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2673">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2674">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2674">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2675">In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> venga completato correttamente, anche se invia inferiore al numero di byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2675">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="384f5-2676">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2676">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="384f5-2677">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2677">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2678">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2678">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2679">Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2679">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2680">È necessario assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-2680">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-2681">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2681">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2682">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2682">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2683">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2683">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2684">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2684">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-2685">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-2685">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2686">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2686">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2687">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2687">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2688">L'esempio di codice seguente illustra l'invio dei dati in un oggetto connesso <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2688">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2689">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2689">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2690">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2690">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2691">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2691">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-2692">Elenco di oggetti <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> in cui sono contenuti i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2692">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2693">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2693">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2694">Invia l'insieme di buffer dell'elenco a un <see cref="T:System.Net.Sockets.Socket" /> connesso utilizzando i <see cref="T:System.Net.Sockets.SocketFlags" /> specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2694">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2695">Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2695">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2696">Questo overload richiede almeno un buffer che contiene i dati da inviare.</span><span class="sxs-lookup"><span data-stu-id="384f5-2696">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="384f5-2697">Il <xref:System.Net.Sockets.SocketFlags> valore predefinito di 0.</span><span class="sxs-lookup"><span data-stu-id="384f5-2697">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="384f5-2698">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketFlags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2698">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-2699">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2699">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2700">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2700">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2701">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2701">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-2702">Se non si utilizza il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2702">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="384f5-2703">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2703">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-2704">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2704">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2705">Se si utilizza un protocollo orientato alla connessione <xref:System.Net.Sockets.Socket.Send%2A> verranno bloccati finché non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2705">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2706">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2706">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2707">In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> venga completato correttamente, anche se invia inferiore al numero di byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2707">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="384f5-2708">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia i byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2708">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="384f5-2709">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2709">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2710">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2710">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2711">Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2711">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2712">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2712">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2713">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2713">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2714">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2714">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-2715">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-2715">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2716">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2716">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2717">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2717">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2718">
            <paramref name="buffers" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2718">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-2719">
            <paramref name="buffers" /> è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2719">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2720">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2720">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2721">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2721">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2722">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2722">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-2723">Numero di byte da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2723">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2724">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2724">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2725">Invia il numero specificato di byte di dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2725">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2726">Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2726">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2727"><xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dati all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo) e restituisce il numero di byte inviato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2727"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="384f5-2728"><xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2728"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="384f5-2729">Questo overload richiede un buffer che contiene i dati da inviare, il numero di byte da inviare e una combinazione bit per bit di qualsiasi <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2729">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="384f5-2730">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2730">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-2731">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2731">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2732">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2732">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2733">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2733">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-2734">Se non si utilizza il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare il <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata al metodo il <xref:System.Net.Sockets.Socket.Send%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2734">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="384f5-2735">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2735">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-2736">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2736">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2737">Con un protocollo orientato alla connessione <xref:System.Net.Sockets.Socket.Send%2A> verranno bloccati finché non viene inviato il numero di byte richiesti, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2737">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2738">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2738">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2739">In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> venga completato correttamente, anche se invia inferiore al numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2739">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="384f5-2740">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2740">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="384f5-2741">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2741">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2742">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2742">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2743">Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2743">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2744">È necessario assicurarsi che le dimensioni non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-2744">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-2745">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2745">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2746">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2746">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2747">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2747">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2748">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2748">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-2749">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-2749">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2750">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2750">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2751">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2751">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2752">Esempio di codice seguente invia i dati nei buffer e specifica <xref:System.Net.Sockets.SocketFlags.None> per <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2752">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2753">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2753">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2754">
            <paramref name="size" /> è inferiore a 0 o supera la dimensione del buffer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2754">
              <paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2755">
            <paramref name="socketFlags" /> non è una combinazione valida di valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2755">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="384f5-2756">- oppure - Si è verificato un errore del sistema operativo durante l'accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2756">-or-  An operating system error occurs while accessing the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2757">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2757">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="384f5-2758">Elenco di oggetti <see cref="T:System.ArraySegment`1" /> di tipo <see cref="T:System.Byte" /> in cui sono contenuti i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2758">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2759">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2759">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="384f5-2760">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2760">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2761">Invia l'insieme di buffer dell'elenco a un <see cref="T:System.Net.Sockets.Socket" /> connesso utilizzando i <see cref="T:System.Net.Sockets.SocketFlags" /> specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2761">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2762">Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2762">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2763">Questo overload richiede almeno un buffer che contiene i dati da inviare.</span><span class="sxs-lookup"><span data-stu-id="384f5-2763">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="384f5-2764">Il <xref:System.Net.Sockets.SocketFlags> valore predefinito di 0.</span><span class="sxs-lookup"><span data-stu-id="384f5-2764">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="384f5-2765">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketFlags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2765">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-2766">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2766">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2767">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2767">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2768">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2768">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-2769">Se non si utilizza il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2769">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="384f5-2770">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2770">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-2771">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2771">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2772">Se si utilizza un protocollo orientato alla connessione <xref:System.Net.Sockets.Socket.Send%2A> verranno bloccati finché non vengono inviati tutti i byte nel buffer, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2772">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2773">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2773">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2774">In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> venga completato correttamente, anche se invia inferiore al numero di byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2774">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="384f5-2775">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia i byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-2775">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="384f5-2776">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2776">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2777">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2777">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2778">Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2778">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2779">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2779">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2780">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2780">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2781">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2781">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-2782">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-2782">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2783">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2783">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2784">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2784">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2785">
            <paramref name="buffers" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2785">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-2786">
            <paramref name="buffers" /> è vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2786">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2787">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2787">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2788">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2788">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2789">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2789">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-2790">Posizione nel buffer di dati da cui iniziare l'invio di dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2790">The position in the data buffer at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-2791">Numero di byte da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2791">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2792">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2792">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2793">Invia il numero specificato di byte di dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso, a partire dall'offset specificato e usando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2793">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2794">Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2794">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2795"><xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dati all'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo) e restituisce il numero di byte inviato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2795"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="384f5-2796"><xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2796"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="384f5-2797">In questo overload, se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2797">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-2798">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2798">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2799">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2799">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2800">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2800">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="384f5-2801">Se non si utilizza <xref:System.Net.Sockets.Socket.SendTo%2A>, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2801">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="384f5-2802">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2802">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-2803">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2803">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2804">È inoltre necessario assicurarsi che le dimensioni non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-2804">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-2805">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2805">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-2806">Se si utilizza un protocollo orientato alla connessione <xref:System.Net.Sockets.Socket.Send%2A> verranno bloccati finché non viene inviato il numero di byte richiesti, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2806">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2807">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2807">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2808">In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> venga completato correttamente, anche se invia inferiore al numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2808">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="384f5-2809">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2809">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="384f5-2810">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2810">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2811">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2811">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2812">Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2812">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2813">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2813">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2814">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2814">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2815">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2815">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-2816">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-2816">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2817">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2817">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2818">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2818">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2819">Esempio di codice seguente specifica il buffer dei dati, un offset, una dimensione, e <xref:System.Net.Sockets.SocketFlags> per l'invio di dati a un oggetto connesso <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2819">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2820">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2820">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2821">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2821">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2822">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2822">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-2823">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2823">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2824">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2824">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2825">
            <paramref name="socketFlags" /> non è una combinazione valida di valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2825">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="384f5-2826">- oppure - Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2826">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2827">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2827">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-2828">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2828">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-2829">Posizione nel buffer di dati da cui iniziare l'invio di dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2829">The position in the data buffer at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-2830">Numero di byte da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2830">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-2831">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2831">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="384f5-2832">Oggetto <see cref="T:System.Net.Sockets.SocketError" /> che memorizza l'errore del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2832">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2833">Invia il numero specificato di byte di dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso, a partire dall'offset specificato e utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2833">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2834">Numero di byte inviati a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2834">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2835"><xref:System.Net.Sockets.Socket.Send%2A> Invia in modo sincrono dati all'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> (metodo) e restituisce il numero di byte inviato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2835"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="384f5-2836"><xref:System.Net.Sockets.Socket.Send%2A> può essere utilizzato per i protocolli orientati alla connessione e senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2836"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="384f5-2837">In questo overload, se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2837">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-2838">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo o <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2838">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2839">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2839">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2840">Se si utilizza un protocollo senza connessione e un piano per inviare dati a diversi host, è necessario utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2840">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="384f5-2841">Se non si utilizza <xref:System.Net.Sockets.Socket.SendTo%2A>, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di ogni chiamata a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2841">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="384f5-2842">È possibile utilizzare <xref:System.Net.Sockets.Socket.SendTo%2A> anche dopo aver stabilito un host remoto predefinito con <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2842">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="384f5-2843">È inoltre possibile modificare l'host remoto predefinito prima di chiamare <xref:System.Net.Sockets.Socket.Send%2A> apportando un'altra chiamata a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2843">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2844">È inoltre necessario assicurarsi che le dimensioni non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-2844">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-2845">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.Send%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2845">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-2846">Se si utilizza un protocollo orientato alla connessione <xref:System.Net.Sockets.Socket.Send%2A> verranno bloccati finché non viene inviato il numero di byte richiesti, a meno che non è stato impostato un timeout utilizzando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2846">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-2847">Se è stato superato il valore di timeout, il <xref:System.Net.Sockets.Socket.Send%2A> chiamata genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2847">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2848">In modalità non bloccante, <xref:System.Net.Sockets.Socket.Send%2A> venga completato correttamente, anche se invia inferiore al numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2848">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="384f5-2849">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2849">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="384f5-2850">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2850">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2851">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2851">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2852">Il completamento del <xref:System.Net.Sockets.Socket.Send%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2852">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2853">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2853">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2854">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2854">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2855">Il completamento di una trasmissione non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2855">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="384f5-2856">Se lo spazio di buffer non è disponibile all'interno del sistema di trasporto per contenere i dati da trasmettere, trasmissione bloccherà a meno che non è stato inserito il socket in modalità non di blocco.</span><span class="sxs-lookup"><span data-stu-id="384f5-2856">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2857">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2857">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2858">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2858">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2859">Esempio di codice seguente specifica il buffer dei dati, un offset, una dimensione, e <xref:System.Net.Sockets.SocketFlags> per l'invio di dati a un oggetto connesso <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2859">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-2860">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2860">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2861">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2861">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2862">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2862">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-2863">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2863">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-2864">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2864">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2865">
            <paramref name="socketFlags" /> non è una combinazione valida di valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2865">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="384f5-2866">- oppure - Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2866">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2867">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2867">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-2868">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2868">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2869">Invia i dati in modo asincrono a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2869">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2870">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2870">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-2871">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2871">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-2872">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2872">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-2873">In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2873">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2874">Il <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo viene utilizzato per scrivere i dati in uscita da uno o più buffer su un socket orientato alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2874">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="384f5-2875">Questo metodo può essere inoltre utilizzato, tuttavia, sui socket orientati che hanno specificato un host remoto in un'operazione di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2875">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="384f5-2876">Il <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo avvia un'operazione asincrona di invio all'host remoto stabilita nel <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2876">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-2877">Le seguenti proprietà e gli eventi di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:</span><span class="sxs-lookup"><span data-stu-id="384f5-2877">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="384f5-2878"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> o <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="384f5-2878"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="384f5-2879"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> è impostato</span><span class="sxs-lookup"><span data-stu-id="384f5-2879"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="384f5-2880"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> è impostato</span><span class="sxs-lookup"><span data-stu-id="384f5-2880"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="384f5-2881">Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà per qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.SendAsync%2A> (metodo), in modo che le informazioni possano essere recuperate nel metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-2881">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="384f5-2882">Se il callback richiede più informazioni rispetto a un singolo oggetto, una classe piccola può essere creata per contenere le altre informazioni sullo stato necessarie come membri.</span><span class="sxs-lookup"><span data-stu-id="384f5-2882">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="384f5-2883">Il <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo genererà un'eccezione se non si chiama innanzitutto <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2883">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="384f5-2884">La chiamata di <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo consente di inviare i dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-2884">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="384f5-2885">Socket orientato ai messaggi, non superare la dimensione massima del messaggio del provider del servizio sottostante Windows sockets.</span><span class="sxs-lookup"><span data-stu-id="384f5-2885">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="384f5-2886">Se i dati sono troppo lunghi per il passaggio in modo atomico attraverso il provider del servizio sottostante, nessun dato viene trasmessa e la <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo genera una <xref:System.Net.Sockets.SocketException> con il <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> impostato per il codice di errore Winsock WSAEMSGSIZE nativo (10040).</span><span class="sxs-lookup"><span data-stu-id="384f5-2886">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="384f5-2887">Si noti che il completamento dei <xref:System.Net.Sockets.Socket.SendAsync%2A> metodo non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-2887">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-2888">Le proprietà <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> sul parametro <paramref name="e" /> devono fare riferimento a buffer validi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2888">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span>
          </span>
          <span data-ttu-id="384f5-2889">È possibile impostare una di queste due proprietà, ma non entrambe contemporaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2889">One or the other of these properties may be set, but not both at the same time.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-2890">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2890">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-2891">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2891">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2892">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2892">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2893">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è ancora connesso o non è stato ottenuto tramite un metodo <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> o <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2893">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-2894">Ottiene o imposta un valore che specifica le dimensioni del buffer di invio del <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2894">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-2895">
            <see cref="T:System.Int32" /> contenente le dimensioni, in byte, del buffer di invio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2895">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span>
          </span>
          <span data-ttu-id="384f5-2896">Il valore predefinito è 8192.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2896">The default is 8192.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2897">Dimensioni maggiori del buffer potrebbero ritardare il riconoscimento di problemi di connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2897">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="384f5-2898">È consigliabile aumentare le dimensioni del buffer il trasferimento di file di grandi dimensioni, se si utilizza una larghezza di banda elevata, la connessione con latenza elevata (ad esempio un satellite a banda larga provider.)</span><span class="sxs-lookup"><span data-stu-id="384f5-2898">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2899">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.SendBufferSize%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-2899">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2900">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2900">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2901">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2901">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-2902">Il valore specificato per un'operazione di impostazione è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2902">The value specified for a set operation is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-2903">Invia un file e dati opzionali in modalità sincrona a un <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2903">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="384f5-2904">Oggetto <see cref="T:System.String" /> che contiene il percorso e il nome del file da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2904">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span>
          </span>
          <span data-ttu-id="384f5-2905">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2905">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2906">Invia il file <paramref name="fileName" /> a un oggetto connesso <see cref="T:System.Net.Sockets.Socket" /> con il flag di trasmissione <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2906">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2907">Questo overload invia il file `fileName` al socket connesso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2907">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="384f5-2908">Il `flags` valore predefinito del parametro <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) e il `preBuffer` e `postBuffer` per impostazione predefinita i parametri `null`.</span><span class="sxs-lookup"><span data-stu-id="384f5-2908">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="384f5-2909">Se `fileName` è nella directory locale, può essere identificato utilizzando solo il nome del file; in caso contrario, è necessario specificare il percorso completo e nome del file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2909">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="384f5-2910">I caratteri jolly ("... \\\myfile.txt ") e i nomi di condivisione UNC ("\\\\\\directory \shared\\\myfile.txt ") sono supportati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2910">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="384f5-2911">Se il file non viene trovato, l'eccezione <xref:System.IO.FileNotFoundException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2911">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="384f5-2912">Questo metodo Usa il `TransmitFile` trovare una funzione nell'API di Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="384f5-2912">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="384f5-2913">Per ulteriori informazioni sul `TransmitFile` (funzione) e i relativi flag, vedere la documentazione di Windows Sockets in MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="384f5-2913">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="384f5-2914"><xref:System.Net.Sockets.Socket.SendFile%2A> Invia in modo sincrono un file all'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2914"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2915"><xref:System.Net.Sockets.Socket.SendFile%2A> può essere utilizzato per entrambi orientato alla connessione e protocolli senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2915"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="384f5-2916">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo, in caso contrario <xref:System.Net.Sockets.Socket.SendFile%2A> genera un <xref:System.Net.Sockets.SocketException> (eccezione).</span><span class="sxs-lookup"><span data-stu-id="384f5-2916">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="384f5-2917">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2917">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2918">Se si utilizza un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.SendFile%2A> blocca fino a quando non viene inviato il file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2918">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="384f5-2919">In modalità non bloccante, <xref:System.Net.Sockets.Socket.SendFile%2A> venga completato correttamente prima di tutto il file è stato inviato.</span><span class="sxs-lookup"><span data-stu-id="384f5-2919">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="384f5-2920">Non è garantito che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2920">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2921">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2921">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2922">Il completamento del <xref:System.Net.Sockets.Socket.SendFile%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2922">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2923">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2923">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2924">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2924">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2925">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2925">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2926">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2926">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2927">Esempio di codice seguente crea e si connette un socket e quindi invia un file all'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2927">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="384f5-2928">Il file "test. txt" si trova nella directory radice del computer locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-2928">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-2929">Il socket non è connesso a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2929">The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2930">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2930">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-2931">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è in modalità di blocco e non può accettare questa chiamata sincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2931">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="384f5-2932">Il parametro <paramref name="fileName" /> del file non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2932">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2933">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2933">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="384f5-2934">Oggetto <see cref="T:System.String" /> che contiene il percorso e il nome del file da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2934">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span>
          </span>
          <span data-ttu-id="384f5-2935">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2935">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="preBuffer">
          <span data-ttu-id="384f5-2936">Oggetto matrice <see cref="T:System.Byte" /> che contiene i dati da inviare prima dell'invio del file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2936">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span>
          </span>
          <span data-ttu-id="384f5-2937">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2937">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="postBuffer">
          <span data-ttu-id="384f5-2938">Oggetto matrice <see cref="T:System.Byte" /> che contiene i dati da inviare dopo l'invio del file.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2938">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span>
          </span>
          <span data-ttu-id="384f5-2939">Questo parametro può essere <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2939">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="384f5-2940">Uno o più valori di <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2940">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2941">Invia il file <paramref name="fileName" /> e i buffer di dati a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso usando il valore di <see cref="T:System.Net.Sockets.TransmitFileOptions" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2941">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2942">Questo overload richiede il nome del file da inviare e una combinazione bit per bit di <xref:System.Net.Sockets.TransmitFileOptions> valori.</span><span class="sxs-lookup"><span data-stu-id="384f5-2942">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="384f5-2943">Il `preBuffer` parametro conterrà tutti i dati che si desidera anteporre al file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2943">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="384f5-2944">`postBuffer` contiene dati che si desidera eseguire il file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2944">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="384f5-2945">Se `fileName` è nella directory di lavoro corrente, può essere identificato utilizzando solo il nome del file; in caso contrario, è necessario specificare il percorso completo e nome del file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2945">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="384f5-2946">I caratteri jolly ("... \\\myfile.txt ") e i nomi di condivisione UNC ("\\\\\\directory \shared\\\myfile.txt ") sono supportati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2946">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="384f5-2947">Il `flags` parametro fornisce il provider di servizi Windows Sockets con ulteriori informazioni sul trasferimento dei file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2947">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="384f5-2948">Per ulteriori informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2948">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="384f5-2949">Questo metodo Usa il `TransmitFile` trovare una funzione nell'API di Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="384f5-2949">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="384f5-2950">Per ulteriori informazioni sul `TransmitFile` (funzione) e i relativi flag, vedere la documentazione di Windows Sockets in MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="384f5-2950">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="384f5-2951"><xref:System.Net.Sockets.Socket.SendFile%2A> Invia in modo sincrono un file all'host remoto specificato nella <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-2951"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-2952"><xref:System.Net.Sockets.Socket.SendFile%2A> può essere utilizzato per entrambi orientato alla connessione e protocolli senza connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2952"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="384f5-2953">Se si utilizza un protocollo senza connessione, è necessario chiamare <xref:System.Net.Sockets.Socket.Connect%2A> prima di chiamare questo metodo; in caso contrario <xref:System.Net.Sockets.Socket.SendFile%2A> genera un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2953">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-2954">Se si utilizza un protocollo orientato alla connessione, è necessario utilizzare <xref:System.Net.Sockets.Socket.Connect%2A> per stabilire una connessione all'host remoto o utilizzare <xref:System.Net.Sockets.Socket.Accept%2A> per accettare una connessione in ingresso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2954">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="384f5-2955">Se si utilizza un protocollo orientato alla connessione, <xref:System.Net.Sockets.Socket.SendFile%2A> blocca fino a quando non viene inviato l'intero file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2955">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="384f5-2956">In modalità non bloccante, <xref:System.Net.Sockets.Socket.SendFile%2A> venga completato correttamente prima di tutto il file è stato inviato.</span><span class="sxs-lookup"><span data-stu-id="384f5-2956">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="384f5-2957">Non è garantito che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2957">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-2958">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-2958">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-2959">Il completamento del <xref:System.Net.Sockets.Socket.SendFile%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-2959">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2960">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-2960">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-2961">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-2961">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-2962">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-2962">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-2963">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-2963">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-2964">Esempio di codice seguente crea e si connette un socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-2964">The following code example creates and connects a socket.</span></span> <span data-ttu-id="384f5-2965">Il file "test. txt" si trova nella directory radice del computer locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-2965">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="384f5-2966">In questo esempio è creare un prebuffer e successivo dei dati e inviarle all'host remoto con il file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2966">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="384f5-2967">Il valore predefinito <xref:System.Net.Sockets.TransmitFileOptions> vengono utilizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-2967">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-2968">Il sistema operativo non è Windows NT o versioni successive.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2968">The operating system is not Windows NT or later.</span>
          </span>
          <span data-ttu-id="384f5-2969">\- oppure - Il socket non è connesso a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2969">\- or -  The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-2970">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2970">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-2971">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è in modalità di blocco e non può accettare questa chiamata sincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2971">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="384f5-2972">Il parametro <paramref name="fileName" /> del file non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2972">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-2973">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2973">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-2974">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2974">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-2975">Invia in modo asincrono un insieme di file o di buffer di dati in memoria a un oggetto <see cref="T:System.Net.Sockets.Socket" /> connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2975">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-2976">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2976">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-2977">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2977">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-2978">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2978">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-2979">In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-2979">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-2980">Il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo viene utilizzato per inviare una raccolta di file o della memoria buffer di dati all'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2980">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="384f5-2981">Il <xref:System.Net.Sockets.Socket> deve essere già connessi all'host remoto.</span><span class="sxs-lookup"><span data-stu-id="384f5-2981">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="384f5-2982">Se un <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> fa riferimento a un file nella directory di lavoro, può essere identificato utilizzando solo il nome del file; in caso contrario, è necessario specificare il percorso completo e nome del file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2982">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="384f5-2983">Sono supportati i caratteri jolly e i nomi delle condivisioni UNC.</span><span class="sxs-lookup"><span data-stu-id="384f5-2983">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="384f5-2984">Se il file non viene trovato, <xref:System.IO.FileNotFoundException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="384f5-2984">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="384f5-2985">Per ricevere una notifica di completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegare e collegare il callback di <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="384f5-2985">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="384f5-2986">Il <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> proprietà di `e` parametro fornisce il provider di servizi Windows Sockets con ulteriori informazioni sul trasferimento dei file.</span><span class="sxs-lookup"><span data-stu-id="384f5-2986">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="384f5-2987">Per ulteriori informazioni su come usare questo parametro, vedere <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="384f5-2987">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="384f5-2988">Le seguenti proprietà e gli eventi di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:</span><span class="sxs-lookup"><span data-stu-id="384f5-2988">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="384f5-2989">Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà per qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> (metodo), in modo che le informazioni possano essere recuperate nel metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-2989">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="384f5-2990">Se il callback richiede più informazioni rispetto a un singolo oggetto, una classe piccola può essere creata per contenere le altre informazioni sullo stato necessarie come membri.</span><span class="sxs-lookup"><span data-stu-id="384f5-2990">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="384f5-2991">Questo metodo Usa la funzione TransmitPackets disponibile nell'API di Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="384f5-2991">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="384f5-2992">Per ulteriori informazioni sulla funzione TransmitPackets e i relativi flag, vedere la documentazione di Windows Sockets in MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="384f5-2992">For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="384f5-2993">Sebbene sia destinato ai protocolli orientati alla connessione, il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo funziona anche per protocolli senza connessione, purché si chiama innanzitutto il <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo per stabilire un host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-2993">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="384f5-2994">Protocolli senza connessione, è necessario anche assicurarsi che le dimensioni del file non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-2994">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-2995">In caso affermativo, il datagramma non verrà inviato e <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> genera un <xref:System.Net.Sockets.SocketException> (eccezione).</span><span class="sxs-lookup"><span data-stu-id="384f5-2995">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="384f5-2996">Il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo è ottimizzato in base al sistema operativo in cui viene utilizzato.</span><span class="sxs-lookup"><span data-stu-id="384f5-2996">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="384f5-2997">Nelle edizioni di Windows server, il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo è ottimizzato per garantire prestazioni elevate.</span><span class="sxs-lookup"><span data-stu-id="384f5-2997">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="384f5-2998">Nelle edizioni di client Windows, il <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> metodo è ottimizzato per l'utilizzo della memoria e risorse minima.</span><span class="sxs-lookup"><span data-stu-id="384f5-2998">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="384f5-2999">Utilizzare la <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag nel <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> proprietà nel `e` parametro può offrire vantaggi significativi delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-2999">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="384f5-3000">Se l'avvio di thread di <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> chiamata al metodo viene utilizzata per calcoli pesanti, è possibile, anche se improbabile, che inizializza impedito l'avvio.</span><span class="sxs-lookup"><span data-stu-id="384f5-3000">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="384f5-3001">Si noti che esiste una differenza tra Inizializza kernel e modalità utente.</span><span class="sxs-lookup"><span data-stu-id="384f5-3001">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="384f5-3002">Kernel avviate quando un thread si trova in uno stato di attesa.</span><span class="sxs-lookup"><span data-stu-id="384f5-3002">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="384f5-3003">In modalità utente vengono avviate quando un thread si trova in uno stato di attesa di avviso.</span><span class="sxs-lookup"><span data-stu-id="384f5-3003">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="384f5-3004">Impossibile trovare il file specificato dalla proprietà <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3004">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-3005">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3005">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-3006">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3006">Windows XP or later is required for this method.</span>
          </span>
          <span data-ttu-id="384f5-3007">Questa eccezione si verifica anche se l'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è connesso a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3007">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3008">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3008">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3009">È in uso un oggetto <see cref="T:System.Net.Sockets.Socket" /> privo di connessione e il file inviato supera la dimensione massima del pacchetto del trasporto sottostante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3009">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-3010">Ottiene o imposta un valore che specifica l'intervallo di tempo dopo il quale si verifica il timeout di una chiamata <see cref="Overload:System.Net.Sockets.Socket.Send" /> sincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3010">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-3011">Valore di timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3011">The time-out value, in milliseconds.</span>
          </span>
          <span data-ttu-id="384f5-3012">Se si imposta per la proprietà un valore compreso tra 1 e 499, il valore verrà impostato su 500.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3012">If you set the property with a value between 1 and 499, the value will be changed to 500.</span>
          </span>
          <span data-ttu-id="384f5-3013">Il valore predefinito è 0, che indica un periodo di timeout indeterminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3013">The default value is 0, which indicates an infinite time-out period.</span>
          </span>
          <span data-ttu-id="384f5-3014">Anche il valore -1 indica un periodo di timeout indeterminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3014">Specifying -1 also indicates an infinite time-out period.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3015">Questa opzione si applica a sincrono <xref:System.Net.Sockets.Socket.Send%2A> solo le chiamate.</span><span class="sxs-lookup"><span data-stu-id="384f5-3015">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="384f5-3016">Se il periodo di timeout viene superato, il <xref:System.Net.Sockets.Socket.Send%2A> metodo genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3016">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3017">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.SendTimeout%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-3017">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3018">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3018">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3019">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3019">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-3020">Il valore specificato per un'operazione set è minore di -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3020">The value specified for a set operation is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-3021">Invia dati a uno specifico endpoint.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3021">Sends data to a specific endpoint.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-3022">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3022">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-3023">Classe <see cref="T:System.Net.EndPoint" /> che rappresenta la destinazione dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3023">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3024">Invia dati a un endpoint specifico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3024">Sends data to the specified endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-3025">Numero di byte inviati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3025">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3026">In questo overload, l'offset del buffer valore predefinito è 0, il numero di byte da inviare i valori predefiniti per le dimensioni del `buffer` parametro e il <xref:System.Net.Sockets.SocketFlags> valore predefinito di 0.</span><span class="sxs-lookup"><span data-stu-id="384f5-3026">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="384f5-3027">Se si utilizza un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3027">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="384f5-3028">È sufficiente eseguire questa operazione se si intende chiamare il <xref:System.Net.Sockets.Socket.Send%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3028">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="384f5-3029">Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro sostituiranno l'host remoto predefinito specificato per tale operazione solo di invio.</span><span class="sxs-lookup"><span data-stu-id="384f5-3029">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="384f5-3030">Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, perché il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale più appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3030">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="384f5-3031">Se è necessario identificare il numero di porta e indirizzo di rete locale assegnato, è possibile usare il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo viene completato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-3031">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="384f5-3032">Sebbene sia destinato ai protocolli senza connessione, <xref:System.Net.Sockets.Socket.SendTo%2A> funziona anche con protocolli orientati alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3032">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="384f5-3033">Se si utilizza un protocollo orientato alla connessione, è innanzitutto necessario stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare una richiesta di connessione in ingresso tramite il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-3033">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-3034">Se si esegue stabilire o accettare una connessione all'host remoto, non <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3034">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-3035">È inoltre possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3035">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-3036">In entrambi i casi, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorerà il `remoteEP` parametro e solo invio di dati per connesso o host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-3036">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="384f5-3037">I socket bloccanti verranno bloccati finché non vengono inviati tutti i byte nel buffer.</span><span class="sxs-lookup"><span data-stu-id="384f5-3037">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="384f5-3038">Poiché un non bloccante <xref:System.Net.Sockets.Socket> viene completata immediatamente, potrebbe non inviare tutti i byte di `buffer`.</span><span class="sxs-lookup"><span data-stu-id="384f5-3038">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="384f5-3039">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia tutti i byte di `buffer`.</span><span class="sxs-lookup"><span data-stu-id="384f5-3039">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="384f5-3040">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-3040">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-3041">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-3041">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="384f5-3042">Il completamento del <xref:System.Net.Sockets.Socket.SendTo%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-3042">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="384f5-3043">Se si utilizza un protocollo senza connessione in modalità di blocco, <xref:System.Net.Sockets.Socket.SendTo%2A> verranno bloccati finché non viene inviato il datagramma.</span><span class="sxs-lookup"><span data-stu-id="384f5-3043">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="384f5-3044">Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3044">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-3045">È inoltre necessario assicurarsi che il numero di byte inviati non superi le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-3045">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-3046">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3046">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3047">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3047">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3048">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3048">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3049">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-3049">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-3050">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-3050">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3051">Esempio di codice seguente invia un datagramma senza connessione all'host remoto specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3051">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-3052">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3052">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-3053">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3053">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3054">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3054">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3055">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3055">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-3056">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3056">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-3057">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3057">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-3058">
            <see cref="T:System.Net.EndPoint" /> che rappresenta la posizione di destinazione dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3058">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3059">Invia dati a un endpoint specifico utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3059">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-3060">Numero di byte inviati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3060">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3061">In questo overload, l'offset del buffer valore predefinito è 0 e il numero di byte da inviare i valori predefiniti per le dimensioni del `buffer`.</span><span class="sxs-lookup"><span data-stu-id="384f5-3061">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="384f5-3062">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-3062">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-3063">Se si utilizza un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3063">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="384f5-3064">È sufficiente eseguire questa operazione se si intende chiamare il <xref:System.Net.Sockets.Socket.Send%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3064">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="384f5-3065">Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro sostituiranno l'host remoto predefinito specificato per tale operazione solo di invio.</span><span class="sxs-lookup"><span data-stu-id="384f5-3065">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="384f5-3066">Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, perché il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale più appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3066">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="384f5-3067">Se è necessario identificare il numero di porta e indirizzo di rete locale assegnato, è possibile usare il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo viene completato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-3067">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="384f5-3068">Sebbene sia destinato ai protocolli senza connessione, <xref:System.Net.Sockets.Socket.SendTo%2A> funziona anche con protocolli orientati alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3068">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="384f5-3069">Se si utilizza un protocollo orientato alla connessione, è innanzitutto necessario stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare una richiesta di connessione in ingresso tramite il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-3069">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-3070">Se si esegue stabilire o accettare una connessione all'host remoto, non <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3070">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-3071">È inoltre possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3071">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-3072">In entrambi i casi, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorerà il `remoteEP` parametro e solo invio di dati per connesso o host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-3072">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="384f5-3073">I socket bloccanti bloccherà finché l'oggetto richiesto tutti i byte di `buffer` vengono inviati.</span><span class="sxs-lookup"><span data-stu-id="384f5-3073">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="384f5-3074">Poiché un non bloccante <xref:System.Net.Sockets.Socket> viene completata immediatamente, potrebbe non inviare tutti i byte di `buffer`.</span><span class="sxs-lookup"><span data-stu-id="384f5-3074">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="384f5-3075">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia tutti i byte di `buffer`.</span><span class="sxs-lookup"><span data-stu-id="384f5-3075">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="384f5-3076">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-3076">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-3077">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-3077">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="384f5-3078">Il completamento del <xref:System.Net.Sockets.Socket.SendTo%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-3078">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="384f5-3079">Se si utilizza un protocollo senza connessione in modalità di blocco, <xref:System.Net.Sockets.Socket.SendTo%2A> verranno bloccati finché non viene inviato il datagramma.</span><span class="sxs-lookup"><span data-stu-id="384f5-3079">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="384f5-3080">Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3080">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-3081">È inoltre necessario assicurarsi che il numero di byte inviati non superi le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-3081">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-3082">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3082">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3083">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3083">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3084">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3084">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3085">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-3085">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-3086">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-3086">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3087">Esempio di codice seguente invia un datagramma senza connessione all'host remoto specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3087">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="384f5-3088"><xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3088"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-3089">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3089">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-3090">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3090">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3091">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3091">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3092">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3092">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-3093">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3093">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-3094">Numero di byte da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3094">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-3095">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3095">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-3096">
            <see cref="T:System.Net.EndPoint" /> che rappresenta la posizione di destinazione dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3096">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3097">Invia il numero specificato di byte di dati all'endpoint specificato, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3097">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-3098">Numero di byte inviati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3098">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3099">In questo overload, l'offset del buffer valore predefinito è 0.</span><span class="sxs-lookup"><span data-stu-id="384f5-3099">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="384f5-3100">Se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-3100">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-3101">Se si utilizza un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3101">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="384f5-3102">È sufficiente eseguire questa operazione se si intende chiamare il <xref:System.Net.Sockets.Socket.Send%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3102">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="384f5-3103">Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro sostituiranno l'host remoto predefinito specificato per tale operazione solo di invio.</span><span class="sxs-lookup"><span data-stu-id="384f5-3103">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="384f5-3104">Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, perché il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale più appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3104">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="384f5-3105">Se è necessario identificare il numero di porta e indirizzo di rete locale assegnato, è possibile usare il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo viene completato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-3105">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="384f5-3106">Sebbene sia destinato ai protocolli senza connessione, <xref:System.Net.Sockets.Socket.SendTo%2A> funziona anche con protocolli orientati alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3106">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="384f5-3107">Se si utilizza un protocollo orientato alla connessione, è innanzitutto necessario stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare una richiesta di connessione in ingresso tramite il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-3107">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-3108">Se si esegue stabilire o accettare una connessione all'host remoto, non <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3108">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-3109">È inoltre possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3109">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-3110">In entrambi i casi, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorerà il `remoteEP` parametro e solo invio di dati per connesso o host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-3110">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="384f5-3111">I socket bloccanti verranno bloccati finché non viene inviato il numero di byte richiesti.</span><span class="sxs-lookup"><span data-stu-id="384f5-3111">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="384f5-3112">Poiché un non bloccante <xref:System.Net.Sockets.Socket> viene completata immediatamente, potrebbe non inviare tutti i byte richiesti in un'unica operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3112">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="384f5-3113">È responsabilità dell'applicazione per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-3113">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="384f5-3114">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-3114">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-3115">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-3115">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="384f5-3116">Il completamento del <xref:System.Net.Sockets.Socket.SendTo%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-3116">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="384f5-3117">Se si utilizza un protocollo senza connessione in modalità di blocco, <xref:System.Net.Sockets.Socket.SendTo%2A> verranno bloccati finché non viene inviato il datagramma.</span><span class="sxs-lookup"><span data-stu-id="384f5-3117">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="384f5-3118">Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3118">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-3119">È inoltre necessario assicurarsi che il numero di byte inviati non superi le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-3119">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-3120">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3120">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3121">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3121">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3122">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3122">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3123">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-3123">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-3124">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-3124">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3125">Esempio di codice seguente invia un datagramma senza connessione all'host remoto specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3125">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="384f5-3126">Le dimensioni e <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3126">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-3127">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3127">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-3128">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3128">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-3129">Il parametro <paramref name="size" /> eccede la dimensione di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3129">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3130">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3130">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3131">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3131">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="384f5-3132">Matrice di <see cref="T:System.Byte" /> che contiene i dati da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3132">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="384f5-3133">Posizione nel buffer di dati da cui iniziare l'invio di dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3133">The position in the data buffer at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="384f5-3134">Numero di byte da inviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3134">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="384f5-3135">Combinazione bit per bit dei valori di <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3135">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="384f5-3136">
            <see cref="T:System.Net.EndPoint" /> che rappresenta la posizione di destinazione dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3136">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3137">Invia il numero di byte di dati specificato all'endpoint specificato, a partire dalla posizione specificata nel buffer, utilizzando l'oggetto <see cref="T:System.Net.Sockets.SocketFlags" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3137">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-3138">Numero di byte inviati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3138">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3139">In questo overload, se si specifica il <xref:System.Net.Sockets.SocketFlags.DontRoute> contrassegna come il `socketflags` parametro, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-3139">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-3140">Se si utilizza un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3140">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="384f5-3141">È sufficiente eseguire questa operazione se si intende chiamare il <xref:System.Net.Sockets.Socket.Send%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3141">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="384f5-3142">Se si chiama il <xref:System.Net.Sockets.Socket.Connect%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendTo%2A>, il `remoteEP` parametro sostituiranno l'host remoto predefinito specificato per tale operazione solo di invio.</span><span class="sxs-lookup"><span data-stu-id="384f5-3142">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="384f5-3143">Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo, perché il provider del servizio sottostante assegnerà il numero di porta e indirizzo di rete locale più appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3143">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="384f5-3144">Se è necessario identificare il numero di porta e indirizzo di rete locale assegnato, è possibile usare il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo viene completato correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-3144">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="384f5-3145">Sebbene sia destinato ai protocolli senza connessione, <xref:System.Net.Sockets.Socket.SendTo%2A> funziona anche con protocolli orientati alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3145">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="384f5-3146">Se si utilizza un protocollo orientato alla connessione, è innanzitutto necessario stabilire una connessione all'host remoto chiamando il <xref:System.Net.Sockets.Socket.Connect%2A> metodo oppure accettare una richiesta di connessione in ingresso tramite il <xref:System.Net.Sockets.Socket.Accept%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="384f5-3146">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="384f5-3147">Se si esegue stabilire o accettare una connessione all'host remoto, non <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3147">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-3148">È inoltre possibile stabilire un host remoto predefinito per un protocollo senza connessione prima di chiamare il <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3148">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="384f5-3149">In entrambi i casi, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorerà il `remoteEP` parametro e solo invio di dati per connesso o host remoto predefinito.</span><span class="sxs-lookup"><span data-stu-id="384f5-3149">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="384f5-3150">I socket bloccanti verranno bloccati finché non viene inviato il numero di byte richiesti.</span><span class="sxs-lookup"><span data-stu-id="384f5-3150">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="384f5-3151">Poiché un non bloccante <xref:System.Net.Sockets.Socket> viene completata immediatamente, potrebbe non inviare tutti i byte richiesti in un'unica operazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3151">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="384f5-3152">Ha la responsabilità di applicazioni per tenere traccia del numero di byte inviati e ripetere l'operazione fino a quando l'applicazione invia il numero di byte richiesto.</span><span class="sxs-lookup"><span data-stu-id="384f5-3152">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="384f5-3153">Non è inoltre alcuna garanzia che i dati inviati vengano visualizzati immediatamente nella rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-3153">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="384f5-3154">Per aumentare l'efficienza della rete, il sistema potrebbero essere ritardate trasmissione fino a quando non verrà raccolte una quantità significativa di dati in uscita.</span><span class="sxs-lookup"><span data-stu-id="384f5-3154">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="384f5-3155">Il completamento del <xref:System.Net.Sockets.Socket.SendTo%2A> metodo significa che il sistema sottostante avesse spazio sufficiente per buffer per l'invio dei dati per una rete.</span><span class="sxs-lookup"><span data-stu-id="384f5-3155">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="384f5-3156">Se si utilizza un protocollo senza connessione in modalità di blocco, <xref:System.Net.Sockets.Socket.SendTo%2A> verranno bloccati finché non viene inviato il datagramma.</span><span class="sxs-lookup"><span data-stu-id="384f5-3156">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="384f5-3157">Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket a <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3157">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="384f5-3158">È inoltre necessario assicurarsi che le dimensioni non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-3158">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-3159">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.SendTo%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3159">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3160">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3160">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3161">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3161">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3162">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-3162">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-3163">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-3163">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3164">Esempio di codice seguente invia un datagramma senza connessione all'host remoto specificato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3164">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="384f5-3165">L'offset, dimensione e <xref:System.Net.Sockets.SocketFlags> vengono passati al <xref:System.Net.Sockets.Socket.SendTo%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3165">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-3166">
            <paramref name="buffer" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3166">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="384f5-3167">oppure <paramref name="remoteEP" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3167">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-3168">
            <paramref name="offset" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3168">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-3169">- oppure - <paramref name="offset" /> è maggiore della lunghezza di <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3169">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="384f5-3170">- oppure - <paramref name="size" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3170">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="384f5-3171">- oppure - <paramref name="size" /> è maggiore della lunghezza di <paramref name="buffer" /> meno il valore del parametro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3171">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3172">
            <paramref name="socketFlags" /> non è una combinazione valida di valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3172">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="384f5-3173">- oppure - Si verifica un errore del sistema operativo durante l'accesso a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3173">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3174">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3174">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="384f5-3175">Uno dei chiamanti nello stack di chiamate non dispone delle autorizzazioni richieste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3175">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="384f5-3176">Oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> da utilizzare per questa operazione socket asincrona.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3176">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3177">Invia i dati in modo asincrono a un host remoto specifico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3177">Sends data asynchronously to a specific remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="384f5-3178">Restituisce <see langword="true" /> se l'operazione di I/O è in sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3178">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="384f5-3179">Al completamento dell'operazione verrà generato l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3179">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="384f5-3180">Restituisce <see langword="false" /> se l'operazione di I/O è stata completata in modo sincrono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3180">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="384f5-3181">In questo caso, l'evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> sul parametro <paramref name="e" /> non verrà generato e l'oggetto <paramref name="e" /> passato come parametro potrebbe essere esaminato immediatamente dopo che la chiamata al metodo è stata restituita per recuperare il risultato dell'operazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3181">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3182">Il <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodo avvia un'operazione asincrona di invio all'host remoto specificato nella <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà del `e` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-3182">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="384f5-3183">La chiamata di <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodo consente di inviare i dati all'interno di un thread di esecuzione separato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3183">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="384f5-3184">Sebbene questo metodo è destinato ai protocolli senza connessione, <xref:System.Net.Sockets.Socket.SendToAsync%2A> funziona con protocolli senza connessione e orientati alla connessione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3184">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="384f5-3185">Per ricevere una notifica di completamento, è necessario creare un metodo di callback che implementa l'EventHandler\<SocketAsyncEventArgs > delegare e collegare il callback di <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="384f5-3185">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="384f5-3186">Le seguenti proprietà e gli eventi di <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> oggetto sono necessari per chiamare correttamente questo metodo:</span><span class="sxs-lookup"><span data-stu-id="384f5-3186">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="384f5-3187">Il chiamante può impostare il <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> proprietà per qualsiasi oggetto di stato utente desiderato prima di chiamare il <xref:System.Net.Sockets.Socket.SendToAsync%2A> (metodo), in modo che le informazioni possano essere recuperate nel metodo di callback.</span><span class="sxs-lookup"><span data-stu-id="384f5-3187">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="384f5-3188">Se il callback richiede più informazioni rispetto a un singolo oggetto, una classe piccola può essere creata per contenere le altre informazioni sullo stato necessarie come membri.</span><span class="sxs-lookup"><span data-stu-id="384f5-3188">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="384f5-3189">Se si utilizza un protocollo orientato alla connessione, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3189">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="384f5-3190">In caso contrario <xref:System.Net.Sockets.Socket.SendToAsync%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3190">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-3191">Quando si utilizza un protocollo orientato alla connessione, il <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodo ignorerà il <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà e invierà i dati per il <xref:System.Net.EndPoint?displayProperty=nameWithType> stabilite nel <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3191">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-3192">Se si utilizza un protocollo senza connessione, non necessaria stabilire un host remoto predefinito con il <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3192">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="384f5-3193">È sufficiente eseguire questa operazione se si intende chiamare il <xref:System.Net.Sockets.Socket.BeginSend%2A> o <xref:System.Net.Sockets.Socket.SendAsync%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="384f5-3193">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="384f5-3194">Se si chiama il <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> metodo prima di chiamare <xref:System.Net.Sockets.Socket.SendToAsync%2A>la <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> proprietà sostituiranno l'host remoto predefinito specificato per tale operazione solo di invio.</span><span class="sxs-lookup"><span data-stu-id="384f5-3194">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="384f5-3195">Inoltre non è necessario chiamare il <xref:System.Net.Sockets.Socket.Bind%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3195">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="384f5-3196">In questo caso, il provider del servizio sottostante assegnerà il numero più appropriato di porta e indirizzo IP rete locale.</span><span class="sxs-lookup"><span data-stu-id="384f5-3196">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="384f5-3197">Se si desidera che il provider del servizio sottostante per selezionare una porta disponibile, utilizzare un numero di porta pari a zero.</span><span class="sxs-lookup"><span data-stu-id="384f5-3197">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="384f5-3198">Se è necessario identificare il numero di porta e indirizzo IP assegnato rete locale, è possibile usare il <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> proprietà dopo il <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento viene segnalato e vengono chiamati i delegati associati.</span><span class="sxs-lookup"><span data-stu-id="384f5-3198">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="384f5-3199">Se si desidera inviare dati a un indirizzo di broadcast, è necessario chiamare prima il <xref:System.Net.Sockets.Socket.SetSocketOption%2A> metodo e impostare l'opzione socket per <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> su true.</span><span class="sxs-lookup"><span data-stu-id="384f5-3199">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="384f5-3200">È inoltre necessario assicurarsi che le dimensioni del buffer non superino le dimensioni massime del provider del servizio sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-3200">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="384f5-3201">In caso affermativo, non verrà inviato il datagramma e <xref:System.Net.Sockets.Socket.SendToAsync%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3201">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="384f5-3202">Se si specifica il flag DontRoute nel <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> proprietà, i dati inviati non verranno indirizzati.</span><span class="sxs-lookup"><span data-stu-id="384f5-3202">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="384f5-3203">Per i socket orientato ai messaggi, è necessario prestare attenzione non deve superare la dimensione massima del messaggio di trasporto sottostante.</span><span class="sxs-lookup"><span data-stu-id="384f5-3203">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="384f5-3204">Se le dimensioni del buffer superano le dimensioni massime del provider del servizio sottostante, non viene inviato il datagramma e <xref:System.Net.Sockets.Socket.SendToAsync%2A> genererà un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3204">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="384f5-3205">Il completamento di un <xref:System.Net.Sockets.Socket.SendToAsync%2A> metodo non indica che i dati siano stati recapitati correttamente.</span><span class="sxs-lookup"><span data-stu-id="384f5-3205">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-3206">L'oggetto <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> non può essere null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3206">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-3207">Era già in corso un'operazione di socket che utilizza l'oggetto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> specificato nel parametro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3207">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-3208">Per questo metodo è necessario Windows XP o versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3208">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3209">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3209">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3210">Il protocollo specificato è orientato alla connessione, ma l'oggetto <see cref="T:System.Net.Sockets.Socket" /> non è ancora connesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3210">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">
          <span data-ttu-id="384f5-3211">Livello di protezione IP da impostare in questo socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3211">The IP protection level to set on this socket.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3212">Imposta il livello di protezione IP in un socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3212">Set the IP protection level on a socket.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3213">Il <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> metodo consente di limitare un un socket IPv6 o indirizzo IP per l'ascolto su un ambito specifico, ad esempio gli indirizzi con lo stesso sito prefisso locale o al collegano.</span><span class="sxs-lookup"><span data-stu-id="384f5-3213">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="384f5-3214">Questa opzione socket consente alle applicazioni di inserire restrizioni di accesso sui socket IPv6 o indirizzo IP.</span><span class="sxs-lookup"><span data-stu-id="384f5-3214">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="384f5-3215">Tali restrizioni consentono a un'applicazione in esecuzione su una LAN privata di proteggersi in modo semplice e affidabile da attacchi esterni.</span><span class="sxs-lookup"><span data-stu-id="384f5-3215">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="384f5-3216">Questa opzione socket consente inoltre di rimuovere le restrizioni di accesso se il `level` parametro è impostato su <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3216">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="384f5-3217">Questa opzione socket allarga o restringe l'ambito di un socket in attesa, consentendo l'accesso illimitato di utenti pubblici e privati, laddove appropriato, o limitando l'accesso solo al medesimo sito, secondo le necessità.</span><span class="sxs-lookup"><span data-stu-id="384f5-3217">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="384f5-3218">Questa opzione socket ha definito i livelli di protezione specificati nell'enumerazione <xref:System.Net.Sockets.IPProtectionLevel>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3218">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="384f5-3219">Il <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> metodo viene utilizzato per attivare o disattivare l'attraversamento indirizzo di rete (NAT) per un <xref:System.Net.Sockets.Socket> istanza.</span><span class="sxs-lookup"><span data-stu-id="384f5-3219">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="384f5-3220">È possibile specificare l'attraversamento NAT con Teredo, 6to4 o un tunnel ISATAP.</span><span class="sxs-lookup"><span data-stu-id="384f5-3220">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="384f5-3221">Quando il `level` parametro è impostato su <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, o <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, si disabilita in modo esplicito l'attraversamento NAT per un <xref:System.Net.Sockets.Socket> istanza.</span><span class="sxs-lookup"><span data-stu-id="384f5-3221">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="384f5-3222">Quando il `level` parametro è impostato su <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, può consentire l'attraversamento NAT per un <xref:System.Net.Sockets.Socket> a seconda delle regole firewall attive sul sistema.</span><span class="sxs-lookup"><span data-stu-id="384f5-3222">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="384f5-3223">Il parametro <paramref name="level" /> non può essere <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3223">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span>
          </span>
          <span data-ttu-id="384f5-3224">Non è possibile impostare il livello di protezione IP su non specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3224">The IP protection level cannot be set to unspecified.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-3225">Il <see cref="T:System.Net.Sockets.AddressFamily" /> del socket deve essere <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3225">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-3226">Imposta un'opzione di <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3226">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="384f5-3227">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3227">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="384f5-3228">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3228">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="384f5-3229">Il valore dell'opzione, rappresentato come <see cref="T:System.Boolean" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3229">The value of the option, represented as a <see cref="T:System.Boolean" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3230">Imposta l'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata sul valore <see cref="T:System.Boolean" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3230">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3231"><xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3231"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-3232">Impostare `optionValue` al `true` per abilitare l'opzione, oppure su `false` per disabilitare l'opzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3232">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="384f5-3233"><xref:System.Net.Sockets.Socket> le opzioni vengono raggruppate per livello di supporto del protocollo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3233"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="384f5-3234">Di seguito sono elencate le varie <xref:System.Net.Sockets.Socket> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3234">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="384f5-3235">Queste opzioni vengono raggruppate in appropriata <xref:System.Net.Sockets.SocketOptionLevel> valore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3235">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="384f5-3236">Se si prevede di impostare una di queste opzioni, assicurarsi di utilizzare l'appropriato <xref:System.Net.Sockets.SocketOptionLevel> valore per il `optionLevel` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-3236">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="384f5-3237">L'opzione si sceglie di impostare deve essere specificata nel `optionName` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-3237">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="384f5-3238">Se si desidera ottenere il valore corrente di una delle opzioni elencate, usare il <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3238">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-3239"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3239"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="384f5-3240"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3240"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="384f5-3241"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3241"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="384f5-3242"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3242"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="384f5-3243">Per ulteriori informazioni su queste opzioni, vedere il <xref:System.Net.Sockets.SocketOptionName> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3243">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3244">Se si riceve un <xref:System.Net.Sockets.SocketException> eccezione, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3244">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3245">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3245">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3246">Esempio di codice seguente consente di aprire un socket e abilita il `DontLinger` e il `OutOfBandInline` opzioni del socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-3246">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3247">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3247">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3248">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3248">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="384f5-3249">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3249">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="384f5-3250">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3250">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="384f5-3251">Matrice di tipo <see cref="T:System.Byte" /> che rappresenta il valore dell'opzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3251">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3252">Imposta l'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata sul valore specificato, rappresentato come una matrice di byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3252">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3253"><xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3253"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-3254">Utilizzare questo overload di impostare tali <xref:System.Net.Sockets.Socket> opzioni che richiedono una matrice di byte come valore di opzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3254">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3255">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3255">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3256">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3256">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3257">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-3257">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-3258">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-3258">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3259">Il codice seguente viene impostata la <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> i valori di timeout.</span><span class="sxs-lookup"><span data-stu-id="384f5-3259">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3260">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3260">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3261">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3261">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="384f5-3262">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3262">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="384f5-3263">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3263">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="384f5-3264">Valore dell'opzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3264">A value of the option.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3265">Imposta l'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata sull'intero specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3265">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3266"><xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3266"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-3267">Per un'opzione con un <xref:System.Boolean> del tipo di dati, specificare un valore diverso da zero per abilitare l'opzione e un valore zero per disabilitare l'opzione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3267">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="384f5-3268">Per un'opzione con un tipo di dati integer, specificare il valore appropriato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3268">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="384f5-3269"><xref:System.Net.Sockets.Socket> le opzioni vengono raggruppate per livello di supporto del protocollo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3269"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="384f5-3270">Di seguito sono elencate le varie <xref:System.Net.Sockets.Socket> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3270">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="384f5-3271">Queste opzioni vengono raggruppate in appropriata <xref:System.Net.Sockets.SocketOptionLevel>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3271">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="384f5-3272">Se si prevede di impostare una di queste opzioni, assicurarsi di utilizzare l'appropriato <xref:System.Net.Sockets.SocketOptionLevel> per il `optionLevel` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-3272">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="384f5-3273">L'opzione si sceglie di impostare deve essere specificata nel `optionName` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-3273">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="384f5-3274">Se si desidera ottenere il valore corrente di una delle opzioni elencate, usare il <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3274">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="384f5-3275"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3275"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="384f5-3276"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3276"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="384f5-3277"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3277"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="384f5-3278"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3278"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="384f5-3279"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> opzioni che possono essere impostate usando questo overload.</span><span class="sxs-lookup"><span data-stu-id="384f5-3279"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="384f5-3280">Per ulteriori informazioni su queste opzioni, vedere il <xref:System.Net.Sockets.SocketOptionName> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="384f5-3280">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3281">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3281">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3282">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3282">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3283">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-3283">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-3284">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-3284">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3285">Il codice seguente viene impostata la <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> i valori di timeout.</span><span class="sxs-lookup"><span data-stu-id="384f5-3285">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3286">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3286">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3287">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3287">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="384f5-3288">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3288">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="384f5-3289">Uno dei valori di <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3289">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="384f5-3290">
            <see cref="T:System.Net.Sockets.LingerOption" /> o <see cref="T:System.Net.Sockets.MulticastOption" /> contenente il valore dell'opzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3290">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3291">Imposta l'opzione <see cref="T:System.Net.Sockets.Socket" /> specificata sul valore specificato, rappresentato come un oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3291">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3292"><xref:System.Net.Sockets.Socket> opzioni determinano il comportamento dell'oggetto corrente <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3292"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-3293">Utilizzare questo overload per impostare il <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, e <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opzioni.</span><span class="sxs-lookup"><span data-stu-id="384f5-3293">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="384f5-3294">Per il <xref:System.Net.Sockets.SocketOptionName.Linger> opzione, usare <xref:System.Net.Sockets.Socket> per il `optionLevel` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-3294">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="384f5-3295">Per <xref:System.Net.Sockets.SocketOptionName.AddMembership> e <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilizzare <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3295">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="384f5-3296">Se si desidera ottenere il valore corrente di una delle opzioni elencate in precedenza, utilizzare il <xref:System.Net.Sockets.Socket.GetSocketOption%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3296">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3297">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3297">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3298">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3298">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3299">Il codice seguente viene impostata la <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valori di timeout.</span><span class="sxs-lookup"><span data-stu-id="384f5-3299">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="384f5-3300">
            <paramref name="optionValue" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3300">
              <paramref name="optionValue" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3301">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3301">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3302">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3302">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">
          <span data-ttu-id="384f5-3303">Uno dei valori <see cref="T:System.Net.Sockets.SocketShutdown" /> che specifica che l'operazione non sarà più consentita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3303">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="384f5-3304">Disabilita le operazioni di invio e di ricezione su un <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3304">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3305">Quando si utilizza un orientato alla connessione <xref:System.Net.Sockets.Socket>, chiamare sempre il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo prima di chiudere il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3305">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-3306">Ciò garantisce che tutti i dati inviati e ricevuti su socket connesso prima che venga chiuso.</span><span class="sxs-lookup"><span data-stu-id="384f5-3306">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="384f5-3307">Chiamare il <xref:System.Net.Sockets.Socket.Close%2A> metodo per liberare tutte le risorse gestite e associate i <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3307">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="384f5-3308">Non tentare di riutilizzare il <xref:System.Net.Sockets.Socket> dopo la chiusura.</span><span class="sxs-lookup"><span data-stu-id="384f5-3308">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="384f5-3309">La tabella seguente illustra la <xref:System.Net.Sockets.SocketShutdown> i valori di enumerazione validi per il `how` parametro.</span><span class="sxs-lookup"><span data-stu-id="384f5-3309">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="384f5-3310">Valore</span><span class="sxs-lookup"><span data-stu-id="384f5-3310">Value</span></span>|<span data-ttu-id="384f5-3311">Descrizione</span><span class="sxs-lookup"><span data-stu-id="384f5-3311">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="384f5-3312">Invia</span><span class="sxs-lookup"><span data-stu-id="384f5-3312">Send</span></span>|<span data-ttu-id="384f5-3313">Disabilita l'invio sul <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3313">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="384f5-3314">Receive</span><span class="sxs-lookup"><span data-stu-id="384f5-3314">Receive</span></span>|<span data-ttu-id="384f5-3315">Disabilitare la ricezione sul <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3315">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="384f5-3316">Entrambi</span><span class="sxs-lookup"><span data-stu-id="384f5-3316">Both</span></span>|<span data-ttu-id="384f5-3317">Disabilitare l'invio e ricezione su questo <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3317">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="384f5-3318">L'impostazione `how` al <xref:System.Net.Sockets.SocketShutdown.Send> specifica che le successive chiamate a <xref:System.Net.Sockets.Socket.Send%2A> non sono consentiti.</span><span class="sxs-lookup"><span data-stu-id="384f5-3318">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="384f5-3319">Se si utilizza un oggetto senza connessione <xref:System.Net.Sockets.Socket>, specificando <xref:System.Net.Sockets.SocketShutdown.Send> non avrà alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="384f5-3319">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="384f5-3320">L'impostazione `how` al <xref:System.Net.Sockets.SocketShutdown.Receive> specifica che le successive chiamate a <xref:System.Net.Sockets.Socket.Receive%2A> non sono consentiti.</span><span class="sxs-lookup"><span data-stu-id="384f5-3320">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="384f5-3321">Non produce alcun effetto su livelli inferiori di protocollo.</span><span class="sxs-lookup"><span data-stu-id="384f5-3321">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="384f5-3322">Se si utilizza un protocollo orientato alla connessione, la connessione viene terminata se si verifica una delle condizioni seguenti dopo una chiamata a <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span><span class="sxs-lookup"><span data-stu-id="384f5-3322">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="384f5-3323">Dati sono nel buffer di rete in ingresso in attesa di essere ricevuti.</span><span class="sxs-lookup"><span data-stu-id="384f5-3323">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="384f5-3324">È arrivata la maggiore quantità di dati.</span><span class="sxs-lookup"><span data-stu-id="384f5-3324">More data has arrived.</span></span>  
  
 <span data-ttu-id="384f5-3325">Se si utilizza un protocollo senza connessione, i datagrammi sono accettati e in coda.</span><span class="sxs-lookup"><span data-stu-id="384f5-3325">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="384f5-3326">Tuttavia, se spazio di buffer non è disponibile per i datagrammi in ingresso aggiuntivi, verranno ignorate e non verrà restituito alcun errore al mittente.</span><span class="sxs-lookup"><span data-stu-id="384f5-3326">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="384f5-3327">Utilizzo <xref:System.Net.Sockets.Socket.Shutdown%2A> su un oggetto senza connessione <xref:System.Net.Sockets.Socket> non è consigliata.</span><span class="sxs-lookup"><span data-stu-id="384f5-3327">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="384f5-3328">L'impostazione `how` a <xref:System.Net.Sockets.SocketShutdown.Both> Disabilita entrambi Invia e riceve come descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="384f5-3328">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3329">Se si riceve un <xref:System.Net.Sockets.SocketException> quando si chiama il <xref:System.Net.Sockets.Socket.Shutdown%2A> metodo, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3329">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3330">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3330">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="384f5-3331">Questo membro genera informazioni di traccia quando viene abilitata la funzionalità di traccia di rete nell'applicazione in uso.</span><span class="sxs-lookup"><span data-stu-id="384f5-3331">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="384f5-3332">Per altre informazioni, vedere [la traccia di rete in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="384f5-3332">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3333">Nell'esempio di codice viene illustrato come utilizzare <xref:System.Net.Sockets.Socket.Shutdown%2A> per disabilitare il <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3333">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3334">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3334">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3335">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3335">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-3336">Ottiene il tipo di <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3336">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-3337">Uno dei valori di <see cref="T:System.Net.Sockets.SocketType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3337">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3338"><xref:System.Net.Sockets.Socket.SocketType%2A> è di sola lettura e viene impostata quando il <xref:System.Net.Sockets.Socket> viene creato.</span><span class="sxs-lookup"><span data-stu-id="384f5-3338"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3339">Consente di visualizzare esempio di codice seguente il <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> nella console.</span><span class="sxs-lookup"><span data-stu-id="384f5-3339">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-3340">Ottiene un valore che indica se è disponibile il supporto per IPv4 e se IPv4 è abilitato sull'host corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3340">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-3341">
            <see langword="true" /> se l'host corrente supporta il protocollo IPv4; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3341">
              <see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3342">Il sistema operativo supporti i protocolli IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="384f5-3342">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-3343">Ottiene un valore che indica se Framework supporta IPv6 per determinati membri <see cref="T:System.Net.Dns" /> obsoleti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3343">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-3344">
            <see langword="true" /> se Framework supporta IPv6 per determinati metodi <see cref="T:System.Net.Dns" /> obsoleti; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3344">
              <see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3345">Il sistema operativo supporti i protocolli IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="384f5-3345">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-3346">Ottiene o imposta un valore che specifica la durata (TTL) dei pacchetti IP inviati dal <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3346">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-3347">La durata (TTL).</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3347">The TTL value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3348">Il valore di durata (TTL) indica il numero massimo di router il pacchetto può attraversare prima che il router Elimina il pacchetto e un messaggio di protocollo ICMP (Internet Control) "TTL superato" viene restituito al mittente del messaggio di errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3348">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="384f5-3349">Il valore di durata (TTL) può essere impostato su un valore compreso tra 0 e 255.</span><span class="sxs-lookup"><span data-stu-id="384f5-3349">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="384f5-3350">Quando questa proprietà non è impostata, il valore di durata (TTL) predefinita per un socket è 32.</span><span class="sxs-lookup"><span data-stu-id="384f5-3350">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="384f5-3351">Impostazione di questa proprietà su un socket di protocollo TCP (Transmission Control) viene ignorato da parte dello stack TCP/IP se è stata stabilita una connessione utilizzando il socket.</span><span class="sxs-lookup"><span data-stu-id="384f5-3351">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="384f5-3352">Se si riceve un <xref:System.Net.Sockets.SocketException>, utilizzare il <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> proprietà per ottenere il codice di errore specifico.</span><span class="sxs-lookup"><span data-stu-id="384f5-3352">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="384f5-3353">Dopo aver ottenuto il codice, fare riferimento alla versione Windows Sockets API errore codice documentazione 2 in MSDN library per una descrizione dettagliata dell'errore.</span><span class="sxs-lookup"><span data-stu-id="384f5-3353">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="384f5-3354">Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Net.Sockets.Socket.Ttl%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="384f5-3354">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="384f5-3355">Non è possibile impostare il valore TTL su un numero negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3355">The TTL value can't be set to a negative number.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="384f5-3356">È possibile impostare questa proprietà solo per i socket inclusi nella famiglia <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3356">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="384f5-3357">Si è verificato un errore durante il tentativo di accesso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3357">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="384f5-3358">Questo errore viene restituito anche quando si tenta di impostare TTL su un valore superiore a 255.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3358">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="384f5-3359">L'oggetto <see cref="T:System.Net.Sockets.Socket" /> è stato chiuso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3359">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="384f5-3360">Specifica se il socket deve utilizzare solo la modalità operazioni di I/O sovrapposte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3360">Specifies whether the socket should only use Overlapped I/O mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="384f5-3361">
            <see langword="true" /> se il <see cref="T:System.Net.Sockets.Socket" /> utilizza solo operazioni di I/O sovrapposte; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3361">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="384f5-3362">Il valore predefinito è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3362">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="384f5-3363">Impostare questa proprietà su `true` per un <xref:System.Net.Sockets.Socket> si intende chiamare <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3363">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="384f5-3364">In caso contrario, il Framework può assegnare una porta di completamento per il socket, consentendo l'utilizzo di <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="384f5-3364">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="384f5-3365">Il socket è stato associato a una porta di completamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="384f5-3365">The socket has been bound to a completion port.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>