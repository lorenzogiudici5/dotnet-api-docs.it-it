<Type Name="Encoder" FullName="System.Text.Encoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="935e8a3f446a4bf08e1efb7afb01e36886d1cd6f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530825" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoder abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Converte un set di caratteri in una sequenza di byte.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere un'istanza di un'implementazione del <xref:System.Text.Encoder> (classe), l'applicazione deve utilizzare il <xref:System.Text.Encoding.GetEncoder%2A> metodo di un <xref:System.Text.Encoding> implementazione.  
  
 Il <xref:System.Text.Encoder.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e <xref:System.Text.Encoder.GetBytes%2A> metodo esegue l'effettiva codifica. Sono disponibili in diverse versioni di entrambi i metodi di <xref:System.Text.Encoder> classe. Per ulteriori informazioni, vedere <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>.  
  
 Oggetto <xref:System.Text.Encoder> oggetto mantiene informazioni sullo stato tra le chiamate successive a `GetBytes` o <xref:System.Text.Decoder.Convert%2A> metodi in modo che non può codificare correttamente le sequenze che includono i blocchi di caratteri. Il <xref:System.Text.Encoder> anche mantiene finali caratteri alla fine di blocchi di dati e i caratteri finali nella successiva operazione di codifica. Ad esempio, un blocco di dati potrebbe terminare con un surrogato alto senza corrispondenza e il surrogato basso corrispondente potrebbe essere in blocco di dati successivo. Pertanto, <xref:System.Text.Encoding.GetDecoder%2A> e <xref:System.Text.Encoding.GetEncoder%2A> sono utili per la trasmissione di rete e le operazioni di file, perché queste operazioni utilizzano spesso blocchi di dati anziché un flusso di dati completo.  
  
> [!NOTE]
>  Quando l'applicazione viene eseguita con un flusso di dati, deve verificare che le informazioni sullo stato vengano eliminate impostando il `flush` parametro `true` nella chiamata al metodo appropriato. Se si verifica un'eccezione o se l'applicazione passa flussi, questo deve chiamare <xref:System.Text.Encoder.Reset%2A> per cancellare lo stato interno del `Encoder` oggetto.  
  
## <a name="version-considerations"></a>Considerazioni sulla versione  
 Oggetto <xref:System.Text.Decoder> o <xref:System.Text.Encoder> durante un'operazione di conversione, è possibile serializzare l'oggetto. Lo stato dell'oggetto è mantenuto se viene deserializzata la stessa versione di .NET Framework, ma se che viene deserializzato in un'altra versione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come convertire una matrice di caratteri Unicode in blocchi di byte usando una codifica specificata. Per il confronto, la matrice di caratteri viene dapprima codificata utilizzando <xref:System.Text.UTF7Encoding>. Successivamente, la matrice di caratteri viene codificata utilizzando un <xref:System.Text.Encoder>.  
  
 [!code-cpp[System.Text.Encoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.Encoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.Encoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder Example/VB/snippet.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Quando l'applicazione eredita da questa classe, è necessario eseguire l'override di tutti i membri.</para>
    </block>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoding" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.Encoder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere un'istanza di un'implementazione di questa classe, l'applicazione deve utilizzare il <xref:System.Text.Encoding.GetEncoder%2A> metodo di un <xref:System.Text.Encoding> implementazione.  
  
   
  
## Examples  
 L'esempio seguente illustra due tecniche per l'inizializzazione di un nuovo <xref:System.Text.Encoder> istanza.  
  
 [!code-cpp[System.Text.Encoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Encoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Encoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte un buffer o una matrice di caratteri Unicode in una sequenza di byte codificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte), flush As Boolean, ByRef charsUsed As Integer, ByRef bytesUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(char* chars, int charCount, System::Byte* bytes, int byteCount, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">Indirizzo di una stringa di caratteri con codifica UTF-16 da convertire.</param>
        <param name="charCount">Numero di caratteri in <c>chars</c> da convertire.</param>
        <param name="bytes">Indirizzo di un buffer in cui archiviare i byte convertiti.</param>
        <param name="byteCount">Numero massimo di byte in <c>bytes</c> da usare durante la conversione.</param>
        <param name="flush">
          <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
        <param name="charsUsed">Quando termina, questo metodo contiene il numero di caratteri di <c>chars</c> che sono stati usati durante la conversione. Questo parametro viene passato non inizializzato.</param>
        <param name="bytesUsed">Quando termina, questo metodo contiene il numero di byte che sono stati usati durante la conversione. Questo parametro viene passato non inizializzato.</param>
        <param name="completed">Quando termina, questo metodo contiene <see langword="true" /> se tutti i caratteri specificati da <c>charCount</c> sono stati convertiti. In caso contrario, <see langword="false" />. Questo parametro viene passato non inizializzato.</param>
        <summary>Converte una matrice di caratteri Unicode in una sequenza di byte codificata e archivia il risultato in un altro buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenere presente che il <xref:System.Text.Encoder> oggetto Salva lo stato tra le chiamate a <xref:System.Text.Encoder.Convert%2A>. Quando l'applicazione viene eseguita con un flusso di dati, è necessario impostare il `flush` parametro `true` per assicurarsi che vengano eliminate le informazioni sullo stato. Con questa impostazione, il codificatore ignora i byte non validi alla fine del blocco di dati e cancella il buffer interno. I dati trasformati restanti che fa parte di un'unità logica, ad esempio il surrogato alto di una coppia di surrogati, viene convertiti in base alle impostazioni di fallback correnti.  
  
 Il `Convert` metodo è progettato per essere usato in un ciclo per codificare una quantità arbitraria di input, ad esempio i dati letti da un file o flusso. Archivia l'output dell'operazione di codifica in un buffer a dimensione fissa. <xref:System.Text.Encoder.GetBytes%2A> verrà generata un'eccezione se il buffer di output non è abbastanza grande, ma <xref:System.Text.Encoder.Convert%2A> riempire una quantità di spazio possibile e verranno restituiti i caratteri letti e scritti. Vedere anche il <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> argomento per ulteriori commenti.  
  
 Il `completed` parametro di output indica se tutti i dati nel buffer di input è stato convertito e memorizzato nel buffer di output. Questo parametro è impostato su `false` se il numero di caratteri specificato da di `charCount` parametro non può essere convertito senza superare il numero di byte specificato da di `byteCount` parametro. In tal caso, l'applicazione deve utilizzare il contenuto del buffer di output o fornire un nuovo buffer di output, incremento di `chars` parametro per il numero di caratteri specificato dal `charsUsed` parametro, quindi chiamare il `Convert` nuovamente (metodo) per elaborare l'input rimanente.  
  
 Il `completed` parametro può essere impostato anche `false`, anche se il `charsUsed` e `charCount` parametri sono uguali. Questa situazione si verifica se sono ancora presenti dati nel <xref:System.Text.Encoder> oggetto che non sono stato archiviato nel `chars` buffer.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> o <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il buffer di output è troppo piccolo per contenere l'input convertito. La dimensione del buffer di output deve essere maggiore o uguale al valore indicato dal metodo <see cref="Overload:System.Text.Encoder.GetByteCount" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoder.Fallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer, byteCount As Integer, flush As Boolean, ByRef charsUsed As Integer, ByRef bytesUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri da convertire.</param>
        <param name="charIndex">Primo elemento di <c>chars</c> da convertire.</param>
        <param name="charCount">Numero di elementi di <c>chars</c> da convertire.</param>
        <param name="bytes">Matrice in cui sono archiviati i byte convertiti.</param>
        <param name="byteIndex">Primo elemento di <c>bytes</c> in cui i dati vengono archiviati.</param>
        <param name="byteCount">Numero massimo di elementi di <c>bytes</c> da usare nella conversione.</param>
        <param name="flush">
          <see langword="true" /> per indicare che non esistono altri dati da convertire; in caso contrario <see langword="false" />.</param>
        <param name="charsUsed">Quando termina, questo metodo contiene il numero di caratteri di <c>chars</c> che sono stati usati durante la conversione. Questo parametro viene passato non inizializzato.</param>
        <param name="bytesUsed">Quando termina, questo metodo contiene il numero di byte prodotti dalla conversione. Questo parametro viene passato non inizializzato.</param>
        <param name="completed">Quando termina, questo metodo contiene <see langword="true" /> se tutti i caratteri specificati da <c>charCount</c> sono stati convertiti. In caso contrario, <see langword="false" />. Questo parametro viene passato non inizializzato.</param>
        <summary>Converte una matrice di caratteri Unicode in una sequenza di byte codificata e archivia il risultato in una matrice di byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenere presente che il <xref:System.Text.Encoder> oggetto Salva lo stato tra le chiamate a <xref:System.Text.Encoder.Convert%2A>. Quando l'applicazione viene eseguita con un flusso di dati, è necessario impostare il `flush` parametro `true` per assicurarsi che vengano eliminate le informazioni sullo stato. Con questa impostazione, il codificatore ignora i byte non validi alla fine del blocco di dati e cancella il buffer interno. I dati trasformati restanti che fa parte di un'unità logica, ad esempio il surrogato alto di una coppia di surrogati, viene convertiti in base alle impostazioni di fallback correnti.  
  
 Il `Convert` metodo è progettato per essere usato in un ciclo per decodificare una quantità arbitraria di input, ad esempio i dati letti da un file o flusso. Archivia l'output dell'operazione di codifica in un buffer a dimensione fissa. <xref:System.Text.Encoder.GetBytes%2A> verrà generata un'eccezione se il buffer di output non è abbastanza grande, ma <xref:System.Text.Encoder.Convert%2A> riempire una quantità di spazio possibile e verranno restituiti i caratteri letti e scritti. Vedere anche il <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> argomento per ulteriori commenti.  
  
 Il `completed` parametro di output indica se tutti i dati nel buffer di input è stato convertito e memorizzato nel buffer di output. Questo parametro è impostato su `false` se il numero di caratteri specificato da di `charCount` parametro non può essere convertito senza superare il numero di byte specificato da di `byteCount` parametro. In tal caso, l'applicazione deve utilizzare il contenuto del buffer di output o fornire un nuovo buffer di output, incremento di `chars` parametro per il numero di caratteri specificato dal `charsUsed` parametro, quindi chiamare il `Convert` nuovamente (metodo) per elaborare l'input rimanente.  
  
 Il `completed` parametro può essere impostato anche `false`, anche se il `charsUsed` e `charCount` parametri sono uguali. Questa situazione si verifica se sono ancora presenti dati nel <xref:System.Text.Encoder> oggetto che non sono stato archiviato nel `chars` buffer.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.Encoder.Convert%2A> metodo per convertire un file di UTF-16 caratteri UTF-8, quindi utilizza il <xref:System.Text.Decoder.Convert%2A> metodo per convertire nuovamente i caratteri UTF-8, UTF-16 caratteri.  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> o <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" />, <paramref name="byteIndex" /> o <paramref name="byteCount" /> è minore di zero.  
  
 oppure  
  
 La lunghezza di <paramref name="chars" /> - <paramref name="charIndex" /> è minore di <paramref name="charCount" />.  
  
 oppure  
  
 La lunghezza di <paramref name="bytes" /> - <paramref name="byteIndex" /> è minore di <paramref name="byteCount" />.</exception>
        <exception cref="T:System.ArgumentException">Il buffer di output è troppo piccolo per contenere l'input convertito. La dimensione del buffer di output deve essere maggiore o uguale al valore indicato dal metodo <see cref="Overload:System.Text.Encoder.GetByteCount" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoder.Fallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ Fallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto <see cref="T:System.Text.EncoderFallback" /> per l'oggetto <see cref="T:System.Text.Encoder" /> corrente.</summary>
        <value>Un oggetto <see cref="T:System.Text.EncoderFallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.EncoderFallback> oggetto rappresenta un gestore degli errori che viene richiamato quando un carattere non può essere convertito in una sequenza di byte codificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore in un'operazione set è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentException">Non è possibile assegnare un nuovo valore in un'operazione di impostazione, poiché l'oggetto <see cref="T:System.Text.EncoderFallbackBuffer" /> corrente contiene dati non ancora codificati.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoder.Fallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As EncoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallbackBuffer ^ FallbackBuffer { System::Text::EncoderFallbackBuffer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Text.EncoderFallbackBuffer" /> associato all'oggetto <see cref="T:System.Text.Encoder" /> corrente.</summary>
        <value>Un oggetto <see cref="T:System.Text.EncoderFallbackBuffer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoder.FallbackBuffer%2A> oggetto rappresenta i dati utilizzati per il <xref:System.Text.EncoderFallback> oggetto. Il <xref:System.Text.EncoderFallback> oggetto rappresenta un gestore degli errori che viene richiamato quando un carattere non può essere convertito in una sequenza di byte codificata.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di byte prodotti dalla codifica di un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.ReadOnlySpan{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <param name="flush">
          <see langword="true" /> per simulare la cancellazione dello stato interno del decodificatore dopo il calcolo; in caso contrario, <see langword="false" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di byte prodotti dalla codifica di un set di caratteri a partire dal puntatore ai caratteri specificato. Un parametro indica se lo stato interno del codificatore deve essere cancellato dopo il calcolo.</summary>
        <returns>Numero di byte ottenuto dalla codifica dei caratteri specificati e di qualsiasi carattere nel buffer interno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non influenzano lo stato del codificatore.  
  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.Encoder.GetBytes%2A> richiede per archiviare i byte risultanti, l'applicazione deve utilizzare <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Se `GetBytes` viene chiamato con `flush` impostato su `false`, il codificatore archivia i caratteri finali alla fine del blocco di dati in un buffer interno e li utilizza nella successiva operazione di codifica. L'applicazione deve chiamare `GetByteCount` su un blocco di dati immediatamente prima di chiamare `GetBytes` sullo stesso blocco, in modo che i caratteri finali del blocco precedente sono inclusi nel calcolo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" /> (<see langword="Nothing" /> in Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoder.Fallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="index">Indice del primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <param name="flush">
          <see langword="true" /> per simulare la cancellazione dello stato interno del decodificatore dopo il calcolo; in caso contrario, <see langword="false" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di byte prodotti dalla codifica di un set di caratteri dalla matrice di caratteri specificata. Un parametro indica se lo stato interno del codificatore deve essere cancellato dopo il calcolo.</summary>
        <returns>Numero di byte ottenuto dalla codifica dei caratteri specificati e di qualsiasi carattere nel buffer interno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non influenzano lo stato del codificatore.  
  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.Encoder.GetBytes%2A> richiede per archiviare i byte risultanti, l'applicazione deve utilizzare <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Se `GetBytes` viene chiamato con `flush` impostato su `false`, il codificatore archivia i caratteri finali alla fine del blocco di dati in un buffer interno e li utilizza nella successiva operazione di codifica. L'applicazione deve chiamare `GetByteCount` su un blocco di dati immediatamente prima di chiamare `GetBytes` sullo stesso blocco, in modo che i caratteri finali del blocco precedente sono inclusi nel calcolo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Text.Encoder.GetByteCount%2A> per restituire il numero di byte necessari per codificare una matrice di caratteri Unicode utilizzando <xref:System.Text.Encoder>.  
  
 [!code-cpp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoder.Fallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, codifica un set di caratteri in una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Puntatore alla posizione in cui iniziare a scrivere la sequenza di byte risultante.</param>
        <param name="byteCount">Numero massimo di byte da scrivere.</param>
        <param name="flush">
          <see langword="true" /> per cancellare lo stato interno del codificatore dopo la conversione; in caso contrario, <see langword="false" />.</param>
        <summary>Quando sottoposto a override in una classe derivata, codifica un set di caratteri partendo dal puntatore ai caratteri specificato e tutti i caratteri presenti nel buffer interno in una sequenza di byte che vengono archiviati a partire dal puntatore ai byte specificato. Un parametro indica se lo stato interno del codificatore deve essere cancellato dopo la conversione.</summary>
        <returns>Numero effettivo di byte scritti nella posizione indicata dal parametro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenere presente che il <xref:System.Text.Encoder> oggetto Salva lo stato tra le chiamate a <xref:System.Text.Encoder.GetBytes%2A>. Quando l'applicazione viene eseguita con un flusso di dati, è necessario impostare il `flush` parametro `true` nell'ultima chiamata a `GetBytes` per assicurarsi che le informazioni sullo stato vengano eliminate e che i byte codificati vengano terminati correttamente. Con questa impostazione, il codificatore ignora i byte non validi alla fine del blocco di dati, ad esempio surrogati non corrispondenti o le sequenze di combinazione incomplete e cancella il buffer interno.  
  
 Per calcolare le dimensioni buffer esatto che `GetBytes` richiede per archiviare i caratteri risultanti, l'applicazione deve utilizzare <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Se `GetBytes` viene chiamato con `flush` impostato su `false`, il codificatore archivia i byte finali alla fine del blocco di dati in un buffer interno e li utilizza nella successiva operazione di codifica. L'applicazione deve chiamare `GetByteCount` su un blocco di dati immediatamente prima di chiamare `GetBytes` sullo stesso blocco, in modo che i caratteri finali del blocco precedente sono inclusi nel calcolo.  
  
 Se l'applicazione consiste nel convertire diversi segmenti di un flusso di input, è consigliabile utilizzare il <xref:System.Text.Encoder.Convert%2A> metodo. <xref:System.Text.Encoder.GetBytes%2A> verrà generata un'eccezione se il buffer di output non è abbastanza grande, ma <xref:System.Text.Encoder.Convert%2A> riempire una quantità di spazio possibile e verranno restituiti i caratteri letti e scritti. Vedere anche il <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> argomento per ulteriori commenti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" /> (<see langword="Nothing" />).  
  
 oppure  
  
 <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> è minore del numero di byte risultante.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoder.Fallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <param name="flush">
          <see langword="true" /> per cancellare lo stato interno del codificatore dopo la conversione; in caso contrario, <see langword="false" />.</param>
        <summary>Quando sottoposto a override in una classe derivata, codifica un set di caratteri partendo dalla matrice di caratteri specificata e tutti i caratteri presenti nel buffer interno nella matrice di byte specificata. Un parametro indica se lo stato interno del codificatore deve essere cancellato dopo la conversione.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenere presente che il <xref:System.Text.Encoder> oggetto Salva lo stato tra le chiamate a <xref:System.Text.Encoder.GetBytes%2A>. Quando l'applicazione viene eseguita con un flusso di dati, è necessario impostare il `flush` parametro `true` nell'ultima chiamata a `GetBytes` per assicurarsi che le informazioni sullo stato vengano eliminate e che i byte codificati vengano terminati correttamente. Con questa impostazione, il codificatore ignora i byte non validi alla fine del blocco di dati, ad esempio surrogati non corrispondenti o le sequenze di combinazione incomplete e cancella il buffer interno.  
  
 Per calcolare le dimensioni buffer esatto che `GetBytes` richiede per archiviare i caratteri risultanti, l'applicazione deve utilizzare <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Se `GetBytes` viene chiamato con `flush` impostato su `false`, il codificatore archivia i byte finali alla fine del blocco di dati in un buffer interno e li utilizza nella successiva operazione di codifica. L'applicazione deve chiamare `GetByteCount` su un blocco di dati immediatamente prima di chiamare `GetBytes` sullo stesso blocco, in modo che i caratteri finali del blocco precedente sono inclusi nel calcolo.  
  
 Se l'applicazione consiste nel convertire diversi segmenti di un flusso di input, è consigliabile utilizzare il <xref:System.Text.Encoder.Convert%2A> metodo. <xref:System.Text.Encoder.GetBytes%2A> verrà generata un'eccezione se il buffer di output non è abbastanza grande, ma <xref:System.Text.Encoder.Convert%2A> riempire una quantità di spazio possibile e verranno restituiti i caratteri letti e scritti. Vedere anche il <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> argomento per ulteriori commenti.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come codificare un intervallo di elementi da una matrice di caratteri e archiviare i byte codificati in un intervallo di elementi in una matrice di byte. Il <xref:System.Text.Encoder.GetByteCount%2A> metodo viene utilizzato per determinare le dimensioni della matrice richieste da <xref:System.Text.Encoder.GetBytes%2A>.  
  
 [!code-cpp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" /> (<see langword="Nothing" />).  
  
 oppure  
  
 <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
 oppure  
  
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
 oppure  
  
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoder.Fallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, reimposta il codificatore allo stato iniziale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cancella lo stato interno del <xref:System.Text.Encoder> oggetto. Il metodo cancella le informazioni di state mantenute da una precedente chiamata a <xref:System.Text.Encoder.GetBytes%2A> o <xref:System.Text.Decoder.Convert%2A>, tra cui finali alla fine del blocco di dati precedente, ad esempio un surrogato alto senza corrispondenza.  
  
 L'applicazione deve chiamare il `Reset` metodo se desidera riutilizzare lo stesso codificatore anche dopo che viene generata un'eccezione da <xref:System.Text.Encoder.GetBytes%2A> o <xref:System.Text.Encoder.GetByteCount%2A>, o se l'applicazione passa flussi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>