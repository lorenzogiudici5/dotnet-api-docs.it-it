<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c200a67bc75e1bfe3c6bbe71ec68fec34b1455fc" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531445" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF8Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF8Encoding : System::Text::Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una codifica UTF-8 dei caratteri Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica è il processo di trasformazione di un insieme di caratteri Unicode in una sequenza di byte. La decodifica è il processo di trasformazione di una sequenza di byte codificati in un set di caratteri Unicode.  
  
 UTF-8 è una codifica che Unicode rappresenta ogni punto di codice come una sequenza di uno a quattro byte. A differenza delle codifiche UTF-16 e UTF-32, la codifica UTF-8 non richiede "ordine dei byte"; lo schema di codifica è lo stesso indipendentemente dal fatto che il processore è big-endian o little-endian. <xref:System.Text.UTF8Encoding> corrisponde alla tabella codici 65001 di Windows. Per ulteriori informazioni sui formati UTF e altre codifiche supportate da <xref:System.Text>, vedere [codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 È possibile creare un'istanza di un <xref:System.Text.UTF8Encoding> oggetto in diversi modi, a seconda se desidera per fornire un byte order mark (BOM) e se si desidera attivare il rilevamento errori. La tabella seguente elenca i costruttori e <xref:System.Text.Encoding> proprietà che restituiscono un <xref:System.Text.UTF8Encoding> oggetto.  
  
|Member|BOM|Rilevamento degli errori|  
|------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>|Yes|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=nameWithType>|No|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType>|Configurabile|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurabile|Configurabile|  
  
 Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo esegue l'effettiva codifica.  
  
 Analogamente, il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica di una sequenza di byte e <xref:System.Text.UTF8Encoding.GetChars%2A> e <xref:System.Text.UTF8Encoding.GetString%2A> i metodi eseguono la decodifica effettiva.  
  
 Per un codificatore o un decodificatore in grado di salvare le informazioni sullo stato durante la codifica o decodifica dei dati che si estende su più blocchi (ad esempio stringhe di caratteri pari a 1 milione è codificato nei segmenti di caratteri di 100.000), utilizzare il <xref:System.Text.UTF8Encoding.GetEncoder%2A> e <xref:System.Text.UTF8Encoding.GetDecoder%2A> , proprietà rispettivamente.  
  
 Facoltativamente, il <xref:System.Text.UTF8Encoding> oggetto fornisce un byte order mark (BOM), ovvero una matrice di byte che possono essere preceduti all'inizio del flusso di byte risultante dal processo di codifica. Se un flusso di byte codificati UTF-8 è preceduto da un byte order mark (BOM), consente il decodificatore di determinare l'ordine dei byte e il formato di trasformazione o UTF. Si noti, tuttavia, che lo Unicode Standard non richiede né consiglia un BOM UTF-8 con codifica flussi. Per ulteriori informazioni sull'ordine dei byte e il byte order mark, vedere lo Unicode Standard nella [home page di Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Se il codificatore è configurato per fornire un indicatore ordine byte, è possibile recuperare tramite una chiamata di <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo; in caso contrario, il metodo restituisce una matrice vuota. Si noti che, anche se un <xref:System.Text.UTF8Encoding> oggetto è configurato per supportare DBA, è necessario includere il BOM all'inizio del flusso di byte codificata come appropriato; i metodi di codifica di <xref:System.Text.UTF8Encoding> classe non eseguire questa operazione automaticamente.  
  
> [!NOTE]
>  Per attivare il rilevamento errori e rendere più sicura l'istanza della classe, è necessario chiamare il <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> costruttore e impostare il `throwOnInvalidBytes` parametro `true`. Con il rilevamento di errori abilitato, un metodo che rileva una sequenza di caratteri o byte non valida genera un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, viene generata alcuna eccezione e la sequenza non valida in genere viene ignorata.  
  
> [!NOTE]
>  Se l'oggetto viene serializzato e deserializzato con diverse versioni di .NET Framework, lo stato di un oggetto di codifica UTF-8 non viene mantenuto.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzato un <xref:System.Text.UTF8Encoding> codificare una stringa di caratteri Unicode e archiviarli in una matrice di byte dell'oggetto. La stringa Unicode include due caratteri, pi greco (U + 03A0) e Sigma (U + 03A3), che sono di fuori dell'intervallo di caratteri ASCII. Quando la matrice di byte codificata viene decodificata in una stringa, i caratteri di pi greco e Sigma sono ancora presenti.  
  
 [!code-cpp[System.Text.UTF8Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 L'esempio seguente usa la stessa stringa dell'esempio precedente, ad eccezione del fatto che scrive i byte codificati in un file e i prefissi il flusso di byte con un byte order mark (BOM). Quindi legge il file in due modi diversi: come file di testo usando un <xref:System.IO.StreamReader> ; dell'oggetto e come un file binario. Come prevedibile, in entrambi i casi è il BOM incluso nella stringa di appena lettura.  
  
 [!code-csharp[System.Text.UTF8Encoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF8Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF8Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un'istanza che non fornisce un byte order mark Unicode e non genera un'eccezione quando viene rilevata una codifica non valida.  
  
> [!NOTE]
>  Per motivi di sicurezza, è consigliabile abilitare il rilevamento errori chiamando un costruttore con un `throwOnInvalidBytes` parametro e impostandone il valore su `true`.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Text.UTF8Encoding> istanza e viene visualizzato il relativo nome.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> per specificare che il metodo <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> restituisce un byte order mark Unicode; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF8Encoding" />. Un parametro specifica se fornire un byte order mark Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un'istanza che non genera un'eccezione quando viene rilevata una codifica non valida.  
  
> [!NOTE]
>  Per motivi di sicurezza, è necessario attivare il rilevamento errori chiamando un costruttore che include un `throwOnInvalidBytes` parametro e impostandone il valore su `true`.  
  
 Il `encoderShouldEmitUTF8Identifier` parametro controlla il funzionamento del <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo. Se `true`, il metodo restituisce una matrice di byte contenente il byte order mark Unicode (BOM) in formato UTF-8.  Se `false`, viene restituita una matrice di byte di lunghezza zero. Tuttavia, l'impostazione `encoderShouldEmitUTF8Identifier` per `true` non causa il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo prefisso il BOM all'inizio della matrice di byte, né comporta il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo per includere il numero di byte nella DBA il numero di byte.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Text.UTF8Encoding> istanza e specifica che un byte order mark Unicode deve essere emessi dal <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo quindi restituisce il prefisso di byte order mark Unicode.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> per specificare che il metodo <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> deve restituire un byte order mark Unicode; in caso contrario, <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> per generare un'eccezione quando viene rilevata una codifica non valida; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF8Encoding" />. I parametri specificano se fornire un byte order mark Unicode e se generare un'eccezione quando viene rilevata una codifica non valida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `encoderShouldEmitUTF8Identifier` parametro controlla il funzionamento del <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo. Se `true`, il metodo restituisce una matrice di byte contenente il byte order mark Unicode (BOM) in formato UTF-8.  Se `false`, viene restituita una matrice di byte di lunghezza zero. Tuttavia, l'impostazione `encoderShouldEmitUTF8Identifier` per `true` non causa il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo prefisso il BOM all'inizio della matrice di byte, né comporta il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo per includere il numero di byte nella DBA il numero di byte.  
  
 Se `throwOnInvalidBytes` è `true`, un metodo che rileva una sequenza di byte non valido genera un <xref:System.ArgumentException?displayProperty=nameWithType> eccezione. In caso contrario, il metodo non genera un'eccezione e la sequenza non valida verrà ignorata.  
  
> [!NOTE]
>  Per motivi di sicurezza, è necessario attivare il rilevamento errori chiamando un costruttore che include un `throwOnInvalidBytes` parametro e impostandolo su `true`.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Text.UTF8Encoding> istanza, specificare che il <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo non deve generare un byte order mark Unicode e deve essere generata un'eccezione quando viene rilevata una codifica non valida. Il comportamento di questo costruttore viene confrontato con il valore predefinito <xref:System.Text.UTF8Encoding.%23ctor> costruttore, che non genera un'eccezione quando viene rilevata una codifica non valida. I due <xref:System.Text.UTF8Encoding> istanze codificare una matrice di caratteri che contiene due surrogati alti (U + D801 e U + D802) in una riga, che è una sequenza di caratteri non validi; un surrogato alto deve sempre essere seguito da un surrogato basso.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da confrontare con l'istanza corrente.</param>
        <summary>Determina se l'oggetto specificato è uguale all'oggetto <see cref="T:System.Text.UTF8Encoding" /> corrente.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> è un'istanza di <see cref="T:System.Text.UTF8Encoding" /> ed è uguale all'oggetto corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due <xref:System.Text.UTF8Encoding> oggetti sono considerati uguali se sono vere tutte le condizioni seguenti:  
  
-   Entrambi gli oggetti forniscono il byte order mark, o meno.  
  
-   Entrambi gli oggetti utilizzano lo stesso di fallback del codificatore.  
  
-   Entrambi gli oggetti utilizzano lo stesso di fallback del decodificatore.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.Equals%2A> metodo per verificare se corrente <xref:System.Text.UTF8Encoding> è uguale a un altro oggetto <xref:System.Text.UTF8Encoding> oggetto. Quattro <xref:System.Text.UTF8Encoding> gli oggetti vengono creati e confrontati e vengono visualizzati i risultati dei confronti.  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars">Oggetto <see cref="T:System.String" /> contenente il set di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica dei caratteri nell'oggetto <see cref="T:System.String" /> specificato.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Preambolo di inserimento all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non verrà riportato nel valore restituito dal <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> e <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> metodi per calcolare il numero massimo ed effettivo di byte necessari per codificare una stringa. Visualizza anche il numero effettivo di byte necessari per archiviare un flusso di byte con un byte order mark.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatti necessari per il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Preambolo di inserimento all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non verrà riportato nel valore restituito dal <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="index">Indice del primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri dalla matrice di caratteri specificata.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, chiamare l'oggetto utilizza <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Preambolo di inserimento all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non verrà riportato nel valore restituito dal <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene compilata una matrice con un alfabeto latino di maiuscole e minuscole e viene chiamato il <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo per determinare il numero di byte necessari per codificare i caratteri minuscoli latini. Visualizza quindi queste informazioni insieme al numero totale di byte necessari se viene aggiunto un byte order mark. Confronta con il valore restituito da questo numero di <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo, che indica il numero massimo di byte necessari per codificare i caratteri minuscoli latini.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 La proprietà <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostata su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica un set di caratteri in una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Puntatore alla posizione in cui iniziare a scrivere la sequenza di byte risultante.</param>
        <param name="byteCount">Numero massimo di byte da scrivere.</param>
        <summary>Codifica un set di caratteri a partire dal puntatore ai caratteri specificato in una sequenza di byte archiviati a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero effettivo di byte scritti nella posizione indicata da <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> restituito dal <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodo o <xref:System.Text.UTF8Encoding.GetEncoder%2A> (metodo), rispettivamente.  
  
 Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserire il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.  
  
 oppure  
  
 <paramref name="byteCount" /> è minore del numero di byte risultante.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Codifica un set di caratteri dalla matrice di caratteri specificata nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> fornito dal <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodo o <xref:System.Text.UTF8Encoding.GetEncoder%2A> (metodo), rispettivamente.  
  
 Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserire il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo per codificare un intervallo di caratteri da una stringa e archivia i byte codificati in un intervallo di elementi in una matrice di byte.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
 oppure  
  
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
 oppure  
  
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.  
  
 oppure  
  
 <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Oggetto <see cref="T:System.String" /> contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Codifica un set di caratteri dall'oggetto <see cref="T:System.String" /> specificato nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> fornito dal <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodo o <xref:System.Text.UTF8Encoding.GetEncoder%2A> (metodo), rispettivamente.  
  
 Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserire il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetBytes%2A> per codificare un intervallo di elementi da una matrice di caratteri Unicode e archiviare i byte codificati in un intervallo di elementi in una matrice di byte.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
 oppure  
  
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
 oppure  
  
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="s" /> contiene una sequenza di carattere non valida.  
  
 oppure  
  
 <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo. Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come valore integer.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte dalla matrice di byte specificata.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo. Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetCharCount%2A> per restituire il numero di caratteri prodotti dalla decodifica di un intervallo di elementi in una matrice di byte.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido in <paramref name="bytes" />.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come valore integer.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodifica una sequenza di byte in un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Puntatore alla posizione in cui iniziare a scrivere il set di caratteri risultante.</param>
        <param name="charCount">Numero massimo di caratteri da scrivere.</param>
        <summary>Decodifica una sequenza di byte a partire dal puntatore ai byte specificato in un set di caratteri archiviati a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero effettivo di caratteri scritti nella posizione indicata da <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo. Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include il byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non DBA, il carattere U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverlo chiamando il <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodo.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> oggetto fornito dal <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodo o <xref:System.Text.UTF8Encoding.GetEncoder%2A> (metodo), rispettivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> o <paramref name="charCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.  
  
 oppure  
  
 <paramref name="charCount" /> è minore del numero di caratteri risultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="byteIndex">Indice del primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Matrice di caratteri che deve contenere il set di caratteri risultante.</param>
        <param name="charIndex">Indice in corrispondenza del quale iniziare a scrivere il set di caratteri risultante.</param>
        <summary>Decodifica una sequenza di byte dalla matrice di byte specificata nella matrice di caratteri specificata.</summary>
        <returns>Numero effettivo di caratteri scritti in <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo. Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include il byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non DBA, il carattere U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverlo chiamando il <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodo.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> fornito dal <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodo o <xref:System.Text.UTF8Encoding.GetEncoder%2A> (metodo), rispettivamente.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetChars%2A> per decodificare un intervallo di elementi in una matrice di byte e archivia il risultato in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> o <paramref name="byteCount" /> o <paramref name="charIndex" /> è minore di zero.  
  
 oppure  
  
 <paramref name="byteindex" /> e <paramref name="byteCount" /> non identificano un intervallo valido in <paramref name="bytes" />.  
  
 oppure  
  
 <paramref name="charIndex" /> non è un indice valido in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.  
  
 oppure  
  
 <paramref name="chars" /> non dispone di sufficiente capacità da <paramref name="charIndex" /> alla fine della matrice per contenere i caratteri risultanti.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un decodificatore che converte una sequenza di byte con codifica UTF-8 in una sequenza di caratteri Unicode.</summary>
        <returns>Decodificatore che converte una sequenza di byte con codifica UTF-8 in una sequenza di caratteri Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo converte blocchi sequenziali di byte in blocchi sequenziali di caratteri, in modo simile al <xref:System.Text.UTF8Encoding.GetChars%2A> metodo di questa classe. Tuttavia, un <xref:System.Text.Decoder> mantiene informazioni sullo stato tra le chiamate in modo da poter decodificare correttamente le sequenze di byte che includono i blocchi. Il <xref:System.Text.Decoder> anche mantiene i byte finali alla fine di blocchi di dati e i byte finali nella successiva operazione di decodifica. Pertanto, <xref:System.Text.UTF8Encoding.GetDecoder%2A> e <xref:System.Text.UTF8Encoding.GetEncoder%2A> sono utili per la trasmissione di rete e le operazioni di file, perché queste operazioni utilizzano spesso blocchi di dati anziché un flusso di dati completo.  
  
 Se è attivato, ovvero il `throwOnInvalidCharacters` parametro del costruttore è impostato su `true`, il rilevamento errori è abilitato anche nel <xref:System.Text.Decoder> restituito da questo metodo. Se è abilitato il rilevamento errori e viene rilevata una sequenza non valida, lo stato del decodificatore non è definito e l'elaborazione deve essere interrotta.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetDecoder%2A> per ottenere un decodificatore UTF-8. Il decodificatore converte una sequenza di byte in una sequenza di caratteri.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un codificatore che converte una sequenza di caratteri Unicode in una sequenza di byte con codifica UTF-8.</summary>
        <returns>Oggetto <see cref="T:System.Text.Encoder" /> che converte una sequenza di caratteri Unicode in una sequenza di byte con codifica UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodo converte blocchi sequenziali di caratteri in blocchi sequenziali di byte, una procedura simile a quella di <xref:System.Text.UTF8Encoding.GetBytes%2A> (metodo). Tuttavia, un <xref:System.Text.Encoder> mantiene informazioni sullo stato tra le chiamate in modo può codificare correttamente le sequenze di caratteri che includono i blocchi. Il <xref:System.Text.Encoder> anche mantiene finali caratteri alla fine di blocchi di dati e i caratteri finali nella successiva operazione di codifica. Ad esempio, un blocco di dati potrebbe terminare con un surrogato alto senza corrispondenza e il surrogato basso corrispondente potrebbe essere in blocco di dati successivo. Pertanto, <xref:System.Text.UTF8Encoding.GetDecoder%2A> e <xref:System.Text.UTF8Encoding.GetEncoder%2A> sono utili per la trasmissione di rete e le operazioni di file, perché queste operazioni utilizzano spesso blocchi di dati anziché un flusso di dati completo.  
  
 Se è attivato, ovvero il `throwOnInvalidCharacters` parametro del costruttore è impostato su `true`, il rilevamento errori è abilitato anche nel <xref:System.Text.Encoder> restituito da questo metodo. Se è abilitato il rilevamento errori e viene rilevata una sequenza non valida, lo stato del codificatore non è definito e l'elaborazione deve essere interrotta.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetEncoder%2A> sequenza di byte codificati per ottenere un codificatore per convertire una sequenza di caratteri in un UTF-8.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza corrente.</summary>
        <returns>Codice hash per l'istanza corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetHashCode%2A> per restituire un codice hash per <xref:System.Text.UTF8Encoding> istanze. Si noti che il codice hash restituito da questo metodo dipende dal costruttore utilizzato per creare il <xref:System.Text.UTF8Encoding> oggetto.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</summary>
        <returns>Numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> è un numero caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.EncoderFallback>. Se si sceglie un fallback con una stringa potenzialmente grande, <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> può restituire valori di grandi dimensioni.  
  
 Nella maggior parte dei casi, questo metodo restituisce numeri opportuni per stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grandi e rilevamento di errori nel raro caso che un buffer più ragionevole è stato superato. È inoltre possibile utilizzare un approccio diverso <xref:System.Text.UTF8Encoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>. Ad esempio, testo in inglese e molti altri linguaggi è spesso necessario un solo byte UTF-8 per rappresentare un carattere, ma il numero restituito da <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> deve consentire la possibilità che la stringa da convertire sarà costituito interamente caratteri che ogni richiede quattro byte.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> non ha alcuna relazione di <xref:System.Text.UTF8Encoding.GetChars%2A>. Se l'applicazione necessita di una funzione simile da utilizzare con <xref:System.Text.UTF8Encoding.GetChars%2A>, è necessario utilizzare <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` non è necessariamente lo stesso valore di `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> per restituire il numero massimo di byte necessari per codificare un numero specificato di caratteri.  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> è minore di zero.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <summary>Calcola il numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</summary>
        <returns>Numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo. Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> è un numero caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.DecoderFallback>. Se si sceglie un fallback con una stringa potenzialmente grande, <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> può restituire valori di grandi dimensioni.  
  
 Nella maggior parte dei casi, questo metodo restituisce numeri opportuni per stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grandi e rilevamento di errori nel raro caso che un buffer più ragionevole è stato superato.  È inoltre possibile utilizzare un approccio diverso <xref:System.Text.UTF8Encoding.GetCharCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> non ha alcuna relazione di <xref:System.Text.UTF8Encoding.GetBytes%2A>. Se l'applicazione necessita di una funzione simile da utilizzare con <xref:System.Text.UTF8Encoding.GetBytes%2A>, è necessario utilizzare <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` non è necessariamente lo stesso valore di `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> per restituire il numero massimo di caratteri prodotti dalla decodifica di un numero specificato di byte.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> è minore di zero.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un byte order mark Unicode codificato in formato UTF-8, se l'oggetto di codifica <see cref="T:System.Text.UTF8Encoding" /> è configurato per fornirne uno.</summary>
        <returns>Matrice di byte contenente il byte order mark Unicode, se l'oggetto di codifica <see cref="T:System.Text.UTF8Encoding" /> è configurato per fornirne uno. In caso contrario, questo metodo restituisce una matrice di byte di lunghezza zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.UTF8Encoding> oggetto può fornire un preambolo, ovvero una matrice di byte che possono essere preceduti della sequenza di byte che risultano dal processo di codifica. Prima di una sequenza di byte codificati con un byte order mark (U + FEFF punto di codice) consente il decodificatore di determinare l'ordine dei byte e il formato di trasformazione o UTF. Il byte order mark (BOM) Unicode viene serializzato come 0xEF 0xBB 0xBF. Si noti che lo Unicode Standard non richiede né si consiglia di utilizzare un BOM UTF-8 codificati flussi.  
  
 È possibile creare un'istanza di un <xref:System.Text.UTF8Encoding> i cui <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo restituisce un valido indicatore ordine byte nei modi seguenti:  
  
-   Recuperando il <xref:System.Text.UTF8Encoding> oggetto restituito dal <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> proprietà.  
  
-   Chiamando un <xref:System.Text.UTF8Encoding> costruttore con un `encoderShouldEmitUTF8Identifier` parametro e impostandone il valore impostato su `true`.  
  
 Tutti gli altri <xref:System.Text.UTF8Encoding> oggetti configurati per restituire una matrice vuota anziché un BOM valido.  
  
 Il BOM forniscono quasi determinati identificazione di una codifica per i file che non hanno più un riferimento per la codifica, ad esempio web senza tag o o di dati o file di testo casuale archiviati quando una società non conteneva interessi internazionali. Spesso i problemi dell'utente potrebbero essere evitati se i dati vengono contrassegnati in modo coerente e configurata correttamente.  
  
 Per gli standard che forniscono un tipo di codifica, un BOM risulta piuttosto ridondante. Tuttavia, può essere utilizzato per consentire a un server di inviare l'intestazione di codifica corretta. In alternativa, può essere utilizzato come fallback nel caso in cui la codifica in caso contrario viene persa.  
  
 Esistono alcuni svantaggi dell'utilizzo di una distinta base. Ad esempio, può essere difficile sapere come limitare i campi del database che utilizzano una distinta base. La concatenazione di file può rappresentare un problema, inoltre, ad esempio, quando i file vengono uniti in tale modo un carattere non necessario può finire al centro dati. Nonostante alcuni svantaggi, tuttavia, l'utilizzo di un indicatore ordine byte è consigliabile.  
  
 Per ulteriori informazioni sull'ordine dei byte e il byte order mark, vedere lo Unicode Standard nella [home page di Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile far precedere l'inizio di un flusso di byte codificati con un preambolo. Si noti che il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo non anteporre una distinta base in una sequenza di byte codificati; fornendo un BOM all'inizio di un flusso di byte appropriato è responsabilità dello sviluppatore.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetPreamble%2A> per restituire il byte Unicode order mark codificato in formato UTF-8. Si noti che il costruttore predefinito per <xref:System.Text.UTF8Encoding> non fornisce un preambolo.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Nell'esempio seguente viene creata un'istanza di due <xref:System.Text.UTF8Encoding> oggetti, il primo chiamando il metodo senza parametri <xref:System.Text.UTF8Encoding.%23ctor> costruttore, che non fornisce un indicatore ordine byte, mentre la seconda chiamando il <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29> costruttore con il relativo `encoderShouldEmitUTF8Identifier` argomento impostato su `true`. Chiama quindi il <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo per scrivere il BOM in un file prima di scrivere una stringa codificata in formato UF8. Come mostra l'output dell'esempio della console, il file che salva i byte dal codificatore secondo contiene tre byte più rispetto alla prima.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 È inoltre possibile confrontare i file utilizzando il `fc` comando in una finestra della console, oppure è possibile esaminare i file in un editor di testo che include una modalità di visualizzazione esadecimale. Si noti che quando il file viene aperto in un editor che supporta UTF-8, il BOM non è visualizzato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Decodifica un intervallo di byte da una matrice di byte in una stringa.</summary>
        <returns>Oggetto <see cref="T:System.String" /> contenente i risultati di decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include il byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non DBA, il carattere U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverlo chiamando il <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodo.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> fornito dal <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodo o <xref:System.Text.UTF8Encoding.GetEncoder%2A> (metodo), rispettivamente.  
  
   
  
## Examples  
 Nell'esempio seguente consente di inizializzare una matrice tramite la chiamata di <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo per determinare esattamente il numero di byte è necessario per una stringa codificata e quindi aggiungere le dimensioni del byte order mark (BOM). Nell'esempio viene quindi chiamato il <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo per archiviare il BOM nella matrice prima di chiamare il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo per archiviare i byte nella matrice codificati. Nell'esempio viene quindi chiamato il <xref:System.Text.UTF8Encoding.GetString%2A> metodo per decodificare la stringa.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Si noti che in questo caso la stringa decodificata è diverso dalla stringa originale, poiché inizia con un contrassegno di ordine di byte a 16 bit U + FFFD. Ciò significa che le due stringhe confronterà contenendo e che, se la stringa di output, il DBA verrà visualizzata come il carattere di sostituzione "?". Per rimuovere il BOM all'inizio della stringa, è possibile chiamare il <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>