<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b2021c365658f4fc13606536efd544aeca18e189" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51917997" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF8Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF8Encoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF8Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una codifica UTF-8 dei caratteri Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica è il processo di trasformazione di un insieme di caratteri Unicode in una sequenza di byte. La decodifica è il processo di trasformazione di una sequenza di byte codificati in un set di caratteri Unicode.  
  
 UTF-8 è Unicode la codifica che rappresenta ogni punto di codice come una sequenza di uno a quattro byte. A differenza delle codifiche UTF-16 e UTF-32, la codifica UTF-8 non richiede "architettura endian"; lo schema di codifica è lo stesso indipendentemente dal fatto che il processore è big-endian o little-endian. <xref:System.Text.UTF8Encoding> corrisponde alla tabella codici 65001 Windows. Per altre informazioni sui formati UTF e altre codifiche supportati da <xref:System.Text>, vedere [codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 È possibile creare un'istanza di un <xref:System.Text.UTF8Encoding> oggetti in diversi modi, a seconda del fatto che si desidera per fornire un byte order mark (BOM) e se si desidera abilitare il rilevamento errori. La tabella seguente elenca i costruttori e il <xref:System.Text.Encoding> proprietà che restituiscono un <xref:System.Text.UTF8Encoding> oggetto.  
  
|Member|INDICATORE ORDINE BYTE|Rilevamento degli errori|  
|------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>|Yes|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=nameWithType>|No|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType>|Configurabile|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurabile|Configurabile|  
  
 Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo esegue l'effettiva codifica.  
  
 Allo stesso modo, il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica una sequenza di byte e il <xref:System.Text.UTF8Encoding.GetChars%2A> e <xref:System.Text.UTF8Encoding.GetString%2A> metodi eseguono la decodifica effettivo.  
  
 Per un codificatore o un decodificatore che è in grado di salvare le informazioni sullo stato codifica o decodifica i dati che si estende su più blocchi (ad esempio string di 1 milione di caratteri che vengono codificati in caratteri 100.000 segmenti), usare il <xref:System.Text.UTF8Encoding.GetEncoder%2A> e <xref:System.Text.UTF8Encoding.GetDecoder%2A> proprietà, rispettivamente.  
  
 Facoltativamente, il <xref:System.Text.UTF8Encoding> oggetto fornisce un byte order mark (BOM), ovvero una matrice di byte che possono essere preceduti all'inizio del flusso di byte che risulta dal processo di codifica. Se un flusso di byte codificati UTF-8 è preceduto da un byte order mark (BOM), consente il decodificatore di determinare l'ordine dei byte e il formato di trasformazione o UTF. Si noti tuttavia che lo Unicode Standard non richiede né consiglia un BOM UTF-8 con codifica flussi. Per altre informazioni sull'ordine dei byte e il byte order mark, vedere lo Unicode Standard nella [home page di Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Se il codificatore è configurato per fornire un indicatore ordine byte, è possibile recuperarlo tramite la chiamata di <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo; in caso contrario, il metodo restituisce una matrice vuota. Si noti che, anche se un <xref:System.Text.UTF8Encoding> oggetto è configurato per il supporto della distinta base, è necessario includere il carattere BOM all'inizio del flusso di byte codificato come appropriato; i metodi di codifica del <xref:System.Text.UTF8Encoding> classe non eseguire questa operazione automaticamente.  
  
> [!NOTE]
>  Per abilitare il rilevamento di errore e rendere più sicuro l'istanza della classe, è necessario chiamare il <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> costruttore e impostare il `throwOnInvalidBytes` parametro per `true`. Con il rilevamento di errori abilitato, un metodo che rileva una sequenza di caratteri o byte non valida genera un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, viene generata alcuna eccezione e la sequenza non valida in genere viene ignorata.  
  
> [!NOTE]
>  Lo stato di un oggetto con codificata UTF-8 non viene mantenuto se l'oggetto viene serializzato e deserializzato con diverse versioni di .NET Framework.  
  
   
  
## Examples  
 L'esempio seguente usa un <xref:System.Text.UTF8Encoding> oggetto da codificare una stringa di caratteri Unicode e averle archiviate in una matrice di byte. La stringa Unicode include due caratteri, Pi (U + 03A0) e Sigma (U + 03A3), che si trovano all'esterno dell'intervallo di caratteri ASCII. Quando viene decodificata la matrice di byte codificata in una stringa, i dispositivo Pi e Sigma caratteri sono ancora presenti.  
  
 [!code-cpp[System.Text.UTF8Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 L'esempio seguente usa la stessa stringa come nell'esempio precedente, ad eccezione del fatto che scrive i byte con codificati in un file e i prefissi il flusso di byte con un byte order mark (BOM). Quindi legge il file in due modi diversi: come file di testo tramite un <xref:System.IO.StreamReader> ; dell'oggetto e come un file binario. Come si può immaginare, nessuna delle due stringhe appena lettura include il carattere BOM.  
  
 [!code-csharp[System.Text.UTF8Encoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informazioni sulle codifiche</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF8Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF8Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un'istanza che non è incluso un byte order mark Unicode e non viene generata un'eccezione quando viene rilevata una codifica non è valido.  
  
> [!NOTE]
>  Per motivi di sicurezza, è consigliabile abilitare il rilevamento errori chiamando un costruttore con un `throwOnInvalidBytes` parametro e impostandone il valore su `true`.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Text.UTF8Encoding> dell'istanza e visualizza il relativo nome.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding encoderShouldEmitUTF8Identifier" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> per specificare che il metodo <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> restituisce un byte order mark Unicode; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF8Encoding" />. Un parametro specifica se fornire un byte order mark Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un'istanza che non genera un'eccezione quando viene rilevata una codifica non è valido.  
  
> [!NOTE]
>  Per motivi di sicurezza, è consigliabile abilitare il rilevamento errori chiamando un costruttore che include un' `throwOnInvalidBytes` parametro e impostandone il valore su `true`.  
  
 Il `encoderShouldEmitUTF8Identifier` parametro controlla il funzionamento del <xref:System.Text.UTF8Encoding.GetPreamble%2A> (metodo). Se `true`, il metodo restituisce una matrice di byte contenente il byte order mark Unicode (BOM) in formato UTF-8.  Se `false`, restituisce una matrice di byte di lunghezza zero. Tuttavia, l'impostazione `encoderShouldEmitUTF8Identifier` per `true` non causa il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo come prefisso il BOM all'inizio della matrice di byte, per né comporta il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo per includere il numero di byte nella DBA il numero di byte.  
  
   
  
## Examples  
 L'esempio seguente crea una nuova <xref:System.Text.UTF8Encoding> dell'istanza e specifica che un byte order mark Unicode debba essere state emesse dal <xref:System.Text.UTF8Encoding.GetPreamble%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo quindi restituisce il prefisso di byte order mark Unicode.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool * bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding (encoderShouldEmitUTF8Identifier, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> per specificare che il metodo <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> deve restituire un byte order mark Unicode; in caso contrario, <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> per generare un'eccezione quando viene rilevata una codifica non valida; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF8Encoding" />. I parametri specificano se fornire un byte order mark Unicode e se generare un'eccezione quando viene rilevata una codifica non valida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `encoderShouldEmitUTF8Identifier` parametro controlla il funzionamento del <xref:System.Text.UTF8Encoding.GetPreamble%2A> (metodo). Se `true`, il metodo restituisce una matrice di byte contenente il byte order mark Unicode (BOM) in formato UTF-8.  Se `false`, restituisce una matrice di byte di lunghezza zero. Tuttavia, l'impostazione `encoderShouldEmitUTF8Identifier` per `true` non causa il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo come prefisso il BOM all'inizio della matrice di byte, per né comporta il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo per includere il numero di byte nella DBA il numero di byte.  
  
 Se `throwOnInvalidBytes` viene `true`, un metodo che rileva una sequenza di byte non valido genera un <xref:System.ArgumentException?displayProperty=nameWithType> eccezione. In caso contrario, il metodo non genera un'eccezione e la sequenza non valida verrà ignorata.  
  
> [!NOTE]
>  Per motivi di sicurezza, è consigliabile abilitare il rilevamento errori chiamando un costruttore che include un' `throwOnInvalidBytes` parametro e si imposta tale parametro su `true`.  
  
   
  
## Examples  
 L'esempio seguente crea una nuova <xref:System.Text.UTF8Encoding> istanza, specificare che il <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo non deve creare un byte order mark Unicode e deve essere generata un'eccezione quando viene rilevata una codifica non è valido. Il comportamento di questo costruttore viene confrontato con il valore predefinito <xref:System.Text.UTF8Encoding.%23ctor> costruttore, che non genera un'eccezione quando viene rilevata una codifica non è valido. I due <xref:System.Text.UTF8Encoding> istanze codificare una matrice di caratteri che contiene due surrogati alti (U + D801 e U + D802) in una riga, ovvero una sequenza di caratteri non validi, un surrogato alto deve sempre essere seguito da un surrogato basso.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF8Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da confrontare con l'istanza corrente.</param>
        <summary>Determina se l'oggetto specificato è uguale all'oggetto <see cref="T:System.Text.UTF8Encoding" /> corrente.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> è un'istanza di <see cref="T:System.Text.UTF8Encoding" /> ed è uguale all'oggetto corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due <xref:System.Text.UTF8Encoding> gli oggetti sono considerati uguali se vengono soddisfatte tutte le condizioni seguenti:  
  
-   Entrambi gli oggetti forniscono il byte order mark, o entrambi non lo sono.  
  
-   Entrambi gli oggetti utilizzano lo stesso di fallback del codificatore.  
  
-   Entrambi gli oggetti utilizzano lo stesso di fallback del decodificatore.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.Equals%2A> metodo per testare se corrente <xref:System.Text.UTF8Encoding> è uguale a un altro oggetto <xref:System.Text.UTF8Encoding> oggetto. Quattro <xref:System.Text.UTF8Encoding> gli oggetti vengono creati e confrontati e vengono visualizzati i risultati dei confronti.  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF8Encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars">Oggetto <see cref="T:System.String" /> contenente il set di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica dei caratteri nell'oggetto <see cref="T:System.String" /> specificato.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserendo il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non viene riflessa nel valore restituito dal <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> e <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> metodi per la quale calcolare il numero massimo e quello effettivo di byte necessari per codificare una stringa. Visualizza anche il numero effettivo di byte necessari per archiviare un flusso di byte con un byte order mark.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatti necessari per il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserendo il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non viene riflessa nel valore restituito dal <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="index">Indice del primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri dalla matrice di caratteri specificata.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama l'oggetto utilizza <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserendo il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non viene riflessa nel valore restituito dal <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente popola una matrice con un alfabeto latino maiuscolo e minuscoli e chiama il <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo per determinare il numero di byte necessari per codificare i caratteri minuscoli latini. Quindi visualizza tale informazione insieme il numero totale di byte necessari se viene aggiunto un byte order mark. Confronta con il valore restituito da questo numero di <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo, che indica il numero massimo di byte necessari per codificare i caratteri minuscoli latini.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
La proprietà <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostata su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica un set di caratteri in una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="uTF8Encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Puntatore alla posizione in cui iniziare a scrivere la sequenza di byte risultante.</param>
        <param name="byteCount">Numero massimo di byte da scrivere.</param>
        <summary>Codifica un set di caratteri a partire dal puntatore ai caratteri specificato in una sequenza di byte archiviati a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero effettivo di byte scritti nella posizione indicata da <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, usare il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> restituito dal <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodo o il <xref:System.Text.UTF8Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
 Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserimento di preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.  
  
oppure 
 <paramref name="byteCount" /> è minore del numero di byte risultante.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Codifica un set di caratteri dalla matrice di caratteri specificata nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, usare il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF8Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF8Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
 Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserimento di preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo per codificare un intervallo di caratteri da una stringa e gli archivi di byte codificati in un intervallo di elementi in una matrice di byte.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
oppure 
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
oppure 
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.  
  
oppure 
 <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Oggetto <see cref="T:System.String" /> contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Codifica un set di caratteri dall'oggetto <see cref="T:System.String" /> specificato nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, usare il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF8Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF8Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
 Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserimento di preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo a codificare un intervallo di elementi da una matrice di caratteri Unicode e archiviare i byte con codificati in un intervallo di elementi in una matrice di byte.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
oppure 
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
oppure 
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="s" /> contiene una sequenza di carattere non valida.  
  
oppure 
 <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF8Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come valore integer.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte dalla matrice di byte specificata.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF8Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo per restituire il numero di caratteri prodotti dalla decodifica di un intervallo di elementi in una matrice di byte.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido in <paramref name="bytes" />.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come valore integer.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodifica una sequenza di byte in un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Puntatore alla posizione in cui iniziare a scrivere il set di caratteri risultante.</param>
        <param name="charCount">Numero massimo di caratteri da scrivere.</param>
        <summary>Decodifica una sequenza di byte a partire dal puntatore ai byte specificato in un set di caratteri archiviati a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero effettivo di caratteri scritti nella posizione indicata da <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF8Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include i byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non-BOM, il carattere di U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverla tramite la chiamata di <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (metodo).  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, usare il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> oggetto fornito dalla <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodo o il <xref:System.Text.UTF8Encoding.GetEncoder%2A> (metodo), rispettivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.  
  
oppure 
 <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> o <paramref name="charCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.  
  
oppure 
 <paramref name="charCount" /> è minore del numero di caratteri risultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="byteIndex">Indice del primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Matrice di caratteri che deve contenere il set di caratteri risultante.</param>
        <param name="charIndex">Indice in corrispondenza del quale iniziare a scrivere il set di caratteri risultante.</param>
        <summary>Decodifica una sequenza di byte dalla matrice di byte specificata nella matrice di caratteri specificata.</summary>
        <returns>Numero effettivo di caratteri scritti in <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF8Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include i byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non-BOM, il carattere di U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverla tramite la chiamata di <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (metodo).  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, usare il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF8Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF8Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetChars%2A> metodo da decodificare un intervallo di elementi in una matrice di byte e archiviare il risultato in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.  
  
oppure 
 <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> o <paramref name="byteCount" /> o <paramref name="charIndex" /> è minore di zero.  
  
oppure 
 <paramref name="byteindex" /> e <paramref name="byteCount" /> non identificano un intervallo valido in <paramref name="bytes" />.  
  
oppure 
 <paramref name="charIndex" /> non è un indice valido in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.  
  
oppure 
 <paramref name="chars" /> non dispone di sufficiente capacità da <paramref name="charIndex" /> alla fine della matrice per contenere i caratteri risultanti.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF8Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un decodificatore che converte una sequenza di byte con codifica UTF-8 in una sequenza di caratteri Unicode.</summary>
        <returns>Decodificatore che converte una sequenza di byte con codifica UTF-8 in una sequenza di caratteri Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo converte sequenziali blocchi di byte in blocchi sequenziali di caratteri, in modo simile al <xref:System.Text.UTF8Encoding.GetChars%2A> overload di questa classe. Tuttavia, un <xref:System.Text.Decoder> mantiene informazioni sullo stato tra chiamate, in modo da poter decodificare correttamente le sequenze di byte che si estendono su blocchi. Il <xref:System.Text.Decoder> anche mantiene byte finali alla fine di blocchi di dati e Usa i byte finali nella successiva operazione di decodifica. Pertanto <xref:System.Text.UTF8Encoding.GetDecoder%2A> e <xref:System.Text.UTF8Encoding.GetEncoder%2A> sono utili per la trasmissione di rete e operazioni di file, perché queste operazioni utilizzano spesso i blocchi di dati anziché un flusso di dati completo.  
  
 Se il rilevamento errori è abilitato, vale a dire il `throwOnInvalidCharacters` parametro del costruttore è impostato su `true`, il rilevamento errori è abilitato anche nel <xref:System.Text.Decoder> restituito da questo metodo. Se è abilitato il rilevamento di errore e viene rilevata una sequenza non valida, lo stato del decodificatore non è definito e deve arrestare l'elaborazione.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodo per ottenere un decodificatore UTF-8. Il decodificatore converte una sequenza di byte in una sequenza di caratteri.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informazioni sulle codifiche</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF8Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un codificatore che converte una sequenza di caratteri Unicode in una sequenza di byte con codifica UTF-8.</summary>
        <returns>Oggetto <see cref="T:System.Text.Encoder" /> che converte una sequenza di caratteri Unicode in una sequenza di byte con codifica UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodo converte blocchi sequenziali di caratteri in blocchi sequenziali di byte, in modo simile al <xref:System.Text.UTF8Encoding.GetBytes%2A> (metodo). Tuttavia, un <xref:System.Text.Encoder> mantiene informazioni sullo stato tra chiamate in modo che può codificare correttamente le sequenze di caratteri che si estendono su blocchi. Il <xref:System.Text.Encoder> anche mantiene finali caratteri alla fine di blocchi di dati e i caratteri finali nella successiva operazione di codifica. Ad esempio, un blocco di dati può terminare con un carattere surrogato alto non corrispondente e potrebbe essere il surrogato basso corrispondente nel blocco di dati successivo. Pertanto <xref:System.Text.UTF8Encoding.GetDecoder%2A> e <xref:System.Text.UTF8Encoding.GetEncoder%2A> sono utili per la trasmissione di rete e operazioni di file, perché queste operazioni utilizzano spesso i blocchi di dati anziché un flusso di dati completo.  
  
 Se il rilevamento errori è abilitato, vale a dire il `throwOnInvalidCharacters` parametro del costruttore è impostato su `true`, il rilevamento errori è abilitato anche nel <xref:System.Text.Encoder> restituito da questo metodo. Se è abilitato il rilevamento di errore e viene rilevata una sequenza non valida, lo stato del codificatore della tabella è definito e deve arrestare l'elaborazione.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetEncoder%2A> sequenza di byte codificati per ottenere un codificatore per convertire una sequenza di caratteri in un UTF-8.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informazioni sulle codifiche</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF8Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza corrente.</summary>
        <returns>Codice hash per l'istanza corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetHashCode%2A> per restituire un codice hash per <xref:System.Text.UTF8Encoding> istanze. Si noti che il codice hash restituito dal metodo dipende dal costruttore utilizzato per creare il <xref:System.Text.UTF8Encoding> oggetto.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF8Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</summary>
        <returns>Numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> è un numero riflette il caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.EncoderFallback>. Se si sceglie un fallback con una stringa di grandi dimensioni, <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> può restituire valori di grandi dimensioni.  
  
 Nella maggior parte dei casi, questo metodo restituisce i numeri di ragionevoli per stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grande e individuare gli errori nel raro caso che un buffer più ragionevole è stato superato. È anche possibile provare a usare un approccio diverso <xref:System.Text.UTF8Encoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>. Ad esempio, testo in lingua inglese e molti altri linguaggi è spesso necessario un solo byte UTF-8 per rappresentare un carattere, ma il numero restituito da <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> deve consentire la possibilità che la stringa da convertire includerà interamente di caratteri che ogni richiede quattro byte.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> non ha alcuna relazione di <xref:System.Text.UTF8Encoding.GetChars%2A>. Se l'applicazione necessita di una funzione simile da utilizzare con <xref:System.Text.UTF8Encoding.GetChars%2A>, è necessario utilizzare <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` non è necessariamente lo stesso valore `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> per restituire il numero massimo di byte necessari per codificare un numero specificato di caratteri.  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> è minore di zero.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF8Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <summary>Calcola il numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</summary>
        <returns>Numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF8Encoding.GetChars%2A> per archiviare i caratteri risultanti, si chiama il <xref:System.Text.UTF8Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> è un numero riflette il caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.DecoderFallback>. Se si sceglie un fallback con una stringa di grandi dimensioni, <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> può restituire valori di grandi dimensioni.  
  
 Nella maggior parte dei casi, questo metodo restituisce i numeri di ragionevoli per stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grande e individuare gli errori nel raro caso che un buffer più ragionevole è stato superato.  È anche possibile provare a usare un approccio diverso <xref:System.Text.UTF8Encoding.GetCharCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> non ha alcuna relazione di <xref:System.Text.UTF8Encoding.GetBytes%2A>. Se l'applicazione necessita di una funzione simile da utilizzare con <xref:System.Text.UTF8Encoding.GetBytes%2A>, è necessario utilizzare <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` non è necessariamente lo stesso valore `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> per restituire il numero massimo di caratteri prodotti dalla decodifica di un numero specificato di byte.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> è minore di zero.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF8Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un byte order mark Unicode codificato in formato UTF-8, se l'oggetto di codifica <see cref="T:System.Text.UTF8Encoding" /> è configurato per fornirne uno.</summary>
        <returns>Matrice di byte contenente il byte order mark Unicode, se l'oggetto di codifica <see cref="T:System.Text.UTF8Encoding" /> è configurato per fornirne uno. In caso contrario, questo metodo restituisce una matrice di byte di lunghezza zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.UTF8Encoding> oggetto può fornire un preambolo, ovvero una matrice di byte che può essere anteposto alla sequenza di byte che risultano dal processo di codifica. Prima di una sequenza di byte codificati con un byte order mark (punto di codice U + FEFF) consente il decodificatore di determinare l'ordine dei byte e il formato di trasformazione o UTF. Il byte order mark Unicode (BOM) viene serializzato come 0xEF 0xBB 0xBF. Si noti che lo Unicode Standard non richiede né consiglia l'uso di un carattere BOM di UTF-8 con codifica flussi.  
  
 È possibile creare un'istanza di un <xref:System.Text.UTF8Encoding> il cui <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo restituisce un valido indicatore ordine byte nei modi seguenti:  
  
-   Recuperando il <xref:System.Text.UTF8Encoding> oggetto restituito dal <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> proprietà.  
  
-   Chiamando un <xref:System.Text.UTF8Encoding> costruttore con un `encoderShouldEmitUTF8Identifier` parametro e impostandone il valore impostato su `true`.  
  
 Tutti gli altri <xref:System.Text.UTF8Encoding> oggetti configurati per restituire una matrice vuota anziché un carattere BOM valido.  
  
 Il carattere BOM forniscono quasi determinati identificazione di una codifica per i file che hanno perso in caso contrario, un riferimento a loro codifica, ad esempio web non siano contrassegnate né in modo corretto con tag dati o file di testo casuale archiviati quando una società non dispone problematiche internazionale. Spesso i problemi dell'utente potrebbero essere evitati se dati vengono contrassegnati in modo coerente e appropriato.  
  
 Per gli standard che forniscono un tipo di codifica, una distinta base è in parte ridondante. Tuttavia, può essere utilizzato per consentire a un server di inviare l'intestazione di codifica corretta. In alternativa, può essere utilizzato come fallback in caso contrario, la codifica viene perduta.  
  
 Esistono alcuni svantaggi dell'utilizzo di un carattere BOM. Ad esempio, può essere difficile sapere come limitare i campi del database che usano un carattere BOM. Concatenazione dei file può rappresentare un problema, inoltre, ad esempio, quando i file vengono uniti in tale modo un carattere non necessario può finire al centro dati. Nonostante alcuni svantaggi, tuttavia, l'uso di un carattere BOM è consigliabile.  
  
 Per altre informazioni sull'ordine dei byte e il byte order mark, vedere lo Unicode Standard nella [home page di Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre l'inizio di un flusso di byte codificati con un preambolo. Si noti che il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo anteporre non una DBA in una sequenza di byte codificati; fornisce un indicatore ordine byte all'inizio di un flusso di byte appropriato è responsabilità dello sviluppatore.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.UTF8Encoding.GetPreamble%2A> per restituire il byte Unicode order mark codificato in formato UTF-8. Si noti che il costruttore predefinito per <xref:System.Text.UTF8Encoding> non è incluso un preambolo.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Nell'esempio seguente crea due <xref:System.Text.UTF8Encoding> oggetti, il primo tramite una chiamata senza parametri <xref:System.Text.UTF8Encoding.%23ctor> costruttore, che non è incluso un carattere BOM e il secondo chiamando il <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29> costruttore con relativo `encoderShouldEmitUTF8Identifier` argomento impostato su `true`. Chiama quindi il <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo per scrivere il BOM in un file prima di scrivere una stringa codificata in formato UF8. Come mostra l'output dell'esempio della console, il file che salva i byte dal secondo codificatore ha tre byte più lungo della prima espressione.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 È anche possibile confrontare i file usando il `fc` comando in una finestra della console, oppure è possibile esaminare i file in un editor di testo che include una modalità di visualizzazione esadecimale. Si noti che quando il file viene aperto in un editor che supporta UTF-8, il carattere BOM non è visualizzato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF8Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Decodifica un intervallo di byte da una matrice di byte in una stringa.</summary>
        <returns>Oggetto <see cref="T:System.String" /> contenente i risultati di decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include i byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non-BOM, il carattere di U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverla tramite la chiamata di <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (metodo).  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, usare il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF8Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF8Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
   
  
## Examples  
 Nell'esempio seguente consente di inizializzare una matrice mediante la chiamata di <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo per determinare esattamente quanti byte sono necessari per una stringa codificata e quindi aggiungere le dimensioni del contrassegno di ordine byte (BOM). Nell'esempio viene quindi chiamato il <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodo per archiviare il carattere BOM nella matrice prima di chiamare il <xref:System.Text.UTF8Encoding.GetBytes%2A> metodo per archiviare i byte nella matrice codificati. Nell'esempio viene quindi chiamato il <xref:System.Text.UTF8Encoding.GetString%2A> metodo da decodificare la stringa.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Si noti che in questo caso la stringa decodificata è diversa dalla stringa originale, poiché inizia con un contrassegno di ordine di byte a 16 bit U + FFFD. Ciò significa che le due stringhe confronterà contenendo e che, se la stringa di output, il carattere BOM verrà visualizzato come carattere di sostituzione "?". Per rimuovere il carattere BOM all'inizio della stringa, è possibile chiamare il <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>