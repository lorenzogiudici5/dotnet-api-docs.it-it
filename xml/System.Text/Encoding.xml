<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d95c61143e58621b3de218589a87909c382856a6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39903185" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una codifica caratteri.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica è il processo di trasformazione di un insieme di caratteri Unicode in una sequenza di byte. Al contrario, la decodifica è il processo di trasformazione di una sequenza di byte codificati in un set di caratteri Unicode. Per informazioni sui formati di trasformazione Unicode (UTF) e altre codifiche supportate dal <xref:System.Text.Encoding>, vedere [codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Si noti che <xref:System.Text.Encoding> è progettate per funzionare con i caratteri Unicode anziché i dati binari arbitrari, ad esempio matrici di byte. Se è necessario codificare i dati binari arbitrari in testo, è necessario utilizzare un protocollo, ad esempio uuencode, che viene implementata dai metodi, ad esempio <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 .NET offre le seguenti implementazioni del <xref:System.Text.Encoding> classe per supportare altre codifiche e le codifiche Unicode corrente:  
  
-   <xref:System.Text.ASCIIEncoding> codifica i caratteri Unicode come singoli caratteri ASCII a 7 bit. Questa codifica supporta solo valori dei caratteri tra U + 0000 e U + 007F. Tabella codici 20127. Disponibile anche tramite il <xref:System.Text.Encoding.ASCII%2A> proprietà.  
  
-   <xref:System.Text.UTF7Encoding> codifica i caratteri Unicode usando la codifica UTF-7. Questa codifica supporta tutti i valori di caratteri Unicode. Tabella codici 65000. Disponibile anche tramite il <xref:System.Text.Encoding.UTF7%2A> proprietà.  
  
-   <xref:System.Text.UTF8Encoding> codifica i caratteri Unicode usando la codifica UTF-8. Questa codifica supporta tutti i valori di caratteri Unicode. Tabella codici 65001. Disponibile anche tramite il <xref:System.Text.Encoding.UTF8%2A> proprietà.  
  
-   <xref:System.Text.UnicodeEncoding> codifica i caratteri Unicode usando la codifica UTF-16. Sono supportati sia ordini little-endian che big-endian byte. Disponibile anche tramite il <xref:System.Text.Encoding.Unicode%2A> proprietà e il <xref:System.Text.Encoding.BigEndianUnicode%2A> proprietà.  
  
-   <xref:System.Text.UTF32Encoding> codifica i caratteri Unicode usando la codifica UTF-32. Little endian (tabella codici 12000) sia dei byte big endian (tabella codici 12001) sono supportati gli ordini. Disponibile anche tramite il <xref:System.Text.Encoding.UTF32%2A> proprietà.  
  
 Il <xref:System.Text.Encoding> classe è destinata principalmente a eseguire la conversione tra codifiche diverse e Unicode. Una delle classi derivate Unicode è spesso la scelta corretta per l'app.  
  
 Usare la <xref:System.Text.Encoding.GetEncoding%2A> metodo per ottenere altre codifiche e chiamare il <xref:System.Text.Encoding.GetEncodings%2A> metodo per ottenere un elenco di tutte le codifiche.  
  
 La tabella seguente elenca le codifiche supportate da .NET Framework e .NET Core. Elenca numero della tabella codici del ogni codifica e i valori della codifica <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> e <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> proprietà. Un segno di spunta nel **supporto di .NET Framework** e **supporto per .NET Core** colonne indica che la tabella codici in modo nativo è supportata da tale implementazione di .NET, indipendentemente dalla piattaforma sottostante. Per .NET Framework, la disponibilità di altre codifiche elencate nella tabella dipende dal sistema operativo. Per .NET Core, sono disponibili altre codifiche tramite il <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> classe o per la derivazione da di <xref:System.Text.EncodingProvider?displayProperty=nameWithType> classe.  

> [!NOTE]
> Le pagine di codice la cui proprietà <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> proprietà corrisponde a uno standard internazionale non necessariamente conformi completamente con tale standard. 

|Tabella codici|nome|Nome visualizzato|Supporto di .NET framework| Supporto per .NET core | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (US-Canada)|||  
|437|IBM437|OEM-Usa|||  
|500|IBM500|IBM EBCDIC (internazionale)|||  
|708|ASMO-708|Arabské (jazyky ASMO 708)|||  
|720|DOS-720|Arabské Jazyky (DOS)|||  
|737|ibm737|Greco (DOS)|||  
|775|ibm775|Pobaltské Jazyky (DOS)|||  
|850|ibm850|Europa occidentale (DOS)|||  
|852|ibm852|Europa centrale (DOS)|||  
|855|IBM855|Cyrilice OEM|||  
|857|ibm857|Turco (DOS)|||  
|858|IBM00858|OEM latino multilingue I|||  
|860|IBM860|Portoghese (DOS)|||  
|861|ibm861|Islandese (DOS)|||  
|862|DOS-862|Ebraico (DOS)|||  
|863|IBM863|Francese (Canada (DOS)|||  
|864|IBM864|Arabské (jazyky 864)|||  
|865|IBM865|Severské Jazyky (DOS)|||  
|866|cp866|Cyrilice (DOS)|||  
|869|ibm869|Greco moderno (DOS)|||  
|870|IBM870|IBM EBCDIC (latino multilingue 2)|||  
|874|windows-874|Thai (Windows)|||  
|875|cp875|IBM EBCDIC (Greco moderno)|||  
|932|shift_jis|Giapponese (Shift-JIS)|||  
|936|gb2312|Cinese semplificato (GB2312)|✓||  
|949|ks_c_5601-1987|Coreano|||  
|950|BIG5|Cinese tradizionale (Big5)|||  
|1026|IBM1026|IBM EBCDIC (turco latino 5)|||  
|1047|IBM01047|IBM Latin 1|||  
|1140|IBM01140|IBM EBCDIC (Stati Uniti-Canada-Europa)|||  
|1141|IBM01141|IBM EBCDIC (Germania-Europa)|||  
|1142|IBM01142|IBM EBCDIC (Danimarca-Norvegia-Europa)|||  
|1143|IBM01143|IBM EBCDIC (Finlandia-Svezia-Europa)|||  
|1144|IBM01144|IBM EBCDIC (Italia-Europa)|||  
|1145|IBM01145|IBM EBCDIC (Spagna-Europa)|||  
|1146|IBM01146|IBM EBCDIC (Regno Unito-Europa)|||  
|1147|IBM01147|IBM EBCDIC (Francie-Euro)|||  
|1148|IBM01148|IBM EBCDIC (internazionale-Europa)|||  
|1149|IBM01149|IBM EBCDIC (Island-Euro)|||  
|1200|UTF-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|✓|  
|1250|windows-1250|Europa centrale (Windows)|||  
|1251|windows-1251|Cirillico (Windows)|||  
|1252|Windows-1252|Europa occidentale (Windows)|✓||  
|1253|windows-1253|Greco (Windows)|||  
|1254|windows-1254|Turco (Windows)|||  
|1255|windows-1255|Ebraico (Windows)|||  
|1256|windows-1256|Arabo (Windows)|||  
|1257|windows-1257|Pobaltské Jazyky (Windows)|||  
|1258|windows-1258|Vietnamita (Windows)|||  
|1361|Johab|Coreano (Johab)|||  
|10000|Macintosh|Europa occidentale (Mac)|||  
|10001|x-mac-giapponese|Giapponese (Mac)|||  
|10002|x-mac-cinese tradizionale|Cinese tradizionale (Mac)|||  
|10003|x-mac-coreano|Coreano (Mac)|✓||  
|10004|x-mac-arabo|Arabo (Mac)|||  
|10005|x-mac-ebraico|Ebraico (Mac)|||  
|10006|x-mac-greco|Greco (Mac)|||  
|10007|x-mac-cirillico|Cyrilice (Mac)|||  
|10008|x-mac-chinesesimp|Cinese semplificato (Mac)|✓||  
|10010|x-mac-romeno|Rumeno (Mac)|||  
|10017|ukrainian-mac-x|Ucraino (Mac)|||  
|10021|x-mac-thai|Thai (Mac)|||  
|10029|x-mac-ce|Europa centrale (Mac)|||  
|10079|x-mac-islandese|Islandese (Mac)|||  
|10081|x-mac-turco|Turco (Mac)|||  
|10082|x-mac-croato|Croato (Mac)|||  
|12000|utf-32|Unicode (UTF-32)|✓|✓|  
|12001|UTF-32BE|Unicode (UTF-32 Big endian)|✓|✓|  
|20000|Chinese-x-CN|Cinese tradizionale (CNS)|||  
|20001|x-cp20001|WAN TCA|||  
|20002|Chinese-x-Eten|Cinese tradizionale (Eten)|||  
|20003|x-cp20003|WAN Ibm5550|||  
|20004|x-cp20004|WAN teletext|||  
|20005|x-cp20005|Tchaj-WAN|||  
|20105|x-IA5|Europa occidentale (IA5)|||  
|20106|x-IA5-Tedesco|Tedesco (IA5)|||  
|20107|x-IA5-svedese|Svedese (IA5)|||  
|20108|x-IA5-Norvegese|Norvegese (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Germania)|||  
|20277|IBM277|IBM EBCDIC (Danimarca-Norvegia)|||  
|20278|IBM278|IBM EBCDIC (Finlandia-Svezia)|||  
|20280|IBM280|IBM EBCDIC (Italia)|||  
|20284|IBM284|IBM EBCDIC (Spagna)|||  
|20285|IBM285|IBM EBCDIC (UK)|||  
|20290|IBM290|IBM EBCDIC (japonsko-katakana)|||  
|20297|IBM297|IBM EBCDIC (Francie)|||  
|20420|IBM420|IBM EBCDIC (arabo)|||  
|20423|IBM423|IBM EBCDIC (greco)|||  
|20424|IBM424|IBM EBCDIC (ebraico)|||  
|20833|EBCDIC-x-KoreanExtended|IBM EBCDIC (coreano esteso)|||  
|20838|IBM-Thai|IBM EBCDIC (Thai)|||  
|20866|koi8-r|Cirillico (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (Islandese)|||  
|20880|IBM880|IBM EBCDIC (cirillico russo)|||  
|20905|IBM905|IBM EBCDIC (Turco)|||  
|20924|IBM00924|IBM Latin 1|||  
|20932|EUC-JP|Giapponese (JIS-1990 0208 e 0212 1990)|||  
|20936|x-cp20936|Cinese semplificato (GB2312 80)|✓||  
|20949|x-cp20949|Coreano Wansung|✓||  
|21025|cp1025|IBM EBCDIC (Cirillico Serbo-bulgaro)|||  
|21866|koi8-u|Cirillico (KOI8-U)|||  
|28591|iso-8859-1|Europa occidentale (ISO)|✓|✓|  
|28592|iso-8859-2|Europa centrale (ISO)|||  
|28593|iso-8859-3|Latino 3 (ISO)|||  
|28594|iso-8859-4|Pobaltské Jazyky (ISO)|||  
|28595|iso-8859-5|Cyrilice (ISO)|||  
|28596|iso-8859-6|Arabo (ISO)|||  
|28597|iso-8859-7|Greco (ISO)|||  
|28598|iso-8859-8|Ebraico (ISO-Visual)|✓||  
|28599|iso-8859-9|Turco (ISO)|||  
|28603|iso-8859-13|Estone (ISO)|||  
|28605|iso-8859-15|Latino 9 (ISO)|||  
|29001|x-Europa|Europa|||  
|38598|iso-8859-8-i|Ebraico (ISO-Logical)|✓||  
|50220|iso-2022-jp|Giapponese (JIS)|✓||  
|50221|csISO2022JP|Giapponese (JIS-consente Kana a 1 byte)|✓||  
|50222|iso-2022-jp|Giapponese (JIS-consente a 1 byte Katakana/Hiragana - così / SI)|✓||  
|50225|iso-2022-kr|Coreano (ISO)|✓||  
|50227|x-cp50227|Cinese semplificato (ISO-2022)|✓||  
|51932|euc-jp|Giapponese (EUC)|✓||  
|51936|EUC-CN|Cinese semplificato (EUC)|✓||  
|51949|EUC-kr|Coreano (EUC)|✓||  
|52936|hz-gb-2312|Cinese semplificato (HZ)|✓||  
|54936|GB18030|Cinese semplificato (GB18030)|✓||  
|57002|x-iscii-de|ISCII Devanagari|✓||  
|57003|x-iscii-be|ISCII Bengali|✓||  
|57004|x-iscii-ta|ISCII Tamil|✓||  
|57005|x-iscii-te|ISCII Telugu|✓||  
|57006|iscii come x|ISCII Assamese|✓||  
|57007|x-iscii-o|ISCII Oriya|✓||  
|57008|x-iscii-ka|ISCII Kannada|✓||  
|57009|x-iscii-ma|ISCII Malayalam|✓||  
|57010|x-iscii-gu|ISCII Gujarati|✓||  
|57011|x-iscii-pa|ISCII Punjabi|✓||  
|65000|UTF-7|Unicode (UTF-7)|✓|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|✓|  
  
 L'esempio seguente chiama il <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> e <xref:System.Text.Encoding.GetEncoding%28System.String%29> metodi per ottenere il greco (Windows) del codice codifica della tabella. Confronta il <xref:System.Text.Encoding> gli oggetti restituiti dalle chiamate di metodo per mostrare che sono uguali, e quindi esegue il mapping consente di visualizzare il punto di codice Unicode e il valore di pagina di codice corrispondente per ogni carattere dell'alfabeto greco.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 UTF-16 e UTF-32 codificatori possono usare l'ordine dei byte big-endian (byte più significativo primo) o il little endian (byte meno significativo prima). Ad esempio, il latino una (u+0041) viene serializzata come segue (in esadecimale):  
  
-   Ordine dei byte UTF-16 big endian: 00 41  
  
-   L'ordine dei byte little-endian UTF-16 little: 41 00  
  
-   Ordine dei byte big-endian UTF-32: 00 00 00 41  
  
-   Ordine dei byte little-endian little UTF-32: 41 00 00 00  
  
 È in genere più efficiente per archiviare i caratteri Unicode utilizzando l'ordine dei byte nativa. Ad esempio, è preferibile usare l'ordine dei byte little-endian little su piattaforme little-endian, ad esempio computer con processori Intel.  
  
 Il <xref:System.Text.Encoding.GetPreamble%2A> metodo recupera una matrice di byte che include il byte order mark (BOM). Se la matrice di byte viene aggiunto come prefisso un flusso codificato, può facilitare il decodificatore per identificare il formato di codifica utilizzato.  
  
 Per altre informazioni sull'ordine dei byte e il byte order mark, vedere lo Unicode Standard nella [home page di Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Si noti che le classi di codifica consentono agli errori di:  
  
-   Cambiare automaticamente a un "?" caratteri.  
  
-   Usare un carattere "best fit".  
  
-   Passare a un comportamento specifico dell'applicazione tramite l'uso del <xref:System.Text.EncoderFallback> e <xref:System.Text.DecoderFallback> classi con il carattere di sostituzione Unicode U + FFFD.  
  
 È necessario generare un'eccezione per qualsiasi errore di flusso di dati. Un'app viene usato un flag "throwonerror" se applicabile o Usa il <xref:System.Text.EncoderExceptionFallback> e <xref:System.Text.DecoderExceptionFallback> classi. Il fallback più appropriato spesso non è consigliabile perché può causare confusione o perdita di dati ed è più lento rispetto a sostituzione di caratteri semplice. Per le codifiche ANSI, il comportamento più appropriato è il valore predefinito.  
  
   
  
## Examples  
 Nell'esempio seguente converte una stringa da una codifica a altra.  
  
> [!NOTE]
>  La matrice di byte [] è l'unico tipo in questo esempio che contiene i dati codificati. I tipi .NET Char e String sono Unicode, pertanto la <xref:System.Text.Encoding.GetChars%2A> chiamata decodifica i dati Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate di eseguire l'override questo costruttore.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">Identificatore della tabella codici della codifica scelta.  
  
oppure 
0, per usare la codifica predefinita.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.Encoding" /> che corrisponde alla tabella codici specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate di eseguire l'override questo costruttore.  
  
 Le chiamate a questo costruttore da una classe derivata di creare un <xref:System.Text.Encoding> oggetto che usa il fallback con mapping più appropriato per la codifica e le operazioni di decodifica. Sia la <xref:System.Text.Encoding.DecoderFallback%2A> e <xref:System.Text.Encoding.EncoderFallback%2A> proprietà sono di sola lettura e non può essere modificata. Per controllare la strategia di fallback per una classe derivata da <xref:System.Text.Encoding>, chiamare il <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> costruttore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> è minore di zero.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">Identificatore della tabella codici di codifica.</param>
        <param name="encoderFallback">Oggetto che fornisce una procedura di gestione degli errori quando un carattere non può essere codificato con la codifica corrente.</param>
        <param name="decoderFallback">Oggetto che fornisce una procedura di gestione degli errori quando una sequenza di byte non può essere decodificata con la codifica corrente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.Encoding" /> che corrisponde alla tabella codici specificata con le strategie di fallback del codificatore e del decodificatore specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore è `protected`; derivata classi eseguirne l'override.  
  
 Si chiama il costruttore da una classe derivata per controllare il fallback di codifica e decodifica strategie. Il <xref:System.Text.Encoding> costruttori di classi creano oggetti di codifica sola lettura che non consentono al codificatore o fallback del decodificatore da impostare dopo la creazione dell'oggetto.  
  
 Se uno dei due `encoderFallback` o `decoderFallback` è null, il fallback con mapping più appropriato viene utilizzato come la relativa strategia di fallback.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una codifica per il set di caratteri ASCII (7 bit).</summary>
        <value>Codifica per il set di caratteri ASCII (7 bit).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sono limitati per i primi 128 caratteri Unicode, da u+0000 a U + 007F caratteri ASCII.  
  
 Quando si seleziona la codifica ASCII per l'app, tenere presente quanto segue:  
  
-   La codifica ASCII è in genere appropriata per i protocolli che richiedono ASCII.  
  
-   Se si richiede la codifica a 8 bit (indicate viene a volte erroneamente come "ASCII"), la codifica UTF-8 è consigliata rispetto di ASCII di codifica. Per i caratteri 0 7F, i risultati sono identici, ma utilizzare UTF-8 consente di evitare la perdita di dati, consentendo di rappresentazione di tutti i caratteri Unicode rappresentabile. Si noti che la codifica ASCII è un all'8 bit ambiguità che possono consentire l'uso dannoso, ma la codifica UTF-8, Elimina l'ambiguità su 8 bit.  
  
-   Prima di .NET Framework versione 2.0, .NET Framework consentiva lo spoofing degli indirizzi ignorando il bit l'8. A partire da .NET Framework 2.0, i punti di codice non ASCII fallback durante la decodifica.  
  
 Il <xref:System.Text.ASCIIEncoding> oggetto restituito da questa proprietà potrebbe non avere il comportamento appropriato per l'app. Usa il fallback di sostituzione per sostituire ogni stringa che non può codificare e ogni byte che non può decodificare con un punto interrogativo ("?") caratteri. In alternativa, è possibile chiamare il <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> metodo per creare un'istanza di un <xref:System.Text.ASCIIEncoding> oggetto il cui fallback è un' <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 L'esempio seguente illustra l'effetto di codifica ASCII sui caratteri che non rientrano nell'intervallo ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una codifica per il formato UTF-16 che usa l'ordine dei byte big-endian.</summary>
        <value>Oggetto di codifica per il formato UTF-16 che usa l'ordine dei byte big endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.UnicodeEncoding> oggetto restituito da questa proprietà non abbia il comportamento appropriato per l'app. Usa il fallback di sostituzione per sostituire ogni stringa che non può codificare e ogni byte che non può decodificare con un punto interrogativo ("?") caratteri. In alternativa, è possibile chiamare il <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> costruttore per creare un'istanza di un big endian <xref:System.Text.UnicodeEncoding> oggetto il cui fallback è un' <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 L'oggetto restituito <xref:System.Text.UnicodeEncoding> oggetto presenta <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, e <xref:System.Text.Encoding.WebName%2A> proprietà, vale a dire il nome "unicodeFFFE". Anche se il contrassegno di ordine byte big-endian UTF-16 è FEFF esadecimale, il nome "unicodeFFFE" è stato scelto perché viene visualizzato il byte order mark come FFFE esadecimale in little-endian computer di Windows.  
  
   
  
## Examples  
 L'esempio seguente legge un file di testo con codifica UTF-16 Usa l'ordine dei byte big-endian.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 Nell'esempio seguente determina il numero di byte necessari per la codifica una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un nome per la codifica corrente che può essere usato con i tag body degli agenti di posta.</summary>
        <value>Nome dell'oggetto <see cref="T:System.Text.Encoding" /> corrente che può essere usato con i tag body degli agenti di posta.  
  
oppure 
Stringa vuota (""), se non è possibile usare l'oggetto <see cref="T:System.Text.Encoding" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è necessaria una codifica per un nome del corpo, è necessario chiamare <xref:System.Text.Encoding.GetEncoding%2A> con il <xref:System.Text.Encoding.BodyName%2A> proprietà. Spesso il metodo recupera una codifica diversa dalla codifica di test fornita nella chiamata. In genere necessario recuperare tale codifica; solo le applicazioni di posta elettronica la maggior parte delle altre applicazioni che necessitano per descrivere una codifica utilizzino relativo <xref:System.Text.Encoding.WebName%2A>.  
  
 In alcuni casi, il valore della <xref:System.Text.Encoding.BodyName%2A> proprietà corrisponde allo standard internazionale che definisce tale codifica. Ciò non significa che l'implementazione sia conforme in modo completo con tale standard.  
  
   
  
## Examples  
 Nell'esempio seguente vengono recuperati i nomi diversi per ogni tipo di codifica e visualizza le codifiche con uno o più nomi diversi da <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Visualizza <xref:System.Text.Encoding.EncodingName%2A> ma non compare su di esso.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, crea una copia superficiale dell'oggetto <see cref="T:System.Text.Encoding" /> corrente.</summary>
        <returns>Copia dell'oggetto <see cref="T:System.Text.Encoding" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il clone sia accessibile in scrittura anche se originale <xref:System.Text.Encoding> oggetto è di sola lettura. Di conseguenza, le proprietà del clone possono essere modificate.  
  
 Una copia superficiale di un oggetto è una copia del solo oggetto. Se l'oggetto contiene riferimenti ad altri oggetti, la copia superficiale non crea copie degli oggetti a cui si fa riferimento. Fa riferimento negli oggetti originali invece. Al contrario, una copia completa di un oggetto crea una copia dell'oggetto e una copia di tutti gli elementi direttamente o indirettamente fa riferimento questo oggetto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene l'identificatore della tabella codici dell'oggetto <see cref="T:System.Text.Encoding" /> corrente.</summary>
        <value>Identificatore della tabella codici dell'oggetto <see cref="T:System.Text.Encoding" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente vengono recuperati i nomi diversi per ogni tipo di codifica e visualizza le codifiche con uno o più nomi diversi da <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Visualizza <xref:System.Text.Encoding.EncodingName%2A> ma non compare su di esso.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte una matrice di byte da una codifica a un'altra.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Formato di codifica di <c>bytes</c>.</param>
        <param name="dstEncoding">Formato di codifica di destinazione.</param>
        <param name="bytes">Byte da convertire.</param>
        <summary>Converte un'intera matrice di byte da una codifica a un'altra.</summary>
        <returns>Matrice di tipo <see cref="T:System.Byte" /> contenente i risultati della conversione di <paramref name="bytes" /> da <paramref name="srcEncoding" /> a <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente converte una stringa codificata in formato Unicode in una stringa con codifica ASCII. Poiché l'oggetto di codifica ASCII restituisce il <xref:System.Text.Encoding.ASCII%2A> proprietà Usa il fallback di sostituzione e il carattere di pi greco non fa parte del set di caratteri ASCII, il carattere di pi greco viene sostituito con un punto interrogativo, come illustrato nell'esempio di output.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> è <see langword="null" />.  
  
oppure 
 <paramref name="dstEncoding" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 **srcEncoding** <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 **dstEncoding** <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Codifica della matrice di origine, <c>bytes</c>.</param>
        <param name="dstEncoding">Codifica della matrice di output.</param>
        <param name="bytes">Matrice di byte da convertire.</param>
        <param name="index">Indice del primo elemento di <c>bytes</c> da convertire.</param>
        <param name="count">Numero di byte da convertire.</param>
        <summary>Converte un intervallo di byte in una matrice di byte da una codifica a un'altra.</summary>
        <returns>Matrice di tipo <see cref="T:System.Byte" /> contenente il risultato della conversione di un intervallo di byte in <paramref name="bytes" /> da <paramref name="srcEncoding" /> a <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> è <see langword="null" />.  
  
oppure 
 <paramref name="dstEncoding" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> e <paramref name="count" /> non specificano un intervallo valido nella matrice di byte.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 **srcEncoding** <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 **dstEncoding** <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Text.DecoderFallback" /> per l'oggetto <see cref="T:System.Text.Encoding" /> corrente.</summary>
        <value>Oggetto di fallback del decodificatore per l'oggetto <see cref="T:System.Text.Encoding" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.DecoderFallback> oggetto rappresenta un gestore degli errori viene richiamato quando una sequenza di byte codificata non può essere decodificata in un carattere. Uno dei seguenti tipi di gestore è supportato:  
  
-   Gestore di fallback con mapping più appropriato, che sostituisce i byte decodificabile con un carattere di sostituzione appropriato.  
  
-   Gestore di fallback di sostituzione, che sostituisce i byte decodificabile con un carattere di sostituzione arbitrario. .NET include un gestore di fallback di sostituzione, <xref:System.Text.DecoderFallback>, che per impostazione predefinita sostituisce i byte decodificabile con un punto interrogativo ("?") caratteri.  
  
-   Un gestore di fallback di eccezione che genera un'eccezione quando byte non decodificabile. .NET include un gestore di fallback di eccezione, <xref:System.Text.DecoderExceptionFallback>, che genera un <xref:System.Text.DecoderFallbackException> quando byte non decodificabile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore in un'operazione di impostazione è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile assegnare un valore in un'operazione di impostazione, poiché l'oggetto <see cref="T:System.Text.Encoding" /> corrente è in sola lettura.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la codifica predefinita per questa implementazione di .NET.</summary>
        <value>La codifica predefinita per questa implementazione di .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Computer diversi è possibile utilizzare codifiche differenti come impostazione predefinita e la codifica predefinita è possibile modificare in un singolo computer. Se si usa il <xref:System.Text.Encoding.Default%2A> codifica da codificare e decodificare i dati trasmessi tra computer o recuperati in momenti diversi nello stesso computer, può convertire i dati in modo non corretto. Inoltre, la codifica restituita dal <xref:System.Text.Encoding.Default%2A> proprietà Usa il fallback con mapping più appropriato per eseguire il mapping di caratteri non supportati per i caratteri supportati dalla tabella codici. Per questi motivi, utilizzando la codifica predefinita non è consigliabile. Per garantire che vengano decodificati correttamente byte con codificati, è consigliabile usare una codifica Unicode, ad esempio <xref:System.Text.UTF8Encoding> o <xref:System.Text.UnicodeEncoding>. È anche possibile utilizzare un protocollo di livello superiore per assicurarsi che venga utilizzato lo stesso formato di codifica e decodifica.  

### <a name="the-default-property-in-the-net-framework"></a>La proprietà predefinita in .NET Framework

In .NET Framework sul desktop di Windows, il <xref:System.Text.Encoding.Default%2A> proprietà sempre Ottiene tabella codici attiva del sistema e crea un <xref:System.Text.Encoding> oggetto che corrisponde a esso. La tabella codici attiva può essere una tabella codici ANSI, che include set insieme a caratteri aggiuntivi che variano in base alla tabella codici di caratteri ASCII. Poiché tutti i <xref:System.Text.Encoding.Default%2A> codifiche basate su tabelle codici ANSI perdita di dati, è possibile usare il <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> invece di codifica. UTF-8 è spesso identici in U + 00 a U + 7F intervallo, ma possono codificare i caratteri di fuori dell'intervallo ASCII senza alcuna perdita.

## <a name="the-default-property-on-net-core"></a>La proprietà predefinita in .NET Core

In .NET Core, il <xref:System.Text.Encoding.Default%2A> proprietà restituisce sempre il <xref:System.Text.UTF8Encoding>. UTF-8 è supportato in tutti i sistemi operativi (Windows, Linux e Max OS X) in esecuzione delle applicazioni .NET Core.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Text.EncoderFallback" /> per l'oggetto <see cref="T:System.Text.Encoding" /> corrente.</summary>
        <value>Oggetto di fallback del codificatore per l'oggetto <see cref="T:System.Text.Encoding" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.EncoderFallback> oggetto rappresenta un gestore degli errori che viene richiamato quando un carattere non può essere convertito in una sequenza di byte codificata. Uno dei seguenti tipi di gestore è supportato:  
  
-   Gestore di fallback con mapping più appropriato, che sostituisce i caratteri che non possono essere codificati con un carattere di sostituzione appropriato.  
  
-   Gestore di fallback di sostituzione, che sostituisce i caratteri che non possono essere codificati con un carattere di sostituzione arbitrario. .NET include un gestore di fallback di sostituzione, <xref:System.Text.EncoderFallback>, che per impostazione predefinita sostituisce i caratteri che non possono essere codificati con un punto interrogativo ("?") caratteri.  
  
-   Un gestore di fallback di eccezione che genera un'eccezione quando non è possibile codificare i caratteri. .NET include un gestore di fallback di eccezione, <xref:System.Text.EncoderExceptionFallback>, che genera un <xref:System.Text.EncoderFallbackException> quando non è possibile decodificare caratteri.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore in un'operazione di impostazione è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile assegnare un valore in un'operazione di impostazione, poiché l'oggetto <see cref="T:System.Text.Encoding" /> corrente è in sola lettura.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene la descrizione leggibile della codifica corrente.</summary>
        <value>Descrizione leggibile dell'oggetto <see cref="T:System.Text.Encoding" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoding.EncodingName%2A> proprietà è destinata alla visualizzazione. Per trovare un nome che può essere passato per il <xref:System.Text.Encoding.GetEncoding%2A> metodo, usare il <xref:System.Text.Encoding.WebName%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente vengono recuperati i nomi diversi per ogni tipo di codifica e visualizza le codifiche con uno o più nomi diversi da <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Visualizza <xref:System.Text.Encoding.EncodingName%2A> ma non compare su di esso.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto <see cref="T:System.Object" /> da confrontare con l'istanza corrente.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Object" /> specificato è uguale all'istanza corrente.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> è un'istanza di <see cref="T:System.Text.Encoding" /> ed è uguale all'istanza corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due istanze di <xref:System.Text.Encoding> sono considerate uguali se essi corrispondono alla stessa tabella codici e le relative `EncoderFallback` e `DecoderFallback` oggetti sono uguali. In particolare, tutte le tabelle codici derivata dispone di una pagina di codice compreso tra 0 e sono normalmente i fallback `null` (`Nothing` in Visual Basic .NET). In questo modo sono tutti considerati uguali tra loro. Una conseguenza è che quando <xref:System.Text.Encoding.Equals%2A> viene usata per popolare una tabella hash, tutte derivate codifiche risultano uguali e rientrano nello stesso slot nella tabella hash.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene due istanze della stessa codifica (uno per la tabella codici) e l'altro in base al nome e viene verificata l'eguaglianza.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di byte prodotti dalla codifica di un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente i caratteri da codificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di byte prodotti dalla codifica di tutti i caratteri nella matrice di caratteri specificata.</summary>
        <returns>Numero di byte prodotti dalla codifica di tutti i caratteri nella matrice di caratteri specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetBytes%2A> per archiviare i byte risultanti, chiamare il <xref:System.Text.Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.Encoding.GetByteCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Il <xref:System.Text.Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%2A> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso.  
  
-   Se l'app gestisce le stringhe di input, è consigliabile usare le versioni di stringa del <xref:System.Text.Encoding.GetBytes%2A> (metodo).  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per la codifica una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa contenente il set di caratteri da codificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di byte prodotti dalla codifica dei caratteri nella stringa specificata.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetBytes%2A> per archiviare i byte risultanti, chiamare il <xref:System.Text.Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.Encoding.GetByteCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Il <xref:System.Text.Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%2A> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso.  
  
-   Se l'app gestisce le stringhe di input, la versione della stringa <xref:System.Text.Encoding.GetBytes%2A> è consigliato.  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per codificare una stringa o un intervallo della stringa, codifica i caratteri e visualizza i byte risultanti.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di byte prodotti dalla codifica di un set di caratteri a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.Encoding.GetBytes%2A> necessaria per archiviare i byte risultanti, è necessario chiamare il <xref:System.Text.Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.Encoding.GetByteCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Il <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono riportate alcune considerazioni per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso.  
  
-   Se l'app gestisce le stringhe di input, è consigliabile usare la versione della stringa di <xref:System.Text.Encoding.GetBytes%2A> (metodo).  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%2A> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="index">Indice del primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di byte prodotti dalla codifica di un set di caratteri dalla matrice di caratteri specificata.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetBytes%2A> per archiviare i byte risultanti, chiamare il <xref:System.Text.Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.Encoding.GetByteCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Il <xref:System.Text.Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%2A> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso.  
  
-   Se l'app gestisce le stringhe di input, la versione della stringa <xref:System.Text.Encoding.GetBytes%2A> è consigliato.  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per codificare i tre caratteri da una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, codifica un set di caratteri in una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente i caratteri da codificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, codifica tutti i caratteri nella matrice di caratteri specificata in una sequenza di byte.</summary>
        <returns>Matrice di byte contenente i risultati della codifica del set di caratteri specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 Il <xref:System.Text.Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%2A> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso. (Ad esempio, una sequenza di caratteri che include coppie di surrogati può terminare con un carattere surrogato alto. Il <xref:System.Text.Encoder> ricorderanno in questo surrogato alto in modo che può essere combinato con un carattere surrogato basso all'inizio di una chiamata successiva. <xref:System.Text.Encoding> non sarà in grado di mantenere lo stato, il carattere verrà quindi inviata al <xref:System.Text.EncoderFallback>.)  
  
-   Se l'app gestisce le stringhe di input, è necessario chiamare la versione della stringa di <xref:System.Text.Encoding.GetBytes%2A> (metodo).  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per la codifica una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa contenente i caratteri da codificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, codifica tutti i caratteri nella stringa specificata in una sequenza di byte.</summary>
        <returns>Matrice di byte contenente i risultati della codifica del set di caratteri specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 Il <xref:System.Text.Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%2A> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso. (Ad esempio, una sequenza di caratteri che include coppie di surrogati può terminare con un carattere surrogato alto. Il <xref:System.Text.Encoder> ricorderanno in questo surrogato alto in modo che può essere combinato con un carattere surrogato basso all'inizio di una chiamata successiva. <xref:System.Text.Encoding> non sarà in grado di mantenere lo stato, il carattere verrà quindi inviata al <xref:System.Text.EncoderFallback>.)  
  
-   Se l'app gestisce le stringhe di input, è consigliabile usare la versione della stringa <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per codificare una stringa o un intervallo della stringa, codifica i caratteri e visualizza i byte risultanti.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="index">Indice del primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, codifica un set di caratteri dalla matrice di caratteri specificata in una sequenza di byte.</summary>
        <returns>Matrice di byte contenente i risultati della codifica del set di caratteri specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 Il <xref:System.Text.Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%2A> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso. (Ad esempio, una sequenza di caratteri che include coppie di surrogati può terminare con un carattere surrogato alto. Il <xref:System.Text.Encoder> ricorderanno in questo surrogato alto in modo che può essere combinato con un carattere surrogato basso all'inizio di una chiamata successiva. <xref:System.Text.Encoding> non sarà in grado di mantenere lo stato, il carattere verrà quindi inviata al <xref:System.Text.EncoderFallback>.)  
  
-   Se l'app gestisce le stringhe di input, è consigliabile usare la versione della stringa <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per codificare i tre caratteri da una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Puntatore alla posizione in cui iniziare a scrivere la sequenza di byte risultante.</param>
        <param name="byteCount">Numero massimo di byte da scrivere.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, codifica un set di caratteri a partire dal puntatore ai caratteri specificato in una sequenza di byte archiviati a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero effettivo di byte scritti nella posizione indicata dal parametro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.Encoding.GetBytes%2A> necessaria per archiviare i byte risultanti, chiamare il <xref:System.Text.Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.Encoding.GetByteCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Se il conversione dei dati sono disponibili solo in blocchi sequenziali (ad esempio i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è necessario utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> oggetto fornito dal <xref:System.Text.Encoding.GetDecoder%2A> o <xref:System.Text.Encoding.GetEncoder%2A> (metodo), rispettivamente, di una classe derivata.  
  
 Il <xref:System.Text.Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%2A> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso. (Ad esempio, una sequenza di caratteri che include coppie di surrogati può terminare con un carattere surrogato alto. Il <xref:System.Text.Encoder> ricorderanno in questo surrogato alto in modo che può essere combinato con un carattere surrogato basso all'inizio di una chiamata successiva. <xref:System.Text.Encoding> non sarà in grado di mantenere lo stato, il carattere verrà quindi inviata al <xref:System.Text.EncoderFallback>.)  
  
-   Se l'app gestisce le stringhe di input, è consigliabile usare la versione della stringa <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> è minore del numero di byte risultante.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, codifica un set di caratteri dalla matrice di caratteri specificata nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetBytes%2A> per archiviare i byte risultanti, è necessario chiamare il <xref:System.Text.Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.Encoding.GetByteCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 Il <xref:System.Text.Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%2A> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso. (Ad esempio, una sequenza di caratteri che include coppie di surrogati può terminare con un carattere surrogato alto. Il <xref:System.Text.Encoder> ricorderanno in questo surrogato alto in modo che può essere combinato con un carattere surrogato basso all'inizio di una chiamata successiva. <xref:System.Text.Encoding> non sarà in grado di mantenere lo stato, il carattere verrà quindi inviata al <xref:System.Text.EncoderFallback>.)  
  
-   Se l'app gestisce le stringhe di input, è consigliabile usare la versione della stringa <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per codificare i tre caratteri da una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
oppure 
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
oppure 
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Stringa contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, codifica un set di caratteri dalla stringa specificata nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetBytes%2A> per archiviare i byte risultanti, è necessario chiamare il <xref:System.Text.Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.Encoding.GetByteCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 Il <xref:System.Text.Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.Encoding.GetBytes%2A> metodo esegue l'effettiva codifica. Il <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (metodo), che consente di gestire più conversioni in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario codificare molti caratteri di input a una tabella codici ed elaborare i caratteri usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, prendendo in considerazione lo stato in cui viene resa persistente dal <xref:System.Text.Encoder> dell'oggetto in uso. (Ad esempio, una sequenza di caratteri che include coppie di surrogati può terminare con un carattere surrogato alto. Il <xref:System.Text.Encoder> ricorderanno in questo surrogato alto in modo che può essere combinato con un carattere surrogato basso all'inizio di una chiamata successiva. <xref:System.Text.Encoding> non sarà in grado di mantenere lo stato, il carattere verrà quindi inviata al <xref:System.Text.EncoderFallback>.)  
  
-   Se l'app gestisce le stringhe di input, è consigliabile usare la versione della stringa <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versione di buffer di caratteri Unicode della <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate utilizzando il <xref:System.Text.Encoder> oggetto o l'inserimento nei buffer esistenti. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il <xref:System.Text.Encoding.GetBytes%2A> versione che supporta le matrici di byte è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetByteCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e viene generata un'eccezione se il buffer di output è troppo piccolo. Per la codifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per codificare una stringa o un intervallo della stringa, codifica i caratteri e visualizza i byte risultanti.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
oppure 
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
oppure 
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di caratteri prodotti dalla decodifica di tutti i byte nella matrice di byte specificata.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> per archiviare i caratteri risultanti, è consigliabile usare il <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> (metodo). Per calcolare la dimensione massima della matrice, è consigliabile usare il <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> (metodo). Il <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Il <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> metodo determina il numero di caratteri risultanti dalla decodifica una sequenza di byte e il <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> metodo esegue la decodifica effettivo. Il <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo che gestisce più passaggi in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario decodificare più byte di una tabella codici input ed elaborare i byte usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate.  
  
-   Se l'app gestisce gli output di stringa, è consigliabile usare il <xref:System.Text.Encoding.GetString%2A> (metodo). Poiché questo metodo deve controllare la lunghezza della stringa e allocare un buffer, è leggermente più lento, ma l'oggetto risultante <xref:System.String> tipo è preferibile.  
  
-   La versione di byte di <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate al buffer di grandi dimensioni. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versione che supporta i caratteri di output i buffer è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetCharCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e genera un'eccezione se il buffer di output è troppo piccolo. Per la decodifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa in una matrice di byte e quindi le decodifica i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.Encoding.GetChars%2A> necessaria per archiviare i caratteri risultanti, è consigliabile usare il <xref:System.Text.Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, usare il <xref:System.Text.Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.Encoding.GetCharCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Il <xref:System.Text.Encoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica una sequenza di byte e il <xref:System.Text.Encoding.GetChars%2A> metodo esegue la decodifica effettivo. Il <xref:System.Text.Encoding.GetChars%2A> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo che gestisce più passaggi in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario decodificare più byte di una tabella codici input ed elaborare i byte usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate.  
  
-   Se l'app gestisce gli output di stringa, è consigliabile usare il <xref:System.Text.Encoding.GetString%2A> (metodo). Poiché questo metodo deve controllare la lunghezza della stringa e allocare un buffer, è leggermente più lento, ma l'oggetto risultante <xref:System.String> tipo è preferibile.  
  
-   La versione di byte di <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate al buffer di grandi dimensioni. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versione che supporta i caratteri di output i buffer è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetCharCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e genera un'eccezione se il buffer di output è troppo piccolo. Per la decodifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte dalla matrice di byte specificata.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetChars%2A> per archiviare i caratteri risultanti, è consigliabile usare il <xref:System.Text.Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, usare il <xref:System.Text.Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.Encoding.GetCharCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Il <xref:System.Text.Encoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica una sequenza di byte e il <xref:System.Text.Encoding.GetChars%2A> metodo esegue la decodifica effettivo. Il <xref:System.Text.Encoding.GetChars%2A> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo che gestisce più passaggi in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario decodificare più byte di una tabella codici input ed elaborare i byte usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate.  
  
-   Se l'app gestisce gli output di stringa, è consigliabile usare il <xref:System.Text.Encoding.GetString%2A> (metodo). Poiché questo metodo deve controllare la lunghezza della stringa e allocare un buffer, è leggermente più lento, ma l'oggetto risultante <xref:System.String> tipo è preferibile.  
  
-   La versione di byte di <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate al buffer di grandi dimensioni. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versione che supporta i caratteri di output i buffer è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetCharCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e genera un'eccezione se il buffer di output è troppo piccolo. Per la decodifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente converte una stringa da una codifica a altra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Nell'esempio seguente codifica una stringa in una matrice di byte e quindi le decodifica un intervallo di byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, decodifica una sequenza di byte in un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, decodifica tutti i byte nella matrice di byte specificata in un set di caratteri.</summary>
        <returns>Matrice di caratteri contenente i risultati di decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ottiene i caratteri da una sequenza di byte di input. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> è diverso da quello <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> poiché <xref:System.Text.Encoding> prevede le conversioni discrete, mentre <xref:System.Text.Decoder> è destinata a più passaggi in un singolo flusso di input.  
  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 **Nota** questo metodo è progettato per funzionare con caratteri Unicode e non su dati binari arbitrari, ad esempio matrici di byte. Se è necessario codificare i dati binari arbitrari in testo, è consigliabile usare un protocollo, ad esempio uuencode, che viene implementata dai metodi, ad esempio <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.Text.Encoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica una sequenza di byte e il <xref:System.Text.Encoding.GetChars%2A> metodo esegue la decodifica effettivo. Il <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo che gestisce più passaggi in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario decodificare più byte di una tabella codici input ed elaborare i byte usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, in quanto le sequenze di byte possono essere interrotta durante l'elaborazione in batch. (Ad esempio, può terminare una parte di una sequenza di MAIUSC ISO-2022 <xref:System.Text.Encoding.GetChars%2A> chiamare e continua all'inizio del successivo <xref:System.Text.Encoding.GetChars%2A> chiamare. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> chiamerà il fallback per le sequenze incompleti, ma <xref:System.Text.Decoder> memorizzerà le sequenze per la chiamata successiva.)  
  
-   Se l'app gestisce gli output di stringa, è consigliabile usare il <xref:System.Text.Encoding.GetString%2A> (metodo). Poiché questo metodo deve controllare la lunghezza della stringa e allocare un buffer, è leggermente più lento, ma l'oggetto risultante <xref:System.String> tipo è preferibile.  
  
-   La versione di byte di <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate al buffer di grandi dimensioni. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versione che supporta i caratteri di output i buffer è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetCharCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e genera un'eccezione se il buffer di output è troppo piccolo. Per la decodifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa in una matrice di byte e quindi le decodifica i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, decodifica una sequenza di byte dalla matrice di byte specificata in un set di caratteri.</summary>
        <returns>Matrice di caratteri contenente i risultati di decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ottiene i caratteri da una sequenza di byte di input. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> è diverso da quello <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> poiché <xref:System.Text.Encoding> prevede le conversioni discrete, mentre <xref:System.Text.Decoder> è destinata a più passaggi in un singolo flusso di input.  
  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 **Nota** questo metodo è progettato per funzionare con caratteri Unicode e non su dati binari arbitrari, ad esempio matrici di byte. Se è necessario codificare i dati binari arbitrari in testo, è consigliabile usare un protocollo, ad esempio uuencode, che viene implementata dai metodi, ad esempio <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.Text.Encoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica una sequenza di byte e il <xref:System.Text.Encoding.GetChars%2A> metodo esegue la decodifica effettivo. Il <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo che gestisce più passaggi in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario decodificare più byte di una tabella codici input ed elaborare i byte usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, in quanto le sequenze di byte possono essere interrotta durante l'elaborazione in batch. (Ad esempio, può terminare una parte di una sequenza di MAIUSC ISO-2022 <xref:System.Text.Encoding.GetChars%2A> chiamare e continua all'inizio del successivo <xref:System.Text.Encoding.GetChars%2A> chiamare. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> chiamerà il fallback per le sequenze incompleti, ma <xref:System.Text.Decoder> memorizzerà le sequenze per la chiamata successiva.)  
  
-   Se l'app gestisce gli output di stringa, è consigliabile usare il <xref:System.Text.Encoding.GetString%2A> (metodo). Poiché questo metodo deve controllare la lunghezza della stringa e allocare un buffer, è leggermente più lento, ma l'oggetto risultante <xref:System.String> tipo è preferibile.  
  
-   La versione di byte di <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate al buffer di grandi dimensioni. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versione che supporta i caratteri di output i buffer è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetCharCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e genera un'eccezione se il buffer di output è troppo piccolo. Per la decodifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa in una matrice di byte e quindi le decodifica un intervallo di byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Puntatore alla posizione in cui iniziare a scrivere il set di caratteri risultante.</param>
        <param name="charCount">Numero massimo di caratteri da scrivere.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, decodifica una sequenza di byte a partire dal puntatore ai byte specificato in un set di caratteri archiviati a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero effettivo di caratteri scritti nella posizione indicata dal parametro <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.Encoding.GetChars%2A> necessaria per archiviare i caratteri risultanti, è consigliabile usare il <xref:System.Text.Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, usare il <xref:System.Text.Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.Encoding.GetCharCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ottiene i caratteri da una sequenza di byte di input. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> è diverso da quello <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> poiché <xref:System.Text.Encoding> prevede le conversioni discrete, mentre <xref:System.Text.Decoder> è destinata a più passaggi in un singolo flusso di input.  
  
 Se il conversione dei dati sono disponibili solo in blocchi sequenziali (ad esempio i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è necessario utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> oggetto fornito dal <xref:System.Text.Encoding.GetDecoder%2A> o <xref:System.Text.Encoding.GetEncoder%2A> (metodo), rispettivamente, di una classe derivata.  
  
 **Nota** questo metodo è progettato per funzionare con caratteri Unicode e non su dati binari arbitrari, ad esempio matrici di byte. Se è necessario codificare i dati binari arbitrari in testo, è consigliabile usare un protocollo, ad esempio uuencode, che viene implementata dai metodi, ad esempio <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.Text.Encoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica una sequenza di byte e il <xref:System.Text.Encoding.GetChars%2A> metodo esegue la decodifica effettivo. Il <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo che gestisce più passaggi in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario decodificare più byte di una tabella codici input ed elaborare i byte usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, in quanto le sequenze di byte possono essere interrotta durante l'elaborazione in batch. (Ad esempio, può terminare una parte di una sequenza di MAIUSC ISO-2022 <xref:System.Text.Encoding.GetChars%2A> chiamare e continua all'inizio del successivo <xref:System.Text.Encoding.GetChars%2A> chiamare. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> chiamerà il fallback per le sequenze incompleti, ma <xref:System.Text.Decoder> memorizzerà le sequenze per la chiamata successiva.)  
  
-   Se l'app gestisce gli output di stringa, il <xref:System.Text.Encoding.GetString%2A> metodo è consigliato. Poiché questo metodo deve controllare la lunghezza della stringa e allocare un buffer, è leggermente più lento, ma l'oggetto risultante <xref:System.String> tipo è preferibile.  
  
-   La versione di byte di <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate al buffer di grandi dimensioni. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versione che supporta i caratteri di output i buffer è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetCharCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e genera un'eccezione se il buffer di output è troppo piccolo. Per la decodifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.  
  
oppure 
 <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> o <paramref name="charCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> è minore del numero di caratteri risultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="byteIndex">Indice del primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Matrice di caratteri che deve contenere il set di caratteri risultante.</param>
        <param name="charIndex">Indice in corrispondenza del quale iniziare a scrivere il set di caratteri risultante.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, decodifica una sequenza di byte dalla matrice di byte specificata nella matrice di caratteri specificata.</summary>
        <returns>Numero effettivo di caratteri scritti in <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetChars%2A> per archiviare i caratteri risultanti, è consigliabile usare il <xref:System.Text.Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, usare il <xref:System.Text.Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.Encoding.GetCharCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > Ottiene i caratteri da una sequenza di byte di input. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > è diverso da quello <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> perché <xref:System.Text.Encoding> prevede le conversioni discrete, mentre <xref:System.Text.Decoder> è progettato per più passaggi in un singolo flusso di input.  
  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 **Nota** questo metodo è progettato per funzionare con caratteri Unicode e non su dati binari arbitrari, ad esempio matrici di byte. Se è necessario codificare i dati binari arbitrari in testo, è consigliabile usare un protocollo, ad esempio uuencode, che viene implementata dai metodi, ad esempio <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Il <xref:System.Text.Encoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica una sequenza di byte e il <xref:System.Text.Encoding.GetChars%2A> metodo esegue la decodifica effettivo. Il <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> metodo prevede le conversioni discrete, a differenza di <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo che gestisce più passaggi in un singolo flusso di input.  
  
 Diverse versioni di <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> sono supportati. Di seguito sono alcune considerazioni sulla programmazione per l'uso di questi metodi:  
  
-   L'app potrebbe essere necessario decodificare più byte di una tabella codici input ed elaborare i byte usando più chiamate. In questo caso, è probabilmente necessario mantenere lo stato tra chiamate, in quanto le sequenze di byte possono essere interrotta durante l'elaborazione in batch. (Ad esempio, può terminare una parte di una sequenza di MAIUSC ISO-2022 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > chiamare e continua all'inizio del successivo [\], Int32, Int32, Char\<xref : System.Text.Encoding.GetChars%2A > chiamare. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > chiamerà il fallback per le sequenze incompleti, ma <xref:System.Text.Decoder> memorizzerà le sequenze per la chiamata successiva.)  
  
-   Se l'app gestisce gli output di stringa, il <xref:System.Text.Encoding.GetString%2A> metodo è consigliato. Poiché questo metodo deve controllare la lunghezza della stringa e allocare un buffer, è leggermente più lento, ma l'oggetto risultante <xref:System.String> tipo è preferibile.  
  
-   La versione di byte di <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> consente alcune tecniche veloce, in particolare con più chiamate al buffer di grandi dimensioni. Tenere presente, tuttavia, questa versione del metodo è talvolta non sicuro, poiché sono necessari i puntatori.  
  
-   Se l'app deve convertire una grande quantità di dati, è necessario riusare il buffer di output. In questo caso, il [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versione che supporta i caratteri di output i buffer è la scelta migliore.  
  
-   È consigliabile usare la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> invece del metodo <xref:System.Text.Encoding.GetCharCount%2A>. Il metodo di conversione converte il maggior numero possibile di dati e genera un'eccezione se il buffer di output è troppo piccolo. Per la decodifica continua di un flusso, questo metodo è spesso la scelta migliore.  
  
   
  
## Examples  
 Nell'esempio seguente converte una stringa da una codifica a altra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Nell'esempio seguente codifica una stringa in una matrice di byte e quindi le decodifica un intervallo di byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.  
  
oppure 
 <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> o <paramref name="byteCount" /> o <paramref name="charIndex" /> è minore di zero.  
  
oppure 
 <paramref name="byteindex" /> e <paramref name="byteCount" /> non identificano un intervallo valido in <paramref name="bytes" />.  
  
oppure 
 <paramref name="charIndex" /> non è un indice valido in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> non dispone di sufficiente capacità da <paramref name="charIndex" /> alla fine della matrice per contenere i caratteri risultanti.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un decodificatore che converte una sequenza di byte codificata in una sequenza di caratteri.</summary>
        <returns>Oggetto <see cref="T:System.Text.Decoder" /> che converte una sequenza di byte codificata in una sequenza di caratteri.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo converte sequenziali blocchi di byte in blocchi sequenziali di caratteri, in modo simile al <xref:System.Text.Encoding.GetChars%2A> overload di questa classe. Tuttavia, un <xref:System.Text.Decoder> mantiene informazioni sullo stato tra chiamate in modo da poter decodificare correttamente le sequenze di byte che si estendono su blocchi. Il <xref:System.Text.Decoder> anche mantiene byte finali alla fine di blocchi di dati e Usa i byte finali nella successiva operazione di decodifica. Pertanto <xref:System.Text.Encoding.GetDecoder%2A> e <xref:System.Text.Encoding.GetEncoder%2A> sono utili per la trasmissione di rete e operazioni di file, perché queste operazioni utilizzano spesso i blocchi di dati anziché un flusso di dati completo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L'implementazione predefinita restituisce un <see cref="T:System.Text.Decoder" /> che chiama il <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> e <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> metodi dell'oggetto corrente <see cref="T:System.Text.Encoding" />. È necessario eseguire l'override di questo metodo per restituire un <see cref="T:System.Text.Decoder" /> che mantiene il proprio stato tra chiamate.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un codificatore che converte una sequenza di caratteri Unicode in una sequenza di byte codificata.</summary>
        <returns>Oggetto <see cref="T:System.Text.Encoder" /> che converte una sequenza di caratteri Unicode in una sequenza di byte codificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodo converte blocchi sequenziali di caratteri in blocchi sequenziali di byte, in modo simile al <xref:System.Text.Encoding.GetBytes%2A> overload di questa classe. Tuttavia, un <xref:System.Text.Encoder> mantiene informazioni sullo stato tra chiamate in modo che la codifica corretta delle sequenze di caratteri che si estendono su blocchi. Il <xref:System.Text.Encoder> anche mantiene finali caratteri alla fine di blocchi di dati e i caratteri finali nella successiva operazione di codifica. Ad esempio, un blocco di dati può terminare con un carattere surrogato alto non corrispondente e potrebbe essere il surrogato basso corrispondente nel blocco di dati successivo. Pertanto <xref:System.Text.Encoding.GetDecoder%2A> e <xref:System.Text.Encoding.GetEncoder%2A> sono utili per la trasmissione di rete e operazioni di file, perché queste operazioni utilizzano spesso i blocchi di dati anziché un flusso di dati completo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L'implementazione predefinita restituisce un <see cref="T:System.Text.Encoder" /> che chiama il <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> e <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> metodi dell'oggetto corrente <see cref="T:System.Text.Encoding" />. È necessario eseguire l'override di questo metodo per restituire un <see cref="T:System.Text.Encoder" /> che mantiene il proprio stato tra chiamate.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una codifica per la tabella codici specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">Identificatore della tabella codici della codifica scelta. I valori possibili vengono elencati nella colonna Tabella codici della tabella visualizzata nell'argomento della classe <see cref="T:System.Text.Encoding" />.  
  
oppure 
0 (zero), per usare la codifica predefinita.</param>
        <summary>Restituisce la codifica associata all'identificatore della tabella codici specificata.</summary>
        <returns>Codifica associata alla tabella codici specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il gestore di fallback dipende dal tipo di codifica di `codepage`. Se `codepage` è un carattere di codice pagina o a byte doppio (DBCS) codifica del set, viene utilizzato un gestore di fallback con mapping più appropriato. In caso contrario, viene utilizzato un gestore di fallback di sostituzione. Questi gestori fallback potrebbero non essere appropriati per l'app. Per specificare il gestore di fallback usato per la codifica specificata da `codepage`, è possibile chiamare il <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> rapporto di overload.  
  
 In .NET Framework, il <xref:System.Text.Encoding.GetEncoding%2A> metodo si basa sulla piattaforma sottostante per supportare la maggior parte delle tabelle codici. Tuttavia, .NET Framework supporta in modo nativo alcune codifiche. Per un elenco delle tabelle codici, vedere il <xref:System.Text.Encoding> argomento relativo alla classe. In .NET Core, il <xref:System.Text.Encoding.GetEncoding%2A> metodo restituisce le codifiche supportate in modo nativo da .NET Core. In entrambe le implementazioni .NET, è possibile chiamare il <xref:System.Text.Encoding.GetEncodings%2A> metodo per ottenere una matrice di <xref:System.Text.EncodingInfo> gli oggetti che contiene informazioni su tutte le codifiche disponibili. 

 Oltre alle codifiche disponibili in modo nativo in .NET Core o che sono intrinsecamente supportate in una versione specifica della piattaforma di .NET Framework, il <xref:System.Text.Encoding.GetEncoding%2A> metodo viene restituito qualsiasi codifiche aggiuntive rese disponibili tramite la registrazione di un <xref:System.Text.EncodingProvider> oggetti. Se la stessa codifica è stata registrata da più <xref:System.Text.EncodingProvider> oggetti, questo metodo restituisce l'ultimo registrato.  

È anche possibile fornire un valore pari a 0 per il `codepage` argomento. Il comportamento preciso dipende dal fatto che tutte le codifiche sono stati resi disponibili tramite la registrazione un <xref:System.Text.EncodingProvider> oggetto:

- Se uno o più provider di codifica sono state registrate, restituisce la codifica dell'ultimo provider registrati che ha scelto di restituire una codifica quando la <xref:System.Text.Encoding.GetEncoding%2A> viene passato un `codepage` argomento 0.     

- In .NET Framework, se nessuna codifica provider è stato registrato, se il <xref:System.Text.CodePagesEncodingProvider> è il provider di codifica registrato, oppure se nessun provider di codifica registrati gestisce un `codepage` valore pari a 0, restituisce tabella codici attiva del sistema operativo. Per determinare la tabella codici attiva nei sistemi Windows, chiamare il Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) (funzione) da .NET Framework sul desktop di Windows.

- In .NET Core, se non sono stati registrati provider di codifica o se nessun provider di codifica registrati gestisce un `codepage` valore pari a 0, restituisce il <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Alcuni codici non supportate delle pagine causa un <xref:System.ArgumentException> eccezione, mentre altre causano un <xref:System.NotSupportedException>. Pertanto, il codice deve rilevare tutte le eccezioni indicate nella sezione delle eccezioni.  
  
> [!NOTE]
>  Le tabelle codici ANSI possono essere diverse in computer diversi e possono modificare in un singolo computer, causando il danneggiamento dei dati. Per questo motivo, se la tabella codici attiva è una tabella codici ANSI, codifica e decodifica i dati usando la tabella codici predefinita restituita da `Encoding.GetEncoding(0)` non è consigliata. Per ottenere risultati più coerenti, è consigliabile usare una codifica Unicode, ad esempio UTF-16 o UTF-8 (tabella codici 65001) invece di una tabella codici specifica.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Restituisce un'istanza memorizzata nella cache con le impostazioni predefinite. È consigliabile utilizzare i costruttori delle classi derivate per ottenere un'istanza con impostazioni diverse. Ad esempio, il <xref:System.Text.UTF32Encoding> classe fornisce un costruttore che consente di abilitare il rilevamento errori.  

   
  
## Examples  
 Nell'esempio seguente ottiene due istanze della stessa codifica (uno dalla tabella codici) e l'altro in base al nome e viene verificata l'eguaglianza.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> è minore di zero o maggiore di 65535.</exception>
        <exception cref="T:System.ArgumentException">La classe <paramref name="codepage" /> non è supportata nella piattaforma sottostante.</exception>
        <exception cref="T:System.NotSupportedException">La classe <paramref name="codepage" /> non è supportata nella piattaforma sottostante.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome della tabella codici della codifica scelta. Qualsiasi valore restituito dalla proprietà <see cref="P:System.Text.Encoding.WebName" /> è valido. I valori possibili vengono elencati nella colonna Nome della tabella visualizzata nell'argomento della classe <see cref="T:System.Text.Encoding" />.</param>
        <summary>Restituisce la codifica associata al nome della tabella codici specificata.</summary>
        <returns>Codifica associata alla tabella codici specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il gestore di fallback dipende dal tipo di codifica di `name`. Se `name` è un carattere di codice pagina o a byte doppio (DBCS) codifica del set, viene utilizzato un gestore di fallback con mapping più appropriato. In caso contrario, viene utilizzato un gestore di fallback di sostituzione. Questi gestori fallback potrebbero non essere appropriati per l'app. Per specificare il gestore di fallback usato per la codifica specificata da `name`, è possibile chiamare il <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> rapporto di overload.  

In .NET Framework, il <xref:System.Text.Encoding.GetEncoding%2A> metodo si basa sulla piattaforma sottostante per supportare la maggior parte delle tabelle codici. Tuttavia, .NET Framework supporta in modo nativo alcune codifiche. Per un elenco delle tabelle codici, vedere il <xref:System.Text.Encoding> argomento relativo alla classe. In .NET Core, il <xref:System.Text.Encoding.GetEncoding%2A> metodo restituisce le codifiche supportate in modo nativo da .NET Core. In entrambe le implementazioni .NET, è possibile chiamare il <xref:System.Text.Encoding.GetEncodings%2A> metodo per ottenere una matrice di <xref:System.Text.EncodingInfo> gli oggetti che contiene informazioni su tutte le codifiche disponibili. 

 Oltre alle codifiche disponibili in modo nativo in .NET Core o che sono intrinsecamente supportate in una versione specifica della piattaforma di .NET Framework, il <xref:System.Text.Encoding.GetEncoding%2A> metodo viene restituito qualsiasi codifiche aggiuntive rese disponibili tramite la registrazione di un <xref:System.Text.EncodingProvider> oggetti. Se la stessa codifica è stata registrata da più <xref:System.Text.EncodingProvider> oggetti, questo metodo restituisce l'ultimo registrato.  
   
> [!NOTE]
>  Le tabelle codici ANSI possono essere diverse in computer diversi, o possono essere modificate per un singolo computer, causando il danneggiamento dei dati. Per ottenere risultati più coerenti, è necessario utilizzare Unicode, ad esempio UTF-16 o UTF-8 (tabella codici 65001) invece di una tabella codici specifica.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Restituisce un'istanza memorizzata nella cache con le impostazioni predefinite. È consigliabile utilizzare i costruttori delle classi derivate per ottenere un'istanza con impostazioni diverse. Ad esempio, il <xref:System.Text.UTF32Encoding> classe fornisce un costruttore che consente di abilitare il rilevamento errori.  
  
## Examples  
 Nell'esempio seguente ottiene due istanze della stessa codifica (uno dalla tabella codici) e l'altro in base al nome e viene verificata l'eguaglianza.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> non è un nome di tabella codici valido.  
  
oppure 
La tabella codici indicata da <paramref name="name" /> non è supportata nella piattaforma sottostante.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">Identificatore della tabella codici della codifica scelta. I valori possibili vengono elencati nella colonna Tabella codici della tabella visualizzata nell'argomento della classe <see cref="T:System.Text.Encoding" />.  
  
oppure 
0 (zero), per usare la codifica predefinita.</param>
        <param name="encoderFallback">Oggetto che fornisce una procedura di gestione degli errori quando un carattere non può essere codificato con la codifica corrente.</param>
        <param name="decoderFallback">Oggetto che fornisce una procedura di gestione degli errori quando una sequenza di byte non può essere decodificata con la codifica corrente.</param>
        <summary>Restituisce la codifica associata all'identificatore della tabella codici specificata. I parametri specificano un gestore errori per i caratteri che non possono essere codificati e per le sequenze di byte che non possono essere decodificate.</summary>
        <returns>Codifica associata alla tabella codici specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Alcune tabelle codici non supportata causano l'eccezione <xref:System.ArgumentException> eccezione, mentre altre causano <xref:System.NotSupportedException>. Pertanto, il codice deve rilevare tutte le eccezioni indicate nella sezione delle eccezioni.  

In .NET Framework, il <xref:System.Text.Encoding.GetEncoding%2A> metodo si basa sulla piattaforma sottostante per supportare la maggior parte delle tabelle codici. Tuttavia, .NET Framework supporta in modo nativo alcune codifiche. Per un elenco delle tabelle codici, vedere il <xref:System.Text.Encoding> argomento relativo alla classe. In .NET Core, il <xref:System.Text.Encoding.GetEncoding%2A> metodo restituisce le codifiche supportate in modo nativo da .NET Core. In entrambe le implementazioni .NET, è possibile chiamare il <xref:System.Text.Encoding.GetEncodings%2A> metodo per ottenere una matrice di <xref:System.Text.EncodingInfo> gli oggetti che contiene informazioni su tutte le codifiche disponibili. 

 Oltre alle codifiche disponibili in modo nativo in .NET Core o che sono intrinsecamente supportate in una versione specifica della piattaforma di .NET Framework, il <xref:System.Text.Encoding.GetEncoding%2A> metodo viene restituito qualsiasi codifiche aggiuntive rese disponibili tramite la registrazione di un <xref:System.Text.EncodingProvider> oggetti. Se la stessa codifica è stata registrata da più <xref:System.Text.EncodingProvider> oggetti, questo metodo restituisce l'ultimo registrato.  

È anche possibile fornire un valore pari a 0 per il `codepage` argomento. Il comportamento preciso dipende dal fatto che tutte le codifiche sono stati resi disponibili tramite la registrazione un <xref:System.Text.EncodingProvider> oggetto:

- Se uno o più provider di codifica sono state registrate, restituisce la codifica dell'ultimo provider registrati che ha scelto di restituire una codifica quando la <xref:System.Text.Encoding.GetEncoding%2A> viene passato un `codepage` argomento 0.     

- In .NET Framework, se nessuna codifica provider è stato registrato, se il <xref:System.Text.CodePagesEncodingProvider> è il provider di codifica registrato, oppure se nessun provider di codifica registrati gestisce un `codepage` valore pari a 0, restituisce la tabella codici attiva.

- In .NET Core, se non sono stati registrati provider di codifica o se nessun provider di codifica registrati gestisce un `codepage` valore pari a 0, restituisce il <xref:System.Text.UTF8Encoding> codifica.

> [!NOTE]
>  Le tabelle codici ANSI possono essere diverse in computer diversi e possono modificare in un singolo computer, causando il danneggiamento dei dati. Per questo motivo, se la tabella codici attiva è una tabella codici ANSI, codifica e decodifica i dati usando la tabella codici predefinita restituita da `Encoding.GetEncoding(0)` non è consigliata. Per ottenere risultati più coerenti, è necessario utilizzare Unicode, ad esempio UTF-16 o UTF-8 (tabella codici 65001) invece di una tabella codici specifica. 
  
 Per ottenere la codifica associata la tabella codici attiva, è possibile specificare sia un valore pari a 0 per il `codepage` argomento o, se il codice è in esecuzione su .NET Framework sul desktop di Windows, recuperare il valore della <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> proprietà. Per determinare la tabella codici attiva corrente, chiamare il Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) (funzione) da .NET Framework sul desktop di Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Restituisce un'istanza memorizzata nella cache con le impostazioni predefinite. È consigliabile utilizzare i costruttori delle classi derivate per ottenere un'istanza con impostazioni diverse. Ad esempio, il <xref:System.Text.UTF32Encoding> classe fornisce un costruttore che consente di abilitare il rilevamento errori.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> (metodo).  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> è minore di zero o maggiore di 65535.</exception>
        <exception cref="T:System.ArgumentException">La classe <paramref name="codepage" /> non è supportata nella piattaforma sottostante.</exception>
        <exception cref="T:System.NotSupportedException">La classe <paramref name="codepage" /> non è supportata nella piattaforma sottostante.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">Nome della tabella codici della codifica scelta. Qualsiasi valore restituito dalla proprietà <see cref="P:System.Text.Encoding.WebName" /> è valido. I valori possibili vengono elencati nella colonna Nome della tabella visualizzata nell'argomento della classe <see cref="T:System.Text.Encoding" />.</param>
        <param name="encoderFallback">Oggetto che fornisce una procedura di gestione degli errori quando un carattere non può essere codificato con la codifica corrente.</param>
        <param name="decoderFallback">Oggetto che fornisce una procedura di gestione degli errori quando una sequenza di byte non può essere decodificata con la codifica corrente.</param>
        <summary>Restituisce la codifica associata al nome della tabella codici specificata. I parametri specificano un gestore errori per i caratteri che non possono essere codificati e per le sequenze di byte che non possono essere decodificate.</summary>
        <returns>Codifica associata alla tabella codici specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

In .NET Framework, il <xref:System.Text.Encoding.GetEncoding%2A> metodo si basa sulla piattaforma sottostante per supportare la maggior parte delle tabelle codici. Tuttavia, .NET Framework supporta in modo nativo alcune codifiche. Per un elenco delle tabelle codici, vedere il <xref:System.Text.Encoding> argomento relativo alla classe. In .NET Core, il <xref:System.Text.Encoding.GetEncoding%2A> metodo restituisce le codifiche supportate in modo nativo da .NET Core. In entrambe le implementazioni .NET, è possibile chiamare il <xref:System.Text.Encoding.GetEncodings%2A> metodo per ottenere una matrice di <xref:System.Text.EncodingInfo> gli oggetti che contiene informazioni su tutte le codifiche disponibili. 

 Oltre alle codifiche disponibili in modo nativo in .NET Core o che sono intrinsecamente supportate in una versione specifica della piattaforma di .NET Framework, il <xref:System.Text.Encoding.GetEncoding%2A> metodo viene restituito qualsiasi codifiche aggiuntive rese disponibili tramite la registrazione di un <xref:System.Text.EncodingProvider> oggetti. Se la stessa codifica è stata registrata da più <xref:System.Text.EncodingProvider> oggetti, questo metodo restituisce l'ultimo registrato.  
  
> [!NOTE]
>  Le tabelle codici ANSI possono essere diverse in computer diversi e possono modificare in un singolo computer, causando il danneggiamento dei dati. Per ottenere risultati più coerenti, è consigliabile usare una codifica Unicode, ad esempio UTF-16 o UTF-8 (tabella codici 65001) invece di una tabella codici specifica.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Restituisce un'istanza memorizzata nella cache con le impostazioni predefinite. È consigliabile utilizzare i costruttori delle classi derivate per ottenere un'istanza con impostazioni diverse. Ad esempio, il <xref:System.Text.UTF32Encoding> classe fornisce un costruttore che consente di abilitare il rilevamento errori.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> (metodo).  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> non è un nome di tabella codici valido.  
  
oppure 
La tabella codici indicata da <paramref name="name" /> non è supportata nella piattaforma sottostante.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice contenente tutte le codifiche.</summary>
        <returns>Matrice contenente tutte le codifiche.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce un elenco di codifiche supportate, in modo univoco distinte dalla tabella codici. Per una tabella che elenca le codifiche supportate, vedere il <xref:System.Text.Encoding> argomento relativo alla classe.  
  
> [!NOTE]
>  L'elenco di codifiche supportate restituite dai <xref:System.Text.Encoding.GetEncodings%2A> metodo non include alcun codifiche aggiuntive rese disponibili da qualsiasi <xref:System.Text.EncodingProvider> implementazioni che sono state registrate dalle chiamate al <xref:System.Text.Encoding.RegisterProvider%2A> (metodo).  
  
 In .NET Framework, le codifiche 50220 e 50222 sono entrambi associati al nome "iso-2022-jp", ma non sono identici. La codifica 50220 converte i caratteri Katakana a metà larghezza in caratteri Katakana a larghezza intera, mentre la codifica 50222 Usa una sequenza di MAIUSC/MAIUSC-annullamento per codificare i caratteri Katakana a metà larghezza. È il nome visualizzato per la codifica 50222 "giapponese (JIS-consente Kana - 1 byte pertanto / SI)" per distinguerla dalla codifica 50220, con la visualizzazione dei nomi "giapponese (JIS)".  
  
 Se si richiede il nome di codifica "iso-2022-jp", .NET Framework restituisce la codifica 50220. La codifica appropriata per l'app dipende tuttavia la modalità di gestione preferito dei caratteri Katakana a metà larghezza.  
  
 Per ottenere una codifica specifica, è consigliabile usare il <xref:System.Text.Encoding.GetEncoding%2A> (metodo).  
  
 <xref:System.Text.Encoding.GetEncodings%2A> Talvolta viene usato per presentare all'utente un elenco di codifiche in un File **Salva con nome** nella finestra di dialogo. Tuttavia, molte codifiche non Unicode sono incompleti e numero di caratteri da convertire "?", oppure ha un comportamento leggermente diverso per piattaforme diverse. È consigliabile usare UTF-8 o UTF-16 come impostazione predefinita.  
  
   
  
## Examples  
 L'esempio seguente controlla i valori di proprietà booleane di ogni tipo di codifica.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza corrente.</summary>
        <returns>Codice hash per l'istanza corrente.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</summary>
        <returns>Numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `charCount` parametro specifica effettivamente il numero di <xref:System.Char> gli oggetti che rappresentano i caratteri Unicode da codificare, poiché .NET, UTF-16 viene utilizzata internamente per rappresentare caratteri Unicode. Di conseguenza, la maggior parte dei caratteri Unicode possono essere rappresentati da uno <xref:System.Char> oggetti, ma un carattere Unicode rappresentato da una coppia di surrogati, ad esempio, richiede due <xref:System.Char> oggetti.  
  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetBytes%2A> per archiviare i byte risultanti, è consigliabile usare il <xref:System.Text.Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, usare il <xref:System.Text.Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.Encoding.GetByteCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> Recupera un numero riflette il caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.EncoderFallback>. Se si sceglie un fallback con una stringa di grandi dimensioni, <xref:System.Text.Encoding.GetMaxByteCount%2A> recupera i valori di grandi dimensioni, in particolare nei casi in cui il peggiore dei casi per la codifica implica cambio modalità per ogni carattere. Ad esempio, può verificarsi per ISO-2022-JP. Per altre informazioni, vedere il post di blog "[What ' s con Encoding.GetMaxByteCount() ed Encoding.GetMaxCharCount()?](http://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 Nella maggior parte dei casi, questo metodo recupera i valori accettabili per le stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grande e individuare gli errori nei rari casi, quando un buffer più ragionevole è troppo piccolo. È anche possibile provare a usare un approccio diverso <xref:System.Text.Encoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Quando si usa <xref:System.Text.Encoding.GetMaxByteCount%2A>, è consigliabile allocare il buffer di output in base alla dimensione massima del buffer di input. Se il buffer di output è vincolato di dimensioni, è possibile usare il <xref:System.Text.Encoding.Convert%2A> (metodo).  
  
 Si noti che <xref:System.Text.Encoding.GetMaxByteCount%2A> prende in considerazione potenziali surrogati residui da una precedente operazione decodificatore. A causa del decodificatore, passando il valore 1 per il metodo recupera 2 per una codifica a byte singolo, ad esempio ASCII. È consigliabile usare il <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> proprietà se queste informazioni sono necessarie.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` non è necessariamente lo stesso valore `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per la codifica una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> è minore di zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Tutti i <see cref="T:System.Text.Encoding" /> implementazioni devono garantire che nessuna eccezione di overflow del buffer si verificano se i buffer vengono ridimensionati in base ai risultati dei calcoli di questo metodo.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, calcola il numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</summary>
        <returns>Numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.Encoding.GetChars%2A> per archiviare i caratteri risultanti, è consigliabile usare il <xref:System.Text.Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, usare il <xref:System.Text.Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.Encoding.GetCharCount%2A> metodo consente in genere l'allocazione di memoria inferiore, mentre il <xref:System.Text.Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> Recupera un numero riflette il caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.DecoderFallback>. Se si sceglie un fallback con una stringa di grandi dimensioni, <xref:System.Text.Encoding.GetMaxCharCount%2A> recupera i valori di grandi dimensioni.  
  
 Nella maggior parte dei casi, questo metodo recupera i numeri di ragionevoli per stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grande e individuare gli errori nel raro caso che un buffer più ragionevole è troppo piccolo. È anche possibile provare a usare un approccio diverso <xref:System.Text.Encoding.GetCharCount%2A> o <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> non ha alcuna relazione di <xref:System.Text.Encoding.GetBytes%2A>. Se si necessita di una funzione simile da utilizzare con <xref:System.Text.Encoding.GetBytes%2A>, è consigliabile usare <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Quando si usa <xref:System.Text.Encoding.GetMaxCharCount%2A>, è consigliabile allocare il buffer di output in base alla dimensione massima del buffer di input. Se il buffer di output è vincolato di dimensioni, è possibile usare il <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> (metodo).  
  
 Si noti che <xref:System.Text.Encoding.GetMaxCharCount%2A> prende in considerazione il caso peggiore per byte rimasti da una precedente operazione del codificatore. Per la maggior parte delle tabelle codici, passando il valore 0 a questo metodo recupera i valori maggiori o uguali a 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` non è necessariamente lo stesso valore `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa in una matrice di byte e quindi le decodifica i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> è minore di zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Tutti i <see cref="T:System.Text.Encoding" /> implementazioni devono garantire che nessuna eccezione di overflow del buffer si verificano se i buffer vengono ridimensionati in base ai risultati dei calcoli di questo metodo.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, restituisce una sequenza di byte che specifica la codifica usata.</summary>
        <returns>Matrice di byte contenente una sequenza di byte che specifica la codifica usata.  
  
oppure 
Matrice di byte di lunghezza zero, se non è necessario alcun preambolo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Facoltativamente, il <xref:System.Text.Encoding> oggetto fornisce un preambolo che rappresenta una matrice di byte che può essere anteposto alla sequenza di byte risultante dal processo di codifica. Se il preambolo contiene un byte order mark (in formato Unicode, il punto di codice U + FEFF), consente il decodificatore di determinare l'ordine dei byte e il formato di trasformazione o UTF.  
  
 Il byte order mark Unicode (BOM) viene serializzato nel modo seguente (in esadecimale):  
  
-   UTF-8: EF BB BF  
  
-   Ordine dei byte UTF-16 big endian: FF FE  
  
-   L'ordine dei byte little-endian UTF-16 little: FF FE  
  
-   Ordine dei byte big-endian UTF-32: 00 00 FF FE  
  
-   Ordine dei byte little-endian little UTF-32: FF FE 00 00  
  
 È consigliabile usare il carattere BOM, perché offre quasi determinati identificazione di una codifica per i file che non hanno più riferimento al <xref:System.Text.Encoding> oggetto, ad esempio, senza codifica o dati web o i file di testo casuale archiviati quando un'azienda non è stato eseguito avere preoccupazioni internazionali o altri dati. Spesso i problemi dell'utente potrebbero essere evitati se i dati in modo coerente e appropriato tag, preferibilmente in UTF-8 o UTF-16.  
  
 Per gli standard che forniscono un tipo di codifica, una distinta base è in parte ridondante. Tuttavia, può essere utilizzato per consentire a un server di inviare l'intestazione di codifica corretta. In alternativa, può essere utilizzato come fallback in caso contrario, la codifica viene perduta.  
  
 Esistono alcuni svantaggi dell'utilizzo di un carattere BOM. Ad esempio, può essere difficile sapere come limitare i campi del database che usano un carattere BOM. Concatenazione dei file può rappresentare un problema, inoltre, ad esempio, quando i file vengono uniti in tale modo un carattere non necessario può finire al centro dati. Nonostante alcuni svantaggi, tuttavia, l'uso di un carattere BOM è consigliabile.  
  
 Per altre informazioni sull'ordine dei byte e il byte order mark, vedere lo Unicode Standard nella [home page di Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Per garantire che i byte con codificati vengono decodificati correttamente, si deve aggiungere byte codificati con un preambolo. Tuttavia, la maggior parte delle codifiche non forniscono un preambolo. Per garantire che vengano decodificati correttamente i byte con codificati, è consigliabile usare una codifica Unicode, vale a dire <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, o <xref:System.Text.UTF32Encoding>, con un preambolo.  
  
   
  
## Examples  
 Nell'esempio seguente determina l'ordine dei byte della codifica in base al preambolo.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, decodifica una sequenza di byte in una stringa.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, decodifica tutti i byte nella matrice di byte specificata in una stringa.</summary>
        <returns>Stringa contenente i risultati di decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare il <xref:System.Text.Decoder> oggetto restituito dal <xref:System.Text.Encoding.GetDecoder%2A> di un deri (metodo) classe vate.  
  
 Vedere la sezione Osservazioni del <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> argomento di riferimento per una descrizione delle considerazioni e le tecniche di decodifica.  
  
 Si noti che il comportamento preciso del <xref:System.Text.Encoding.GetString%2A> metodo per un particolare <xref:System.Text.Encoding> implementazione dipende dalla strategia di fallback definita per tale <xref:System.Text.Encoding> oggetto. Per altre informazioni, vedere la sezione "Scelta di una strategia di Fallback" del [codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) argomento.  
  
   
  
## Examples  
 Nell'esempio seguente legge una stringa con codificata UTF-8 da un file binario rappresentato da un <xref:System.IO.FileStream> oggetto. Per i file sono inferiori a 2048 byte, legge il contenuto dell'intero file in una matrice di byte e chiama il <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> metodo per eseguire la decodifica. Per i file più grandi, legge 2.048 byte alla volta in una matrice di byte, chiama il <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per determinare il numero di caratteri contenuti nella matrice e quindi chiama il <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> metodo per eseguire la decodifica.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 L'esempio Usa il testo seguente, che deve essere salvato in un file con codificata UTF-8 denominato Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matrice di byte contiene punti di codice Unicode non validi.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore a una matrice di byte.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, decodifica un numero di byte specificato partendo da un indirizzo specificato in una stringa.</summary>
        <returns>Stringa contenente i risultati di decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoding.GetString%2A> metodo è progettato per ottimizzare le prestazioni quando si dispone di un puntatore nativo in una matrice di byte. Invece di creare una matrice di byte gestita e averlo decodificato, è invece possibile chiamare questo metodo senza dover creare eventuali oggetti intermedi.  
  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare il <xref:System.Text.Decoder> oggetto restituito dal <xref:System.Text.Encoding.GetDecoder%2A> di un deri (metodo) classe vate.  
  
 Vedere la sezione Osservazioni del <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> argomento di riferimento per una descrizione delle considerazioni e le tecniche di decodifica.  
  
 Si noti che il comportamento preciso del <xref:System.Text.Encoding.GetString%2A> metodo per un particolare <xref:System.Text.Encoding> implementazione dipende dalla strategia di fallback definita per tale <xref:System.Text.Encoding> oggetto. Per altre informazioni, vedere la sezione "Scelta di una strategia di Fallback" del [codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) argomento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è un puntatore Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> è minore di zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, decodifica una sequenza di byte dalla matrice di byte specificata in una stringa.</summary>
        <returns>Stringa contenente i risultati di decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se i dati da convertire sono disponibili solo nei blocchi sequenziali (ad esempio, i dati letti da un flusso) o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, è consigliabile usare la <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dal <xref:System.Text.Encoding.GetDecoder%2A> metodo o il <xref:System.Text.Encoding.GetEncoder%2A> metodo, rispettivamente, di una classe derivata.  
  
 Vedere la sezione Osservazioni del <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> argomento di riferimento per una descrizione delle considerazioni e le tecniche di decodifica.  
  
   
  
## Examples  
 Nell'esempio seguente legge una stringa con codificata UTF-8 da un file binario che è rappresentato da un <xref:System.IO.FileStream> oggetto. Per i file sono inferiori a 2048 byte, legge il contenuto dell'intero file in una matrice di byte e chiama il <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo per eseguire la decodifica. Per i file più grandi, legge 2.048 byte alla volta in una matrice di byte, chiama il <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per determinare il numero di caratteri contenuti nella matrice e quindi chiama il <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> metodo per eseguire la decodifica.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 L'esempio Usa il testo seguente, che deve essere salvato in un file con codificata UTF-8 denominato Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matrice di byte contiene punti di codice Unicode non validi.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un nome per la codifica corrente che può essere usato con i tag di intestazione degli agenti di posta.</summary>
        <value>Nome dell'oggetto <see cref="T:System.Text.Encoding" /> corrente da usare con i tag di intestazione degli agenti di posta.  
  
oppure 
Stringa vuota (""), se non è possibile usare l'oggetto <see cref="T:System.Text.Encoding" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è necessaria una codifica per un nome di intestazione, è necessario chiamare il <xref:System.Text.Encoding.GetEncoding%2A> metodo con il <xref:System.Text.Encoding.HeaderName%2A> proprietà. Spesso il metodo recupera una codifica diversa dalla codifica di test fornita nella chiamata. Solo le applicazioni di posta elettronica in genere necessario recuperare tale codifica.  
  
 In alcuni casi, il valore della <xref:System.Text.Encoding.BodyName%2A> proprietà corrisponde allo standard internazionale che definisce tale codifica. Ciò non significa che l'implementazione sia conforme in modo completo con tale standard.  
  
 Si noti che <xref:System.Text.Encoding.WebName%2A> restituisce il nome da utilizzare per descrivere una codifica. Il <xref:System.Text.Encoding.HeaderName%2A> definisce proprietà che potrebbe funzionare meglio per un'applicazione di posta elettronica, ad esempio una codifica diversa. Tuttavia, non è consigliabile usare la proprietà da definire la codifica.  
  
   
  
## Examples  
 Nell'esempio seguente vengono recuperati i nomi diversi per ogni tipo di codifica e visualizza le codifiche con uno o più nomi diversi da <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Visualizza <xref:System.Text.Encoding.EncodingName%2A> ma non compare su di esso.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un valore che indica se la codifica corrente è sempre normalizzata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un valore che indica se la codifica corrente è sempre normalizzata, usando il formato di normalizzazione predefinito.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Text.Encoding" /> corrente è sempre normalizzato; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il formato di normalizzazione predefinito è <xref:System.Text.NormalizationForm.FormC>, che usa una scomposizione canonica completa, seguita dalla sostituzione delle sequenze con i relativi componenti primari, se possibile.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Uno dei valori di <see cref="T:System.Text.NormalizationForm" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se la codifica corrente viene sempre normalizzata, usando il formato di normalizzazione specificato.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Text.Encoding" /> corrente viene sempre normalizzato usando il valore di <see cref="T:System.Text.NormalizationForm" /> specificato; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il formato di normalizzazione predefinito è <xref:System.Text.NormalizationForm.FormC>, che usa una scomposizione canonica completa, seguita dalla sostituzione delle sequenze con i relativi componenti primari, se possibile.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se la codifica corrente può essere usata dai browser client per visualizzare il contenuto.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Text.Encoding" /> corrente può essere utilizzato dai browser client per visualizzare il contenuto; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente controlla i valori di proprietà booleane di ogni tipo di codifica.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se la codifica corrente può essere usata dai browser client per salvare il contenuto.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Text.Encoding" /> corrente può essere utilizzato dai browser client per salvare il contenuto; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente controlla i valori di proprietà booleane di ogni tipo di codifica.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se la codifica corrente può essere usata dai client di posta e dai client delle news per visualizzare il contenuto.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Text.Encoding" /> corrente può essere utilizzato dai client di posta e dai client delle news per visualizzare il contenuto; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente controlla i valori di proprietà booleane di ogni tipo di codifica.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se la codifica corrente può essere usata dai client di posta e dai client delle news per salvare il contenuto.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Text.Encoding" /> corrente può essere usato dai client di posta e dai client delle news per salvare il contenuto; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente controlla i valori di proprietà booleane di ogni tipo di codifica.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se la codifica corrente è di sola lettura.</summary>
        <value>
          <see langword="true" /> se la classe <see cref="T:System.Text.Encoding" /> corrente è in sola lettura; in caso contrario <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene un valore che indica se la codifica corrente usa punti di codice a un byte.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Text.Encoding" /> corrente utilizza punti di codice a un byte; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un byte singolo di codifica, ad esempio, <xref:System.Text.ASCIIEncoding>, questa proprietà recupera `true`.  
  
> [!CAUTION]
>  È necessario prestare attenzione nella funzione con il valore per l'applicazione <xref:System.Text.Encoding.IsSingleByte%2A>. Un presupposto del modo in cui sarà possibile proseguire una codifica potrebbe risultare errato. Ad esempio, Windows-1252 ha un valore pari `true` per <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, ma Encoding.GetMaxByteCount(1) restituisce 2. Questo avviene perché il metodo prende in considerazione potenziali surrogati residui da una precedente operazione decodificatore.  
  
   
  
## Examples  
 L'esempio seguente controlla i valori di proprietà booleane di ogni tipo di codifica.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Sottoclasse di <see cref="T:System.Text.EncodingProvider" /> che fornisce l'accesso a codifiche caratteri aggiuntive.</param>
        <summary>Registra un provider di codifica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoding.RegisterProvider%2A> metodo consente di registrare una classe derivata da <xref:System.Text.EncodingProvider> che rende carattere le codifiche disponibili in una piattaforma che non in caso contrario, li supporta. Dopo aver registrato il provider di codifica, le codifiche supportate possono essere recuperate chiamando qualsiasi <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> rapporto di overload. Se sono presenti più provider di codifica, la <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> metodo tenta di recuperare una codifica specificata da ogni provider a partire da quello registrato più di recente.

Registrazione di un provider di codifica utilizzando il <xref:System.Text.Encoding.RegisterProvider%2A> metodo modifica anche il comportamento del [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) e [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) metodi quando viene passato un argomento di `0`:

- Se il provider registrato è il <xref:System.Text.CodePagesEncodingProvider>, il metodo restituisce il tipo di codifica che corrisponde alla tabella codici attiva di sistema durante l'esecuzione nel sistema operativo Windows.

- Un provider di codifica personalizzato è possibile scegliere la codifica da restituire quando uno di questi <xref:System.Text.Encoding.GetEncoding%2A> overload del metodo è stato passato un argomento di `0`. Il provider può anche scegliere di non restituire una codifica facendo in modo che il <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> metodo viene restituito `null`. 
  
A partire da .NET Framework 4.6, .NET Framework include un provider di codifica, <xref:System.Text.CodePagesEncodingProvider>, che rende disponibili le codifiche sono presenti in .NET Framework completo, ma non sono disponibili nella piattaforma Windows universale. Per impostazione predefinita, la piattaforma universale di Windows supporta solo le codifiche Unicode, ASCII e tabella codici 28591.  
  
 Se viene utilizzato lo stesso provider di codifica in più chiamate al <xref:System.Text.Encoding.RegisterProvider%2A> (metodo), solo la prima chiamata al metodo registra il provider. Le chiamate successive vengono ignorate.  
  
 Se il <xref:System.Text.Encoding.RegisterProvider%2A> viene chiamato per registrare più provider che gestiscono la stessa codifica, l'ultimo provider registrato è l'oggetto utilizzato per tutte le operazioni di operazioni di decodifica e codifica. Tutti i provider registrati in precedenza vengono ignorati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una codifica per il formato UTF-16 che usa l'ordine dei byte little endian.</summary>
        <value>Codifica per il formato UTF-16 che usa l'ordine dei byte little-endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sulle codifiche supportate da .NET e una descrizione della codifica Unicode da usare, vedere [codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Il <xref:System.Text.UnicodeEncoding> oggetto restituito da questa proprietà non abbia il comportamento appropriato per l'app. Usa il fallback di sostituzione per sostituire ogni stringa che non può codificare e ogni byte che non può decodificare con un punto interrogativo ("?") caratteri. In alternativa, è possibile chiamare il <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> costruttore per creare un'istanza di little endian <xref:System.Text.UnicodeEncoding> oggetto il cui fallback è un' <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per la codifica una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una codifica per il formato UTF-32 che usa l'ordine dei byte little endian.</summary>
        <value>Oggetto codifica per il formato UTF-32 che usa l'ordine dei byte little-endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.UTF32Encoding> oggetto restituito da questa proprietà non abbia il comportamento appropriato per l'app. Usa il fallback di sostituzione per sostituire ogni byte che non può decodificare e ogni stringa che non può codificare con il carattere Unicode REPLACEMENT CHARACTER (U + FFFE). In alternativa, è possibile chiamare il <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> costruttore per creare un'istanza di un <xref:System.Text.UTF32Encoding> oggetto il cui fallback è un' <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Per una descrizione dell'ordine dei byte little-endian little, vedere il <xref:System.Text.Encoding> argomento relativo alla classe.  
  
 Per informazioni sulle codifiche supportate da .NET e una descrizione della codifica Unicode da usare, vedere [codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per la codifica una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una codifica per il formato UTF-7.</summary>
        <value>Codifica per il formato UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica UTF-7 viene usata principalmente in ambienti che storicamente sono state applicate restrizioni a 7 bit, ad esempio NNTP e alcune applicazioni di posta elettronica. A causa di problemi con affidabilità e sicurezza, è consigliabile non usare UTF7 codifica negli ambienti a 8 bit in cui la codifica UTF-8 è invece possibile utilizzare.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per la codifica una matrice di caratteri vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una codifica per il formato UTF-8.</summary>
        <value>Codifica per il formato UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce un <xref:System.Text.UTF8Encoding> oggetto che consente di codificare i caratteri Unicode (codifica UTF-16) in una sequenza di uno a quattro byte per carattere, e che consente di decodificare una matrice di byte con codifica UTF-8 per i caratteri Unicode (codifica UTF-16). Per informazioni sulle codifiche di caratteri supportate da .NET e una descrizione della codifica Unicode da usare, vedere [codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Il <xref:System.Text.UTF8Encoding> oggetto restituito da questa proprietà potrebbe non avere il comportamento appropriato per l'app.  
  
-   Restituisce un <xref:System.Text.UTF8Encoding> oggetto che fornisce un byte order mark Unicode (BOM). Per creare un'istanza di una codifica UTF8, che non fornisce un carattere BOM, chiamare un overload del <xref:System.Text.UTF8Encoding.%23ctor%2A> costruttore.  
  
-   Restituisce un <xref:System.Text.UTF8Encoding> oggetto che usa il fallback di sostituzione per sostituire ogni stringa che non può codificare e ogni byte che non può decodificare con un punto interrogativo ("?") caratteri. In alternativa, è possibile chiamare il <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> costruttore per creare un'istanza di un <xref:System.Text.UTF8Encoding> oggetto il cui fallback è un' <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 L'esempio seguente definisce una matrice che include i caratteri seguenti:  
  
-   ALFABETO LATINO Z (U + 007A)  
  
-   LATINO LETTER (U + 0061)  
  
-   COMBINAZIONE MACCHIATO (U + 0306)  
  
-   ALFABETO LATINO ALWAYS ENCRYPTED CON ACUTA (U + 01FD)  
  
-   LETTERA GRECA BETA (U + 03B2)  
  
-   Una coppia di surrogati (U + D800 a U + DD54) che costituisce greco ACROPHONIC ATTIC una delle MIGLIAIA STATERS (U + 10154).  
  
 Visualizza le unità di codice UTF-16 di ciascun carattere e determina il numero di byte necessari da un codificatore UTF-8 per codificare la matrice di caratteri. Quindi vengono codificati i caratteri e visualizza il numero di byte con codifica UTF-8 risultante.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene il nome registrato con IANA (Internet Assigned Numbers Authority) per la codifica corrente.</summary>
        <value>Nome IANA per l'oggetto <see cref="T:System.Text.Encoding" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoding.WebName%2A> proprietà è lo stesso come il <xref:System.Text.EncodingInfo.Name%2A> proprietà.  
  
 Si noti che <xref:System.Text.Encoding.WebName%2A> restituisce un nome registrato con IANA per la codifica. Quando il relativo valore è il nome di uno standard, l'implementazione della codifica potrebbe non essere conforme in modo completo a tale standard. Il <xref:System.Text.Encoding.HeaderName%2A> proprietà definisce una codifica diversa che potrebbe funzionare meglio per le intestazioni di messaggio di posta elettronica. Tuttavia, è consigliabile usare la maggior parte delle app <xref:System.Text.Encoding.WebName%2A> invece.  
  
 Per altre informazioni su IANA, visitare [www.iana.org](https://www.iana.org/).  
  
 Il <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> equivale al <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> restituiti da <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Alcuni dei nomi web sono duplicati. vedere la sezione Osservazioni per <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> per altre informazioni.  
  
   
  
## Examples  
 L'esempio seguente include il <xref:System.Text.Encoding.WebName%2A> in un'intestazione HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 Nell'esempio seguente vengono recuperati i nomi diversi per ogni tipo di codifica e visualizza le codifiche con uno o più nomi diversi da <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Visualizza <xref:System.Text.Encoding.EncodingName%2A> ma non compare su di esso.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene la tabella codici del sistema operativo Windows che meglio corrisponde alla codifica corrente.</summary>
        <value>Tabella codici del sistema operativo Windows che meglio corrisponde all'oggetto <see cref="T:System.Text.Encoding" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene fornita per garantire la compatibilità con le multilingue di Windows (MLang) le API, ad esempio, per determinare le famiglie di caratteri. Per la globalizzazione, una delle codifiche Unicode è consigliabile usare invece. È anche consigliabile usare <xref:System.Text.Encoding.WebName%2A> invece di <xref:System.Text.Encoding.WindowsCodePage%2A> per identificare la tabella codici.  
  
   
  
## Examples  
 Nell'esempio seguente determina la tabella codici di Windows che meglio corrisponde a ogni tipo di codifica.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>