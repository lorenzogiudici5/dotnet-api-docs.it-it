<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37bb8ffd133cbb1ddd3c3fdd2f593086d39584aa" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531565" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una codifica UTF-16 dei caratteri Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica è il processo di trasformazione di un insieme di caratteri Unicode in una sequenza di byte. La decodifica è il processo di trasformazione di una sequenza di byte codificati in un set di caratteri Unicode.  
  
 Il [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) assegna un punto di codice (un numero) a ogni carattere in ogni script supportato. Unicode Transformation Format (UTF) è un modo per codificare quel punto di codice. Il [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) utilizza i seguenti UTF:  
  
-   UTF-8, che rappresenta ogni punto di codice come una sequenza di uno a quattro byte.  
  
-   UTF-16, che rappresenta ogni punto di codice come una sequenza di due interi a 16 bit.  
  
-   UTF-32, che rappresenta ogni punto di codice come intero a 32 bit.  
  
 Per ulteriori informazioni sui formati UTF e altre codifiche supportate da <xref:System.Text>, vedere [codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 La <xref:System.Text.UnicodeEncoding> classe rappresenta una codifica UTF-16. Il codificatore può utilizzare entrambi gli ordini dei byte big-endian (byte più significativo primo) o little endian (byte meno significativo prima). Ad esempio, l'alfabeto latino (punto di codice U + 0041) viene serializzato come segue (in esadecimale):  
  
-   Ordine dei byte big endian: 00 00 00 41  
  
-   Ordine dei byte little-endian little: 41 00 00 00  
  
 È in genere più efficiente per archiviare i caratteri Unicode utilizzando l'ordine dei byte nativo di una particolare piattaforma. Ad esempio, è preferibile utilizzare l'ordine dei byte little-endian little su piattaforme little-endian, ad esempio computer Intel. La <xref:System.Text.UnicodeEncoding> classe corrisponde alle tabelle di codici di Windows 1200 (ordine dei byte little-endian little) e 1201 (ordine dei byte big endian). È possibile determinare "ordine dei byte" di una particolare architettura chiamando il <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> metodo.  
  
 Facoltativamente, il <xref:System.Text.UnicodeEncoding> oggetto fornisce un byte order mark (BOM), ovvero una matrice di byte che possono essere preceduti della sequenza di byte risultante dal processo di codifica. Se il preambolo contiene un byte order mark (BOM), consente il decodificatore di determinare l'ordine dei byte e il formato di trasformazione o UTF.  
  
 Se il <xref:System.Text.UnicodeEncoding> istanza è configurata per fornire un indicatore ordine byte, è possibile recuperarla chiamando il <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodo; in caso contrario, il metodo restituisce una matrice vuota. Si noti che, anche se un <xref:System.Text.UnicodeEncoding> oggetto è configurato per supportare DBA, è necessario includere il BOM all'inizio del flusso di byte codificata come appropriato; i metodi di codifica di <xref:System.Text.UnicodeEncoding> classe non eseguire questa operazione automaticamente.  
  
 Per attivare il rilevamento errori e rendere più sicura l'istanza della classe, è consigliabile creare un <xref:System.Text.UnicodeEncoding> oggetto chiamando il <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e l'impostazione relativa `throwOnInvalidBytes` argomento `true`. Con il rilevamento di errori, un metodo che rileva una sequenza di caratteri o byte non valida genera un <xref:System.ArgumentException>. Senza il rilevamento di errori, viene generata alcuna eccezione e la sequenza non valida in genere viene ignorata.  
  
 È possibile creare un'istanza di un <xref:System.Text.UnicodeEncoding> oggetto in diversi modi, a seconda se si desidera per fornire un byte order mark (BOM), se si desidera che la codifica big-endian o little-endian e se si desidera attivare il rilevamento errori. La tabella seguente elenca i <xref:System.Text.UnicodeEncoding> costruttori e <xref:System.Text.Encoding> le proprietà che restituiscono un <xref:System.Text.UnicodeEncoding> oggetto.  
  
|Member|Ordine dei byte|BOM|Rilevamento degli errori|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|Big-endian|Yes|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|Little-endian|Yes|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|Little-endian|Yes|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|Configurabile|Configurabile|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurabile|Configurabile|Configurabile|  
  
 Il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodo esegue l'effettiva codifica.  
  
 Analogamente, il <xref:System.Text.UnicodeEncoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica di una sequenza di byte e <xref:System.Text.UnicodeEncoding.GetChars%2A> e <xref:System.Text.UnicodeEncoding.GetString%2A> i metodi eseguono la decodifica effettiva.  
  
 Per un codificatore o un decodificatore in grado di salvare le informazioni sullo stato durante la codifica o decodifica dei dati che si estende su più blocchi (ad esempio stringhe di caratteri pari a 1 milione è codificato nei segmenti di caratteri di 100.000), utilizzare il <xref:System.Text.UnicodeEncoding.GetEncoder%2A> e <xref:System.Text.UnicodeEncoding.GetDecoder%2A> , proprietà rispettivamente.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come codificare una stringa di caratteri Unicode in una matrice di byte utilizzando un <xref:System.Text.UnicodeEncoding> oggetto. Matrice di byte viene decodificata in una stringa per dimostrare che non vi è alcuna perdita di dati.  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 L'esempio seguente usa la stessa stringa come quello precedente, ad eccezione del fatto che scrive i byte codificati in un file e i prefissi il flusso di byte con un byte order mark (BOM). Quindi legge il file in due modi diversi: come file di testo usando un <xref:System.IO.StreamReader> ; dell'oggetto e come un file binario. Come prevedibile, in entrambi i casi è il BOM incluso nella stringa di appena lettura.  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UnicodeEncoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UnicodeEncoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un'istanza che utilizza l'ordine dei byte little-endian little, fornisce un byte order mark Unicode e non genera un'eccezione quando viene rilevata una codifica non valida.  
  
> [!NOTE]
>  Per motivi di sicurezza, è necessario attivare il rilevamento errori chiamando il <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e l'impostazione relativa `throwOnInvalidBytes` argomento `true`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.Text.UnicodeEncoding> istanza e visualizzare il nome della codifica.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> per usare l'ordine dei byte big-endian (byte più significativo al primo posto) o <see langword="false" /> per usare l'ordine dei byte little-endian (byte meno significativo al primo posto).</param>
        <param name="byteOrderMark">
          <see langword="true" /> per specificare che il metodo <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> restituisce un byte order mark Unicode; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UnicodeEncoding" />. I parametri specificano se usare l'ordine dei byte big-endian e se il metodo <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> restituisce un byte order mark Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un'istanza che non genera un'eccezione quando viene rilevata una codifica non valida.  
  
> [!NOTE]
>  Per motivi di sicurezza, è necessario attivare il rilevamento errori chiamando il <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e l'impostazione relativa `throwOnInvalidBytes` argomento `true`.  
  
 Il `byteOrderMark` parametro controlla il funzionamento del <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodo. Se `true`, il metodo restituisce una matrice di byte contenente il byte order mark Unicode (BOM) in formato UTF-16.  Se `false`, viene restituita una matrice di byte di lunghezza zero. Tuttavia, l'impostazione `byteOrderMark` per `true` non causa il <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodo prefisso il BOM all'inizio della matrice di byte, né comporta il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo per includere il numero di byte nella DBA il numero di byte.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.Text.UnicodeEncoding> contrassegno dell'ordine dei byte Unicode e istanza che specifica se supportare l'ordinamento dei byte little-endian o big-endian little.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> per usare l'ordine dei byte big-endian (byte più significativo al primo posto) o <see langword="false" /> per usare l'ordine dei byte little-endian (byte meno significativo al primo posto).</param>
        <param name="byteOrderMark">
          <see langword="true" /> per specificare che il metodo <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> restituisce un byte order mark Unicode; in caso contrario, <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> per specificare che viene generata un'eccezione quando viene rilevata una codifica non valida; in caso contrario <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UnicodeEncoding" />. I parametri specificano se usare l'ordine dei byte big-endian, se fornire un byte order mark Unicode e se generare un'eccezione quando viene rilevata una codifica non valida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `byteOrderMark` parametro controlla il funzionamento del <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodo. Se `true`, il metodo restituisce una matrice di byte contenente il byte order mark Unicode (BOM) in formato UTF-16.  Se `false`, viene restituita una matrice di byte di lunghezza zero. Tuttavia, l'impostazione `byteOrderMark` per `true` non causa il <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodo prefisso il BOM all'inizio della matrice di byte, né comporta il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo per includere il numero di byte nella DBA il numero di byte.  
  
 Se il `throwOnInvalidBytes` parametro `true`, un metodo che rileva una sequenza di byte non valido genera <xref:System.ArgumentException?displayProperty=nameWithType>. In caso contrario, il metodo non genera un'eccezione e la sequenza non valida verrà ignorata.  
  
> [!NOTE]
>  Per motivi di sicurezza, le applicazioni si consiglia di utilizzare questo costruttore per creare un'istanza di <xref:System.Text.UnicodeEncoding> classe e attivare il rilevamento errori impostando `throwOnInvalidBytes` a `true`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il comportamento di <xref:System.Text.UnicodeEncoding>, con il rilevamento di errori abilitata e senza.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Rappresenta la dimensione dei caratteri Unicode in byte. Il campo è una costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questo campo è una costante con segno a 32 bit con un valore pari a 2.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come restituire il valore di <xref:System.Text.UnicodeEncoding.CharSize> e visualizzarlo.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da confrontare con l'oggetto corrente.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Object" /> specificato è uguale all'oggetto <see cref="T:System.Text.UnicodeEncoding" /> corrente.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> è un'istanza di <see cref="T:System.Text.UnicodeEncoding" /> ed è uguale all'oggetto corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due <xref:System.Text.UnicodeEncoding> oggetti sono considerati uguali se sono vere tutte le condizioni seguenti:  
  
-   Entrambi gli oggetti utilizzano lo stesso ordine di byte (little-endian o big-endian).  
  
-   Entrambi gli oggetti forniscono il byte order mark, o meno.  
  
-   Entrambi gli oggetti utilizzano lo stesso di fallback del codificatore.  
  
-   Entrambi gli oggetti utilizzano lo stesso di fallback del decodificatore.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Text.UnicodeEncoding.Equals%2A> metodo per verificare se l'oggetto corrente <xref:System.Text.UnicodeEncoding> è uguale a un altro oggetto <xref:System.Text.UnicodeEncoding> oggetto. Cinque <xref:System.Text.UnicodeEncoding> gli oggetti vengono creati e confrontati e vengono visualizzati i risultati dei confronti.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa contenente il set di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica dei caratteri nella stringa specificata.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UnicodeEncoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
> [!NOTE]
>  Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Preambolo di inserimento all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non verrà riportato nel valore restituito dal <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> metodo.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> e <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> metodi per calcolare il numero massimo ed effettivo di byte necessari per codificare una stringa. Visualizza anche il numero effettivo di byte necessari per archiviare un flusso di byte con un byte order mark.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="s" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.UnicodeEncoding.GetBytes%2A> richiede per archiviare i byte risultanti, si chiama il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
> [!NOTE]
>  Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Preambolo di inserimento all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non verrà riportato nel valore restituito dal <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è attivato e <paramref name="chars" /> contiene una sequenza di caratteri non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="index">Indice del primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri dalla matrice di caratteri specificata.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UnicodeEncoding.GetBytes%2A> per archiviare i byte risultanti, l'applicazione utilizza <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori abilitato, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Preambolo di inserimento all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non verrà riportato nel valore restituito dal <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene compilata una matrice con un alfabeto latino di maiuscole e minuscole e viene chiamato il <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo per determinare il numero di byte necessari per codificare i caratteri minuscoli latini. Visualizza quindi queste informazioni insieme al numero totale di byte necessari se viene aggiunto un byte order mark. Confronta con il valore restituito da questo numero di <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo, che indica il numero massimo di byte necessari per codificare i caratteri minuscoli latini. Nell'esempio seguente inserisce in una matrice con una combinazione di caratteri greco e cirillico e chiamate di <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo per determinare il numero di byte necessari per codificare i caratteri cirillici. Visualizza quindi queste informazioni insieme al numero totale di byte necessari se viene aggiunto un byte order mark. Confronta con il valore restituito da questo numero di <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo, che indica il numero massimo di byte necessari per codificare i caratteri cirillici.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica un set di caratteri in una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Puntatore alla posizione in cui iniziare a scrivere la sequenza di byte risultante.</param>
        <param name="byteCount">Numero massimo di byte da scrivere.</param>
        <summary>Codifica un set di caratteri a partire dal puntatore ai caratteri specificato in una sequenza di byte archiviati a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero effettivo di byte scritti nella posizione indicata dal parametro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.UnicodeEncoding.GetBytes%2A> richiede per archiviare i byte risultanti, si chiama il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, l'applicazione deve utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> oggetto fornito dal <xref:System.Text.UnicodeEncoding.GetDecoder%2A> o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (metodo), rispettivamente.  
  
> [!NOTE]
>  Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserire il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" /> (<see langword="Nothing" />).  
  
 oppure  
  
 <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.  
  
 oppure  
  
 <paramref name="byteCount" /> è minore del numero di byte risultante.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Codifica un set di caratteri dalla matrice di caratteri specificata nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UnicodeEncoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, l'applicazione deve utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> fornito dal <xref:System.Text.UnicodeEncoding.GetDecoder%2A> (metodo) o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (metodo), rispettivamente.  
  
> [!NOTE]
>  Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserire il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodo per un intervallo di caratteri da codificare un <xref:System.String> e archiviare i byte codificati in un intervallo di elementi in una matrice di byte.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" /> (<see langword="Nothing" />).  
  
 oppure  
  
 <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
 oppure  
  
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
 oppure  
  
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.  
  
 oppure  
  
 <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Stringa contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Codifica un set di caratteri dall'oggetto <see cref="T:System.String" /> specificato nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UnicodeEncoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo. Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo. Il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, l'applicazione deve utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> fornito dal <xref:System.Text.UnicodeEncoding.GetDecoder%2A> (metodo) o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (metodo), rispettivamente.  
  
> [!NOTE]
>  Per garantire che i byte codificati vengano decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserire il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come codificare un intervallo di elementi da una matrice di caratteri Unicode e archiviare i byte codificati in un intervallo di elementi in una matrice di byte.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
 oppure  
  
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
 oppure  
  
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="s" /> contiene una sequenza di carattere non valida.  
  
 oppure  
  
 <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.UnicodeEncoding.GetChars%2A> per archiviare i caratteri risultanti, l'applicazione utilizza <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Per calcolare la dimensione massima della matrice, l'applicazione deve utilizzare <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Il <xref:System.Text.UnicodeEncoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come valore integer.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte dalla matrice di byte specificata.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UnicodeEncoding.GetChars%2A> per archiviare i caratteri risultanti, l'applicazione utilizza <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Per calcolare la dimensione massima della matrice, l'applicazione deve utilizzare <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Il <xref:System.Text.UnicodeEncoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Text.UnicodeEncoding.GetCharCount%2A> per restituire il numero di caratteri prodotti dalla decodifica di un intervallo di elementi in una matrice di byte utilizzando <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido in <paramref name="bytes" />.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come valore integer.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodifica una sequenza di byte in un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Puntatore alla posizione in cui iniziare a scrivere il set di caratteri risultante.</param>
        <param name="charCount">Numero massimo di caratteri da scrivere.</param>
        <summary>Decodifica una sequenza di byte a partire dal puntatore ai byte specificato in un set di caratteri archiviati a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero effettivo di caratteri scritti nella posizione indicata dal parametro <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare la dimensione esatta della matrice che <xref:System.Text.UnicodeEncoding.GetChars%2A> per archiviare i caratteri risultanti, l'applicazione utilizza <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Per calcolare la dimensione massima della matrice, l'applicazione deve utilizzare <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Il <xref:System.Text.UnicodeEncoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include il byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non DBA, il carattere U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverlo chiamando il <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodo.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, l'applicazione deve utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> oggetto fornito dal <xref:System.Text.UnicodeEncoding.GetDecoder%2A> o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (metodo), rispettivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).  
  
 oppure  
  
 <paramref name="chars" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> o <paramref name="charCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.  
  
 oppure  
  
 <paramref name="charCount" /> è minore del numero di caratteri risultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="byteIndex">Indice del primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Matrice di caratteri che deve contenere il set di caratteri risultante.</param>
        <param name="charIndex">Indice in corrispondenza del quale iniziare a scrivere il set di caratteri risultante.</param>
        <summary>Decodifica una sequenza di byte dalla matrice di byte specificata nella matrice di caratteri specificata.</summary>
        <returns>Numero effettivo di caratteri scritti in <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UnicodeEncoding.GetChars%2A> per archiviare i caratteri risultanti, l'applicazione utilizza <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Per calcolare la dimensione massima della matrice, l'applicazione deve utilizzare <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Il <xref:System.Text.UnicodeEncoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include il byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non DBA, il carattere U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverlo chiamando il <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodo.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, l'applicazione deve utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> fornito dal <xref:System.Text.UnicodeEncoding.GetDecoder%2A> (metodo) o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (metodo), rispettivamente.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Text.UnicodeEncoding.GetChars%2A> per decodificare un intervallo di elementi in una matrice di byte e archivia il risultato in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).  
  
 oppure  
  
 <paramref name="chars" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> o <paramref name="byteCount" /> o <paramref name="charIndex" /> è minore di zero.  
  
 oppure  
  
 <paramref name="byteindex" /> e <paramref name="byteCount" /> non identificano un intervallo valido in <paramref name="bytes" />.  
  
 oppure  
  
 <paramref name="charIndex" /> non è un indice valido in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.  
  
 oppure  
  
 <paramref name="chars" /> non dispone di sufficiente capacità da <paramref name="charIndex" /> alla fine della matrice per contenere i caratteri risultanti.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un decodificatore in grado di convertire una sequenza di byte codificati UTF-16 in una sequenza di caratteri Unicode.</summary>
        <returns>Oggetto <see cref="T:System.Text.Decoder" /> che converte una sequenza di byte codificati UTF-16 in una sequenza di caratteri Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo converte blocchi sequenziali di byte in blocchi sequenziali di caratteri, in modo simile al <xref:System.Text.UnicodeEncoding.GetChars%2A>. Tuttavia, un <xref:System.Text.Decoder> mantiene informazioni sullo stato tra le chiamate in modo da poter decodificare correttamente le sequenze di byte che includono i blocchi. Il <xref:System.Text.Decoder> anche mantiene i byte finali alla fine di blocchi di dati e i byte finali nella successiva operazione di decodifica. Pertanto, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> e <xref:System.Text.UnicodeEncoding.GetEncoder%2A> sono utili per la trasmissione di rete e le operazioni di file, perché queste operazioni utilizzano spesso blocchi di dati anziché un flusso di dati completo.  
  
 Se è attivato, ovvero il `throwOnInvalidBytes` parametro del costruttore è impostato su `true`, il rilevamento errori è abilitato anche nel <xref:System.Text.Decoder> restituito da questo metodo. Se è abilitato il rilevamento errori e viene rilevata una sequenza non valida, lo stato del decodificatore non è definito e l'elaborazione deve essere interrotta.  
  
   
  
## Examples  
 Nell'esempio seguente usa un codificatore e un decodificatore per codificare una stringa in una matrice di byte e quindi decodificare i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un codificatore in grado di convertire una sequenza di caratteri Unicode in una sequenza di byte codificati UTF-16.</summary>
        <returns>Oggetto <see cref="T:System.Text.Encoder" /> che converte una sequenza di caratteri Unicode in una sequenza di byte codificati UTF-16.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodo converte blocchi sequenziali di caratteri in blocchi sequenziali di byte in modo simile al <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodo di questa classe. Tuttavia, un <xref:System.Text.Encoder> oggetto mantiene informazioni sullo stato tra le chiamate in modo che può codificare correttamente le sequenze di caratteri che includono i blocchi. Il <xref:System.Text.Encoder> oggetto anche mantiene i caratteri finali alla fine di blocchi di dati e utilizza i caratteri finali nella successiva operazione di codifica. Ad esempio, un blocco di dati potrebbe terminare con un surrogato alto senza corrispondenza e il surrogato basso corrispondente potrebbe essere in blocco di dati successivo. Pertanto, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> e <xref:System.Text.UnicodeEncoding.GetEncoder%2A> sono utili per la trasmissione di rete e le operazioni di file, perché queste operazioni utilizzano spesso blocchi di dati anziché un flusso di dati completo.  
  
 Se è attivato, ovvero il `throwOnInvalidBytes` parametro del costruttore è impostato su `true`, il rilevamento errori è abilitato anche nel <xref:System.Text.Encoder> oggetto restituito da questo metodo. Se è abilitato il rilevamento errori e viene rilevata una sequenza non valida, lo stato del codificatore non è definito e l'elaborazione deve essere interrotta.  
  
   
  
## Examples  
 Nell'esempio seguente usa un codificatore e un decodificatore per codificare una stringa in una matrice di byte e quindi decodificare i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza corrente.</summary>
        <returns>Codice hash per l'oggetto <see cref="T:System.Text.UnicodeEncoding" /> corrente.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</summary>
        <returns>Numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UnicodeEncoding.GetBytes%2A> per archiviare i byte risultanti, l'applicazione utilizza <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Per calcolare la dimensione massima della matrice, l'applicazione deve utilizzare <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>. Il <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Recupera un numero caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.EncoderFallback>. Se si sceglie un fallback con una stringa potenzialmente grande, <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> può restituire valori di grandi dimensioni.  
  
 Nella maggior parte dei casi, questo metodo recupera ragionevole per stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grandi e rilevamento di errori nel raro caso che un buffer più ragionevole è stato superato. È inoltre possibile utilizzare un approccio diverso <xref:System.Text.UnicodeEncoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> non ha alcuna relazione di <xref:System.Text.UnicodeEncoding.GetChars%2A>. Se l'applicazione necessita di una funzione simile da utilizzare con <xref:System.Text.UnicodeEncoding.GetChars%2A>, è necessario utilizzare <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` non è necessariamente lo stesso valore di `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> per restituire il numero massimo di byte necessari per codificare un numero specificato di caratteri.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> è minore di zero.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <summary>Calcola il numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</summary>
        <returns>Numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UnicodeEncoding.GetChars%2A> per archiviare i caratteri risultanti, l'applicazione utilizza <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Per calcolare la dimensione massima della matrice, l'applicazione deve utilizzare <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Il <xref:System.Text.UnicodeEncoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Recupera un numero caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.DecoderFallback>. Se si sceglie un fallback con una stringa potenzialmente grande, <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> recupera i valori di grandi dimensioni.  
  
 Nella maggior parte dei casi, questo metodo recupera ragionevole per stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grandi e rilevamento di errori nel raro caso che un buffer più ragionevole è stato superato. È inoltre possibile utilizzare un approccio diverso <xref:System.Text.UnicodeEncoding.GetCharCount%2A> o <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> non ha alcuna relazione di <xref:System.Text.UnicodeEncoding.GetBytes%2A>. Se l'applicazione necessita di una funzione simile da utilizzare con <xref:System.Text.UnicodeEncoding.GetBytes%2A>, è necessario utilizzare <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` non è necessariamente lo stesso valore di `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> per restituire il numero massimo di caratteri prodotti dalla decodifica di un numero specificato di byte.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> è minore di zero.  
  
 oppure  
  
 Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un byte order mark e Unicode codificato in formato UTF-16, se il costruttore per questa istanza ne ha richiesto la presenza.</summary>
        <returns>Matrice di byte contenente il byte order mark Unicode, se l'oggetto <see cref="T:System.Text.UnicodeEncoding" /> è configurato per fornirne uno. In caso contrario, questo metodo restituisce una matrice di byte di lunghezza zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.UnicodeEncoding> oggetto può fornire un preambolo, ovvero una matrice di byte che possono essere preceduti della sequenza di byte risultante dal processo di codifica. Prima di una sequenza di byte codificati con un byte order mark (U + FEFF punto di codice) consente il decodificatore di determinare l'ordine dei byte e il formato di trasformazione o UTF. Il byte order mark (BOM) Unicode viene serializzato nel modo seguente (in esadecimale):  
  
-   Ordine dei byte big endian: FF FE  
  
-   Ordine dei byte little-endian little: FF FE  
  
 È possibile creare un'istanza di un <xref:System.Text.UnicodeEncoding> i cui <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodo restituisce un valido indicatore ordine byte nei modi seguenti:  
  
-   Recuperando il <xref:System.Text.UnicodeEncoding> oggetto restituito dal <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> o <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> proprietà.  
  
-   Tramite la chiamata senza parametri <xref:System.Text.UnicodeEncoding.%23ctor> costruttore per creare un'istanza di un <xref:System.Text.UnicodeEncoding> oggetto.  
  
-   Fornendo `true` come valore della `byteOrderMark` argomento per il <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> costruttori.  
  
 È consigliabile utilizzare il BOM, poiché fornisce l'identificazione quasi certa di una codifica per i file che non hanno più un riferimento per la codifica, ad esempio tag o o dati web o file di testo casuali archiviati quando una società non disponeva problemi internazionali. Spesso i problemi dell'utente potrebbero essere evitati se i dati vengono contrassegnati in modo coerente e configurata correttamente.  
  
 Per gli standard che forniscono un tipo di codifica, un BOM risulta piuttosto ridondante. Tuttavia, può essere utilizzato per consentire a un server di inviare l'intestazione di codifica corretta. In alternativa, può essere utilizzato come fallback nel caso in cui la codifica in caso contrario viene persa.  
  
 Esistono alcuni svantaggi dell'utilizzo di una distinta base. Ad esempio, può essere difficile sapere come limitare i campi del database che utilizzano una distinta base. La concatenazione di file può rappresentare un problema, inoltre, ad esempio, quando i file vengono uniti in tale modo un carattere non necessario può finire al centro dati. Nonostante alcuni svantaggi, tuttavia, l'utilizzo di un indicatore ordine byte è consigliabile.  
  
> [!CAUTION]
>  Per garantire che i byte codificati vengano decodificati correttamente, è necessario anteporre l'inizio di un flusso di byte codificati con un preambolo. Si noti che il <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodo non anteporre una distinta base in una sequenza di byte codificati; fornendo un BOM all'inizio di un flusso di byte appropriato è responsabilità dello sviluppatore.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodo per recuperare i byte order mark Unicode big endian o little endian per un'istanza di un <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Nell'esempio seguente viene creata un'istanza di due <xref:System.Text.UnicodeEncoding> oggetti, il primo dei quali non si fornisce un indicatore ordine byte, mentre la seconda di quale non. Chiama quindi il <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodo per scrivere il BOM in un file prima di scrivere una stringa codificata in formato Unicode. Come mostra l'output dell'esempio della console, il file che salva i byte dal codificatore secondo contiene tre byte più rispetto alla prima.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 È inoltre possibile confrontare i file utilizzando il `fc` comando in una finestra della console, oppure è possibile esaminare i file in un editor di testo che include una modalità di visualizzazione esadecimale. Si noti che quando il file viene aperto in un editor che supporti la codifica UTF-16, il BOM non è visualizzato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Decodifica un intervallo di byte da una matrice di byte in una stringa.</summary>
        <returns>Oggetto <see cref="T:System.String" /> contenente i risultati di decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con il rilevamento di errori, una sequenza non valida, questo metodo generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include il byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non DBA, il carattere U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverlo chiamando il <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodo.  
  
 Dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, se la quantità di dati è talmente grande che deve essere la suddivisione in blocchi più piccoli, l'applicazione deve utilizzare il <xref:System.Text.Decoder> o <xref:System.Text.Encoder> oggetto fornito dal <xref:System.Text.UnicodeEncoding.GetDecoder%2A> o <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (metodo), rispettivamente.  
  
   
  
## Examples  
 Nell'esempio seguente consente di inizializzare una matrice tramite la chiamata di <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodo per determinare esattamente il numero di byte è necessario per una stringa codificata e quindi aggiungere le dimensioni del byte order mark (BOM). Nell'esempio viene quindi chiamato il <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodo per archiviare il BOM nella matrice prima di chiamare il <xref:System.Text.Encoding.GetBytes%2A> metodo per archiviare i byte nella matrice codificati. Nell'esempio viene quindi chiamato il <xref:System.Text.UnicodeEncoding.GetString%2A> metodo per decodificare la stringa.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Si noti che in questo caso la stringa decodificata è diverso dalla stringa originale, poiché inizia con un contrassegno di ordine di byte a 16 bit U + FFFD. Ciò significa che le due stringhe confronterà contenendo e che, se la stringa di output, il DBA verrà visualizzata come il carattere di sostituzione "?". Per rimuovere il BOM all'inizio della stringa, è possibile chiamare il <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
 oppure  
  
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica di caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>