<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="68ced1dc453efaf4e152c451e7c5446f89d298fc" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39998813" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una stringa modificabile di caratteri. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe rappresenta un oggetto di tipo stringa il cui valore è una sequenza modificabile di caratteri.  
  
 Contenuto della sezione:  
  
-   [I tipi String e StringBuilder](#StringAndSB)  
  
-   [Funzionamento di StringBuilder](#HowWorks)  
  
-   [Allocazione di memoria](#Memory)  
  
-   [Creare un'istanza di un oggetto StringBuilder](#Instantiating)  
  
-   [Chiamata di metodi di StringBuilder](#Calling)  
  
-   [Esecuzione di operazioni di StringBuilder](#Operations)  
  
    -   [L'iterazione di StringBuilder caratteri](#Iterating)  
  
    -   [Aggiunta di testo a un oggetto StringBuilder](#Adding)  
  
    -   [Eliminazione di testo da un oggetto StringBuilder](#Deleting)  
  
    -   [La modifica del testo in un oggetto StringBuilder](#Modifying)  
  
-   [Ricerca il testo in un oggetto StringBuilder](#Searching)  
  
-   [Conversione dell'oggetto StringBuilder in una stringa](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>I tipi String e StringBuilder  
 Sebbene <xref:System.Text.StringBuilder> e <xref:System.String> entrambi rappresentano infatti sequenze di caratteri, vengono implementate in modo diverso. <xref:System.String> è un tipo non modificabile. Vale a dire, ogni operazione che viene visualizzato per modificare un <xref:System.String> oggetto crea effettivamente una nuova stringa.  
  
 Ad esempio, la chiamata per il <xref:System.String.Concat%2A?displayProperty=nameWithType> metodo nell'esempio c# seguente viene visualizzato per modificare il valore di una variabile stringa denominata `value`. In effetti, il <xref:System.String.Concat%2A> metodo restituisce un `value` oggetto con un valore diverso e un indirizzo dal `value` oggetto passato al metodo. Si noti che l'esempio deve essere compilata con la `/unsafe` opzione del compilatore.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Per le routine che la modifica delle stringhe complete (ad esempio applicazioni che modificano una stringa più volte in un ciclo), modificare ripetutamente una stringa può esatte una riduzione significativa delle prestazioni. L'alternativa consiste nell'usare <xref:System.Text.StringBuilder>, ovvero una classe di stringa modificabile. Modificabilità significa che dopo aver creata un'istanza della classe, e può essere modificato da aggiunta, rimozione, sostituzione o inserimento di caratteri. Oggetto <xref:System.Text.StringBuilder> oggetto mantiene un buffer per includere le espansioni nella stringa. I nuovi dati vengono aggiunti al buffer se chat è disponibile. in caso contrario, viene allocato un nuovo e di dimensioni maggiori, i dati dal buffer originale vengono copiati nel nuovo buffer, e i nuovi dati viene quindi aggiunto al buffer di nuovo.  
  
> [!IMPORTANT]
>  Anche se il <xref:System.Text.StringBuilder> classe offre in genere prestazioni migliori rispetto al <xref:System.String> (classe), è consigliabile non automaticamente sostituire <xref:System.String> con <xref:System.Text.StringBuilder> ogni volta che si desidera modificare le stringhe. Prestazioni dipendono dalle dimensioni della stringa, la quantità di memoria da allocare per la nuova stringa, il sistema in cui è in esecuzione l'app e il tipo di operazione. È consigliabile essere pronti a testare l'app per determinare se <xref:System.Text.StringBuilder> effettivamente offre un miglioramento significativo delle prestazioni.  
  
 È consigliabile usare il <xref:System.String> classe in queste condizioni:  
  
-   Quando il numero di modifiche che verranno apportate all'app in una stringa è piccolo. In questi casi <xref:System.Text.StringBuilder> potrebbe essere offerta trascurabile o alcun miglioramento delle prestazioni rispetto a <xref:System.String>.  
  
-   Quando si esegue un numero fisso di operazioni di concatenazione, in particolare con i valori letterali stringa. In questo caso, il compilatore può combinare le operazioni di concatenazione in un'unica operazione.  
  
-   Quando è necessario eseguire operazioni di ricerca estesa mentre si compila la stringa. Il <xref:System.Text.StringBuilder> criteri di ricerca non dispone di classe, ad esempio `IndexOf` o `StartsWith`. È possibile convertire le <xref:System.Text.StringBuilder> dell'oggetto a un <xref:System.String> per queste operazioni e questo può negare il miglioramento delle prestazioni dall'utilizzo <xref:System.Text.StringBuilder>. Per altre informazioni, vedere la [ricerca il testo in un oggetto StringBuilder](#Searching) sezione.  
  
 È consigliabile usare il <xref:System.Text.StringBuilder> classe in queste condizioni:  
  
-   Quando si prevede che l'app per rendere un numero sconosciuto di modifiche a una stringa in fase di progettazione (ad esempio, quando si usa un ciclo per concatenare un numero casuale di stringhe che contengono l'input dell'utente).  
  
-   Quando si prevede che l'app per rendere un numero significativo di modifiche a una stringa.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Funzionamento di StringBuilder  
 Il <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> proprietà indica il numero di caratteri di <xref:System.Text.StringBuilder> oggetto contiene attualmente. Se si aggiungono caratteri per il <xref:System.Text.StringBuilder> dell'oggetto, la sua lunghezza aumenta fino a quando non pari alla dimensione del <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> proprietà, che definisce il numero di caratteri che può contenere l'oggetto. Se il numero di caratteri aggiunti fa sì che la lunghezza del <xref:System.Text.StringBuilder> oggetto di superare le capacità corrente, la nuova memoria viene allocata, il valore del <xref:System.Text.StringBuilder.Capacity%2A> è raddoppiata proprietà, vengono aggiunti nuovi caratteri per il <xref:System.Text.StringBuilder> oggetto e relativo <xref:System.Text.StringBuilder.Length%2A>proprietà viene modificata. Memoria aggiuntiva per il <xref:System.Text.StringBuilder> oggetto viene allocato in modo dinamico finché non raggiunge il valore definito mediante il <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> proprietà. Quando viene raggiunta la capacità massima, non può essere allocata nessuna ulteriore memoria per il <xref:System.Text.StringBuilder> oggetto e provando ad aggiungere caratteri o espanderla oltre la capacità massima genera un'eccezione un' <xref:System.ArgumentOutOfRangeException> o un <xref:System.OutOfMemoryException> eccezione.  
  
 Nell'esempio seguente viene illustrato come un <xref:System.Text.StringBuilder> oggetto alloca nuova memoria e aumenta la capacità in modo dinamico quando si espande la stringa assegnata all'oggetto. Il codice crea un <xref:System.Text.StringBuilder> oggetto chiamando il costruttore predefinito (senza parametri). La capacità predefinita di questo oggetto è 16 caratteri e alla capacità massima è superiore a 2 miliardi caratteri. Aggiunta la stringa "This is a una frase". risultati in una nuova allocazione di memoria perché la lunghezza della stringa (19 caratteri) supera la capacità predefinita del <xref:System.Text.StringBuilder> oggetto. La capacità dell'oggetto raddoppia più di 32 caratteri, viene aggiunta la nuova stringa e la lunghezza dell'oggetto ora è uguale a 19 caratteri. Il codice aggiunge quindi la stringa "This is a una frase aggiuntiva". il valore della <xref:System.Text.StringBuilder> oggetto 11 volte. Ogni volta che l'operazione di Accodamento fa sì che la lunghezza del <xref:System.Text.StringBuilder> oggetto al superamento della capacità, la capacità esistente è raddoppiato negli anni e <xref:System.Text.StringBuilder.Append%2A> operazione ha esito positivo.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Allocazione di memoria  
 La capacità predefinita di un <xref:System.Text.StringBuilder> oggetto è 16 caratteri e alla capacità massima predefinita è <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Vengono usati questi valori predefiniti se si chiama il <xref:System.Text.StringBuilder.%23ctor> e <xref:System.Text.StringBuilder.%23ctor%28System.String%29> costruttori.  
  
 È possibile definire in modo esplicito la capacità iniziale di un <xref:System.Text.StringBuilder> oggetto nei modi seguenti:  
  
-   Chiamata dei <xref:System.Text.StringBuilder> costruttori che include un `capacity` parametro quando si crea l'oggetto.  
  
-   In modo esplicito assegnando un nuovo valore per il <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> proprietà da espandere esistente <xref:System.Text.StringBuilder> oggetto. Si noti che la proprietà genera un'eccezione se la nuova capacità sia inferiore a quella esistente della capacità o maggiore di <xref:System.Text.StringBuilder> capacità massima dell'oggetto.  
  
-   Chiamando il <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> metodo con la nuova capacità. La nuova capacità non deve essere maggiore di <xref:System.Text.StringBuilder> capacità massima dell'oggetto. Tuttavia, a differenza di un'assegnazione per la <xref:System.Text.StringBuilder.Capacity%2A> proprietà, <xref:System.Text.StringBuilder.EnsureCapacity%2A> non genera un'eccezione se la nuova capacità desiderate è inferiore alla capacità esistente; in questo caso, la chiamata al metodo ha alcun effetto.  
  
 Se la lunghezza della stringa assegnata al <xref:System.Text.StringBuilder> oggetto nella chiamata al costruttore supera la capacità predefinita o la capacità specificata, il <xref:System.Text.StringBuilder.Capacity%2A> viene impostata per la lunghezza della stringa specificata con il `value` parametro.  
  
 È possibile definire in modo esplicito la capacità massima di un <xref:System.Text.StringBuilder> chiamando il <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> costruttore. Non è possibile modificare la capacità massima assegnando un nuovo valore per il <xref:System.Text.StringBuilder.MaxCapacity%2A> proprietà, perché è di sola lettura.  
  
 La sezione precedente viene allocato Mostra, ogni volta che la capacità esistente è memoria insufficiente, aggiuntiva e la capacità di un <xref:System.Text.StringBuilder> valori Double fino al valore definito dall'oggetto il <xref:System.Text.StringBuilder.MaxCapacity%2A> proprietà.  
  
 In generale, la capacità predefinita e la capacità massima sono adeguate per la maggior parte delle app. È opportuno considerare l'impostazione di questi valori nelle condizioni seguenti:  
  
-   Se le dimensioni finali del <xref:System.Text.StringBuilder> oggetto condizione potrebbe diventare estremamente grande, in genere che superano di diversi megabyte. In questo caso, potrebbero esserci alcuni vantaggi nelle prestazioni dell'impostazione iniziale <xref:System.Text.StringBuilder.Capacity%2A> proprietà su un valore molto elevato per eliminare la necessità di riallocazioni un numero eccessivo di memoria.  
  
-   Se l'app è in esecuzione in un sistema con memoria limitata. È possibile in questo caso, è consigliabile impostare il <xref:System.Text.StringBuilder.MaxCapacity%2A> proprietà minore <xref:System.Int32.MaxValue?displayProperty=nameWithType> se l'app gestisce le stringhe di grandi dimensioni che possono causare l'esecuzione in un ambiente di memoria vincolata.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Creare un'istanza di un oggetto StringBuilder  
 Crea un'istanza di un <xref:System.Text.StringBuilder> oggetto chiamando uno dei sei costruttori disponibili la classe di overload, che sono elencate nella tabella riportata di seguito. Tre dei costruttori di creare un'istanza di un <xref:System.Text.StringBuilder> il cui valore è una stringa vuota, ma impostare relativi <xref:System.Text.StringBuilder.Capacity%2A> e <xref:System.Text.StringBuilder.MaxCapacity%2A> valori in modo diverso. I tre costruttori rimanenti definiscono un <xref:System.Text.StringBuilder> oggetto con un valore di stringa specifico e la capacità. Due dei tre costruttori usano la capacità massima predefinita di <xref:System.Int32.MaxValue?displayProperty=nameWithType>, mentre il terzo modo è possibile impostare la capacità massima.  
  
|Costruttore|Valore stringa|Capacità|Capacità massima|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definito dal `capacity` parametro|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definito dal `capacity` parametro|Definito dal `maxCapacity` parametro|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Definito dal `value` parametro|16 o `value`. <xref:System.String.Length%2A>, qualunque sia il maggiore|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Definito dal `value` parametro|Definita per il `capacity` parametro o `value`. <xref:System.String.Length%2A>, qualunque sia il maggiore.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Definito da `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Definita per il `capacity` parametro o `value`. <xref:System.String.Length%2A>, qualunque sia il maggiore.|Definito dal `maxCapacity` parametro|  
  
 L'esempio seguente usa tre di questi overload del costruttore per creare un'istanza <xref:System.Text.StringBuilder> oggetti.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Chiamata di metodi di StringBuilder  
 La maggior parte dei metodi che modificano la stringa in un <xref:System.Text.StringBuilder> istanza restituiscono un riferimento a quell'istanza stessa. In questo modo è possibile chiamare <xref:System.Text.StringBuilder> metodi in due modi:  
  
-   È possibile effettuare chiamate al metodo singole e ignorare il valore restituito, come avviene nell'esempio seguente.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   È possibile rendere una serie di chiamate al metodo in un'unica istruzione. Può risultare utile se si vuole scrivere una singola istruzione che concatena le operazioni successive. Nell'esempio seguente consente di consolidare i tre chiamate al metodo dell'esempio precedente in una singola riga di codice.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Esecuzione di operazioni di StringBuilder  
 È possibile usare i metodi del <xref:System.Text.StringBuilder> classe per eseguire l'iterazione, aggiungere, eliminare o modificare i caratteri in un <xref:System.Text.StringBuilder> oggetto.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>L'iterazione di StringBuilder caratteri  
 È possibile accedere ai caratteri in una <xref:System.Text.StringBuilder> utilizzando il <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> proprietà. In c# <xref:System.Text.StringBuilder.Chars%2A> è un indicizzatore, in Visual Basic, è la proprietà predefinita del <xref:System.Text.StringBuilder> classe. In questo modo è possibile impostare o recuperare i singoli caratteri usando solo l'indice senza fare riferimento in modo esplicito il <xref:System.Text.StringBuilder.Chars%2A> proprietà. I caratteri in una <xref:System.Text.StringBuilder> oggetto iniziano in corrispondenza dell'indice 0 (zero) e continuare a indicizzare <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Chars%2A> proprietà. Aggiunge 10 numeri casuali da un <xref:System.Text.StringBuilder> dell'oggetto e quindi scorre ogni carattere. Se la categoria del carattere Unicode è <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, riduce il numero da 1 (o modifica il numero a 9, se il valore è 0). L'esempio visualizza il contenuto del <xref:System.Text.StringBuilder> entrambi prima e dopo che sono stati modificati i valori dei singoli caratteri dell'oggetto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Aggiunta di testo a un oggetto StringBuilder  
 Il <xref:System.Text.StringBuilder> classe include i metodi seguenti per espande il contenuto di un <xref:System.Text.StringBuilder> oggetto:  
  
-   Il <xref:System.Text.StringBuilder.Append%2A> metodo aggiunge una stringa, una sottostringa, una matrice di caratteri, una parte di una matrice di caratteri, un singolo carattere ripetuto più volte, o tipo di rappresentazione di stringa di dati primitivo in un <xref:System.Text.StringBuilder> oggetto.  
  
-   Il <xref:System.Text.StringBuilder.AppendLine%2A> metodo aggiunge un terminatore di riga o una stringa con un terminatore di riga un <xref:System.Text.StringBuilder> oggetto.  
  
-   Il <xref:System.Text.StringBuilder.AppendFormat%2A> metodo aggiunge un a un <xref:System.Text.StringBuilder> oggetto. Le rappresentazioni di stringa degli oggetti incluse nella stringa di risultato possano riflettono le convenzioni di formattazione delle impostazioni cultura correnti del sistema o impostazioni cultura specificate.  
  
-   Il <xref:System.Text.StringBuilder.Insert%2A> metodo inserisce una stringa, una sottostringa, più le ripetizioni di una stringa, una matrice di caratteri, una parte di una matrice di caratteri o la rappresentazione di stringa di dati primitivo digitare in una posizione specificata nel <xref:System.Text.StringBuilder> oggetto. La posizione è definita da un indice in base zero.  
  
 L'esempio seguente usa il <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, e <xref:System.Text.StringBuilder.Insert%2A> metodi per espandere il testo di un <xref:System.Text.StringBuilder> oggetto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Eliminazione di testo da un oggetto StringBuilder  
 Il <xref:System.Text.StringBuilder> classe include metodi che consentono di ridurre le dimensioni dell'oggetto corrente <xref:System.Text.StringBuilder> istanza. Il <xref:System.Text.StringBuilder.Clear%2A> metodo rimuove tutti i caratteri e imposta il <xref:System.Text.StringBuilder.Length%2A> proprietà su zero. Il <xref:System.Text.StringBuilder.Remove%2A> metodo consente di eliminare un numero specificato di caratteri a partire da una posizione di indice specifico. Inoltre, è possibile rimuovere i caratteri dalla fine di una <xref:System.Text.StringBuilder> oggetto impostando relativo <xref:System.Text.StringBuilder.Length%2A> proprietà su un valore che è minore della lunghezza dell'istanza corrente.  
  
 L'esempio seguente rimuove parte del testo da un <xref:System.Text.StringBuilder> oggetto, Visualizza le capacità risultante, la capacità massima e i valori delle proprietà di lunghezza e quindi chiama il <xref:System.Text.StringBuilder.Clear%2A> metodo per rimuovere tutti i caratteri dal <xref:System.Text.StringBuilder> oggetto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>La modifica del testo in un oggetto StringBuilder  
 Il <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> metodo sostituisce tutte le occorrenze di un carattere o una stringa all'interno dell'intero <xref:System.Text.StringBuilder> oggetto o in un intervallo di caratteri specifico. L'esempio seguente usa il <xref:System.Text.StringBuilder.Replace%2A> metodo per sostituire tutti i punti esclamativi (!) con punti interrogativi (?) nel <xref:System.Text.StringBuilder> oggetto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Ricerca il testo in un oggetto StringBuilder  
 Il <xref:System.Text.StringBuilder> classe non include metodi simili per il <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, e <xref:System.String.StartsWith%2A?displayProperty=nameWithType> metodi forniti dal <xref:System.String> (classe), che consentono di eseguire la ricerca l'oggetto per un determinato carattere o una sottostringa. Determinare la presenza o l'avvio di posizione del carattere di una sottostringa è necessario cercare un <xref:System.String> valore utilizzando un metodo di ricerca di stringa o un metodo di espressione regolare. Sono disponibili quattro modi per implementare tali ricerche, come illustrato nella tabella seguente.  
  
|Tecnica|Professionisti|Svantaggi|  
|---------------|----------|----------|  
|I valori di stringa di ricerca prima di aggiungerli al <xref:System.Text.StringBuilder> oggetto.|È utile per la verifica dell'esistenza di una sottostringa.|Non può essere utilizzato quando la posizione di indice di una sottostringa è importante.|  
|Chiamare <xref:System.Text.StringBuilder.ToString%2A> e cercare l'oggetto restituito <xref:System.String> oggetto.|Facile da usare se si assegna a tutto il testo un <xref:System.Text.StringBuilder> dell'oggetto e quindi iniziare a modificarlo.|Complesso da chiamare ripetutamente <xref:System.Text.StringBuilder.ToString%2A> se è necessario apportare modifiche prima di tutto il testo viene aggiunto al <xref:System.Text.StringBuilder> oggetto.<br /><br /> È necessario ricordarsi di lavorare dalla fine del <xref:System.Text.StringBuilder> testo dell'oggetto se si stanno apportando le modifiche.|  
|Usare il <xref:System.Text.StringBuilder.Chars%2A> proprietà da cercare in modo sequenziale un intervallo di caratteri.|È utile se si è preoccupati con singoli caratteri o una sottostringa di piccole dimensioni.|Un'operazione complessa se il numero di caratteri da cercare è elevato o se la logica di ricerca è complessa.<br /><br />Risultati molto una riduzione delle prestazioni per gli oggetti che hanno raggiunto la dimensione molto grande tramite chiamate al metodo ripetuta.  |  
|Convertire le <xref:System.Text.StringBuilder> dell'oggetto a un <xref:System.String> dell'oggetto e apportare modifiche nel <xref:System.String> oggetto.|È utile se il numero di modifiche è ridotto.|Nega il miglioramento delle prestazioni dei <xref:System.Text.StringBuilder> classe se il numero di modifiche è di grandi dimensioni.|  
  
 Esaminiamo queste tecniche in maggiore dettaglio.  
  
-   Se l'obiettivo della ricerca deve determinare se una particolare sottostringa esiste (vale a dire, se non si intende la posizione della sottostringa), è possibile cercare le stringhe prima di archiviarli nel <xref:System.Text.StringBuilder> oggetto. Nell'esempio seguente fornisce una possibile implementazione. Definisce un `StringBuilderFinder` classe il cui costruttore viene passato un riferimento a un <xref:System.Text.StringBuilder> oggetto e la sottostringa da trovare nella stringa. In questo caso, l'esempio tenta di determinare se registrate le temperature in gradi Fahrenheit o Celsius e aggiunge il testo introduttivo appropriato all'inizio del <xref:System.Text.StringBuilder> oggetto. Un generatore di numeri casuali viene usato per selezionare una matrice che contiene i dati in gradi Celsius o gradi Fahrenheit.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Chiamare il <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodo per convertire le <xref:System.Text.StringBuilder> dell'oggetto a un <xref:System.String> oggetto. È possibile cercare la stringa con i metodi, ad esempio <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> oppure <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, oppure è possibile usare espressioni regolari e <xref:System.Text.RegularExpressions.Regex> classe a ricerca di modelli. Poiché entrambe <xref:System.Text.StringBuilder> e <xref:System.String> gli oggetti usano per archiviare caratteri, le posizioni dell'indice di caratteri, sottostringhe, la codifica UTF-16 e corrispondenze di espressioni regolari sono gli stessi in entrambi gli oggetti. In questo modo è possibile usare <xref:System.Text.StringBuilder> metodi di apportare modifiche nella stessa posizione in cui tale testo viene trovato nel <xref:System.String> oggetto.  
  
    > [!NOTE]
    >  Se si adotta questo approccio, dovrebbe funzionare dalla fine del <xref:System.Text.StringBuilder> oggetto alla sua introduzione in modo che non devi più volte convertire i <xref:System.Text.StringBuilder> oggetto in una stringa.  
  
     Questo approccio viene illustrato nell'esempio seguente: Archivia le occorrenze di ogni lettera dell'alfabeto inglese in un <xref:System.Text.StringBuilder> oggetto. Viene quindi convertito il testo da un <xref:System.String> dell'oggetto e viene utilizzata un'espressione regolare per identificare la posizione iniziale di ogni sequenza di quattro caratteri. Infine, aggiunge un carattere di sottolineatura prima di ogni sequenza di quattro caratteri, ad eccezione della prima sequenza e converte il primo carattere della sequenza di lettere maiuscole.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Usare la <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> proprietà per la ricerca in modo sequenziale un intervallo di caratteri in un <xref:System.Text.StringBuilder> oggetto. Questo approccio potrebbe non essere pratica se il numero di caratteri da cercare è grande o logica di ricerca è particolarmente complessa. Per le implicazioni sulle prestazioni di accesso basati sull'indice di carattere per carattere per dimensioni molto grandi, chunked <xref:System.Text.StringBuilder> oggetti, vedere la documentazione per il <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> proprietà. 
  
     Nell'esempio seguente ha funzionalità identico all'esempio precedente, ma presenta differenze nell'implementazione. Usa il <xref:System.Text.StringBuilder.Chars%2A> proprietà per rilevare quando un valore del carattere è stato modificato, inserisce un carattere di sottolineatura in tale posizione e converte il primo carattere nella sequenza di nuovo in lettere maiuscole.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Store tutto il testo non modificato nella <xref:System.Text.StringBuilder> dell'oggetto, chiamare il <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodo per convertire il <xref:System.Text.StringBuilder> dell'oggetto a un <xref:System.String> dell'oggetto e apportare le modifiche nel <xref:System.String> oggetto. È possibile usare questo approccio se si dispone solo di alcune modifiche; in caso contrario, il costo dell'uso delle stringhe non modificabile potrebbe annullare i vantaggi delle prestazioni dell'utilizzo un <xref:System.Text.StringBuilder> oggetto.  
  
     Nell'esempio seguente ha funzionalità identico per i due esempi precedenti, ma presenta differenze nell'implementazione. Crea una <xref:System.Text.StringBuilder> dell'oggetto, lo converte in un <xref:System.String> dell'oggetto e quindi utilizza un'espressione regolare per eseguire tutte le modifiche rimanenti nella stringa. Il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> metodo utilizza un'espressione lambda per eseguire la sostituzione su ogni corrispondenza.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Conversione dell'oggetto StringBuilder in una stringa  
 È necessario convertire l'oggetto <xref:System.Text.StringBuilder> in un oggetto <xref:System.String> prima di poter passare la stringa rappresentata dall'oggetto <xref:System.Text.StringBuilder> a un metodo che contiene un parametro <xref:System.String> o per visualizzarlo nell'interfaccia utente. Si esegue questa conversione chiamando il <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> (metodo). Per informazioni generali, vedere l'esempio precedente, che chiama il <xref:System.Text.StringBuilder.ToString%2A> metodo per convertire un <xref:System.Text.StringBuilder> oggetto in una stringa in modo che possa essere passata a un metodo di espressione regolare.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare molti dei metodi definiti dal <xref:System.Text.StringBuilder> classe.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.StringBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di stringa dell'istanza corrente è impostato su <xref:System.String.Empty?displayProperty=nameWithType>, e la capacità è impostata sul valore predefinito di specifici dell'implementazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il <xref:System.Text.StringBuilder.%23ctor%2A> costruttore senza parametri.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Dimensione iniziale consigliata per questa istanza.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.StringBuilder" /> usando la capacità specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `capacity` parametro definisce il numero massimo di caratteri che possono essere archiviati nella memoria allocata dall'istanza corrente. Il valore viene assegnato al <xref:System.Text.StringBuilder.Capacity%2A> proprietà. Se il numero di caratteri da archiviare nell'istanza corrente supera questa `capacity` valore, il <xref:System.Text.StringBuilder> oggetto alloca memoria aggiuntiva per archiviarle.  
  
 Il valore di stringa dell'istanza corrente è impostato su <xref:System.String.Empty?displayProperty=nameWithType>. Se `capacity` è uguale a zero, la capacità specifiche dell'implementazione predefinita viene usata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il <xref:System.Text.StringBuilder.%23ctor%2A> costruttore con una capacità specificata.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa usata per inizializzare il valore dell'istanza. Se <c>value</c> è <see langword="null" />, il nuovo oggetto <see cref="T:System.Text.StringBuilder" /> conterrà una stringa vuota, ovvero <see cref="F:System.String.Empty" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.StringBuilder" /> usando la stringa specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` è `null`, il nuovo oggetto <xref:System.Text.StringBuilder> conterrà una stringa vuota, ovvero <xref:System.String.Empty>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il <xref:System.Text.StringBuilder.%23ctor%2A> costruttore con la stringa specificata.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Dimensione iniziale consigliata per <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Numero massimo di caratteri che la stringa corrente può contenere.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.StringBuilder" /> che inizia con una capacità specificata e può raggiungere un valore massimo specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `capacity` parametro definisce il numero massimo di caratteri che possono essere archiviati nella memoria allocata dall'istanza corrente. Il valore viene assegnato al <xref:System.Text.StringBuilder.Capacity%2A> proprietà. Se il numero di caratteri da archiviare nell'istanza corrente supera questa `capacity` valore, il <xref:System.Text.StringBuilder> oggetto alloca memoria aggiuntiva per archiviarle.  
  
 Se `capacity` è uguale a zero, la capacità specifiche dell'implementazione predefinita viene usata.  
  
 Il `maxCapacity` proprietà definisce il numero massimo di caratteri che può contenere l'istanza corrente. Il valore viene assegnato al <xref:System.Text.StringBuilder.MaxCapacity%2A> proprietà. Se il numero di caratteri da archiviare nell'istanza corrente supera ciò `maxCapacity` valore, il <xref:System.Text.StringBuilder> oggetto non allocare memoria aggiuntiva, ma genera un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il <xref:System.Text.StringBuilder.%23ctor%2A> costruttore con una capacità specificata e la capacità massima.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> è minore di 1, <paramref name="capacity" /> è minore di zero o <paramref name="capacity" /> è maggiore di <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa usata per inizializzare il valore dell'istanza. Se <c>value</c> è <see langword="null" />, il nuovo oggetto <see cref="T:System.Text.StringBuilder" /> conterrà una stringa vuota, ovvero <see cref="F:System.String.Empty" />.</param>
        <param name="capacity">Dimensione iniziale consigliata per <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.StringBuilder" /> usando la stringa e la capacità specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `capacity` parametro definisce il numero massimo di caratteri che possono essere archiviati nella memoria allocata dall'istanza corrente. Il valore viene assegnato al <xref:System.Text.StringBuilder.Capacity%2A> proprietà. Se il numero di caratteri da archiviare nell'istanza corrente supera questa `capacity` valore, il <xref:System.Text.StringBuilder> oggetto alloca memoria aggiuntiva per archiviarle.  
  
 Se `capacity` è uguale a zero, la capacità specifiche dell'implementazione predefinita viene usata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il <xref:System.Text.StringBuilder.%23ctor%2A> costruttore con una stringa iniziale e una capacità specificata.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene la sottostringa usata per inizializzare il valore dell'istanza. Se <c>value</c> è <see langword="null" />, il nuovo oggetto <see cref="T:System.Text.StringBuilder" /> conterrà una stringa vuota, ovvero <see cref="F:System.String.Empty" />.</param>
        <param name="startIndex">Posizione all'interno di <c>value</c> in cui inizia la sottostringa.</param>
        <param name="length">Numero di caratteri nella sottostringa.</param>
        <param name="capacity">Dimensione iniziale consigliata per <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.StringBuilder" /> dalla sottostringa e la capacità specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `capacity` parametro definisce il numero massimo di caratteri che possono essere archiviati nella memoria allocata dall'istanza corrente. Il valore viene assegnato al <xref:System.Text.StringBuilder.Capacity%2A> proprietà. Se il numero di caratteri da archiviare nell'istanza corrente supera questa `capacity` valore, il <xref:System.Text.StringBuilder> oggetto alloca memoria aggiuntiva per archiviarle.  
  
 Se `capacity` è uguale a zero, la capacità specifiche dell'implementazione predefinita viene usata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il <xref:System.Text.StringBuilder.%23ctor%2A> costruttore con la stringa specificata.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.  
  
oppure 
 la somma di <paramref name="startIndex" /> e <paramref name="length" /> non è una posizione all'interno di <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accoda la rappresentazione di stringa di un oggetto specificato a questa istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Valore booleano da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un valore booleano specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Boolean%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Boolean%29> chiamate al metodo il <xref:System.Boolean.ToString?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value`. La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un intero senza segno a 8 bit specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Byte%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Byte%29> chiamate al metodo il <xref:System.Byte.ToString%28System.IFormatProvider%29> metodo per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Unità di codice con codifica UTF-16 da aggiungere.</param>
        <summary>Accoda la rappresentazione di stringa di un oggetto <see cref="T:System.Char" /> specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Char%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Matrice di caratteri da accodare.</param>
        <summary>Accoda la rappresentazione di stringa dei caratteri Unicode in una matrice specificata a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo aggiunge tutti i caratteri nella matrice specificata per l'istanza corrente nello stesso ordine come appaiono in `value`. Se `value` è `null`, viene apportata alcuna modifica.  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un numero decimale specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Decimal%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Decimal%29> chiamate al metodo il <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un numero a virgola mobile a precisione doppia specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Double%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Double%29> chiamate al metodo il <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un intero con segno a 16 bit specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Int16%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Int16%29> chiamate al metodo il <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un intero con segno a 32 bit specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Int32%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Int32%29> chiamate al metodo il <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un intero con segno a 64 bit specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Int64%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Int64%29> chiamate al metodo il <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un oggetto specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Object%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente. Definisce un `Dog` classe, crea un' `Dog` oggetto e rende tre chiamate al <xref:System.Text.StringBuilder.Append%2A> metodo per creare una stringa che contiene nome e la generazione di dog.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Object%29> chiamate al metodo il <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value`. Se `value` viene `null`, non vengono apportate modifiche per il <xref:System.Text.StringBuilder> oggetto.  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un intero con segno a 8 bit specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.SByte%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.SByte%29> chiamate al metodo il <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un numero a virgola mobile e precisione singola specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Single%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Single%29> chiamate al metodo il <xref:System.Single.ToString%2A?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da accodare.</param>
        <summary>Accoda una copia della stringa specificata a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.String%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Se `value` è `null`, viene apportata alcuna modifica.  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un intero senza segno a 16 bit specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.UInt16%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.UInt16%29> chiamate al metodo il <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value`. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un intero senza segno a 32 bit specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.UInt32%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.UInt32%29> chiama il <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valore da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di un intero senza segno a 64 bit specificato a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.UInt64%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 Il <xref:System.Text.StringBuilder.Append%28System.UInt64%29> chiamate al metodo il <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodo per ottenere la rappresentazione di stringa di `value` per le impostazioni cultura correnti. Per controllare la formattazione della `value`, chiamare il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carattere da accodare.</param>
        <param name="repeatCount">Numero delle operazioni di accodamento di <c>value</c>.</param>
        <summary>Accoda un numero specificato di copie della rappresentazione di stringa di un carattere Unicode a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> è minore di zero.  
  
oppure 
Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice di caratteri.</param>
        <param name="valueCount">Numero di caratteri nella matrice.</param>
        <summary>Accoda a questa istanza una matrice di caratteri Unicode a partire da un indirizzo specificato.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo aggiunge `valueCount` caratteri a partire dall'indirizzo `value` all'istanza corrente.  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> oggetto.  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> è minore di zero.  
  
oppure 
Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> è un puntatore Null.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Matrice di caratteri.</param>
        <param name="startIndex">Posizione iniziale in <c>value</c>.</param>
        <param name="charCount">Numero di caratteri da accodare.</param>
        <summary>Accoda la rappresentazione di stringa di una sottomatrice specificata di caratteri Unicode a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo aggiunge l'intervallo specificato di caratteri in `value` all'istanza corrente. Se `value` viene `null` e `startIndex` e `count` siano entrambi pari a zero, non vengono apportate modifiche.  
  
 Il <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" /> e <paramref name="startIndex" /> e <paramref name="charCount" /> sono diversi da zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> è minore di zero.  
  
oppure 
 <paramref name="startIndex" /> è minore di zero.  
  
oppure 
 <paramref name="startIndex" /> + <paramref name="charCount" /> è maggiore della lunghezza di <paramref name="value" />.  
  
oppure 
Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene la sottostringa da accodare.</param>
        <param name="startIndex">Posizione iniziale della sottostringa all'interno di <c>value</c>.</param>
        <param name="count">Numero di caratteri in <c>value</c> da accodare.</param>
        <summary>Accoda una copia della sottostringa specificata a questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo aggiunge l'intervallo specificato di caratteri in `value` all'istanza corrente. Se `value` viene `null` e `startIndex` e `count` siano entrambi pari a zero, non vengono apportate modifiche.  
  
 Il <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> metodo modifica l'istanza esistente di questa classe; non restituisce una nuova istanza della classe. Per questo motivo, è possibile chiamare un metodo o una proprietà sul riferimento esistente e non è necessario assegnare il valore restituito per un <xref:System.Text.StringBuilder> dell'oggetto, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" /> e <paramref name="startIndex" /> e <paramref name="count" /> sono diversi da zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> minore di zero.  
  
oppure 
 <paramref name="startIndex" /> minore di zero.  
  
oppure 
 <paramref name="startIndex" /> + <paramref name="count" /> è maggiore della lunghezza di <paramref name="value" />.  
  
oppure 
Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accoda la stringa restituita dall'elaborazione di una stringa in formato composito, che contiene zero o più elementi di formato, a questa istanza. Ogni elemento di formato viene sostituito dalla rappresentazione di stringa di un argomento dell'oggetto corrispondente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Stringa in formato composito.</param>
        <param name="arg0">Oggetto da formattare.</param>
        <summary>Accoda la stringa restituita dall'elaborazione di una stringa in formato composito, che contiene zero o più elementi di formato, a questa istanza. Ogni elemento di formato viene sostituito dalla rappresentazione di stringa di un singolo argomento.</summary>
        <returns>Riferimento a questa istanza con <paramref name="format" /> accodato. Ogni elemento di formato in <paramref name="format" /> viene sostituito dalla rappresentazione di stringa di <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione corrente <xref:System.Text.StringBuilder> oggetto.  
  
 Il `format` parametro è costituita da zero o più sequenze di testo combinato con zero o più segnaposto indicizzati, denominati elementi di formato. L'indice degli elementi di formato deve essere 0, in modo che corrispondano a `arg0`, l'unico oggetto nell'elenco di parametri di questo metodo. Il processo di formattazione sostituisce ogni elemento di formato con la rappresentazione di stringa di `arg0`.  
  
 La sintassi di un elemento di formato è come segue:  
  
 {*indice*[,*lunghezza*] [:*formatString*]}  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*index*|La posizione in base zero nell'elenco dei parametri dell'oggetto da formattare. Se l'oggetto specificato da *indice* viene `null`, l'elemento di formato viene sostituito dalla <xref:System.String.Empty?displayProperty=nameWithType>. Se non è disponibile alcun parametro nel *indice* posizione, un <xref:System.FormatException> viene generata un'eccezione.|  
|,*lunghezza*|Il numero minimo di caratteri nella rappresentazione di stringa del parametro. Se è positivo, il parametro è allineato a destra; Se un valore negativo, è allineato a sinistra.|  
|:*formatString*|Una stringa di formato standard o personalizzato supportato dal parametro.|  
  
> [!NOTE]
>  Per le stringhe di formato standard e personalizzati utilizzate con valori di data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Per le stringhe di formato standard e personalizzate usate con valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato standard usate con le enumerazioni, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` rappresenta l'oggetto da formattare. Ogni elemento di formato in `format` viene sostituito con la rappresentazione di stringa di `arg0`. Se l'elemento di formato include `formatString` e `arg0` implementa il <xref:System.IFormattable> interfaccia, quindi `arg0.ToString(formatString, null)` definisce la formattazione. In caso contrario, `arg0.ToString()` definisce la formattazione.  
  
 Se la stringa assegnata a `format` è "Grazie per aver donato {0: # # #} lattine di alimenti alla nostra organizzazione." e `arg0` è un numero intero con il valore 10, il valore restituito sarà "Grazie per aver donato 10 lattine di alimenti alla nostra organizzazione".  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  
  
oppure 
L'indice di un elemento di formato è minore di 0 (zero) oppure maggiore o uguale a 1 (uno).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della stringa espansa supererebbe <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Stringa in formato composito.</param>
        <param name="args">Matrice di oggetti da formattare.</param>
        <summary>Accoda la stringa restituita dall'elaborazione di una stringa in formato composito, che contiene zero o più elementi di formato, a questa istanza. Ogni elemento di formato viene sostituito dalla rappresentazione di stringa di un argomento corrispondente in una matrice di parametri.</summary>
        <returns>Riferimento a questa istanza con <paramref name="format" /> accodato. Ogni elemento di formato in <paramref name="format" /> viene sostituito dalla rappresentazione di stringa dell'argomento dell'oggetto corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione corrente <xref:System.Text.StringBuilder> oggetto.  
  
 Il `format` parametro è costituita da zero o più sequenze di testo combinato con zero o più segnaposto indicizzati, denominati elementi di formato, corrispondenti agli oggetti nell'elenco dei parametri di questo metodo. Il processo di formattazione sostituisce ogni elemento di formato con la rappresentazione di stringa dell'oggetto corrispondente.  
  
 La sintassi di un elemento di formato è come segue:  
  
 {*indice*[,*lunghezza*] [:*formatString*]}  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*index*|La posizione in base zero nell'elenco dei parametri dell'oggetto da formattare. Se l'oggetto specificato da *indice* viene `null`, l'elemento di formato viene sostituito dalla <xref:System.String.Empty?displayProperty=nameWithType>. Se non è disponibile alcun parametro nel *indice* posizione, un <xref:System.FormatException> viene generata un'eccezione.|  
|,*lunghezza*|Il numero minimo di caratteri nella rappresentazione di stringa del parametro. Se è positivo, il parametro è allineato a destra; Se un valore negativo, è allineato a sinistra.|  
|:*formatString*|Una stringa di formato standard o personalizzato supportato dal parametro.|  
  
> [!NOTE]
>  Per le stringhe di formato standard e personalizzati utilizzate con valori di data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Per le stringhe di formato standard e personalizzate usate con valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato standard usate con le enumerazioni, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` rappresenta gli oggetti da formattare. Ogni elemento di formato in `format` viene sostituito con la rappresentazione di stringa dell'oggetto corrispondente nel `args`. Se l'elemento di formato include `formatString` e l'oggetto corrispondente nella `args` implementa il <xref:System.IFormattable> interfaccia, quindi `args[index].ToString(formatString, provider)` definisce la formattazione. In caso contrario, `args[index].ToString()` definisce la formattazione.  
  
 Se la stringa assegnata a `format` è "Grazie per aver donato {0: # # #} lattine di alimenti alla nostra organizzazione." e `arg0` è un numero intero con il valore 10, il valore restituito sarà "Grazie per aver donato 10 lattine di alimenti alla nostra organizzazione".  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> o <paramref name="args" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  
  
oppure 
L'indice di un elemento di formato è minore di 0 (zero) o maggiore o uguale alla lunghezza della matrice <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della stringa espansa supererebbe <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">Stringa in formato composito.</param>
        <param name="arg0">Oggetto da formattare.</param>
        <summary>Accoda la stringa restituita dall'elaborazione di una stringa in formato composito, che contiene zero o più elementi di formato, a questa istanza. Ogni elemento di formato viene sostituito dalla rappresentazione di stringa di un singolo argomento usando un provider del formato specificato.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento. Al termine dell'operazione di accodamento, questa istanza conterrà tutti i dati esistenti prima dell'operazione, seguiti da una copia di <paramref name="format" /> in cui le specifiche di formato vengono sostituite dalla rappresentazione di stringa di <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) di .NET Framework per convertire il valore di `arg0` alla relativa rappresentazione di testo e incorporare tale rappresentazione corrente <xref:System.Text.StringBuilder> oggetto.  
  
 Il `format` parametro è costituita da zero o più sequenze di testo combinato con zero o più segnaposto indicizzati, denominati elementi di formato. L'indice di ogni elemento di formato deve essere zero (0), poiché questo metodo contiene un elenco di argomenti con un singolo argomento. Il processo di formattazione sostituisce ogni elemento di formato con la rappresentazione di stringa di `arg0`.  
  
 La sintassi di un elemento di formato è come segue:  
  
 {*indice*[,*lunghezza*] [:*formatString*]}  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*index*|La posizione in base zero nell'elenco dei parametri dell'oggetto da formattare. Se l'oggetto specificato da *indice* viene `null`, l'elemento di formato viene sostituito dalla <xref:System.String.Empty?displayProperty=nameWithType>. In questo caso, poiché il <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> metodo presenta un solo argomento nell'elenco di argomenti, il valore di *indice* deve sempre essere 0. In caso contrario, un <xref:System.FormatException> viene generata un'eccezione.|  
|,*lunghezza*|Il numero minimo di caratteri nella rappresentazione di stringa del parametro. Se è positivo, il parametro è allineato a destra; Se un valore negativo, è allineato a sinistra.|  
|:*formatString*|Una stringa di formato standard o personalizzato supportato dal parametro.|  
  
> [!NOTE]
>  Per le stringhe di formato standard e personalizzati utilizzate con valori di data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Per le stringhe di formato standard e personalizzate usate con valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato standard usate con le enumerazioni, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Il `provider` parametro specifica un <xref:System.IFormatProvider> implementazione in grado di fornire informazioni di formattazione per gli oggetti in `args`. `provider` può essere uno degli elementi seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.  
  
-   Oggetto <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura per `arg0` se è un valore numerico.  
  
-   Oggetto <xref:System.Globalization.DateTimeFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura per `arg0` se è un valore di data e ora.  
  
-   Una classe personalizzata <xref:System.IFormatProvider> implementazione che fornisce informazioni di formattazione per `arg0`. In genere, un'implementazione di questo tipo implementa inoltre il <xref:System.ICustomFormatter> interfaccia.  
  
 Se il `provider` parametro è `null`, formattazione informazioni vengono ottenute dalle impostazioni cultura correnti.  
  
 `arg0` rappresenta l'oggetto da formattare. Ogni elemento di formato in `format` viene sostituito con la rappresentazione di stringa di `arg0`. Se l'elemento di formato include `formatString` e `arg0` implementa il <xref:System.IFormattable> interfaccia, quindi `arg0.ToString(formatString, provider)` definisce la formattazione. In caso contrario, `arg0.ToString()` definisce la formattazione.  
  
   
  
## Examples  
 I seguenti sono incluse due chiamate al <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> (metodo). Entrambi usano le convenzioni di formattazione delle impostazioni cultura inglese-Gran Bretagna (en-GB). Il primo inserisce la rappresentazione di stringa di un <xref:System.Decimal> valore valuta in una stringa di risultato. Gli inserimenti secondo un <xref:System.DateTime> valore in due posizioni nel risultato di una stringa, il primo includendo solo il breve data stringa e la seconda stringa di ora breve.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  
  
oppure 
L'indice di un elemento di formato è minore di 0 (zero) oppure maggiore o uguale a 1 (uno).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della stringa espansa supererebbe <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">Stringa in formato composito.</param>
        <param name="args">Matrice di oggetti da formattare.</param>
        <summary>Accoda la stringa restituita dall'elaborazione di una stringa in formato composito, che contiene zero o più elementi di formato, a questa istanza. Ogni elemento di formato viene sostituito dalla rappresentazione di stringa di un argomento corrispondente in una matrice di parametri usando un provider del formato specificato.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento. Al termine dell'operazione di accodamento, questa istanza conterrà tutti i dati esistenti prima dell'operazione, seguiti da una copia di <paramref name="format" /> in cui le specifiche di formato vengono sostituite dalla rappresentazione di stringa dell'argomento dell'oggetto corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione corrente <xref:System.Text.StringBuilder> oggetto.  
  
 Il `format` parametro è costituita da zero o più sequenze di testo combinato con zero o più segnaposto indicizzati, denominati elementi di formato, corrispondenti agli oggetti nell'elenco dei parametri di questo metodo. Il processo di formattazione sostituisce ogni elemento di formato con la rappresentazione di stringa dell'oggetto corrispondente.  
  
 La sintassi di un elemento di formato è come segue:  
  
 {*indice*[,*lunghezza*] [:*formatString*]}  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*index*|La posizione in base zero nell'elenco dei parametri dell'oggetto da formattare. Se l'oggetto specificato da *indice* viene `null`, l'elemento di formato viene sostituito dalla <xref:System.String.Empty?displayProperty=nameWithType>. Se non è disponibile alcun parametro nel *indice* posizione, un <xref:System.FormatException> viene generata un'eccezione.|  
|,*lunghezza*|Il numero minimo di caratteri nella rappresentazione di stringa del parametro. Se è positivo, il parametro è allineato a destra; Se un valore negativo, è allineato a sinistra.|  
|:*formatString*|Una stringa di formato standard o personalizzato supportato dal parametro.|  
  
> [!NOTE]
>  Per le stringhe di formato standard e personalizzati utilizzate con valori di data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Per le stringhe di formato standard e personalizzate usate con valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato standard usate con le enumerazioni, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Il `provider` parametro specifica un <xref:System.IFormatProvider> implementazione in grado di fornire informazioni di formattazione per gli oggetti in `args`. `provider` può essere uno degli elementi seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.  
  
-   Oggetto <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura per valori numerici in `args`.  
  
-   Oggetto <xref:System.Globalization.DateTimeFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura per i valori di data e ora in `args`.  
  
-   Una classe personalizzata <xref:System.IFormatProvider> implementazione che fornisce informazioni di formattazione per una o più degli oggetti in `args`. In genere, un'implementazione di questo tipo implementa inoltre il <xref:System.ICustomFormatter> interfaccia. Il secondo esempio nella sezione successiva illustra un' <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> chiamata al metodo con un oggetto personalizzato <xref:System.IFormatProvider> implementazione.  
  
 Se il `provider` parametro è `null`, informazioni sul provider di formato viene ottenuti da impostazioni cultura correnti.  
  
 `args` rappresenta gli oggetti da formattare. Ogni elemento di formato in `format` viene sostituito con la rappresentazione di stringa dell'oggetto corrispondente nel `args`. Se l'elemento di formato include `formatString` e l'oggetto corrispondente nella `args` implementa il <xref:System.IFormattable> interfaccia, quindi `args[index].ToString(formatString, provider)` definisce la formattazione. In caso contrario, `args[index].ToString()` definisce la formattazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 L'esempio seguente definisce una classe personalizzata <xref:System.IFormatProvider> implementazione denominato `CustomerFormatter` che formatta un numero con trattini cliente di 10 cifre dopo il quarta e il settima cifre. Viene passato al <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metodo per creare una stringa che include il numero formattato cliente e il nome del cliente.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  
  
oppure 
L'indice di un elemento di formato è minore di 0 (zero) o maggiore o uguale alla lunghezza della matrice <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della stringa espansa supererebbe <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Stringa in formato composito.</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <summary>Accoda la stringa restituita dall'elaborazione di una stringa in formato composito, che contiene zero o più elementi di formato, a questa istanza. Ogni elemento di formato viene sostituito dalla rappresentazione di stringa di uno dei due argomenti.</summary>
        <returns>Riferimento a questa istanza con <paramref name="format" /> accodato. Ogni elemento di formato in <paramref name="format" /> viene sostituito dalla rappresentazione di stringa dell'argomento dell'oggetto corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione corrente <xref:System.Text.StringBuilder> oggetto.  
  
 Il `format` parametro è costituita da zero o più sequenze di testo combinato con zero o più segnaposto indicizzati, denominati elementi di formato, corrispondenti a `arg0` e `arg1`, i due oggetti nell'elenco dei parametri di questo metodo. Il processo di formattazione sostituisce ogni elemento di formato con la rappresentazione di stringa dell'oggetto corrispondente.  
  
 La sintassi di un elemento di formato è come segue:  
  
 {*indice*[,*lunghezza*] [:*formatString*]}  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*index*|La posizione in base zero nell'elenco dei parametri dell'oggetto da formattare. Se l'oggetto specificato da *indice* viene `null`, l'elemento di formato viene sostituito dalla <xref:System.String.Empty?displayProperty=nameWithType>. Se non è disponibile alcun parametro nel *indice* posizione, un <xref:System.FormatException> viene generata un'eccezione.|  
|,*lunghezza*|Il numero minimo di caratteri nella rappresentazione di stringa del parametro. Se è positivo, il parametro è allineato a destra; Se un valore negativo, è allineato a sinistra.|  
|:*formatString*|Una stringa di formato standard o personalizzato supportato dal parametro.|  
  
> [!NOTE]
>  Per le stringhe di formato standard e personalizzati utilizzate con valori di data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Per le stringhe di formato standard e personalizzate usate con valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato standard usate con le enumerazioni, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` e `arg1` rappresentano gli oggetti da formattare. Ogni elemento di formato in `format` viene sostituito con la rappresentazione di stringa di uno `arg0` o `arg1`. Se l'elemento di formato include `formatString` e implementa l'oggetto corrispondente il <xref:System.IFormattable> un'interfaccia, quindi `arg` *x* `.ToString(formatString, provider)` definisce la formattazione, dove *x* è l'indice dell'argomento. In caso contrario, `arg` *x* `.ToString()` definisce la formattazione.  
  
 Se la stringa assegnata a `format` è "Grazie per aver donato {0: # # #} lattine di alimenti alla nostra organizzazione." e `arg0` è un numero intero con il valore 10, il valore restituito sarà "Grazie per aver donato 10 lattine di alimenti alla nostra organizzazione".  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  
  
oppure 
L'indice di un elemento di formato è minore di 0 (zero) oppure maggiore o uguale a 2 (due).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della stringa espansa supererebbe <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">Stringa in formato composito.</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <summary>Accoda la stringa restituita dall'elaborazione di una stringa in formato composito, che contiene zero o più elementi di formato, a questa istanza. Ogni elemento di formato viene sostituito dalla rappresentazione di stringa di uno di due argomenti usando un provider del formato specificato.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento. Al termine dell'operazione di accodamento, questa istanza conterrà tutti i dati esistenti prima dell'operazione, seguiti da una copia di <paramref name="format" /> in cui le specifiche di formato vengono sostituite dalla rappresentazione di stringa dell'argomento dell'oggetto corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione corrente <xref:System.Text.StringBuilder> oggetto.  
  
 Il `format` parametro è costituita da zero o più sequenze di testo combinato con zero o più segnaposto indicizzati, denominati elementi di formato, corrispondenti agli oggetti nell'elenco dei parametri di questo metodo. Il processo di formattazione sostituisce ogni elemento di formato con la rappresentazione di stringa dell'oggetto corrispondente.  
  
 La sintassi di un elemento di formato è come segue:  
  
 {*indice*[,*lunghezza*] [:*formatString*]}  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*index*|La posizione in base zero nell'elenco dei parametri dell'oggetto da formattare. Se l'oggetto specificato da *indice* viene `null`, l'elemento di formato viene sostituito dalla <xref:System.String.Empty?displayProperty=nameWithType>. Se non è disponibile alcun parametro nel *indice* posizione, un <xref:System.FormatException> viene generata un'eccezione.|  
|,*lunghezza*|Il numero minimo di caratteri nella rappresentazione di stringa del parametro. Se è positivo, il parametro è allineato a destra; Se un valore negativo, è allineato a sinistra.|  
|:*formatString*|Una stringa di formato standard o personalizzato supportato dal parametro.|  
  
> [!NOTE]
>  Per le stringhe di formato standard e personalizzati utilizzate con valori di data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Per le stringhe di formato standard e personalizzate usate con valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato standard usate con le enumerazioni, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Il `provider` parametro specifica un <xref:System.IFormatProvider> implementazione che possa fornire informazioni di formattazione `arg0` e `arg1`. `provider` può essere uno degli elementi seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.  
  
-   Oggetto <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura per `arg0` o `arg1` se sono valori numerici.  
  
-   Oggetto <xref:System.Globalization.DateTimeFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura per `arg0` o `arg1` se si tratta di valori di data e ora.  
  
-   Una classe personalizzata <xref:System.IFormatProvider> implementazione che fornisce informazioni di formattazione `arg0` e `arg1`. In genere, un'implementazione di questo tipo implementa inoltre il <xref:System.ICustomFormatter> interfaccia.  
  
 Se il `provider` parametro è `null`, informazioni sul provider di formato viene ottenuti da impostazioni cultura correnti.  
  
 `arg0` e `arg1` rappresentano gli oggetti da formattare. Ogni elemento di formato in `format` viene sostituito con la rappresentazione di stringa dell'oggetto con l'indice corrispondente. Se l'elemento di formato include `formatString` e l'argomento corrispondente implementa le <xref:System.IFormattable> interface, quindi l'argomento `ToString(formatString, provider)` metodo consente di definire la formattazione. In caso contrario, l'argomento `ToString()` metodo consente di definire la formattazione.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> metodo per visualizzare i dati di temperatura e ora archiviati in un oggetto generico <xref:System.Collections.Generic.Dictionary%602> oggetto. Si noti che la stringa di formato include tre elementi di formato, anche se esistono solo per gli oggetti da formattare. Poiché il primo oggetto nell'elenco (un valore data e ora) viene utilizzato da due elementi di formato: verrà visualizzato il primo formato elemento l'ora e il secondo Visualizza la data.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  
  
oppure 
L'indice di un elemento di formato è minore di 0 (zero) oppure maggiore o uguale a 2 (due).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della stringa espansa supererebbe <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Stringa in formato composito.</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <param name="arg2">Terzo oggetto da formattare.</param>
        <summary>Accoda la stringa restituita dall'elaborazione di una stringa in formato composito, che contiene zero o più elementi di formato, a questa istanza. Ogni elemento di formato viene sostituito dalla rappresentazione di stringa di uno dei tre argomenti.</summary>
        <returns>Riferimento a questa istanza con <paramref name="format" /> accodato. Ogni elemento di formato in <paramref name="format" /> viene sostituito dalla rappresentazione di stringa dell'argomento dell'oggetto corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione corrente <xref:System.Text.StringBuilder> oggetto.  
  
 Il `format` parametro è costituita da zero o più sequenze di testo combinato con zero o più segnaposto indicizzati, denominati elementi di formato, corrispondenti a `arg0` tramite `arg2`, gli oggetti nell'elenco dei parametri di questo metodo. Il processo di formattazione sostituisce ogni elemento di formato con la rappresentazione di stringa dell'oggetto corrispondente.  
  
 La sintassi di un elemento di formato è come segue:  
  
 {*indice*[,*lunghezza*] [:*formatString*]}  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*index*|La posizione in base zero nell'elenco dei parametri dell'oggetto da formattare. Se l'oggetto specificato da *indice* viene `null`, l'elemento di formato viene sostituito dalla <xref:System.String.Empty?displayProperty=nameWithType>. Se non è disponibile alcun parametro nel *indice* posizione, un <xref:System.FormatException> viene generata un'eccezione.|  
|,*lunghezza*|Il numero minimo di caratteri nella rappresentazione di stringa del parametro. Se è positivo, il parametro è allineato a destra; Se un valore negativo, è allineato a sinistra.|  
|:*formatString*|Una stringa di formato standard o personalizzato supportato dal parametro.|  
  
> [!NOTE]
>  Per le stringhe di formato standard e personalizzati utilizzate con valori di data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Per le stringhe di formato standard e personalizzate usate con valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato standard usate con le enumerazioni, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, e `arg2` rappresentano gli oggetti da formattare. Ogni elemento di formato in `format` viene sostituito con la rappresentazione di stringa di uno `arg0`, `arg1`, o `arg2`, a seconda dell'indice dell'elemento di formato. Se l'elemento di formato include `formatString` e l'oggetto corrispondente nella `args` implementa il <xref:System.IFormattable> interfaccia, quindi `arg` *x* `.ToString(formatString, null)` definisce la formattazione, in cui * x* è l'indice dell'argomento. In caso contrario, `arg` *x* `.ToString()` definisce la formattazione.  
  
 Se la stringa assegnata a `format` è "Grazie per aver donato {0: # # #} lattine di alimenti alla nostra organizzazione." e `arg0` è un numero intero con il valore 10, il valore restituito sarà "Grazie per aver donato 10 lattine di alimenti alla nostra organizzazione".  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.AppendFormat%2A> (metodo).  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  
  
oppure 
L'indice di un elemento di formato è minore di 0 (zero) oppure maggiore o uguale a 3 (due).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della stringa espansa supererebbe <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">Stringa in formato composito.</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <param name="arg2">Terzo oggetto da formattare.</param>
        <summary>Accoda la stringa restituita dall'elaborazione di una stringa in formato composito, che contiene zero o più elementi di formato, a questa istanza. Ogni elemento di formato viene sostituito dalla rappresentazione di stringa di uno di tre argomenti usando un provider del formato specificato.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento. Al termine dell'operazione di accodamento, questa istanza conterrà tutti i dati esistenti prima dell'operazione, seguiti da una copia di <paramref name="format" /> in cui le specifiche di formato vengono sostituite dalla rappresentazione di stringa dell'argomento dell'oggetto corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa il [funzionalità di formattazione composita](~/docs/standard/base-types/composite-formatting.md) di .NET Framework per convertire il valore di un oggetto nella relativa rappresentazione di testo e incorporare tale rappresentazione corrente <xref:System.Text.StringBuilder> oggetto.  
  
 Il `format` parametro è costituita da zero o più sequenze di testo combinato con zero o più segnaposto indicizzati, denominati elementi di formato, corrispondenti agli oggetti nell'elenco dei parametri di questo metodo. Il processo di formattazione sostituisce ogni elemento di formato con la rappresentazione di stringa dell'oggetto corrispondente.  
  
 La sintassi di un elemento di formato è come segue:  
  
 {*indice*[,*lunghezza*] [:*formatString*]}  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*index*|La posizione in base zero nell'elenco dei parametri dell'oggetto da formattare. Se l'oggetto specificato da *indice* viene `null`, l'elemento di formato viene sostituito dalla <xref:System.String.Empty?displayProperty=nameWithType>. Se non è disponibile alcun parametro nel *indice* posizione, un <xref:System.FormatException> viene generata un'eccezione.|  
|,*lunghezza*|Il numero minimo di caratteri nella rappresentazione di stringa del parametro. Se è positivo, il parametro è allineato a destra; Se un valore negativo, è allineato a sinistra.|  
|:*formatString*|Una stringa di formato standard o personalizzato supportato dal parametro.|  
  
> [!NOTE]
>  Per le stringhe di formato standard e personalizzati utilizzate con valori di data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Per le stringhe di formato standard e personalizzate usate con valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato standard usate con le enumerazioni, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Il `provider` parametro specifica un <xref:System.IFormatProvider> implementazione che possa fornire informazioni di formattazione `arg0` e `arg1`. `provider` può essere uno degli elementi seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.  
  
-   Oggetto <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura per `arg0` o `arg1` se sono valori numerici.  
  
-   Oggetto <xref:System.Globalization.DateTimeFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura per `arg0`, `arg1`, o `arg2` se si tratta di valori di data e ora.  
  
-   Una classe personalizzata <xref:System.IFormatProvider> implementazione che fornisce informazioni di formattazione `arg0`, `arg1`, e `arg2`. In genere, un'implementazione di questo tipo implementa inoltre il <xref:System.ICustomFormatter> interfaccia.  
  
 Se il `provider` parametro è `null`, informazioni sul provider di formato viene ottenuti da impostazioni cultura correnti.  
  
 `arg0`, `arg1`, e `arg2` rappresentano gli oggetti da formattare. Ogni elemento di formato in `format` viene sostituito con la rappresentazione di stringa dell'oggetto con l'indice corrispondente. Se l'elemento di formato include `formatString` e l'argomento corrispondente implementa le <xref:System.IFormattable> interface, quindi l'argomento `ToString(formatString, provider)` metodo consente di definire la formattazione. In caso contrario, l'argomento `ToString()` metodo consente di definire la formattazione.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodo illustrano il risultato di un valore booleano `And` operazione con i valori interi. Si noti che la stringa di formato include sei elementi di formato, ma il metodo ha solo tre elementi nell'elenco di argomenti, poiché ogni elemento viene formattato in due modi diversi.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  
  
oppure 
L'indice di un elemento di formato è minore di 0 (zero) oppure maggiore o uguale a 3 (tre).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della stringa espansa supererebbe <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accoda il terminatore di riga predefinito oppure una copia di una stringa specificata e il terminatore di riga predefinito alla fine di questa istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accoda il terminatore di riga predefinito alla fine dell'oggetto <see cref="T:System.Text.StringBuilder" /> corrente.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il terminatore di riga predefinito è il valore corrente del <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> proprietà.  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.AppendLine%2A> (metodo).  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da accodare.</param>
        <summary>Accoda una copia della stringa specificata seguita dal terminatore di riga predefinito alla fine dell'oggetto <see cref="T:System.Text.StringBuilder" /> corrente.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di accodamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il terminatore di riga predefinito è il valore corrente del <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> proprietà.  
  
 La capacità di questa istanza viene regolata in base alle esigenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <see cref="T:System.Text.StringBuilder" /> chiamando il <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> costruttore, sia la lunghezza e dalla capacità del <see cref="T:System.Text.StringBuilder" /> istanza può crescere oltre il valore di relativo <see cref="P:System.Text.StringBuilder.MaxCapacity" /> proprietà. Ciò può verificarsi in particolare quando si chiama il <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metodi per aggiungere stringhe di piccole dimensioni.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero massimo di caratteri che possono essere contenuti nella memoria allocata dall'istanza corrente.</summary>
        <value>Numero massimo di caratteri che possono essere contenuti nella memoria allocata dall'istanza corrente. Questo valore può essere compreso tra <see cref="P:System.Text.StringBuilder.Length" /> e <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> non influenza il valore di stringa dell'istanza corrente. <xref:System.Text.StringBuilder.Capacity%2A> può essere ridotto fino a quando non è minore di <xref:System.Text.StringBuilder.Length%2A>.  
  
 Il <xref:System.Text.StringBuilder> alloca più spazio quando richiesto e aumenta in modo dinamico <xref:System.Text.StringBuilder.Capacity%2A> conseguenza. Per motivi di prestazioni, un <xref:System.Text.StringBuilder> potrebbe allocare altra memoria quelle necessarie. La quantità di memoria allocata è specifico dell'implementazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Capacity%2A> proprietà.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore specificato per un'operazione set è minore della lunghezza corrente di questa istanza.  
  
oppure 
Il valore specificato per un'operazione set è minore della capacità massima.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posizione del carattere.</param>
        <summary>Ottiene o imposta il carattere nella posizione del carattere specificata in questa istanza.</summary>
        <value>Carattere Unicode nella posizione <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `index` parametro è la posizione di un carattere all'interno di <xref:System.Text.StringBuilder>. Il primo carattere nella stringa è in corrispondenza dell'indice 0. La lunghezza di una stringa è il numero di caratteri in esso contenuti. L'ultimo carattere accessibile di un <xref:System.Text.StringBuilder> istanza è in corrispondenza dell'indice <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> la proprietà predefinita del <xref:System.Text.StringBuilder> classe. In c#, è un indicizzatore. Ciò significa che è possono recuperare singoli caratteri dal <xref:System.Text.StringBuilder.Chars%2A> proprietà come illustrato nell'esempio seguente, che conta il numero di caratteri alfabetici, spazi vuoti e caratteri di punteggiatura in una stringa.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Prestazioni e l'indicizzazione basata su caratteri

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nei limiti dell'istanza durante l'impostazione di un carattere.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> non è compreso nei limiti dell'istanza durante l'ottenimento di un carattere.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti i caratteri dall'istanza di <see cref="T:System.Text.StringBuilder" /> corrente.</summary>
        <returns>Oggetto la cui proprietà <see cref="P:System.Text.StringBuilder.Length" /> è 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> è un metodo pratico che è equivalente all'impostazione di <xref:System.Text.StringBuilder.Length%2A> proprietà dell'istanza corrente a 0 (zero).  
  
 Chiama il <xref:System.Text.StringBuilder.Clear%2A> metodo non modifica l'istanza corrente <xref:System.Text.StringBuilder.Capacity%2A> o <xref:System.Text.StringBuilder.MaxCapacity%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente crea un'istanza di un <xref:System.Text.StringBuilder> oggetto con una stringa, le chiamate di <xref:System.Text.StringBuilder.Clear%2A> (metodo) e quindi aggiunge una nuova stringa.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Posizione iniziale in questa istanza da cui verranno copiati i caratteri. L'indice è in base zero.</param>
        <param name="destination">Matrice in cui verranno copiati i caratteri.</param>
        <param name="destinationIndex">Posizione iniziale in <c>destination</c> in cui verranno copiati i caratteri. L'indice è in base zero.</param>
        <param name="count">Numero dei caratteri da copiare.</param>
        <summary>Copia i caratteri da un segmento specificato di questa istanza a un segmento specificato di una matrice <see cref="T:System.Char" /> di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.StringBuilder.CopyTo%2A> metodo deve essere usato nei rari casi, quando è necessario copiare in modo efficiente sezioni successive di un <xref:System.Text.StringBuilder> oggetto in una matrice. La matrice deve essere una dimensione fissa, preallocata, riutilizzabile e possibilmente globalmente accessibile.  
  
 Ad esempio, è stato possibile popolare l'applicazione un <xref:System.Text.StringBuilder> dell'oggetto con un numero elevato di caratteri, usare il <xref:System.Text.StringBuilder.CopyTo%2A> metodo per copiare le parti successive di dimensioni ridotte del <xref:System.Text.StringBuilder> oggetto in una matrice in cui vengono elaborate le parti. Quando tutti i dati nel <xref:System.Text.StringBuilder> oggetto viene elaborato, le dimensioni del <xref:System.Text.StringBuilder> oggetto è impostato su zero e il ciclo viene ripetuto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.CopyTo%2A> (metodo).  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="sourceIndex" /> è maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" /> è maggiore della lunghezza di questa istanza.  
  
oppure 
 <paramref name="destinationIndex" /> + <paramref name="count" /> è maggiore della lunghezza di <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Capacità minima da garantire.</param>
        <summary>Garantisce che la capacità di questa istanza di <see cref="T:System.Text.StringBuilder" /> corrisponda almeno al valore specificato.</summary>
        <returns>Nuova capacità di questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la capacità corrente è inferiore al `capacity` parametro, la memoria per questa istanza viene riallocata che deve per contenere almeno `capacity` numero di caratteri; in caso contrario, memoria non è stata modificata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.EnsureCapacity%2A> (metodo).  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.  
  
oppure 
Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Oggetto da confrontare con questa istanza o <see langword="null" />.</param>
        <summary>Restituisce un valore che indica se questa istanza è uguale a un oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se questa istanza e <paramref name="sb" /> hanno la stessa stringa e gli stessi valori <see cref="P:System.Text.StringBuilder.Capacity" /> e<see cref="P:System.Text.StringBuilder.MaxCapacity" />; altrimenti, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice seguente usa il <xref:System.Text.StringBuilder.Equals%2A> metodo per verificare se due <xref:System.Text.StringBuilder> oggetti sono uguali. Il metodo viene chiamato più volte dopo che vengono apportate piccole modifiche a ogni oggetto e i risultati vengono visualizzati nella console.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserisce la rappresentazione di stringa di un oggetto specificato in questa istanza in una posizione del carattere specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un valore booleano in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un intero senza segno a 8 bit specificato in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un carattere Unicode specificato in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.  
  
oppure 
Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Matrice di caratteri da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di una matrice specificata di caratteri Unicode in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
 Se `value` viene `null`, il <xref:System.Text.StringBuilder> non viene modificato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.  
  
oppure 
Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un numero decimale in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un numero a virgola mobile e precisione doppia in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un intero con segno a 16 bit specificato in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un intero con segno a 32 bit specificato in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un intero con segno a 64 bit in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Oggetto da inserire o <see langword="null" />.</param>
        <summary>Inserisce la rappresentazione di stringa di un oggetto in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
 Se `value` è `null`, il valore di questa istanza viene modificato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un intero con segno a 8 bit specificato in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un numero a virgola mobile a precisione singola in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Stringa da inserire.</param>
        <summary>Inserisce una stringa in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità viene regolata in base alle esigenze.  
  
 Questa istanza di <xref:System.Text.StringBuilder> non viene modificato se `value` viene `null`, o `value` non `null` ma la sua lunghezza è pari a zero.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza corrente di questa istanza.  
  
oppure 
La somma della lunghezza corrente di questo oggetto <see cref="T:System.Text.StringBuilder" /> e della lunghezza di <paramref name="value" /> è superiore a <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un intero senza segno a 16 bit in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un intero senza segno a 32 bit in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Valore da inserire.</param>
        <summary>Inserisce la rappresentazione di stringa di un intero senza segno a 64 bit in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> viene usato per ottenere una rappresentazione di stringa di `value`. Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versioni precedenti, le chiamate a questo metodo ha generato un' <see cref="T:System.ArgumentOutOfRangeException" /> se inseriscono <paramref name="value" /> causerebbe lunghezza totale dell'oggetto di superare <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il metodo genera un <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Stringa da inserire.</param>
        <param name="count">Numero delle operazioni di inserimento di <c>value</c>.</param>
        <summary>Inserisce una o più copie di una stringa specificata in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
 Ciò <xref:System.Text.StringBuilder> oggetto non viene modificato se `value` viene `null`, `value` non `null` ma la sua lunghezza è pari a zero, o `count` è uguale a zero.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore della lunghezza corrente di questa istanza.  
  
oppure 
 <paramref name="count" /> è minore di zero.</exception>
        <exception cref="T:System.OutOfMemoryException">La somma della lunghezza corrente di questo oggetto <see cref="T:System.Text.StringBuilder" /> e della lunghezza di <paramref name="value" /> moltiplicato per <paramref name="count" /> è superiore a <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posizione in questa istanza in cui inizia l'inserimento.</param>
        <param name="value">Matrice di caratteri.</param>
        <param name="startIndex">Indice iniziale all'interno di <c>value</c>.</param>
        <param name="charCount">Numero di caratteri da scrivere.</param>
        <summary>Inserisce la rappresentazione di stringa di una sottomatrice specificata di caratteri Unicode in questa istanza nella posizione del carattere specificata.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caratteri esistenti vengono spostate per liberare spazio per il nuovo testo. La capacità di questa istanza viene regolata in base alle esigenze.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Insert%2A> (metodo).  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" /> e <paramref name="startIndex" /> e <paramref name="charCount" /> sono diversi da zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="index" />, <paramref name="startIndex" /> o <paramref name="charCount" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> è maggiore della lunghezza di questa istanza.  
  
oppure 
 la somma di <paramref name="startIndex" /> e <paramref name="charCount" /> non è una posizione all'interno di <paramref name="value" />.  
  
oppure 
Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la lunghezza dell'oggetto <see cref="T:System.Text.StringBuilder" /> corrente.</summary>
        <value>Lunghezza di questa istanza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lunghezza di una <xref:System.Text.StringBuilder> oggetto viene definito dal relativo numero di <xref:System.Char> oggetti.  
  
 Ad esempio la <xref:System.String.Length%2A?displayProperty=nameWithType> proprietà, il <xref:System.Text.StringBuilder.Length%2A> proprietà indica la lunghezza dell'oggetto stringa corrente. A differenza di <xref:System.String.Length%2A?displayProperty=nameWithType> proprietà, che è di sola lettura, la <xref:System.Text.StringBuilder.Length%2A> proprietà consente di modificare la lunghezza della stringa archiviata per il <xref:System.Text.StringBuilder> oggetto.  
  
 Se la lunghezza specificata è minore della lunghezza corrente, corrente <xref:System.Text.StringBuilder> oggetto viene troncato alla lunghezza specificata. Se la lunghezza specificata è maggiore della lunghezza corrente, la fine del valore della stringa dell'oggetto corrente <xref:System.Text.StringBuilder> oggetto viene riempito con il carattere Unicode NULL (u+0000).  
  
 Se la lunghezza specificata è maggiore della capacità corrente, <xref:System.Text.StringBuilder.Capacity%2A> aumenta in modo che sia maggiore o uguale alla lunghezza specificata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Length%2A> proprietà.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore specificato per un'operazione impostata è minore di zero o maggiore di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la capacità massima di questa istanza.</summary>
        <value>Numero massimo di caratteri che questa istanza può contenere.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità massima per questa implementazione è <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Tuttavia, questo valore è specifico dell'implementazione e potrebbe essere diverso nelle implementazioni di altri o versione successive. È possibile impostare esplicitamente la capacità massima di un <xref:System.Text.StringBuilder> chiamando il <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> costruttore.  
  
 Nel[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando si crea un'istanza di <xref:System.Text.StringBuilder> chiamando il <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> costruttore, sia la lunghezza e dalla capacità del <xref:System.Text.StringBuilder> istanza può crescere oltre il valore di relativo <xref:System.Text.StringBuilder.MaxCapacity%2A> proprietà. Ciò può verificarsi in particolare quando si chiama il <xref:System.Text.StringBuilder.Append%2A> e <xref:System.Text.StringBuilder.AppendFormat%2A> metodi per aggiungere stringhe di piccole dimensioni.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">Numero di caratteri da rimuovere.</param>
        <summary>Rimuove l'intervallo di caratteri specificato da questa istanza.</summary>
        <returns>Riferimento a questa istanza dopo il completamento dell'operazione di rimozione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo corrente rimuove l'intervallo di caratteri specificato dall'istanza corrente. I caratteri alla posizione (`startIndex` + `length`) vengono spostati `startIndex`, e il valore di stringa dell'istanza corrente è ridotto a `length`. La capacità dell'istanza corrente non è interessata.  
  
> [!NOTE]
>  Il <xref:System.Text.StringBuilder.Remove%2A> metodo modifica il valore dell'oggetto corrente <xref:System.Text.StringBuilder> dell'istanza e restituisce tale istanza. Non creare e restituire un nuovo <xref:System.Text.StringBuilder> oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Remove%2A> (metodo).  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero, oppure <paramref name="startIndex" /> + <paramref name="length" /> è maggiore della lunghezza di questa istanza.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sostituisce tutte le occorrenze di un carattere o di una stringa specificata in questa istanza con un altro carattere o un'altra stringa specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Carattere da sostituire.</param>
        <param name="newChar">Carattere che sostituisce <c>oldChar</c>.</param>
        <summary>Sostituisce tutte le occorrenze di un carattere specificato in questa istanza con un altro carattere specificato.</summary>
        <returns>Riferimento a questa istanza con <paramref name="oldChar" /> sostituito da <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale, distinzione maiuscole/minuscole per identificare le occorrenze di `oldChar` nell'istanza corrente. Le dimensioni dell'oggetto corrente <xref:System.Text.StringBuilder> istanza rimane invariata dopo la sostituzione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Replace%2A> (metodo).  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Stringa da sostituire.</param>
        <param name="newValue">Stringa che sostituisce <c>oldValue</c> oppure <see langword="null" />.</param>
        <summary>Sostituisce tutte le occorrenze di una stringa specificata in questa istanza con un'altra stringa specificata.</summary>
        <returns>Riferimento a questa istanza con tutte le istanze di <paramref name="oldValue" /> sostituite da <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale, distinzione maiuscole/minuscole per identificare le occorrenze di `oldValue` nell'istanza corrente. Se `newValue` viene `null` oppure <xref:System.String.Empty?displayProperty=nameWithType>, tutte le occorrenze di `oldValue` vengono rimossi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Replace%2A> (metodo).  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="oldValue" /> è zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Carattere da sostituire.</param>
        <param name="newChar">Carattere che sostituisce <c>oldChar</c>.</param>
        <param name="startIndex">Posizione in questa istanza in cui inizia la sottostringa.</param>
        <param name="count">Lunghezza della sottostringa.</param>
        <summary>Sostituisce tutte le occorrenze di un carattere specificato in una sottostringa di questa istanza con un altro carattere specificato.</summary>
        <returns>Riferimento a questa istanza con <paramref name="oldChar" /> sostituito da <paramref name="newChar" /> nell'intervallo compreso tra <paramref name="startIndex" /> e <paramref name="startIndex" /> + <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale, distinzione maiuscole/minuscole per identificare le occorrenze di `oldChar` nell'istanza corrente. Le dimensioni dell'oggetto corrente <xref:System.Text.StringBuilder> oggetto resta invariato dopo la sostituzione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Replace%2A> (metodo).  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" /> è maggiore della lunghezza del valore di questa istanza.  
  
oppure 
 <paramref name="startIndex" /> o <paramref name="count" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Stringa da sostituire.</param>
        <param name="newValue">Stringa che sostituisce <c>oldValue</c> oppure <see langword="null" />.</param>
        <param name="startIndex">Posizione in questa istanza in cui inizia la sottostringa.</param>
        <param name="count">Lunghezza della sottostringa.</param>
        <summary>Sostituisce tutte le occorrenze di una stringa specificata in una sottostringa di questa istanza con un'altra stringa specificata.</summary>
        <returns>Riferimento a questa istanza con tutte le istanze di <paramref name="oldValue" /> sostituite da <paramref name="newValue" /> nell'intervallo compreso tra <paramref name="startIndex" /> e <paramref name="startIndex" /> + <paramref name="count" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale, distinzione maiuscole/minuscole per identificare le occorrenze di `oldValue` nella sottostringa specificata. Se `newValue` viene `null` oppure <xref:System.String.Empty?displayProperty=nameWithType>, tutte le occorrenze di `oldValue` vengono rimossi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Text.StringBuilder.Replace%2A> (metodo).  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="oldValue" /> è zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="startIndex" /> più <paramref name="count" /> indica una posizione di carattere non all'interno di questa istanza.  
  
oppure 
Aumentando il valore di questa istanza, verrebbe superato il limite di <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto da popolare con le informazioni sulla serializzazione.</param>
        <param name="context">Posizione di archiviazione e recupero dei dati serializzati. Riservato per utilizzi futuri.</param>
        <summary>Popola un oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con i dati necessari per deserializzare l'oggetto <see cref="T:System.Text.StringBuilder" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `context` parametro è riservato per usi futuri e non fa parte di questa operazione.  
  
 Per altre informazioni, vedere il metodo <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore di un oggetto <see cref="T:System.Text.StringBuilder" /> in un oggetto <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il valore di questa istanza in un oggetto <see cref="T:System.String" />.</summary>
        <returns>Stringa il cui valore è lo stesso di questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare il <xref:System.Text.StringBuilder.ToString%2A> metodo per convertire il <xref:System.Text.StringBuilder> dell'oggetto a un <xref:System.String> dell'oggetto prima di poter passare la stringa rappresentata dalla <xref:System.Text.StringBuilder> oggetto da un metodo che presenta un <xref:System.String> parametro o per visualizzarlo nell'interfaccia utente.  
  
   
  
## Examples  
 Nel codice riportato di seguito viene illustrata la chiamata al metodo <xref:System.Text.StringBuilder.ToString%2A>. In questo esempio fa parte di un esempio più esaustivo disponibile per il <xref:System.Text.StringBuilder> classe.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione iniziale della sottostringa in questa istanza.</param>
        <param name="length">Lunghezza della sottostringa.</param>
        <summary>Converte il valore di una sottostringa di questa istanza in un oggetto <see cref="T:System.String" />.</summary>
        <returns>Stringa il cui valore è lo stesso della sottostringa specificata di questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare il <xref:System.Text.StringBuilder.ToString%2A> metodo per convertire il <xref:System.Text.StringBuilder> dell'oggetto a un <xref:System.String> dell'oggetto prima di poter passare la stringa rappresentata dalla <xref:System.Text.StringBuilder> oggetto da un metodo che presenta un <xref:System.String> parametro o per visualizzarlo nell'interfaccia utente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.  
  
oppure 
la somma di <paramref name="startIndex" /> e <paramref name="length" /> è maggiore della lunghezza dell'istanza corrente.</exception>
      </Docs>
    </Member>
  </Members>
</Type>