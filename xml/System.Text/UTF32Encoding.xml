<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f95e573289acacb798f6a2ed881a000896e12920" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48666737" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UTF32Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF32Encoding sealed : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF32Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una codifica UTF-32 dei caratteri Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica è il processo di trasformazione di un insieme di caratteri Unicode in una sequenza di byte. La decodifica è il processo di trasformazione di una sequenza di byte codificati in un set di caratteri Unicode.  
  
 Il [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) assegna un punto di codice (un numero) per ogni carattere in ogni script supportato. Un formato di trasformazione Unicode (UTF) è un modo per codificare quel punto di codice. Il [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) utilizza i seguenti UTF:  
  
-   UTF-8, che rappresenta ogni punto di codice come una sequenza di uno a quattro byte.  
  
-   UTF-16, che rappresenta ogni punto di codice come una sequenza di numeri interi a 16 bit di uno o due.  
  
-   UTF-32, che rappresenta ogni punto di codice come valore intero a 32 bit.  
  
 Per altre informazioni sui formati UTF e altre codifiche supportati da <xref:System.Text>, vedere [codifica dei caratteri in .NET](~/docs/standard/base-types/character-encoding.md).
  
 Il <xref:System.Text.UTF32Encoding> classe rappresenta una codifica UTF-32. Il codificatore può utilizzare l'ordine dei byte big-endian (byte più significativo primo) o il little endian (byte meno significativo prima). Ad esempio, l'alfabeto latino (punto di codice u+0041) viene serializzato come segue (in esadecimale):  
  
-   Ordine dei byte big-endian: 00 00 00 41  
  
-   Ordine dei byte little-endian little: 41 00 00 00  
  
 È in genere più efficiente per archiviare i caratteri Unicode utilizzando l'ordine dei byte nativa. Ad esempio, è preferibile usare l'ordine dei byte little-endian little su piattaforme little-endian, ad esempio computer con processori Intel. <xref:System.Text.UTF32Encoding> corrisponde alle tabelle di codici di Windows (ordine dei byte little-endian little) 12000 e 12001 (nell'ordine dei byte big endian). È possibile determinare il "architettura endian" di una particolare architettura chiamando il <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> (metodo).  
  
 Facoltativamente, il <xref:System.Text.UTF32Encoding> oggetto fornisce un byte order mark (BOM), ovvero una matrice di byte che può essere anteposto alla sequenza di byte risultante dal processo di codifica. Se il preambolo contiene un byte order mark (BOM), consente il decodificatore di determinare l'ordine dei byte e il formato di trasformazione o UTF di una matrice di byte.  
  
 Se il <xref:System.Text.UTF32Encoding> istanza è configurata per fornire un indicatore ordine byte, è possibile recuperarla chiamando il <xref:System.Text.UTF32Encoding.GetPreamble%2A> metodo; in caso contrario, il metodo restituisce una matrice vuota. Si noti che, anche se un <xref:System.Text.UTF32Encoding> oggetto è configurato per il supporto della distinta base, è necessario includere il carattere BOM all'inizio del flusso di byte codificato come appropriato; i metodi di codifica del <xref:System.Text.UTF32Encoding> classe non eseguire questa operazione automaticamente.  
  
 Per abilitare il rilevamento di errore e rendere più sicuro l'istanza della classe, è consigliabile creare un <xref:System.Text.UTF32Encoding> chiamando il <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e l'impostazione relativo `throwOnInvalidBytes` argomento `true`. Con il rilevamento di errori, un metodo che rileva una sequenza di caratteri o byte non valida genera un <xref:System.ArgumentException> eccezione. Senza il rilevamento di errori, viene generata alcuna eccezione e la sequenza non valida in genere viene ignorata.  
  
 È possibile creare un'istanza di un <xref:System.Text.UTF32Encoding> oggetti in diversi modi, a seconda del fatto che si desidera per fornire un byte order mark (BOM), se si desidera che la codifica big-endian o little-endian e se si desidera abilitare il rilevamento errori. La tabella seguente elenca i <xref:System.Text.UTF32Encoding> costruttori e i <xref:System.Text.Encoding> le proprietà che restituiscono un <xref:System.Text.UnicodeEncoding> oggetto.  
  
|Member|Ordine dei byte|INDICATORE ORDINE BYTE|Rilevamento degli errori|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|Little-endian|Yes|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|Little-endian|Yes|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurabile|Configurabile|Nessuna (fallback di sostituzione)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurabile|Configurabile|Configurabile|  
  
 Il <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodo determina il numero di byte risultanti dalla codifica di un set di caratteri Unicode e il <xref:System.Text.UTF32Encoding.GetBytes%2A> metodo esegue l'effettiva codifica.  
  
 Allo stesso modo, il <xref:System.Text.UTF32Encoding.GetCharCount%2A> metodo determina il numero di caratteri risultanti dalla decodifica una sequenza di byte e il <xref:System.Text.UTF32Encoding.GetChars%2A> e <xref:System.Text.UTF32Encoding.GetString%2A> metodi eseguono la decodifica effettivo.  
  
 Per un codificatore o un decodificatore che è in grado di salvare le informazioni sullo stato codifica o decodifica i dati che si estende su più blocchi (ad esempio string di 1 milione di caratteri che vengono codificati in caratteri 100.000 segmenti), usare il <xref:System.Text.UTF32Encoding.GetEncoder%2A> e <xref:System.Text.UTF32Encoding.GetDecoder%2A> proprietà, rispettivamente.  
  
   
  
## Examples  
 L'esempio seguente illustra il comportamento di <xref:System.Text.UTF32Encoding> oggetti con e senza il rilevamento di errori abilitato. Crea una matrice di byte il cui ultimo quattro byte rappresentano una coppia di surrogati non valida; surrogato alto U + D8FF è seguito da un 01FF U +, che è compreso nell'intervallo dei surrogati basso (0xDC00 e 0xDFFF). Senza il rilevamento di errori, il decodificatore UTF32 Usa il fallback di sostituzione per sostituire la coppia di surrogati non valida con REPLACEMENT CHARACTER (U + FFFD).  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 Nell'esempio seguente codifica una stringa di caratteri Unicode in una matrice di byte usando un <xref:System.Text.UTF32Encoding> oggetto. Quindi, la matrice di byte viene decodificata in una stringa per illustrare che non vi sia alcuna perdita di dati.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 L'esempio seguente usa la stessa stringa come quello precedente, ad eccezione del fatto che scrive i byte con codificati in un file e i prefissi il flusso di byte con un byte order mark (BOM). Quindi legge il file in due modi diversi: come file di testo tramite un <xref:System.IO.StreamReader> ; dell'oggetto e come un file binario. Come si può immaginare, in entrambi i casi è il carattere BOM incluso nella stringa di appena letta.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Text.UnicodeEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informazioni sulle codifiche</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF32Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF32Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un'istanza che usa l'ordine dei byte little-endian little, fornisce un byte order mark Unicode e non genera un'eccezione quando viene rilevata una codifica non è valido.  
  
> [!NOTE]
>  Per motivi di sicurezza, è consigliabile abilitare il rilevamento errori chiamando il <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e l'impostazione relativa `throwOnInvalidCharacters` argomento `true`.  
  
   
  
## Examples  
 Il seguente esempio recupera e Visualizza e contrassegna l'ordine dei byte per diversi <xref:System.Text.UTF32Encoding> istanze.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> per usare l'ordine dei byte big-endian (byte più significativo al primo posto) o <see langword="false" /> per usare l'ordine dei byte little-endian (byte meno significativo al primo posto).</param>
        <param name="byteOrderMark">
          <see langword="true" /> per specificare che viene fornito un byte order mark Unicode; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF32Encoding" />. I parametri specificano se usare l'ordine dei byte big-endian e se il metodo <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> restituisce un byte order mark Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un'istanza che non genera un'eccezione quando viene rilevata una codifica non è valido.  
  
> [!NOTE]
>  Per motivi di sicurezza, è consigliabile abilitare il rilevamento errori chiamando il <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e l'impostazione relativa `throwOnInvalidCharacters` argomento `true`.  
  
   
  
## Examples  
 Il seguente esempio recupera e Visualizza e contrassegna l'ordine dei byte per diversi <xref:System.Text.UTF32Encoding> istanze.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidCharacters As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark, throwOnInvalidCharacters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> per usare l'ordine dei byte big-endian (byte più significativo al primo posto) o <see langword="false" /> per usare l'ordine dei byte little-endian (byte meno significativo al primo posto).</param>
        <param name="byteOrderMark">
          <see langword="true" /> per specificare che viene fornito un byte order mark Unicode; in caso contrario, <see langword="false" />.</param>
        <param name="throwOnInvalidCharacters">
          <see langword="true" /> per specificare che viene generata un'eccezione quando viene rilevata una codifica non valida; in caso contrario <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.UTF32Encoding" />. I parametri specificano se usare l'ordine dei byte big-endian, se fornire un byte order mark Unicode e se generare un'eccezione quando viene rilevata una codifica non valida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `throwOnInvalidCharacters` viene `true`, un metodo che rileva una sequenza di byte non validi genera <xref:System.ArgumentException?displayProperty=nameWithType>. In caso contrario, il metodo non genera un'eccezione e la sequenza non valida verrà ignorata.  
  
> [!NOTE]
>  Per motivi di sicurezza, è consigliabile abilitare il rilevamento errori chiamando il <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e l'impostazione relativa `throwOnInvalidCharacters` argomento `true`.  
  
   
  
## Examples  
 L'esempio seguente illustra il comportamento di <xref:System.Text.UTF32Encoding>, con il rilevamento di errori abilitato e senza.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF32Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Classe <see cref="T:System.Object" /> da confrontare con l'oggetto corrente.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Object" /> specificato è uguale all'oggetto <see cref="T:System.Text.UTF32Encoding" /> corrente.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> è un'istanza di <see cref="T:System.Text.UTF32Encoding" /> ed è uguale all'oggetto corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due <xref:System.Text.UTF32Encoding> gli oggetti sono considerati uguali se vengono soddisfatte tutte le condizioni seguenti:  
  
-   Entrambi gli oggetti utilizzano lo stesso ordine di byte.  
  
-   Entrambi gli oggetti forniscono il byte order mark, o entrambi non lo sono.  
  
-   Entrambi gli oggetti utilizzano lo stesso di fallback del codificatore.  
  
-   Entrambi gli oggetti utilizzano lo stesso di fallback del decodificatore.  
  
   
  
## Examples  
 L'esempio seguente crea <xref:System.Text.UTF32Encoding> gli oggetti usando parametri diversi valori e li archivia per verificarne l'uguaglianza.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF32Encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Oggetto <see cref="T:System.String" /> contenente il set di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica dei caratteri nell'oggetto <see cref="T:System.String" /> specificato.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserendo il preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non viene riflessa nel valore restituito dal <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> e <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> metodi per la quale calcolare il numero massimo e quello effettivo di byte necessari per codificare una stringa. Visualizza anche il numero effettivo di byte necessari per archiviare un flusso di byte con un byte order mark.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="s" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Il <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserimento di un preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non viene riflessa nel valore restituito dal <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="index">Indice del primo carattere da codificare.</param>
        <param name="count">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero di byte prodotti dalla codifica di un set di caratteri dalla matrice di caratteri specificata.</summary>
        <returns>Numero di byte prodotti dalla codifica dei caratteri specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserimento di un preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore e il numero di byte del preambolo non viene riflessa nel valore restituito dal <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente popola una matrice con un alfabeto latino maiuscolo e minuscoli e chiama il <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo per determinare il numero di byte necessari per codificare i caratteri minuscoli latini. Quindi visualizza tale informazione insieme il numero totale di byte necessari se viene aggiunto un byte order mark. Confronta con il valore restituito da questo numero di <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo, che indica il numero massimo di byte necessari per codificare i caratteri minuscoli latini. Nell'esempio seguente popola una matrice con una combinazione di caratteri greco e cirillico e le chiamate di <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodo per determinare il numero di byte necessari per codificare i caratteri cirillici. Quindi visualizza tale informazione insieme il numero totale di byte necessari se viene aggiunto un byte order mark. Confronta con il valore restituito da questo numero di <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodo, che indica il numero massimo di byte necessari per codificare i caratteri cirillici.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica un set di caratteri in una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntatore al primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Puntatore alla posizione in cui iniziare a scrivere la sequenza di byte risultante.</param>
        <param name="byteCount">Numero massimo di byte da scrivere.</param>
        <summary>Codifica un set di caratteri a partire dal puntatore ai caratteri specificato in una sequenza di byte archiviati a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero effettivo di byte scritti nella posizione indicata dal parametro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, l'applicazione usa il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF32Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF32Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
> [!NOTE]
>  Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserimento di un preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UTF32Encoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.  
  
oppure 
 <paramref name="byteCount" /> è minore del numero di byte risultante.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matrice di caratteri contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Codifica un set di caratteri dalla matrice di caratteri specificata nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, l'applicazione usa il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF32Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF32Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
> [!NOTE]
>  Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserimento di un preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UTF32Encoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per codificare i tre caratteri da una matrice di caratteri, quindi vengono codificati i caratteri e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
oppure 
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
oppure 
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="chars" /> contiene una sequenza di carattere non valida.  
  
oppure 
 <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Oggetto <see cref="T:System.String" /> contenente il set di caratteri da codificare.</param>
        <param name="charIndex">Indice del primo carattere da codificare.</param>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <param name="bytes">Matrice di byte che deve contenere la sequenza di byte risultante.</param>
        <param name="byteIndex">Indice in corrispondenza del quale iniziare a scrivere la sequenza di byte risultante.</param>
        <summary>Codifica un set di caratteri dall'oggetto <see cref="T:System.String" /> specificato nella matrice di byte specificata.</summary>
        <returns>Numero effettivo di byte scritti in <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, l'applicazione usa il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF32Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF32Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
> [!NOTE]
>  Per garantire che i byte con codificati vengono decodificati correttamente quando vengono salvati come un file o un flusso, è possibile anteporre un flusso di byte codificati con un preambolo. Inserimento di un preambolo all'inizio di un flusso di byte (ad esempio all'inizio di una serie di byte da scrivere in un file) è responsabilità dello sviluppatore. Il <xref:System.Text.UTF32Encoding.GetBytes%2A> metodo non anteporre un preambolo all'inizio di una sequenza di byte codificati.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per codificare una stringa, quindi codifica la stringa e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.  
  
oppure 
 <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> è minore di zero.  
  
oppure 
 <paramref name="charIndex" /> e <paramref name="charCount" /> non identificano un intervallo valido in <paramref name="chars" />.  
  
oppure 
 <paramref name="byteIndex" /> non è un indice valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento errori è abilitato e <paramref name="s" /> contiene una sequenza di carattere non valida.  
  
oppure 
 <paramref name="bytes" /> non dispone di sufficiente capacità da <paramref name="byteIndex" /> alla fine della matrice per contenere i byte risultanti.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte a partire dal puntatore ai byte specificato.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> Calcola la dimensione della matrice esatti necessaria per il <xref:System.Text.UTF32Encoding.GetChars%2A> metodo per archiviare i caratteri risultanti. Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come valore integer.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Calcola il numero di caratteri prodotti dalla decodifica di una sequenza di byte dalla matrice di byte specificata.</summary>
        <returns>Numero di caratteri prodotti dalla decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.UTF32Encoding.GetCharCount%2A> metodo calcola le dimensioni della matrice esatti necessari per il <xref:System.Text.UTF32Encoding.GetChars%2A> metodo per archiviare i caratteri risultanti. Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa in una matrice di byte e quindi le decodifica i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido in <paramref name="bytes" />.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come valore integer.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodifica una sequenza di byte in un set di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntatore al primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Puntatore alla posizione in cui iniziare a scrivere il set di caratteri risultante.</param>
        <param name="charCount">Numero massimo di caratteri da scrivere.</param>
        <summary>Decodifica una sequenza di byte a partire dal puntatore ai byte specificato in un set di caratteri archiviati a partire dal puntatore ai caratteri specificato.</summary>
        <returns>Numero effettivo di caratteri scritti nella posizione indicata da <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF32Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include i byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non-BOM, il carattere di U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverla tramite la chiamata di <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (metodo).  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, l'applicazione usa il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF32Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF32Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.  
  
oppure 
 <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> o <paramref name="charCount" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.  
  
oppure 
 <paramref name="charCount" /> è minore del numero di caratteri risultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="byteIndex">Indice del primo byte da decodificare.</param>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <param name="chars">Matrice di caratteri che deve contenere il set di caratteri risultante.</param>
        <param name="charIndex">Indice in corrispondenza del quale iniziare a scrivere il set di caratteri risultante.</param>
        <summary>Decodifica una sequenza di byte dalla matrice di byte specificata nella matrice di caratteri specificata.</summary>
        <returns>Numero effettivo di caratteri scritti in <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetChars%2A> per archiviare i caratteri risultanti, chiamare il <xref:System.Text.UTF32Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, chiamare il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include i byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non-BOM, il carattere di U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverla tramite la chiamata di <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (metodo).  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, l'applicazione usa il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF32Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF32Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa in una matrice di byte e quindi le decodifica i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.  
  
oppure 
 <paramref name="chars" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> o <paramref name="byteCount" /> o <paramref name="charIndex" /> è minore di zero.  
  
oppure 
 <paramref name="byteindex" /> e <paramref name="byteCount" /> non identificano un intervallo valido in <paramref name="bytes" />.  
  
oppure 
 <paramref name="charIndex" /> non è un indice valido in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.  
  
oppure 
 <paramref name="chars" /> non dispone di sufficiente capacità da <paramref name="charIndex" /> alla fine della matrice per contenere i caratteri risultanti.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF32Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un decodificatore in grado di convertire una sequenza di byte codificati UTF-32 in una sequenza di caratteri Unicode.</summary>
        <returns>Oggetto <see cref="T:System.Text.Decoder" /> che converte una sequenza di byte codificati UTF-32 in una sequenza di caratteri Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodo converte sequenziali blocchi di byte in blocchi sequenziali di caratteri, in modo simile al <xref:System.Text.UTF32Encoding.GetChars%2A> (metodo). Tuttavia, un <xref:System.Text.Decoder> mantiene informazioni sullo stato tra chiamate, in modo da poter decodificare correttamente le sequenze di byte che si estendono su blocchi. Il <xref:System.Text.Decoder> anche mantiene byte finali alla fine di blocchi di dati e Usa i byte finali nella successiva operazione di decodifica. Pertanto <xref:System.Text.UTF32Encoding.GetDecoder%2A> e <xref:System.Text.UTF32Encoding.GetEncoder%2A> sono utili per la trasmissione di rete e operazioni di file, perché queste operazioni utilizzano spesso i blocchi di dati anziché un flusso di dati completo.  
  
 Se il rilevamento errori è abilitato, vale a dire il `throwOnInvalidCharacters` parametro del costruttore è stato impostato su `true`, il rilevamento errori è abilitato anche nel <xref:System.Text.Decoder> restituito da questo metodo. Se è abilitato il rilevamento di errore e viene rilevata una sequenza non valida, lo stato del decodificatore non è definito e deve arrestare l'elaborazione.  
  
   
  
## Examples  
 Nell'esempio seguente usa un codificatore e un decodificatore per codificare una stringa in una matrice di byte e quindi decodificare i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informazioni sulle codifiche</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF32Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un codificatore in grado di convertire una sequenza di caratteri Unicode in una sequenza di byte codificati UTF-32.</summary>
        <returns>Oggetto <see cref="T:System.Text.Encoder" /> che converte una sequenza di byte codificati UTF-32 in una sequenza di caratteri Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodo converte blocchi sequenziali di caratteri in blocchi sequenziali di byte, in modo simile al <xref:System.Text.UTF32Encoding.GetBytes%2A> (metodo). Tuttavia, un <xref:System.Text.Encoder> mantiene informazioni sullo stato tra chiamate in modo che può codificare correttamente le sequenze di caratteri che si estendono su blocchi. Il <xref:System.Text.Encoder> anche mantiene finali caratteri alla fine di blocchi di dati e i caratteri finali nella successiva operazione di codifica. Ad esempio, un blocco di dati può terminare con un surrogato senza corrispondenza e potrebbe essere il surrogato corrisponda nel blocco di dati successivo. Pertanto <xref:System.Text.UTF32Encoding.GetDecoder%2A> e <xref:System.Text.UTF32Encoding.GetEncoder%2A> sono utili per la trasmissione di rete e operazioni di file, perché queste operazioni utilizzano spesso i blocchi di dati anziché un flusso di dati completo.  
  
 Se il rilevamento errori è abilitato, vale a dire il `throwOnInvalidCharacters` parametro del costruttore è stato impostato su `true`, il rilevamento errori è abilitato anche nel <xref:System.Text.Encoder> restituito da questo metodo. Se è abilitato il rilevamento di errore e viene rilevata una sequenza non valida, lo stato del codificatore della tabella è definito e deve arrestare l'elaborazione.  
  
   
  
## Examples  
 Nell'esempio seguente usa un codificatore e un decodificatore per codificare una stringa in una matrice di byte e quindi decodificare i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informazioni sulle codifiche</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF32Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza corrente.</summary>
        <returns>Codice hash per l'oggetto <see cref="T:System.Text.UTF32Encoding" /> corrente.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF32Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Numero di caratteri da codificare.</param>
        <summary>Calcola il numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</summary>
        <returns>Numero massimo di byte prodotti dalla codifica del numero di caratteri specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetBytes%2A> per archiviare i byte risultanti, si chiama il <xref:System.Text.UTF32Encoding.GetByteCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> è un numero riflette il caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.EncoderFallback>. Se si sceglie un fallback con una stringa di grandi dimensioni, <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> può restituire valori di grandi dimensioni.  
  
 Nella maggior parte dei casi, questo metodo restituisce i numeri di ragionevoli per stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grande e individuare gli errori nel raro caso che un buffer più ragionevole è stato superato. È anche possibile prendere in considerazione un approccio diverso e usare <xref:System.Text.UTF32Encoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> non ha alcuna relazione con <xref:System.Text.UTF32Encoding.GetChars%2A>. Se è necessaria una funzione simile da utilizzare con <xref:System.Text.UTF32Encoding.GetChars%2A>, usare <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` non è necessariamente lo stesso valore `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Nell'esempio seguente determina il numero di byte necessari per codificare una stringa, quindi codifica la stringa e visualizza il numero di byte risultante.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> è minore di zero.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> è impostato su <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF32Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Numero di byte da decodificare.</param>
        <summary>Calcola il numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</summary>
        <returns>Numero massimo di caratteri prodotti dalla decodifica del numero di byte specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per calcolare le dimensioni della matrice esatta richiesta dal <xref:System.Text.UTF32Encoding.GetChars%2A> per archiviare i caratteri risultanti, si chiama il <xref:System.Text.UTF32Encoding.GetCharCount%2A> (metodo). Per calcolare la dimensione massima della matrice, si chiama il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (metodo). Il <xref:System.Text.UTF32Encoding.GetCharCount%2A> metodo in genere alloca memoria inferiore, mentre il <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodo in genere viene eseguito più velocemente.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> è un numero riflette il caso peggiore, incluso il caso peggiore per l'oggetto attualmente selezionato <xref:System.Text.DecoderFallback>. Se si sceglie un fallback con una stringa di grandi dimensioni, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> può restituire valori di grandi dimensioni.  
  
 Nella maggior parte dei casi, questo metodo restituisce i numeri di ragionevoli per stringhe di piccole dimensioni. Per le stringhe di grandi dimensioni, potrebbe essere necessario scegliere tra l'utilizzo di buffer molto grande e individuare gli errori nel raro caso che un buffer più ragionevole è stato superato. È anche possibile prendere in considerazione un approccio diverso e usare <xref:System.Text.UTF32Encoding.GetCharCount%2A> o <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> non ha alcuna relazione con <xref:System.Text.UTF32Encoding.GetBytes%2A>. Se è necessaria una funzione simile da utilizzare con <xref:System.Text.UTF32Encoding.GetBytes%2A>, usare <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` non è necessariamente lo stesso valore `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa in una matrice di byte e quindi le decodifica i byte in una matrice di caratteri.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> è minore di zero.  
  
oppure 
Il numero di byte ottenuto è maggiore del numero massimo che può essere restituito come numero intero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF32Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un byte order mark Unicode codificato in formato UTF-32, se l'oggetto di codifica <see cref="T:System.Text.UTF32Encoding" /> è configurato per fornirne uno.</summary>
        <returns>Matrice di byte contenente il byte order mark Unicode, se l'oggetto <see cref="T:System.Text.UTF32Encoding" /> è configurato per fornirne uno. In caso contrario, questo metodo restituisce una matrice di byte di lunghezza zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.UTF32Encoding> oggetto può fornire un preambolo, ovvero una matrice di byte che può essere anteposto alla sequenza di byte risultante dal processo di codifica. Prima di una sequenza di byte codificati con un byte order mark (punti di codice U + 0000 U + FEFF) consente il decodificatore di determinare l'ordine dei byte e il formato di trasformazione o UTF. Il byte order mark Unicode (BOM) viene serializzato nel modo seguente (in esadecimale):  
  
-   Ordine dei byte big-endian: 00 00 FF FE  
  
-   Ordine dei byte little-endian little: FF FE 00 00  
  
 È possibile creare un'istanza di un <xref:System.Text.UTF32Encoding> il cui <xref:System.Text.UTF32Encoding.GetPreamble%2A> metodo restituisce un valido indicatore ordine byte nei modi seguenti:  
  
-   Recuperando il <xref:System.Text.UTF32Encoding> oggetto restituito dal <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType> proprietà.  
  
-   Tramite la chiamata senza parametri <xref:System.Text.UTF32Encoding.%23ctor> costruttore per creare un'istanza di un <xref:System.Text.UTF32Encoding> oggetto.  
  
-   Fornendo `true` come valore del `byteOrderMark` argomento per il <xref:System.Text.UTF32Encoding.%23ctor%2A> e <xref:System.Text.UTF32Encoding.%23ctor%2A> costruttori.  
  
 È consigliabile usare il carattere BOM, in quanto fornisce quasi determinati identificazione di una codifica per i file che non hanno più riferimento al <xref:System.Text.UTF32Encoding> oggetto, ad esempio, senza codifica o dati web, o i file di testo casuale archiviati quando un Business non aveva internazionale problemi o altri dati. Spesso, i problemi dell'utente potrebbero essere evitati se dati vengono contrassegnati in modo coerente e appropriato.  
  
 Per gli standard che forniscono un tipo di codifica, una distinta base è in parte ridondante. Tuttavia, può essere utilizzato per consentire a un server di inviare l'intestazione di codifica corretta. In alternativa, può essere utilizzato come fallback in caso contrario, la codifica viene perduta.  
  
 Esistono alcuni svantaggi dell'utilizzo di un carattere BOM. Ad esempio, può essere difficile sapere come limitare i campi del database che usano un carattere BOM. Concatenazione dei file può rappresentare un problema, inoltre, ad esempio, quando i file vengono uniti in tale modo un carattere non necessario può finire al centro dati. Nonostante alcuni svantaggi, tuttavia, l'uso di un carattere BOM è consigliabile.  
  
 Per altre informazioni sull'ordine dei byte e il byte order mark, vedere lo Unicode Standard nella [home page di Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Per garantire che i byte con codificati vengono decodificati correttamente, si deve aggiungere byte codificati con un preambolo. Si noti che il <xref:System.Text.UTF32Encoding.GetBytes%2A> metodo anteporre non una DBA in una sequenza di byte codificati; fornisce un indicatore ordine byte all'inizio di un flusso di byte appropriato è responsabilità dello sviluppatore.  
  
   
  
## Examples  
 Il seguente codice esempio recupera e Visualizza e contrassegna l'ordine dei byte per diversi <xref:System.Text.UTF32Encoding> istanze.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 Nell'esempio seguente crea due <xref:System.Text.UTF32Encoding> oggetti, la prima delle quali non è incluso un carattere BOM e il secondo dei quali esegue. Chiama quindi il <xref:System.Text.UTF32Encoding.GetPreamble%2A> metodo per scrivere il BOM in un file prima di scrivere una stringa con codifica UTF-32. Come illustrato nell'output dell'esempio, il file che salva i byte dal secondo codificatore ha quattro più byte che il primo.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 È anche possibile confrontare i file usando il `fc` comando in una finestra della console, oppure è possibile esaminare i file in un editor di testo che include una modalità di visualizzazione esadecimale. Si noti che quando il file viene aperto in un editor che supporta UTF-32, il carattere BOM non è visualizzato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF32Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matrice di byte contenente la sequenza di byte da decodificare.</param>
        <param name="index">Indice del primo byte da decodificare.</param>
        <param name="count">Numero di byte da decodificare.</param>
        <summary>Decodifica un intervallo di byte da una matrice di byte in una stringa.</summary>
        <returns>Stringa contenente i risultati di decodifica della sequenza di byte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con il rilevamento di errori, una sequenza non valida fa in modo che questo metodo consente di generare un <xref:System.ArgumentException>. Senza il rilevamento di errori, le sequenze non valide vengono ignorate e viene generata alcuna eccezione.  
  
 Se l'intervallo di byte da decodificare include i byte order mark (BOM) e la matrice di byte è stata restituita da un metodo di un tipo compatibile con non-BOM, il carattere di U + FFFE è incluso nella matrice di caratteri restituita da questo metodo. È possibile rimuoverla tramite la chiamata di <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (metodo).  
  
 I dati da convertire, ad esempio i dati letti da un flusso, potrebbero essere disponibili solo in blocchi sequenziali. In questo caso, o se la quantità di dati è talmente grande che deve essere suddiviso in blocchi più piccoli, l'applicazione deve utilizzare il <xref:System.Text.Decoder> o il <xref:System.Text.Encoder> forniti dalle <xref:System.Text.UTF32Encoding.GetDecoder%2A> (metodo) o il <xref:System.Text.UTF32Encoding.GetEncoder%2A> metodo, rispettivamente.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa in due matrici di matrici di byte, in ordine little-endian e l'altra nell'ordine big-endian. Quindi le decodifica i byte in una stringa.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 Nell'esempio seguente consente di inizializzare una matrice mediante la chiamata di <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodo per determinare esattamente quanti byte sono necessari per una stringa codificata e quindi aggiungere le dimensioni del contrassegno di ordine byte (BOM). Nell'esempio viene quindi chiamato il <xref:System.Text.UTF32Encoding.GetPreamble%2A> metodo per archiviare il carattere BOM nella matrice prima di chiamare il <xref:System.Text.UTF32Encoding.GetBytes%2A> metodo per archiviare i byte nella matrice codificati. Nell'esempio viene quindi chiamato il <xref:System.Text.UTF32Encoding.GetString%2A> metodo da decodificare la stringa.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Si noti che in questo caso la stringa decodificata è diversa dalla stringa originale, poiché inizia con un bit 32 byte order mark U + FFFE u+0000. Ciò significa che le due stringhe confronterà contenendo e che, se la stringa di output, il carattere BOM verrà visualizzato come carattere di sostituzione "?".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Il rilevamento degli errori è abilitato, e <paramref name="bytes" /> contiene una sequenza di byte non valida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Si è verificato un fallback. Per una spiegazione completa, vedere [Codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md) 
-e- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> è impostato su <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>