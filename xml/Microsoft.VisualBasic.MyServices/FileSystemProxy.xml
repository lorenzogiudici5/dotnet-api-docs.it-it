<Type Name="FileSystemProxy" FullName="Microsoft.VisualBasic.MyServices.FileSystemProxy">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="89bf08eba0c9a70050105d9c7483e714837ad08e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37711299" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemProxy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FileSystemProxy extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.MyServices.FileSystemProxy" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemProxy" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemProxy" />
  <TypeSignature Language="F#" Value="type FileSystemProxy = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Specifica proprietà e metodi per l'uso di unità, file e directory.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem` oggetto.  
  
|A|Vedere|  
|--------|---------|  
|Leggere da un file di testo|[Procedura: leggere da file di testo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Lettura da un file di testo delimitato|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file di testo a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lettura da un file di testo con più formati|[Procedura: leggere da file di testo con più formati](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Leggere da un file binario|[Procedura: leggere da file binari](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Lettura da un file di testo con un <xref:System.IO.StreamReader>|[Procedura: leggere il testo da file con un oggetto StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Scrivere in un file di testo|[Procedura: scrivere testo in file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Aggiungere un file di testo|[Procedura: aggiungere testo a file di testo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Scrivere in un file binario|[Procedura: scrivere all'interno di file binari](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Scrivere in file di testo nel **MyDocuments** directory|[Procedura: scrivere testo in file della directory Documenti](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Scrivere in un file di testo con un `StreamWriter`|[Procedura: scrivere testo in file con un oggetto StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Copiare i file con un criterio specifico|[Procedura: copiare file con un criterio specifico in una directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Copiare un file nella stessa directory|[Procedura: creare una copia di un file nella stessa directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiare un file in una directory diversa|[Procedura: creare una copia di un file in una directory diversa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Creare un file|[Procedura: creare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Eliminare un file|[Procedura: eliminare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Trovare i file con un criterio specifico|[Procedura: trovare file con un modello specifico](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Spostare un file|[Procedura: spostare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Rinominare un file|[Procedura: rinominare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Copiare una directory in un'altra directory|[Procedura: copiare una directory in un'altra directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Creare una directory|[Procedura: creare una directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Trovare sottodirectory con un criterio specifico|[Procedura: cercare sottodirectory con un modello specifico](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Ottenere la raccolta di file in una directory|[Procedura: ottenere la raccolta di file di una directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Leggere il **MyDocuments** directory|[Procedura: recuperare il contenuto della directory Documenti](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Analizzare un percorso di file|[Procedura: analizzare percorsi di file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Questo esempio viene verificata per determinare se la cartella `C:\backup\logs` esista e controlla le relative proprietà.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
  </Docs>
  <Members>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="member this.CombinePath : string * string -&gt; string" Usage="fileSystemProxy.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory">
          <see langword="String" />. Primo percorso da combinare.</param>
        <param name="relativePath">
          <see langword="String" />. Secondo percorso da combinare.</param>
        <summary>Combina due percorsi e restituisce un percorso formattato correttamente.</summary>
        <returns>Combinazione dei percorsi specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo elimina i caratteri barra in eccesso per creare un percorso formattato correttamente.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CombinePath` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Combinare un nome di file e percorso di directory|[Procedura: analizzare percorsi di file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 In questo esempio combina un nome di file e percorso di directory per creare un percorso formattato correttamente.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 In questo esempio combina due percorsi per creare un percorso formattato correttamente.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Questo esempio vengono restituite `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseDirectory" /> o <paramref name="relativePath" /> sono percorsi in formato non valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia una directory in un'altra directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Directory da copiare.</param>
        <param name="destinationDirectoryName">Percorso in cui copiare la directory.</param>
        <summary>Copia una directory in un'altra directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di copiare il contenuto della directory nonché la directory stessa. Se la directory di destinazione non esiste, viene creato. Se esiste una directory con lo stesso nome nel percorso di destinazione, il contenuto delle due directory viene unito. È possibile specificare un nuovo nome per la directory durante l'operazione.  
  
 Quando si copiano file all'interno di una directory, potrebbero essere generate eccezioni che sono causati da un file specifico. Quando vengono generate queste eccezioni, vengono consolidati in un'unica eccezione il cui `Data` proprietà contiene le voci sotto forma di un <xref:System.Collections.IDictionary> in cui il percorso del file o directory è la chiave e il messaggio di eccezione specifico è contenuto di valore corrispondente. Usare `For…Each` per enumerare le voci.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CopyDirectory` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Copiare una directory|[Procedura: copiare una directory in un'altra directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Nell'esempio seguente la directory copiata `TestDirectory1` in `TestDirectory2`, sovrascrivendo i file esistenti.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Sostituire `C:\TestDirectory1` e `C:\TestDirectory2` con il percorso e nome della directory di cui si desidera eseguire la copia e la posizione in cui si desidera eseguire la copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory di origine non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il percorso di origine e il percorso di destinazione coincidono.</exception>
        <exception cref="T:System.InvalidOperationException">Questa operazione è ciclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di una cartella nel percorso sono presenti i due punti (:) oppure il formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">È disponibile un file di destinazione, ma non è possibile accedervi.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Directory da copiare.</param>
        <param name="destinationDirectoryName">Percorso in cui copiare la directory.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copia una directory in un'altra directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di copiare il contenuto della directory nonché la directory stessa. Se la directory di destinazione non esiste, viene creato. Se esiste una directory con lo stesso nome nel percorso di destinazione, il contenuto delle due directory viene unito. È possibile specificare un nuovo nome per la directory durante l'operazione.  
  
 Quando si copiano file all'interno di una directory, potrebbero essere generate eccezioni che sono causati da un file specifico. Quando vengono generate queste eccezioni, vengono consolidati in un'unica eccezione il cui `Data` proprietà contiene le voci sotto forma di un <xref:System.Collections.IDictionary> in cui il percorso del file o directory è la chiave e il messaggio di eccezione specifico è contenuto di valore corrispondente. Usare `For…Each` per enumerare le voci.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CopyDirectory` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Copiare una directory|[Procedura: copiare una directory in un'altra directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Nell'esempio seguente la directory copiata `TestDirectory1` in `TestDirectory2`, sovrascrivendo i file esistenti.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Sostituire `C:\TestDirectory1` e `C:\TestDirectory2` con il percorso e nome della directory di cui si desidera eseguire la copia e la posizione in cui si desidera eseguire la copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory di origine non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il percorso di origine e il percorso di destinazione coincidono.</exception>
        <exception cref="T:System.InvalidOperationException">Questa operazione è ciclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di una cartella nel percorso sono presenti i due punti (:) oppure il formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">È disponibile un file di destinazione, ma non è possibile accedervi.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> è impostato su <see langword="UIOption.AllDialogs" /> e l'utente annulla l'operazione oppure uno o più file nella directory non possono essere copiati.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * bool -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Directory da copiare.</param>
        <param name="destinationDirectoryName">Percorso in cui copiare la directory.</param>
        <param name="overwrite">
          <see langword="True" /> per sovrascrivere i file esistenti; in caso contrario, <see langword="False" />. Il valore predefinito è <see langword="False" />.</param>
        <summary>Copia una directory in un'altra directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di copiare il contenuto della directory nonché la directory stessa. Se la directory di destinazione non esiste, viene creato. Se esiste una directory con lo stesso nome nel percorso di destinazione, il contenuto delle due directory viene unito. È possibile specificare un nuovo nome per la directory durante l'operazione.  
  
 Quando si copiano file all'interno di una directory, potrebbero essere generate eccezioni che sono causati da un file specifico, ad esempio un file esistente durante un'unione `overwrite` è impostata su `False`. Quando vengono generate queste eccezioni, vengono consolidati in un'unica eccezione il cui `Data` proprietà contiene le voci sotto forma di un <xref:System.Collections.IDictionary> in cui il percorso del file o directory è la chiave e il messaggio di eccezione specifico è contenuto di valore corrispondente. Usare `For…Each` per enumerare le voci.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CopyDirectory` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Copiare una directory|[Procedura: copiare una directory in un'altra directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Nell'esempio seguente la directory copiata `TestDirectory1` in `TestDirectory2`, sovrascrivendo i file esistenti.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Sostituire `C:\TestDirectory1` e `C:\TestDirectory2` con il percorso e nome della directory di cui si desidera eseguire la copia e la posizione in cui si desidera eseguire la copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory di origine non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il percorso di origine e il percorso di destinazione coincidono.</exception>
        <exception cref="T:System.InvalidOperationException">Questa operazione è ciclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di una cartella nel percorso sono presenti i due punti (:) oppure il formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">È disponibile un file di destinazione, ma non è possibile accedervi.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Directory da copiare.</param>
        <param name="destinationDirectoryName">Percorso in cui copiare la directory.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Specifica l'azione da eseguire se l'utente seleziona **Annulla** durante l'operazione. Il valore predefinito è <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copia una directory in un'altra directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di copiare il contenuto della directory nonché la directory stessa. Se la directory di destinazione non esiste, viene creato. Se esiste una directory con lo stesso nome nel percorso di destinazione, il contenuto delle due directory viene unito. È possibile specificare un nuovo nome per la directory durante l'operazione.  
  
 Quando si copiano file all'interno di una directory, potrebbero essere generate eccezioni che sono causati da un file specifico. Quando vengono generate queste eccezioni, vengono consolidati in un'unica eccezione il cui `Data` proprietà contiene le voci sotto forma di un <xref:System.Collections.IDictionary> in cui il percorso del file o directory è la chiave e il messaggio di eccezione specifico è contenuto di valore corrispondente. Usare `For…Each` per enumerare le voci.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CopyDirectory` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Copiare una directory|[Procedura: copiare una directory in un'altra directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Nell'esempio seguente la directory copiata `TestDirectory1` in `TestDirectory2`, sovrascrivendo i file esistenti.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Sostituire `C:\TestDirectory1` e `C:\TestDirectory2` con il percorso e nome della directory di cui si desidera eseguire la copia e la posizione in cui si desidera eseguire la copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory di origine non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il percorso di origine e il percorso di destinazione coincidono.</exception>
        <exception cref="T:System.InvalidOperationException">Questa operazione è ciclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di una cartella nel percorso sono presenti i due punti (:) oppure il formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">È disponibile un file di destinazione, ma non è possibile accedervi.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> è impostato su <see langword="UIOption.AllDialogs" /> e l'utente annulla l'operazione oppure uno o più file nella directory non possono essere copiati.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Consente di copiare un file in un nuovo percorso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">File da copiare.</param>
        <param name="destinationFileName">Percorso in cui copiare il file.</param>
        <summary>Consente di copiare un file in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` non conserva le voci ACE (Access Control Entries). Il file appena creato eredita le voci ACE predefinito dalla directory in cui viene creato.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CopyFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Copiare un file nella stessa directory.|[Procedura: creare una copia di un file nella stessa directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiare un file in una directory diversa.|[Procedura: creare una copia di un file in una directory diversa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In questo esempio copia i file `Test.txt` nella directory `TestFiles2` senza sovrascrivere i file esistenti.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Sostituire i percorsi dei file con i percorsi da usare nel codice.  
  
 In questo esempio copia i file `Test.txt` nella directory `TestFiles2` e lo rinomina `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Sostituire i percorsi dei file con i percorsi da usare nel codice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contiene informazioni sul percorso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di origine non è valido o non esiste.</exception>
        <exception cref="T:System.IO.IOException">Un file della directory di destinazione con lo stesso nome è già in uso.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controlla la possibilità di accedere a tutte le variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controlla se è possibile accedere alle variabili del Registro di sistema. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">File da copiare.</param>
        <param name="destinationFileName">Percorso in cui copiare il file.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Consente di copiare un file in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` non conserva le voci ACE (Access Control Entries). Il file appena creato eredita le voci ACE predefinito dalla directory in cui viene creato.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CopyFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Copiare un file nella stessa directory.|[Procedura: creare una copia di un file nella stessa directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiare un file in una directory diversa.|[Procedura: creare una copia di un file in una directory diversa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In questo esempio copia i file `Test.txt` nella directory `TestFiles2` senza sovrascrivere i file esistenti.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Sostituire i percorsi dei file con i percorsi da usare nel codice.  
  
 In questo esempio copia i file `Test.txt` nella directory `TestFiles2` e lo rinomina `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Sostituire i percorsi dei file con i percorsi da usare nel codice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contiene informazioni sul percorso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di origine non è valido o non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file di destinazione esiste già e <paramref name="overwrite" /> è impostato su <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controlla la possibilità di accedere a tutte le variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controlla se è possibile accedere alle variabili del Registro di sistema. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * bool -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">File da copiare.</param>
        <param name="destinationFileName">Percorso in cui copiare il file.</param>
        <param name="overwrite">
          <see langword="True" /> se i file esistenti devono essere sovrascritti; in caso contrario, <see langword="False" />. Il valore predefinito è <see langword="False" />.</param>
        <summary>Consente di copiare un file in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` non conserva le voci ACE (Access Control Entries). Il file appena creato eredita le voci ACE predefinito dalla directory in cui viene creato.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CopyFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Copiare un file nella stessa directory.|[Procedura: creare una copia di un file nella stessa directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiare un file in una directory diversa.|[Procedura: creare una copia di un file in una directory diversa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In questo esempio copia i file `Test.txt` nella directory `TestFiles2` senza sovrascrivere i file esistenti.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Sostituire i percorsi dei file con i percorsi da usare nel codice.  
  
 In questo esempio copia i file `Test.txt` nella directory `TestFiles2` e lo rinomina `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Sostituire i percorsi dei file con i percorsi da usare nel codice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contiene informazioni sul percorso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di origine non è valido o non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file di destinazione esiste già e <paramref name="overwrite" /> è impostato su <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controlla la possibilità di accedere a tutte le variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controlla se è possibile accedere alle variabili del Registro di sistema. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">File da copiare.</param>
        <param name="destinationFileName">Percorso in cui copiare il file.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Specifica l'azione da eseguire se l'utente seleziona **Annulla** durante l'operazione. Il valore predefinito è <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Consente di copiare un file in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` non conserva le voci ACE (Access Control Entries). Il file appena creato eredita le voci ACE predefinito dalla directory in cui viene creato.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CopyFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Copiare un file nella stessa directory.|[Procedura: creare una copia di un file nella stessa directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiare un file in una directory diversa.|[Procedura: creare una copia di un file in una directory diversa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 In questo esempio copia i file `Test.txt` nella directory `TestFiles2` senza sovrascrivere i file esistenti.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Sostituire i percorsi dei file con i percorsi da usare nel codice.  
  
 In questo esempio copia i file `Test.txt` nella directory `TestFiles2` e lo rinomina `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Sostituire i percorsi dei file con i percorsi da usare nel codice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contiene informazioni sul percorso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di origine non è valido o non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file di destinazione esiste già e <paramref name="overwrite" /> è impostato su <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="UICancelOption" /> è impostato su <see langword="ThrowException" /> e l'utente ha annullato l'operazione oppure si è verificato un errore di I/O non specificato.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controlla la possibilità di accedere a tutte le variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controlla se è possibile accedere alle variabili del Registro di sistema. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.CreateDirectory : string -&gt; unit" Usage="fileSystemProxy.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nome e percorso della directory.</param>
        <summary>Crea una directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la directory esiste già, non verranno generate eccezioni.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.CreateDirectory` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Creare una directory|[Procedura: creare una directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 In questo esempio viene creata la directory `NewDirectory`, in `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome della directory non è valido. Ad esempio, sono contenuti caratteri non consentiti oppure è solo uno spazio vuoto.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il nome della directory è troppo lungo.</exception>
        <exception cref="T:System.NotSupportedException">Il nome della directory contiene solo i due punti (:).</exception>
        <exception cref="T:System.IO.IOException">La directory padre della directory da creare è di sola lettura</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria per creare la directory.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la directory corrente.</summary>
        <value>Directory corrente per le operazioni di I/O di file.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` è una variabile di ambiente a livello di sistema.  
  
   
  
## Examples  
 In questo esempio restituisce la directory corrente e lo visualizza in una finestra di messaggio.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 In questo esempio imposta la directory corrente `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Il percorso non è valido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina una directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Directory da eliminare.</param>
        <param name="onDirectoryNotEmpty">Specifica le azioni da intraprendere quando si deve eliminare una directory contenente file o directory. Il valore predefinito è <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Elimina una directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio elimina la directory `OldDirectory` solo se è vuota.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In questo esempio elimina la directory `OldDirectory` e tutti i relativi contenuti.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In questo esempio elimina la directory `OldDirectory` e tutti i relativi contenuti, in cui viene chiesto all'utente di confermare l'eliminazione, ma non invia il contenuto per il **Cestino**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In questo esempio elimina la directory `OldDirectory` e tutti i relativi contenuti, inviarli per il **Cestino**, ma non mostra lo stato di avanzamento dell'operazione.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso è una stringa di lunghezza zero, con formato non corretto e contenente solo spazi vuoti o caratteri non validi (compresi i caratteri jolly). Il percorso è il percorso di un dispositivo, ovvero inizia con \\\\\\.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory non esiste o è un file.</exception>
        <exception cref="T:System.IO.IOException">Un file della directory o sottodirectory è in uso.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome della directory sono presenti i due punti (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <exception cref="T:System.OperationCanceledException">L'utente annulla l'operazione o la directory non può essere eliminata.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Directory da eliminare.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Specifica se il file eliminato deve essere inviato al **Cestino**. Il valore predefinito è <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Elimina una directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `showUI` e `recycle` parametri non sono supportati nelle applicazioni che non sono interattive, ad esempio servizi di Windows con l'utente.  
  
   
  
## Examples  
 L'esempio elimina la directory `OldDirectory` solo se è vuota.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In questo esempio elimina la directory `OldDirectory` e tutti i relativi contenuti.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In questo esempio elimina la directory `OldDirectory` e tutti i relativi contenuti, in cui viene chiesto all'utente di confermare l'eliminazione, ma non invia il contenuto per il **Cestino**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In questo esempio elimina la directory `OldDirectory` e tutti i relativi contenuti, inviarli per il **Cestino**, ma non mostra lo stato di avanzamento dell'operazione.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso è una stringa di lunghezza zero, con formato non corretto e contenente solo spazi vuoti o caratteri non validi (compresi i caratteri jolly). Il percorso è il percorso di un dispositivo, ovvero inizia con \\\\\\.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory non esiste o è un file.</exception>
        <exception cref="T:System.IO.IOException">Un file della directory o sottodirectory è in uso.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome della directory sono presenti i due punti (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <exception cref="T:System.OperationCanceledException">L'utente annulla l'operazione o la directory non può essere eliminata.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Directory da eliminare.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Specifica se il file eliminato deve essere inviato al **Cestino**. Il valore predefinito è <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Specifica se generare un'eccezione se l'utente seleziona **Annulla**.</param>
        <summary>Elimina una directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `showUI`, `recycle`, e `onUserCancel` parametri non sono supportati nelle applicazioni che non sono interattive, ad esempio servizi di Windows con l'utente.  
  
   
  
## Examples  
 L'esempio elimina la directory `OldDirectory` solo se è vuota.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In questo esempio elimina la directory `OldDirectory` e tutti i relativi contenuti.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In questo esempio elimina la directory `OldDirectory` e tutti i relativi contenuti, in cui viene chiesto all'utente di confermare l'eliminazione, ma non invia il contenuto per il **Cestino**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In questo esempio elimina la directory `OldDirectory` e tutti i relativi contenuti, inviarli per il **Cestino**, ma non mostra lo stato di avanzamento dell'operazione.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso è una stringa di lunghezza zero, con formato non corretto e contenente solo spazi vuoti o caratteri non validi (compresi i caratteri jolly). Il percorso è il percorso di un dispositivo, ovvero inizia con \\\\\\.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory non esiste o è un file.</exception>
        <exception cref="T:System.IO.IOException">Un file della directory o sottodirectory è in uso.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome della directory sono presenti i due punti (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <exception cref="T:System.OperationCanceledException">L'utente annulla l'operazione o la directory non può essere eliminata.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string -&gt; unit" Usage="fileSystemProxy.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nome e percorso del file da eliminare.</param>
        <summary>Elimina un file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.DeleteFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Per eliminare un file|[Procedura: eliminare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 In questo esempio elimina il file `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 In questo esempio elimina il file `Test.txt` e consente all'utente di confermare che il file deve essere eliminato.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In questo esempio elimina il file `Test.txt` e lo invia al **Cestino**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi, presenta una barra finale nel punto in cui è necessario specificare un file o è il percorso di un dispositivo, ovvero inizia con \\\\\\.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria per eliminare il file oppure il file è di sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="fileSystemProxy.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Nome e percorso del file da eliminare.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Specifica se il file eliminato deve essere inviato al **Cestino**. Il valore predefinito è <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Elimina un file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `showUI` e `recycle` parametri non sono supportati nelle applicazioni che non sono interattive, ad esempio servizi di Windows con l'utente.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.DeleteFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Per eliminare un file|[Procedura: eliminare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 In questo esempio elimina il file `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 In questo esempio elimina il file `Test.txt` e consente all'utente di confermare che il file deve essere eliminato.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In questo esempio elimina il file `Test.txt` e lo invia al **Cestino**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi, presenta una barra finale nel punto in cui è necessario specificare un file o è il percorso di un dispositivo, ovvero inizia con \\\\\\.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria per eliminare il file oppure il file è di sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Nome e percorso del file da eliminare.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Specifica se il file eliminato deve essere inviato al **Cestino**. Il valore predefinito è <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Specifica se viene generata un'eccezione quando l'utente annulla l'operazione. Il valore predefinito è <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Elimina un file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `showUI`, `recycle`, e `onUserCancel` parametri non sono supportati nelle applicazioni che non sono interattive, ad esempio servizi di Windows con l'utente.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.DeleteFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Per eliminare un file|[Procedura: eliminare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 In questo esempio elimina il file `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 In questo esempio elimina il file `Test.txt` e consente all'utente di confermare che il file deve essere eliminato.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In questo esempio elimina il file `Test.txt` e lo invia al **Cestino**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi, presenta una barra finale nel punto in cui è necessario specificare un file o è il percorso di un dispositivo, ovvero inizia con \\\\\\.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria per eliminare il file oppure il file è di sola lettura.</exception>
        <exception cref="T:System.OperationCanceledException">L'utente ha annullato l'operazione e <paramref name="onUserCancel" /> è impostato su <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.DirectoryExists : string -&gt; bool" Usage="fileSystemProxy.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Percorso della directory.</param>
        <summary>Restituisce <see langword="True" /> se la directory specificata esiste.</summary>
        <returns>
          <see langword="True" /> se la directory esiste. In caso contrario, <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In questo esempio determina se la directory `C:\backup\logs` esista e controlla le relative proprietà.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.Drives" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un insieme in sola lettura di tutti i nomi di unità disponibili.</summary>
        <value>Insieme di sola lettura di tutte le unità disponibili come oggetti <see cref="T:System.IO.DriveInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce tutte le unità logiche.  
  
   
  
## Examples  
 In questo esempio vengono visualizzati i nomi delle unità disponibili in una finestra di messaggio.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.FileExists : string -&gt; bool" Usage="fileSystemProxy.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nome e percorso del file.</param>
        <summary>Restituisce <see langword="True" /> se il file specificato esiste.</summary>
        <returns>Restituisce <see langword="True" /> se il file è presente. In caso contrario, questo metodo restituisce <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'applicazione non ha autorizzazioni sufficienti per leggere il file specificato, il `FileExists` restituzione del metodo `False`, indipendentemente dall'esistenza del percorso; il metodo non genera un'eccezione.  
  
   
  
## Examples  
 Questo esempio verifica se il file `Check.txt` esiste e vengono fornite le informazioni contenute in una finestra di messaggio.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome del file termina con una barra rovesciata (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un insieme di stringhe in sola lettura che rappresenta i nomi dei file contenenti il testo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="member this.FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Directory in cui eseguire la ricerca.</param>
        <param name="containsText">Testo di ricerca.</param>
        <param name="ignoreCase">
          <see langword="True" /> se per la ricerca deve essere fatta distinzione tra maiuscole e minuscole; in caso contrario, <see langword="False" />. Il valore predefinito è <see langword="True" />.</param>
        <param name="searchType">Specifica se includere le sottocartelle. Il valore predefinito è <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Restituisce un insieme di stringhe in sola lettura che rappresenta i nomi dei file contenenti il testo specificato.</summary>
        <returns>Insieme di sola lettura dei nomi di file contenenti il testo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non vengono trovati file corrispondenti al criterio specificato, verrà restituita una raccolta vuota.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.FindInFiles` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Cerca in una directory per i file che contiene una stringa specifica|[Procedura dettagliata: Modifica di file e directory in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 In questo esempio cerca nella directory `C:\TestDir` per tutti i file che contiene la stringa `"sample string"` e visualizzare i risultati nella `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Per poter funzionare, il progetto deve contenere una `ListBox` denominato `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory specificata non esiste.</exception>
        <exception cref="T:System.IO.IOException">La directory specificata punta a un file esistente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel percorso della directory specificato sono presenti i due punti (:) oppure il formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="member this.FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Directory in cui eseguire la ricerca.</param>
        <param name="containsText">Testo di ricerca.</param>
        <param name="ignoreCase">
          <see langword="True" /> se per la ricerca deve essere fatta distinzione tra maiuscole e minuscole; in caso contrario, <see langword="False" />. Il valore predefinito è <see langword="True" />.</param>
        <param name="searchType">Specifica se includere le sottocartelle. Il valore predefinito è <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Criterio da soddisfare.</param>
        <summary>Restituisce un insieme di stringhe in sola lettura che rappresenta i nomi dei file contenenti il testo specificato.</summary>
        <returns>Insieme di sola lettura dei nomi di file contenenti il testo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non vengono trovati file corrispondenti al criterio specificato, verrà restituita una raccolta vuota.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.FindInFiles` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Cerca in una directory per i file che contiene una stringa specifica|[Procedura dettagliata: Modifica di file e directory in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 In questo esempio cerca nella directory `C:\TestDir` per tutti i file che contiene la stringa `"sample string"` e visualizzare i risultati nella `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Per poter funzionare, il progetto deve contenere una `ListBox` denominato `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory specificata non esiste.</exception>
        <exception cref="T:System.IO.IOException">La directory specificata punta a un file esistente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel percorso della directory specificato sono presenti i due punti (:) oppure il formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un insieme di stringhe che rappresenta i nomi dei percorsi delle sottodirectory contenute in una directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nome e percorso della directory.</param>
        <summary>Restituisce un insieme di stringhe che rappresenta i nomi dei percorsi delle sottodirectory contenute in una directory.</summary>
        <returns>Insieme di sola lettura dei nomi di percorso delle sottodirectory incluse nella directory specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.GetDirectories` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Sottodirectory di elenco con un criterio specifico|[Procedura: cercare sottodirectory con un modello specifico](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L'esempio seguente restituisce tutte le directory nella struttura di directory che contengono la parola `Logs` nei relativi nomi e li aggiunge a `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 In questo esempio è necessario disporre una `ListBox` denominato `ListBox1` sul form.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory specificata non esiste.</exception>
        <exception cref="T:System.IO.IOException">La directory specificata punta a un file esistente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Nome e percorso della directory.</param>
        <param name="searchType">Specifica se includere le sottocartelle. Il valore predefinito è <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Criterio per la corrispondenza dei nomi.</param>
        <summary>Restituisce un insieme di stringhe che rappresenta i nomi dei percorsi delle sottodirectory contenute in una directory.</summary>
        <returns>Insieme di sola lettura dei nomi di percorso delle sottodirectory incluse nella directory specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il parametro `wildcards` per specificare un criterio specifico. Se si vogliono includere i contenuti delle sottodirectory nella ricerca, impostare il parametro `searchType` su `SearchAllSubDirectories`.  
  
 Se non vengono trovate directory corrispondenti al criterio specificato, verrà restituita una raccolta vuota.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.GetDirectories` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Sottodirectory di elenco con un criterio specifico|[Procedura: cercare sottodirectory con un modello specifico](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L'esempio seguente restituisce tutte le directory nella struttura di directory che contengono la parola `Logs` nei relativi nomi e li aggiunge a `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 In questo esempio è necessario disporre una `ListBox` denominato `ListBox1` sul form.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Uno o più dei caratteri jolly specificati è <see langword="Nothing" /> o una stringa vuota oppure in esso sono contenuti solo spazi.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory specificata non esiste.</exception>
        <exception cref="T:System.IO.IOException">La directory specificata punta a un file esistente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="fileSystemProxy.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">
          <see langword="String" />. Percorso della directory.</param>
        <summary>Restituisce un oggetto <see cref="T:System.IO.DirectoryInfo" /> per il percorso specificato.</summary>
        <returns>Oggetto <see cref="T:System.IO.DirectoryInfo" /> per il percorso specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la directory non esiste, viene generata un'eccezione non finché la prima volta che una proprietà <xref:System.IO.DirectoryInfo> si accede all'oggetto.  
  
   
  
## Examples  
 Questo esempio mostra come ottenere un <xref:System.IO.DirectoryInfo> oggetto per la directory `C:\Documents and Settings` e consente di visualizzare la directory ora di creazione, ultimo tempo di accesso e ultima ora di scrittura.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel percorso della directory sono presenti i due punti (:) oppure il formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="member this.GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="fileSystemProxy.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Unità da esaminare.</param>
        <summary>Restituisce un oggetto <see cref="T:System.IO.DriveInfo" /> per l'unità specificata.</summary>
        <returns>Oggetto <see cref="T:System.IO.DriveInfo" /> per l'unità specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.DriveInfo> classe modella un'unità e fornisce metodi e proprietà per ottenere informazioni sull'unità. Usare <xref:System.IO.DriveInfo> per determinare quali le unità sono disponibili e il tipo di unità sono. È anche possibile eseguire una query la proprietà per determinare la capacità e spazio disponibile sull'unità.  
  
   
  
## Examples  
 Questo esempio si ottengono un <xref:System.IO.DriveInfo> oggetto per l'unità C e lo usa per visualizzare informazioni sull'unità.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Per informazioni sui tipi di unità diversa, vedere <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="drive" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.GetFileInfo : string -&gt; System.IO.FileInfo" Usage="fileSystemProxy.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nome e percorso del file.</param>
        <summary>Restituisce un oggetto <see cref="T:System.IO.FileInfo" /> per il file specificato.</summary>
        <returns>Oggetto <see cref="T:System.IO.FileInfo" /> per il file specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non viene generata un'eccezione se il file non esiste; piuttosto, verrà generata la prima volta che le proprietà dell'oggetto sono accessibili.  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `My.Computer.FileSystem.GetFileInfo` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Determinare il nome e percorso di un file|[Procedura: analizzare percorsi di file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Questo esempio viene recuperata una <xref:System.IO.FileInfo?displayProperty=nameWithType> oggetto per il file `MyLogFile.log` e lo usa per nome completo del file, ora dell'ultimo accesso e lunghezza del report.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome del percorso non è valido. Ad esempio, sono contenuti caratteri non validi oppure è solo uno spazio vuoto. Il nome file termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.NotSupportedException">Nel percorso sono presenti i due punti a metà della stringa.</exception>
        <exception cref="T:System.IO.PathTooLongException">Percorso troppo lungo.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'accesso ACL (elenco di controllo di accesso) al file.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un insieme di stringhe in sola lettura che rappresenta i nomi dei file contenuti in una directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Directory in cui eseguire la ricerca.</param>
        <summary>Restituisce un insieme di stringhe in sola lettura che rappresenta i nomi dei file contenuti in una directory.</summary>
        <returns>Insieme di sola lettura dei nomi di file della directory specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non vengono trovati file corrispondenti al criterio specificato, verrà restituita una raccolta vuota.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.GetFiles` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Ottenere la raccolta di file in una directory|[Procedura: ottenere la raccolta di file di una directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Trovare i file con un criterio specifico in una directory|[Procedura: trovare file con un modello specifico](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L'esempio seguente restituisce tutti i file della directory e li aggiunge a `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 In questo esempio è necessario disporre una `ListBox` denominato `ListBox1` sul form.  
  
 In questo esempio restituisce tutti i file nella directory con l'estensione `.txt` e li aggiunge a `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 In questo esempio è necessario disporre una `ListBox` denominato `ListBox1` sul form.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory da cercare non esiste.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> fa riferimento a un file esistente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Directory in cui eseguire la ricerca.</param>
        <param name="searchType">Specifica se includere le sottocartelle. Il valore predefinito è <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Criterio da soddisfare.</param>
        <summary>Restituisce un insieme di stringhe in sola lettura che rappresenta i nomi dei file contenuti in una directory.</summary>
        <returns>Insieme di sola lettura dei nomi di file della directory specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non vengono trovati file corrispondenti al criterio specificato, verrà restituita una raccolta vuota.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.GetFiles` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Ottenere la raccolta di file in una directory|[Procedura: ottenere la raccolta di file di una directory](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Trovare i file con un criterio specifico in una directory|[Procedura: trovare file con un modello specifico](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L'esempio seguente restituisce tutti i file della directory e li aggiunge a `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 In questo esempio è necessario disporre una `ListBox` denominato `ListBox1` sul form.  
  
 In questo esempio restituisce tutti i file nella directory con l'estensione `.txt` e li aggiunge a `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 In questo esempio è necessario disporre una `ListBox` denominato `ListBox1` sul form.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory da cercare non esiste.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> fa riferimento a un file esistente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone delle autorizzazioni necessarie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetName : string -&gt; string" Usage="fileSystemProxy.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Obbligatorio. Percorso da analizzare. <see langword="String" />.</param>
        <summary>Analizza il nome del file al di fuori del percorso fornito.</summary>
        <returns>Nome del file nel percorso specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un'operazione di stringa; il `FileSystem` non viene esaminato.  
  
 Il `GetName` metodo ignora una barra che si verificano alla fine del percorso.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.GetFileName` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Analizzare un percorso di file|[Procedura: analizzare percorsi di file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Nell'esempio seguente analizza un percorso di file e restituisce il nome del file.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Sostituire il percorso `C:\Testdirectory\Testfile` con il percorso che si desidera analizzare.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetParentPath : string -&gt; string" Usage="fileSystemProxy.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso da esaminare.</param>
        <summary>Restituisce il percorso padre del percorso fornito.</summary>
        <returns>Percorso padre del percorso fornito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un'operazione di stringa; il file system non viene esaminato.  
  
   
  
## Examples  
 Questo esempio mostra come ottenere il percorso padre per `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nel percorso non è contenuto un percorso padre in quanto si tratta di un percorso radice.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="member this.GetTempFileName : unit -&gt; string" Usage="fileSystemProxy.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un file temporaneo di zero byte con nome univoco nel disco e restituisce il percorso completo di tale file.</summary>
        <returns>Classe <see langword="String" /> contenente il percorso completo del file temporaneo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per creare un file temporaneo.  
  
   
  
## Examples  
 In questo esempio viene creato un file temporaneo e restituisce il relativo percorso.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sposta una directory da un percorso a un altro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Percorso della directory da spostare.</param>
        <param name="destinationDirectoryName">Percorso della directory in cui viene spostata la directory di origine.</param>
        <summary>Sposta una directory da un percorso a un altro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se viene effettuato un tentativo di spostare una directory all'interno di una directory che non esiste, verrà creata la struttura di destinazione.  
  
   
  
## Examples  
 In questo esempio spostata `Directory1` all'interno di `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In questo esempio spostata `Directory1` all'interno di `Directory2`, sovrascrivendo la directory se esiste già.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory non esiste.</exception>
        <exception cref="T:System.IO.IOException">L'origine è una directory radice o il percorso di origine e il percorso di destinazione sono uguali.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Questa operazione è ciclica.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Percorso della directory da spostare.</param>
        <param name="destinationDirectoryName">Percorso della directory in cui viene spostata la directory di origine.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Sposta una directory da un percorso a un altro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se viene effettuato un tentativo di spostare una directory all'interno di una directory che non esiste, verrà creata la struttura di destinazione.  
  
   
  
## Examples  
 In questo esempio spostata `Directory1` all'interno di `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In questo esempio spostata `Directory1` all'interno di `Directory2`, sovrascrivendo la directory se esiste già.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory non esiste.</exception>
        <exception cref="T:System.IO.IOException">La directory di destinazione esiste già e l'elemento <paramref name="overwrite" /> è impostato su <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Questa operazione è ciclica.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * bool -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Percorso della directory da spostare.</param>
        <param name="destinationDirectoryName">Percorso della directory in cui viene spostata la directory di origine.</param>
        <param name="overwrite">
          <see langword="True" /> se le directory esistenti devono essere sovrascritte; in caso contrario, <see langword="False" />. Il valore predefinito è <see langword="False" />.</param>
        <summary>Sposta una directory da un percorso a un altro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se viene effettuato un tentativo di spostare una directory all'interno di una directory che non esiste, verrà creata la struttura di destinazione.  
  
   
  
## Examples  
 In questo esempio spostata `Directory1` all'interno di `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In questo esempio spostata `Directory1` all'interno di `Directory2`, sovrascrivendo la directory se esiste già.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory non esiste.</exception>
        <exception cref="T:System.IO.IOException">La directory di destinazione esiste già e l'elemento <paramref name="overwrite" /> è impostato su <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Questa operazione è ciclica.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Percorso della directory da spostare.</param>
        <param name="destinationDirectoryName">Percorso della directory in cui viene spostata la directory di origine.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Specifica se viene generata un'eccezione quando l'utente annulla l'operazione. Il valore predefinito è <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Sposta una directory da un percorso a un altro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se viene effettuato un tentativo di spostare una directory all'interno di una directory che non esiste, verrà creata la struttura di destinazione.  
  
   
  
## Examples  
 In questo esempio spostata `Directory1` all'interno di `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In questo esempio spostata `Directory1` all'interno di `Directory2`, sovrascrivendo la directory se esiste già.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero, contiene solo spazi vuoti, contiene caratteri non validi o è il percorso di un dispositivo (inizia con \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory non esiste.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="onUserCancel" /> è impostato su <see langword="ThrowException" /> e non è possibile copiare una sottodirectory del file.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> è impostato su <see langword="ThrowException" /> e l'utente annulla l'operazione oppure non è possibile completarla.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Questa operazione è ciclica.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sposta un file in un nuovo percorso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Percorso del file da spostare.</param>
        <param name="destinationFileName">Percorso della directory in cui spostare il file.</param>
        <summary>Sposta un file in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la struttura di destinazione non esiste, viene creato.  
  
 Il `MoveFile` metodo conserva le voci ACE (Access Control Entries) solo quando si spostano file all'interno dello stesso volume. Ciò include le voci ACE ereditate diventano dirette quando spostato (diretto ACE hanno la precedenza sulle ACE ereditate). Se un file viene spostato tra i volumi, verranno copiate non ACE.  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `My.Computer.FileSystem.MoveFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Spostare un file|[Procedura: spostare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Questo esempio il file spostato `Test.txt` dal `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In questo esempio il file viene spostato `Test.txt` dal `TestDir1` al `TestDir2` e lo rinomina `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di origine non è valido o non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controlla la possibilità di accedere a tutte le variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controlla se è possibile accedere alle variabili del Registro di sistema. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Percorso del file da spostare.</param>
        <param name="destinationFileName">Percorso della directory in cui spostare il file.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Sposta un file in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la struttura di destinazione non esiste, viene creato.  
  
 Il `MoveFile` metodo conserva le voci ACE (Access Control Entries) solo quando si spostano file all'interno dello stesso volume. Ciò include le voci ACE ereditate diventano dirette quando spostato (diretto ACE hanno la precedenza sulle ACE ereditate). Se un file viene spostato tra i volumi, verranno copiate non ACE.  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `My.Computer.FileSystem.MoveFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Spostare un file|[Procedura: spostare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Questo esempio il file spostato `Test.txt` dal `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In questo esempio il file viene spostato `Test.txt` dal `TestDir1` al `TestDir2` e lo rinomina `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di origine non è valido o non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controlla la possibilità di accedere a tutte le variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controlla se è possibile accedere alle variabili del Registro di sistema. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * bool -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Percorso del file da spostare.</param>
        <param name="destinationFileName">Percorso della directory in cui spostare il file.</param>
        <param name="overwrite">
          <see langword="True" /> per sovrascrivere i file esistenti; in caso contrario, <see langword="False" />. Il valore predefinito è <see langword="False" />.</param>
        <summary>Sposta un file in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la struttura di destinazione non esiste, viene creato.  
  
 Il `MoveFile` metodo conserva le voci ACE (Access Control Entries) solo quando si spostano file all'interno dello stesso volume. Ciò include le voci ACE ereditate diventano dirette quando spostato (diretto ACE hanno la precedenza sulle ACE ereditate). Se un file viene spostato tra i volumi, verranno copiate non ACE.  
  
 La tabella seguente elenca esempi di un'attività che coinvolgono il `My.Computer.FileSystem.MoveFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Spostare un file|[Procedura: spostare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Questo esempio il file spostato `Test.txt` dal `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In questo esempio il file viene spostato `Test.txt` dal `TestDir1` al `TestDir2` e lo rinomina `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di origine non è valido o non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controlla la possibilità di accedere a tutte le variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controlla se è possibile accedere alle variabili del Registro di sistema. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Percorso del file da spostare.</param>
        <param name="destinationFileName">Percorso della directory in cui spostare il file.</param>
        <param name="showUI">Specifica se tenere traccia in modo visivo dello stato dell'operazione. Il valore predefinito è <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Specifica se viene generata un'eccezione quando l'utente annulla l'operazione. Il valore predefinito è <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Sposta un file in un nuovo percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la struttura di destinazione non esiste, viene creato.  
  
 Il `MoveFile` metodo conserva le voci ACE (Access Control Entries) solo quando si spostano file all'interno dello stesso volume. Ciò include le voci ACE ereditate diventano dirette quando spostato (diretto ACE hanno la precedenza sulle ACE ereditate). Se un file viene spostato tra i volumi, verranno copiate non ACE.  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `My.Computer.FileSystem.MoveFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Spostare un file|[Procedura: spostare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Questo esempio il file spostato `Test.txt` dal `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In questo esempio il file viene spostato `Test.txt` dal `TestDir1` al `TestDir2` e lo rinomina `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file di origine non è valido o non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> è impostato su <see langword="ThrowException" /> e l'utente ha annullato l'operazione oppure si è verificato un errore di I/O non specificato.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controlla la possibilità di accedere a tutte le variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controlla se è possibile accedere alle variabili del Registro di sistema. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controlla le autorizzazioni correlate alle interfacce utente e agli Appunti. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Il metodo <see langword="OpenTextFieldParser" /> consente di creare un oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, mediante il quale è possibile analizzare in modo semplice ed efficiente file di testo strutturati, ad esempio log. L'oggetto <see langword="TextFieldParser" /> può essere utilizzato per leggere sia i file a larghezza fissa che quelli delimitati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">File da aprire con <see langword="TextFieldParser" />.</param>
        <summary>Il metodo <see langword="OpenTextFieldParser" /> consente di creare un oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, mediante il quale è possibile analizzare in modo semplice ed efficiente file di testo strutturati, ad esempio log. L'oggetto <see langword="TextFieldParser" /> può essere utilizzato per leggere sia i file a larghezza fissa che quelli delimitati.</summary>
        <returns>Oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> per la lettura del file specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.OpenTextFieldParser` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file di testo delimitato|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file di testo a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lettura da un file di testo con più formati|[Procedura: leggere da file di testo con più formati](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In questo esempio si apre la `TextFieldParser.reader` e lo usa per leggere da `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Non è possibile analizzare una riga utilizzando il formato specificato. Il messaggio di eccezione specifica la riga che ha generato l'eccezione, mentre alla proprietà <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> viene assegnato il testo contenuto nella riga.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Descrive un set di autorizzazioni di sicurezza applicato al codice. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">File da aprire con <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Larghezze dei campi.</param>
        <summary>Il metodo <see langword="OpenTextFieldParser" /> consente di creare un oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, mediante il quale è possibile analizzare in modo semplice ed efficiente file di testo strutturati, ad esempio log. L'oggetto <see langword="TextFieldParser" /> può essere utilizzato per leggere sia i file a larghezza fissa che quelli delimitati.</summary>
        <returns>Oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> per la lettura del file specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.OpenTextFieldParser` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file di testo delimitato|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file di testo a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lettura da un file di testo con più formati|[Procedura: leggere da file di testo con più formati](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In questo esempio si apre la `TextFieldParser.reader` e lo usa per leggere da `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Non è possibile analizzare una riga utilizzando il formato specificato. Il messaggio di eccezione specifica la riga che ha generato l'eccezione, mentre alla proprietà <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> viene assegnato il testo contenuto nella riga.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Descrive un set di autorizzazioni di sicurezza applicato al codice. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">File da aprire con <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Delimitatori dei campi.</param>
        <summary>Il metodo <see langword="OpenTextFieldParser" /> consente di creare un oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, mediante il quale è possibile analizzare in modo semplice ed efficiente file di testo strutturati, ad esempio log. L'oggetto <see langword="TextFieldParser" /> può essere utilizzato per leggere sia i file a larghezza fissa che quelli delimitati.</summary>
        <returns>Oggetto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> per la lettura del file specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.OpenTextFieldParser` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Lettura da un file di testo delimitato|[Procedura: leggere da file di testo delimitati da virgola](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lettura da un file di testo a larghezza fissa|[Procedura: leggere da file di testo a larghezza fissa](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lettura da un file di testo con più formati|[Procedura: leggere da file di testo con più formati](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 In questo esempio si apre la `TextFieldParser.reader` e lo usa per leggere da `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Non è possibile analizzare una riga utilizzando il formato specificato. Il messaggio di eccezione specifica la riga che ha generato l'eccezione, mentre alla proprietà <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> viene assegnato il testo contenuto nella riga.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Descrive un set di autorizzazioni di sicurezza applicato al codice. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un oggetto <see cref="T:System.IO.StreamReader" /> per eseguire la lettura da un file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="fileSystemProxy.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">File da leggere.</param>
        <summary>Apre un oggetto <see cref="T:System.IO.StreamReader" /> per eseguire la lettura da un file.</summary>
        <returns>Oggetto <see cref="T:System.IO.StreamReader" /> per eseguire la lettura dal file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo i file di testo possono essere letto utilizzando un <xref:System.IO.StreamReader>.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.OpenTextFileReader` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Aprire un file con un <xref:System.IO.StreamReader>|[Procedura: leggere il testo da file con un oggetto StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Questo esempio viene aperto il file `Testfile.txt`legge una riga da essa e viene visualizzata la riga in un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome del file termina con una barra rovesciata (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file specificato.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per leggere il file.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="fileSystemProxy.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">File da leggere.</param>
        <param name="encoding">Codifica da utilizzare per il contenuto del file. Il valore predefinito è ASCII.</param>
        <summary>Apre un oggetto <see cref="T:System.IO.StreamReader" /> per eseguire la lettura da un file.</summary>
        <returns>Oggetto <see cref="T:System.IO.StreamReader" /> per eseguire la lettura dal file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo i file di testo possono essere letto utilizzando un <xref:System.IO.StreamReader>.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.OpenTextFileReader` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Aprire un file con un <xref:System.IO.StreamReader>|[Procedura: leggere il testo da file con un oggetto StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Questo esempio viene aperto il file `Testfile.txt`legge una riga da essa e viene visualizzata la riga in un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome del file termina con una barra rovesciata (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file specificato.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per leggere il file.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un oggetto <see cref="T:System.IO.StreamWriter" /> per eseguire la scrittura nel file specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="fileSystemProxy.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">File in cui scrivere.</param>
        <param name="append">
          <see langword="True" /> per aggiungere i dati al contenuto del file; <see langword="False" /> per sovrascrivere il contenuto del file. Il valore predefinito è <see langword="False" />.</param>
        <summary>Apre un oggetto <see cref="T:System.IO.StreamWriter" /> per eseguire la scrittura nel file specificato.</summary>
        <returns>Oggetto <see cref="T:System.IO.StreamWriter" /> per eseguire la scrittura nel file specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `OpenTextFileWriter` metodo apre e Inizializza un flusso per un file e quindi restituisce il <xref:System.IO.StreamWriter> oggetto per il flusso. È possibile scrivere nel flusso di tutte le volte in base alle esigenze e quindi chiuderla dopo averli completati.  
  
> [!NOTE]
>  È necessario chiamare il <xref:System.IO.StreamWriter.Close%2A> metodo su di <xref:System.IO.StreamWriter> oggetto per verificare che tutti i dati in modo corretto viene scritto nel flusso sottostante.  
  
 Se si siano scrivendo solo alcune stringhe in un file, potrebbe essere più semplice usare il <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> (metodo).  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `My.Computer.FileSystem.OpenTextFileWriter` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Scrivere testo in un file con un `StreamWriter`|[Procedura: scrivere testo in file con un oggetto StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Questo esempio viene aperto un <xref:System.IO.StreamWriter> con il `My.Computer.FileSystem.OpenTextFileWriter` metodo e lo usa per scrivere una stringa in un file di testo con il `WriteLine` metodo del `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome file termina con una barra finale.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="fileSystemProxy.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">File in cui scrivere.</param>
        <param name="append">
          <see langword="True" /> per aggiungere i dati al contenuto del file; <see langword="False" /> per sovrascrivere il contenuto del file. Il valore predefinito è <see langword="False" />.</param>
        <param name="encoding">Codifica da utilizzare per la scrittura nel file. Il valore predefinito è ASCII.</param>
        <summary>Apre un oggetto <see cref="T:System.IO.StreamWriter" /> per eseguire la scrittura nel file specificato.</summary>
        <returns>Oggetto <see cref="T:System.IO.StreamWriter" /> per eseguire la scrittura nel file specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `OpenTextFileWriter` metodo apre e Inizializza un flusso per un file e quindi restituisce il <xref:System.IO.StreamWriter> oggetto per il flusso. È possibile scrivere nel flusso di tutte le volte in base alle esigenze e quindi chiuderla dopo averli completati.  
  
> [!NOTE]
>  È necessario chiamare il <xref:System.IO.StreamWriter.Close%2A> metodo su di <xref:System.IO.StreamWriter> oggetto per verificare che tutti i dati in modo corretto viene scritto nel flusso sottostante.  
  
 Se si siano scrivendo solo alcune stringhe in un file, potrebbe essere più semplice usare il <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> (metodo).  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `My.Computer.FileSystem.OpenTextFileWriter` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Scrivere testo in un file con un `StreamWriter`|[Procedura: scrivere testo in file con un oggetto StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Questo esempio viene aperto un <xref:System.IO.StreamWriter> con il `My.Computer.FileSystem.OpenTextFileWriter` metodo e lo usa per scrivere una stringa in un file di testo con il `WriteLine` metodo del `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome file termina con una barra finale.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.ReadAllBytes : string -&gt; byte[]" Usage="fileSystemProxy.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">File da leggere.</param>
        <summary>Restituisce il contenuto di un file come matrice di byte.</summary>
        <returns>Matrice di <see langword="Byte" /> contenente i contenuti del file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ReadAllBytes` metodo di `My.Computer.FileSystem` oggetto consente di leggere da un file binario. Il contenuto del file viene restituito come matrice di byte.  
  
 Non basarsi sul nome del file per prendere decisioni in merito al relativo contenuto. È possibile ad esempio che il file Form1.vb non sia un file di origine di Visual Basic. Prima di usare i dati nell'applicazione verificare tutti gli input.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.ReadAllBytes` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Leggere da un file binario|[Procedura: leggere da file binari](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 In questo esempio legge dal file `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per la scrittura della stringa nel buffer.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il contenuto di un file di testo come <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.ReadAllText : string -&gt; string" Usage="fileSystemProxy.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nome e percorso del file da leggere.</param>
        <summary>Restituisce il contenuto di un file di testo come <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> contenente i contenuti del file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo `ReadAllText` dell'oggetto `My.Computer.FileSystem` consente la lettura di un file di testo. Il contenuto del file viene restituito sotto forma di stringa.  
  
 La codifica del file può essere specificato se il contenuto del file è in una codifica, ad esempio ASCII o UTF-8. Se esegue la lettura da un file con caratteri estesi, è necessario specificare la codifica del file usando un altro overload del <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText%2A> (metodo).  
  
 Non basarsi sul nome del file per prendere decisioni in merito al relativo contenuto. È possibile ad esempio che il file Form1.vb non sia un file di origine di Visual Basic. Prima di usare i dati nell'applicazione verificare tutti gli input.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.ReadAllText` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Leggere da un file di testo|[Procedura: leggere da file di testo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 In questo esempio legge il contenuto di `Test.txt` in una stringa e quindi lo visualizza in una finestra di messaggio.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 In questo esempio legge il contenuto del file ASCII `Test.txt` in una stringa e quindi lo visualizza in una finestra di messaggio.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per la scrittura della stringa nel buffer.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.ReadAllText : string * System.Text.Encoding -&gt; string" Usage="fileSystemProxy.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Nome e percorso del file da leggere.</param>
        <param name="encoding">Codifica dei caratteri da utilizzare nella lettura del file. Il valore predefinito è UTF-8.</param>
        <summary>Restituisce il contenuto di un file di testo come <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> contenente i contenuti del file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo `ReadAllText` dell'oggetto `My.Computer.FileSystem` consente la lettura di un file di testo. Il contenuto del file viene restituito sotto forma di stringa.  
  
 La codifica del file può essere specificato se il contenuto del file è in una codifica, ad esempio ASCII o UTF-8. Se esegue la lettura da un file con caratteri estesi, è necessario specificare la codifica del file.  
  
 Non basarsi sul nome del file per prendere decisioni in merito al relativo contenuto. È possibile ad esempio che il file Form1.vb non sia un file di origine di Visual Basic. Prima di usare i dati nell'applicazione verificare tutti gli input.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.ReadAllText` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Leggere da un file di testo|[Procedura: leggere da file di testo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 In questo esempio legge il contenuto di `Test.txt` in una stringa e quindi lo visualizza in una finestra di messaggio.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 In questo esempio legge il contenuto del file ASCII `Test.txt` in una stringa e quindi lo visualizza in una finestra di messaggio.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per la scrittura della stringa nel buffer.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="member this.RenameDirectory : string * string -&gt; unit" Usage="fileSystemProxy.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Percorso e nome della directory da rinominare.</param>
        <param name="newName">Nuovo nome per la directory.</param>
        <summary>Rinomina una directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non può essere usato per spostare una directory. usare il `MoveDirectory` metodo per spostare e rinominare la directory.  
  
   
  
## Examples  
 Questo esempio Rinomina il `Test` directory `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contiene informazioni sul percorso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> è <see langword="Nothing" />.  -oppure- <paramref name="newName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory non esiste.</exception>
        <exception cref="T:System.IO.IOException">È disponibile un file o directory esistente con il nome specificato in <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="member this.RenameFile : string * string -&gt; unit" Usage="fileSystemProxy.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">File da rinominare.</param>
        <param name="newName">Nuovo nome del file.</param>
        <summary>Rinomina un file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non può essere usato per spostare un file. Per spostare e rinominare un file, usare il metodo <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile%2A>.  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `My.Computer.FileSystem.RenameFile` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Rinominare un file|[Procedura: rinominare un file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 Questo esempio Rinomina il file `Test.txt` a `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Modifica "`C:\Test.txt`" per il percorso e il nome del file che si desidera rinominare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contiene informazioni sul percorso o termina con una barra rovesciata (\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.  -oppure- <paramref name="newName" /> è <see langword="Nothing" /> o una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">È disponibile un file o directory esistente con il nome specificato in <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone dell'autorizzazione necessaria.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SpecialDirectories">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.SpecialDirectories" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SpecialDirectories As SpecialDirectoriesProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ SpecialDirectories { Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SpecialDirectories : Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.SpecialDirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che fornisce proprietà per l'accesso a directory cui si fa generalmente riferimento.</summary>
        <value>Questa proprietà restituisce l'oggetto <see cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" /> per il computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In questo esempio restituisce il percorso di directory Desktop dell'utente e lo visualizza.  
  
 [!code-vb[VbVbcnMyFileSystem#80](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#80)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="member this.WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="fileSystemProxy.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Percorso e nome del file in cui scrivere.</param>
        <param name="data">Dati da scrivere nel file.</param>
        <param name="append">
          <see langword="True" /> per aggiungere i dati al contenuto del file; <see langword="False" /> per sovrascrivere il contenuto del file. Il valore predefinito è <see langword="False" />.</param>
        <summary>Scrive dati in un file binario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il percorso specificato, escluso il nome di file, non è valido, un <xref:System.IO.DirectoryNotFoundException> verrà generata l'eccezione. Se il percorso sia valido, ma il file non esiste, viene creato il file.  
  
> [!NOTE]
>  Il `WriteAllBytes` metodo apre un file, in cui scrive e lo chiude. Il codice che utilizza il `WriteAllBytes` metodo è più semplice rispetto al codice che usa un <xref:System.IO.BinaryWriter> oggetto. Tuttavia, se si stiano aggiungendo dati in un file usando un ciclo, un <xref:System.IO.BinaryWriter> oggetto può fornire prestazioni migliori perché è sufficiente aprire e chiudere il file una sola volta.  
  
 La tabella seguente elenca un esempio di un'attività che coinvolgono il `My.Computer.FileSystem.WriteAllBytes` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Scrivere in un file binario|[Procedura: scrivere all'interno di file binari](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 In questo esempio viene aggiunta la matrice di dati `CustomerData` al file `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per la scrittura della stringa nel buffer.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive testo in un file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="member this.WriteAllText : string * string * bool -&gt; unit" Usage="fileSystemProxy.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">File in cui scrivere.</param>
        <param name="text">Testo da scrivere nel file.</param>
        <param name="append">
          <see langword="True" /> per aggiungere i dati al contenuto del file; <see langword="False" /> per sovrascrivere il contenuto del file. Il valore predefinito è <see langword="False" />.</param>
        <summary>Scrive testo in un file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica UTF-8 consente di scrivere nel file. Per specificare una codifica diversa, usare un overload diverso del <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> (metodo).  
  
 Se il file specificato non esiste, viene creato.  
  
 Se la codifica specificata non corrisponde alla codifica esistente del file, la codifica specificata viene ignorata.  
  
> [!NOTE]
>  Il `WriteAllText` metodo apre un file, in cui scrive e lo chiude. Il codice che utilizza il `WriteAllText` metodo è più semplice rispetto al codice che usa un <xref:System.IO.StreamWriter> oggetto. Tuttavia, se si aggiunge le stringhe in un file usando un ciclo, un <xref:System.IO.StreamWriter> oggetto può fornire prestazioni migliori perché è sufficiente aprire e chiudere il file una sola volta. Per altre informazioni, vedere il metodo <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.WriteAllText` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Scrivere testo in un file|[Procedura: scrivere testo in file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Aggiungere testo a un file|[Procedura: aggiungere testo a file di testo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 In questo esempio scrive la riga `"This is new text to be added."` al file `Test.txt`, sovrascrivendo il testo esistente nel file.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Questo esempio scrive i nomi dei file nei `Documents and Settings` cartella `FileList.txt`, inserendo un ritorno a capo restituiscono tra ciascuno per una migliore leggibilità.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per la scrittura della stringa nel buffer.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="fileSystemProxy.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">File in cui scrivere.</param>
        <param name="text">Testo da scrivere nel file.</param>
        <param name="append">
          <see langword="True" /> per aggiungere i dati al contenuto del file; <see langword="False" /> per sovrascrivere il contenuto del file. Il valore predefinito è <see langword="False" />.</param>
        <param name="encoding">Codifica da utilizzare per la scrittura nel file. Il valore predefinito è UTF-8.</param>
        <summary>Scrive testo in un file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il file specificato non esiste, viene creato.  
  
 Se la codifica specificata non corrisponde alla codifica esistente del file, la codifica specificata viene ignorata.  
  
> [!NOTE]
>  Il `WriteAllText` metodo apre un file, in cui scrive e lo chiude. Il codice che utilizza il `WriteAllText` metodo è più semplice rispetto al codice che usa un <xref:System.IO.StreamWriter> oggetto. Tuttavia, se si aggiunge le stringhe in un file usando un ciclo, un <xref:System.IO.StreamWriter> oggetto può fornire prestazioni migliori perché è sufficiente aprire e chiudere il file una sola volta. Per altre informazioni, vedere il metodo <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 La tabella seguente elenca alcuni esempi di attività che implicano il `My.Computer.FileSystem.WriteAllText` (metodo).  
  
|A|Vedere|  
|--------|---------|  
|Scrivere testo in un file|[Procedura: scrivere testo in file](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Aggiungere testo a un file|[Procedura: aggiungere testo a file di testo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 In questo esempio scrive la riga `"This is new text to be added."` al file `Test.txt`, sovrascrivendo il testo esistente nel file.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Questo esempio scrive i nomi dei file nei `Documents and Settings` cartella `FileList.txt`, inserendo un ritorno a capo restituiscono tra ciascuno per una migliore leggibilità.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido per uno dei motivi seguenti: è una stringa di lunghezza zero; contiene solo spazi vuoti; contiene caratteri non validi o è il percorso di un dispositivo ovvero inizia con \\\\.\\; termina con una barra finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> è <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Il file è in uso in un altro processo oppure si verifica un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del percorso supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">Nel nome di un file o di una directory del percorso sono presenti i due punti (:) oppure il relativo formato non è valido.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per la scrittura della stringa nel buffer.</exception>
        <exception cref="T:System.Security.SecurityException">L'utente non dispone delle autorizzazioni necessarie per visualizzare il percorso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controlla se è possibile accedere ai file e alle cartelle. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>