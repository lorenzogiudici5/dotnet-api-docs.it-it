<Type Name="SortedList&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.SortedList&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ca63497479eed3b89ff5780d298c69f9d33e555" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36713055" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SortedList&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.SortedList`2" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class SortedList : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Tipo di chiavi nella raccolta.</typeparam>
    <typeparam name="TValue">Tipo di valori nella raccolta.</typeparam>
    <summary>Rappresenta una raccolta di coppie chiave/valore ordinate per chiave in base all'implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> associata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.SortedList%602> classe generica è una matrice di coppie chiave/valore con O (log `n`) il recupero, dove n è il numero di elementi nel dizionario. In questo passaggio è simile al <xref:System.Collections.Generic.SortedDictionary%602> classe generica. Le due classi hanno modelli a oggetti simili e che entrambi contengano O (log `n`) il recupero. In cui le due classi sono diversi è in uso della memoria e velocità di inserimento e rimozione:  
  
-   <xref:System.Collections.Generic.SortedList%602> Usa meno memoria <xref:System.Collections.Generic.SortedDictionary%602>.  
  
-   <xref:System.Collections.Generic.SortedDictionary%602> dispone di inserimento più veloce e operazioni di rimozione per dati non ordinati, O (log `n`) anziché O (`n`) per <xref:System.Collections.Generic.SortedList%602>.  
  
-   Se l'elenco viene popolato in una sola volta da dati ordinati, <xref:System.Collections.Generic.SortedList%602> è più veloce <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Un'altra differenza tra i <xref:System.Collections.Generic.SortedDictionary%602> e <xref:System.Collections.Generic.SortedList%602> classi è che <xref:System.Collections.Generic.SortedList%602> supporta il recupero indicizzato efficiente di chiavi e valori tramite le raccolte restituite dal <xref:System.Collections.Generic.SortedList%602.Keys%2A> e <xref:System.Collections.Generic.SortedList%602.Values%2A> proprietà. Non è necessario rigenerare gli elenchi quando si accede a proprietà, poiché gli elenchi sono semplicemente wrapper per le matrici interne di chiavi e valori. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.Values%2A> proprietà per il recupero indicizzato di valori da un elenco ordinato di stringhe:  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 <xref:System.Collections.Generic.SortedList%602> viene implementato come una matrice di coppie chiave/valore, ordinate per chiave.  Ogni elemento può essere recuperato come un <xref:System.Collections.Generic.KeyValuePair%602> oggetto.  
  
 Gli oggetti chiave devono essere non modificabili, purché vengono utilizzati come chiavi di <xref:System.Collections.Generic.SortedList%602>. Ogni chiave in un <xref:System.Collections.Generic.SortedList%602> devono essere univoci. Non può essere una chiave `null`, ma un valore può essere, se il tipo di valori nell'elenco, `TValue`, è un tipo riferimento.  
  
 <xref:System.Collections.Generic.SortedList%602> richiede un'implementazione di un operatore di confronto per ordinare e per eseguire confronti.  L'operatore di confronto predefinito <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il tipo di chiave `TKey` implementa <xref:System.IComparable%601?displayProperty=nameWithType> e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il tipo di chiave `TKey` implementa <xref:System.IComparable?displayProperty=nameWithType>.  Se il tipo di chiave `TKey` non implementa entrambe le interfacce, è possibile specificare un <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implementazione in un overload del costruttore che accetta un `comparer` parametro.  
  
 La capacità di un <xref:System.Collections.Generic.SortedList%602> è il numero di elementi di <xref:System.Collections.Generic.SortedList%602> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.SortedList%602>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna. È possibile diminuire la capacità chiamando <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> oppure impostando la <xref:System.Collections.Generic.SortedList%602.Capacity%2A> proprietà in modo esplicito. Riduce la capacità la memoria viene riallocata e vi copia tutti gli elementi di <xref:System.Collections.Generic.SortedList%602>.  
  
 Per grandi <xref:System.Collections.Generic.SortedList%602> oggetti, è possibile aumentare la capacità massima a 2 miliardi di elementi in un sistema a 64 bit impostando il `enabled` attributo dell'elemento di configurazione per `true` nell'ambiente di runtime.  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) restituisce un oggetto di tipo degli elementi nella raccolta. Poiché gli elementi del <xref:System.Collections.Generic.SortedList%602> sono coppie chiave/valore, il tipo di elemento non è il tipo della chiave o il tipo del valore. Al contrario, il tipo di elemento è <xref:System.Collections.Generic.KeyValuePair%602>. Ad esempio:  
  
 [!code-cpp[Generic.SortedList#12](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#12)]
 [!code-csharp[Generic.SortedList#12](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#12)]
 [!code-vb[Generic.SortedList#12](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#12)]  
  
 Il `foreach` istruzione è un wrapper per l'enumeratore, che consente solo di leggere, non la scrittura da alla raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.SortedList%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Nell'esempio viene utilizzata la <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà (l'indicizzatore in c#) per recuperare i valori, dimostrando che un <xref:System.Collections.Generic.KeyNotFoundException> viene generata quando una chiave richiesta non è presente e che il valore associato alla chiave è possibile sostituire.  
  
 Nell'esempio viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> un modo più efficiente per recuperare i valori, se un programma deve provare valori di chiave che non sono presenti nell'elenco ordinato e viene illustrato come utilizzare il metodo di <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> metodo per verificare se esiste una chiave prima di chiamare il <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo.  
  
 Nell'esempio viene illustrato come enumerare le chiavi e valori nell'elenco ordinato e illustrato come enumerare le chiavi e valori da soli utilizzando il <xref:System.Collections.Generic.SortedList%602.Keys%2A> proprietà e il <xref:System.Collections.Generic.SortedList%602.Values%2A> proprietà.  
  
 Infine, nell'esempio viene illustrato il <xref:System.Collections.Generic.SortedList%602.Remove%2A> metodo.  
  
 [!code-cpp[Generic.SortedList#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#1)]
 [!code-csharp[Generic.SortedList#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#1)]
 [!code-vb[Generic.SortedList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  Oggetto <see cref="T:System.Collections.Generic.SortedList`2" /> può supportare più lettori contemporaneamente, fino a quando la raccolta non viene modificata.  Anche in questo caso, l'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</threadsafe>
    <altmember cref="T:System.Collections.Generic.IDictionary`2" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.Generic.SortedDictionary`2" />
    <altmember cref="T:System.Collections.Generic.KeyValuePair`2" />
    <altmember cref="T:System.Collections.Generic.IComparer`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.SortedList`2" />, con la capacità iniziale predefinita e che usa l'interfaccia <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedList%602> devono essere univoci in base all'operatore di confronto predefinito.  
  
 Questo costruttore utilizza il valore predefinito per la capacità iniziale del <xref:System.Collections.Generic.SortedList%602>. Per impostare la capacità iniziale, utilizzare il <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%29> costruttore. Se è possibile stimare le dimensioni finali della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.Generic.SortedList%602>.  
  
 Questo costruttore utilizza l'operatore di confronto predefinito per `TKey`. Per specificare un operatore di confronto, usare il <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IComparer%7B%600%7D%29> costruttore. L'operatore di confronto predefinito <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il tipo di chiave `TKey` implementa <xref:System.IComparable%601?displayProperty=nameWithType> e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il tipo di chiave `TKey` implementa <xref:System.IComparable?displayProperty=nameWithType>.  Se il tipo di chiave `TKey` non implementa entrambe le interfacce, è possibile specificare un <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implementazione in un overload del costruttore che accetta un `comparer` parametro.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.SortedList%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementazione di <see cref="T:System.Collections.Generic.IComparer`1" /> da usare quando si confrontano le chiavi.  -oppure-  <see langword="null" /> per usare l'elemento <see cref="T:System.Collections.Generic.Comparer`1" /> predefinito per questo tipo di chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.SortedList`2" />, con la capacità iniziale predefinita e che usa l'interfaccia <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedList%602> devono essere univoci in base all'operatore di confronto specificato.  
  
 Questo costruttore utilizza il valore predefinito per la capacità iniziale del <xref:System.Collections.Generic.SortedList%602>. Per impostare la capacità iniziale, utilizzare il <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> costruttore. Se è possibile stimare le dimensioni finali della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.Generic.SortedList%602>.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente crea un elenco ordinato con un operatore di confronto tra maiuscole e minuscole per le impostazioni cultura correnti. L'esempio aggiunge quattro elementi, alcune con chiavi lettere minuscole e alcuni con chiavi di lettere maiuscole. Nell'esempio vengono quindi tenta di aggiungere un elemento con una chiave che differisce da una chiave esistente solo per i casi, intercetta l'eccezione risulta e visualizza un messaggio di errore. Infine, l'esempio mostra gli elementi di ordinamento tra maiuscole e minuscole.  
  
 [!code-csharp[Generic.SortedList.ctor_IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; dictionary" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Oggetto <see cref="T:System.Collections.Generic.IDictionary`2" /> i cui elementi sono copiati nel nuovo oggetto <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.SortedList`2" /> che contiene gli elementi copiati dall'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" /> specificata, la cui capacità è sufficiente a contenere il numero di elementi copiati e che usa l'interfaccia <see cref="T:System.Collections.Generic.IComparer`1" /> predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedList%602> devono essere univoci in base all'impostazione predefinita operatore di confronto; in modo analogo, ogni chiave nell'origine `dictionary` devono inoltre essere univoci in base all'operatore di confronto predefinito.  
  
 La capacità della nuova <xref:System.Collections.Generic.SortedList%602> è impostato sul numero di elementi in `dictionary`, pertanto non viene effettuata alcuna operazione di ridimensionamento mentre viene popolato l'elenco.  
  
 Questo costruttore utilizza l'operatore di confronto predefinito per `TKey`. Per specificare un operatore di confronto, usare il <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> costruttore. L'operatore di confronto predefinito <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il tipo di chiave `TKey` implementa <xref:System.IComparable%601?displayProperty=nameWithType> e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il tipo di chiave `TKey` implementa <xref:System.IComparable?displayProperty=nameWithType>.  Se il tipo di chiave `TKey` non implementa entrambe le interfacce, è possibile specificare un <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implementazione in un overload del costruttore che accetta un `comparer` parametro.  
  
 Se i dati in `dictionary` sono ordinati, questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `dictionary`. In caso contrario, è un'operazione O (`n`*`n`) operazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare <xref:System.Collections.Generic.SortedList%602> per creare una copia ordinata le informazioni contenute in un <xref:System.Collections.Generic.Dictionary%602>, passando il <xref:System.Collections.Generic.Dictionary%602> per il <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%29> costruttore.  
  
 [!code-csharp[Generic.SortedList.ctor_IDic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IDic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> contiene una o più chiavi duplicate.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : int -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero iniziale degli elementi che <see cref="T:System.Collections.Generic.SortedList`2" /> può contenere.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.SortedList`2" />, con la capacità iniziale predefinita e che usa l'interfaccia <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedList%602> devono essere univoci in base all'operatore di confronto predefinito.  
  
 La capacità di un <xref:System.Collections.Generic.SortedList%602> è il numero di elementi che la <xref:System.Collections.Generic.SortedList%602> può contenere prima del ridimensionamento. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.SortedList%602>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.Generic.SortedList%602>.  
  
 È possibile diminuire la capacità chiamando <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> oppure impostando la <xref:System.Collections.Generic.SortedList%602.Capacity%2A> proprietà in modo esplicito. Riduce la capacità la memoria viene riallocata e vi copia tutti gli elementi di <xref:System.Collections.Generic.SortedList%602>.  
  
 Questo costruttore utilizza l'operatore di confronto predefinito per `TKey`. Per specificare un operatore di confronto, usare il <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> costruttore. L'operatore di confronto predefinito <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il tipo di chiave `TKey` implementa <xref:System.IComparable%601?displayProperty=nameWithType> e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il tipo di chiave `TKey` implementa <xref:System.IComparable?displayProperty=nameWithType>.  Se il tipo di chiave `TKey` non implementa entrambe le interfacce, è possibile specificare un <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implementazione in un overload del costruttore che accetta un `comparer` parametro.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `capacity`.  
  
   
  
## Examples  
 Esempio di codice seguente crea un elenco ordinato con una capacità iniziale pari a 4 e la popola con 4 voci.  
  
 [!code-csharp[Generic.SortedList.ctor_Int32#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_Int32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; (dictionary, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Oggetto <see cref="T:System.Collections.Generic.IDictionary`2" /> i cui elementi sono copiati nel nuovo oggetto <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <param name="comparer">Implementazione di <see cref="T:System.Collections.Generic.IComparer`1" /> da usare quando si confrontano le chiavi.  -oppure-  <see langword="null" /> per usare l'elemento <see cref="T:System.Collections.Generic.Comparer`1" /> predefinito per questo tipo di chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.SortedList`2" /> che contiene gli elementi copiati dall'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" /> specificata, la cui capacità è sufficiente a contenere il numero di elementi copiati e che usa l'interfaccia <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedList%602> devono essere univoci in base all'oggetto specificato operatore di confronto; in modo analogo, ogni chiave nell'origine `dictionary` devono inoltre essere univoci in base all'operatore di confronto specificato.  
  
 La capacità della nuova <xref:System.Collections.Generic.SortedList%602> è impostato sul numero di elementi in `dictionary`, pertanto non viene effettuata alcuna operazione di ridimensionamento mentre viene popolato l'elenco.  
  
 Se i dati in `dictionary` sono ordinati, questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `dictionary`. In caso contrario, è un'operazione O (`n`*`n`) operazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare <xref:System.Collections.Generic.SortedList%602> per creare una distinzione tra maiuscole e ordinati copia delle informazioni in una distinzione <xref:System.Collections.Generic.Dictionary%602>, passando il <xref:System.Collections.Generic.Dictionary%602> per il <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> costruttore. In questo esempio, gli operatori di confronto tra maiuscole e minuscole sono per le impostazioni cultura correnti.  
  
 [!code-csharp[Generic.SortedList.ctor_IDicIComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IDicIComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> contiene una o più chiavi duplicate.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int capacity, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero iniziale degli elementi che <see cref="T:System.Collections.Generic.SortedList`2" /> può contenere.</param>
        <param name="comparer">Implementazione di <see cref="T:System.Collections.Generic.IComparer`1" /> da usare quando si confrontano le chiavi.  -oppure-  <see langword="null" /> per usare l'elemento <see cref="T:System.Collections.Generic.Comparer`1" /> predefinito per questo tipo di chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.SortedList`2" />, con la capacità iniziale specificata e che usa l'interfaccia <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedList%602> devono essere univoci in base all'operatore di confronto specificato.  
  
 La capacità di un <xref:System.Collections.Generic.SortedList%602> è il numero di elementi che la <xref:System.Collections.Generic.SortedList%602> può contenere prima del ridimensionamento. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.SortedList%602>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.Generic.SortedList%602>.  
  
 È possibile diminuire la capacità chiamando <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> oppure impostando la <xref:System.Collections.Generic.SortedList%602.Capacity%2A> proprietà in modo esplicito. Riduce la capacità la memoria viene riallocata e vi copia tutti gli elementi di <xref:System.Collections.Generic.SortedList%602>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `capacity`.  
  
   
  
## Examples  
 Esempio di codice seguente crea un elenco ordinato con una capacità iniziale pari a 5 e un operatore di confronto tra maiuscole e minuscole per le impostazioni cultura correnti. L'esempio aggiunge quattro elementi, alcune con chiavi lettere minuscole e alcuni con chiavi di lettere maiuscole. Nell'esempio vengono quindi tenta di aggiungere un elemento con una chiave che differisce da una chiave esistente solo per i casi, intercetta l'eccezione risulta e visualizza un messaggio di errore. Infine, l'esempio mostra gli elementi di ordinamento tra maiuscole e minuscole.  
  
 [!code-csharp[Generic.SortedList.ctor_Int32IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_Int32IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit&#xA;override this.Add : 'Key * 'Value -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da aggiungere.</param>
        <param name="value">Valore dell'elemento da aggiungere. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Aggiunge un elemento con la chiave e il valore specificati al metodo <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non può essere una chiave `null`, ma un valore può essere, se il tipo di valori nell'elenco ordinato, `TValue`, è un tipo riferimento.  
  
 È anche possibile usare il <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave non esiste nel <xref:System.Collections.Generic.SortedList%602>, ad esempio `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nella <xref:System.Collections.Generic.SortedList%602>, impostando il <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Se <xref:System.Collections.Generic.SortedList%602.Count%2A> è già pari <xref:System.Collections.Generic.SortedList%602.Capacity%2A>, la capacità del <xref:System.Collections.Generic.SortedList%602> viene aumentata automaticamente la riallocazione della matrice interna, e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Questo metodo è un'operazione O (`n`) per dati non ordinati, dove `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>. È un'operazione O (log `n`) operazione se il nuovo elemento viene aggiunto alla fine dell'elenco. Se l'inserimento comporta un ridimensionamento, l'operazione è O (`n`).  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.SortedList%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Generic.SortedList`2" /> è già presente un elemento con la stessa chiave.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di elementi che <see cref="T:System.Collections.Generic.SortedList`2" /> può contenere.</summary>
        <value>Numero degli elementi che <see cref="T:System.Collections.Generic.SortedList`2" /> può contenere.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> è il numero di elementi che la <xref:System.Collections.Generic.SortedList%602> può archiviare. <xref:System.Collections.Generic.SortedList%602.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.SortedList%602>.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> è sempre maggiore o uguale a <xref:System.Collections.Generic.SortedList%602.Count%2A>. Se <xref:System.Collections.Generic.SortedList%602.Count%2A> supera <xref:System.Collections.Generic.SortedList%602.Capacity%2A> durante l'aggiunta di elementi, la capacità viene aumentata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 È possibile diminuire la capacità chiamando <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> oppure impostando la <xref:System.Collections.Generic.SortedList%602.Capacity%2A> proprietà in modo esplicito. Quando il valore di <xref:System.Collections.Generic.SortedList%602.Capacity%2A> è impostato in modo esplicito, la matrice interna viene riallocata anche per consentire la capacità specificata.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è un'operazione O (`n`) operazione, in cui `n` è la nuova capacità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'oggetto <see cref="P:System.Collections.Generic.SortedList`2.Capacity" /> è impostato su un valore minore di <see cref="P:System.Collections.Generic.SortedList`2.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile nel sistema non è sufficiente.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Count" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.TrimExcess" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli elementi da <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> non subisce modifiche. Per reimpostare la capacità del <xref:System.Collections.Generic.SortedList%602>, chiamare <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> o impostare il <xref:System.Collections.Generic.SortedList%602.Capacity%2A> proprietà direttamente. L'eliminazione di un oggetto vuoto <xref:System.Collections.Generic.SortedList%602> imposta la capacità del <xref:System.Collections.Generic.SortedList%602> per la capacità predefinita.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.TrimExcess" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IComparer&lt;'Key&gt;" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'interfaccia <see cref="T:System.Collections.Generic.IComparer`1" /> per l'elenco ordinato.</summary>
        <value>Oggetto <see cref="T:System.IComparable`1" /> dell'oggetto <see cref="T:System.Collections.Generic.SortedList`2" /> corrente</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Collections.Generic.SortedList`2" /> contiene una chiave specifica.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.SortedList`2" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> metodo per verificare se esiste una chiave prima di chiamare il <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo. Viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> metodo per recuperare valori che è un modo efficiente per recuperare i valori quando un programma prova spesso chiavi che non sono presenti nell'elenco ordinato. Infine, Mostra il modo meno efficiente per verificare se esistono chiavi, tramite il <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà (l'indicizzatore in c#).  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#6)]
 [!code-csharp[Generic.SortedList#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#6)]
 [!code-vb[Generic.SortedList#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#6)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsValue (value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.ContainsValue : 'Value -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Valore da individuare in <see cref="T:System.Collections.Generic.SortedList`2" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Stabilisce se <see cref="T:System.Collections.Generic.SortedList`2" /> contiene un valore specifico.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.SortedList`2" /> contiene un elemento con il valore specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto predefinito <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> per il tipo di valore `TValue`.  <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Controlla se il valore di tipo `TValue` implementa <xref:System.IComparable%601?displayProperty=nameWithType> e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il valore di tipo `TValue` implementa <xref:System.IComparable?displayProperty=nameWithType>.  Se il valore di tipo `TValue` non implementa entrambe le interfacce, questo metodo utilizza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, è proporzionale al tempo di esecuzione medio <xref:System.Collections.Generic.SortedList%602.Count%2A>. Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <value>Numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> è il numero di elementi che la <xref:System.Collections.Generic.SortedList%602> può archiviare. <xref:System.Collections.Generic.SortedList%602.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.SortedList%602>.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> è sempre maggiore o uguale a <xref:System.Collections.Generic.SortedList%602.Count%2A>. Se <xref:System.Collections.Generic.SortedList%602.Count%2A> supera <xref:System.Collections.Generic.SortedList%602.Capacity%2A> durante l'aggiunta di elementi, la capacità viene aumentata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione di <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns>Interfaccia <see cref="T:System.Collections.Generic.IEnumerator`1" /> di tipo <see cref="T:System.Collections.Generic.KeyValuePair`2" /> per la raccolta <see cref="T:System.Collections.Generic.SortedList`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Il dizionario viene mantenuto un ordinamento usando una struttura interna. Ogni nuovo elemento è posizionato in corrispondenza della posizione di ordinamento corretto e l'albero viene regolato per mantenere l'ordinamento ogni volta che un elemento viene rimosso. Durante l'enumerazione, viene mantenuto l'ordinamento.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 La proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public int IndexOfKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfKey (key As TKey) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfKey(TKey key);" />
      <MemberSignature Language="F#" Value="member this.IndexOfKey : 'Key -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <summary>Cerca la chiave specificata e restituisce l'indice in base zero all'interno dell'intera raccolta <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns>Indice in base zero della chiave specificata nel parametro <paramref name="key" /> all'interno dell'intera raccolta <see cref="T:System.Collections.Generic.SortedList`2" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una ricerca binaria; Pertanto, questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public int IndexOfValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfValue (value As TValue) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.IndexOfValue : 'Value -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Valore da individuare in <see cref="T:System.Collections.Generic.SortedList`2" />.  Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Cerca il valore specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intera raccolta <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns>Indice in base zero della prima occorrenza di <paramref name="value" /> all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.SortedList`2" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto predefinito <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> per il tipo di valore `TValue`.  <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Controlla se il valore di tipo `TValue` implementa <xref:System.IComparable%601?displayProperty=nameWithType> e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> controlla se il valore di tipo `TValue` implementa <xref:System.IComparable?displayProperty=nameWithType>.  Se il valore di tipo `TValue` non implementa entrambe le interfacce, questo metodo utilizza <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, è proporzionale al tempo di esecuzione medio <xref:System.Collections.Generic.SortedList%602.Count%2A>. Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave di cui si deve ottenere o impostare il valore.</param>
        <summary>Ottiene o imposta il valore associato alla chiave specificata.</summary>
        <value>Valore associato alla chiave specificata. Se la chiave specificata non viene trovata, un'operazione get genera <see cref="T:System.Collections.Generic.KeyNotFoundException" /> e un'operazione set crea un nuovo elemento con la chiave specificata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di accedere a un elemento specifico della raccolta utilizzando la sintassi seguente: `myCollection[key]`.  
  
 Non può essere una chiave `null`, ma un valore può essere, se il tipo di valori nell'elenco, `TValue`, è un tipo riferimento.  
  
 Se la chiave non viene trovata quando un valore viene recuperato, <xref:System.Collections.Generic.KeyNotFoundException> viene generata un'eccezione. Se la chiave non viene trovata quando viene impostato un valore, la chiave e il valore vengono aggiunti.  
  
 È anche possibile usare il <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave non esiste nel <xref:System.Collections.Generic.SortedList%602>, ad esempio `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nella <xref:System.Collections.Generic.SortedList%602>, impostando il <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Generic.SortedList%602.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Nel linguaggio c# viene utilizzata la parola chiave per definire gli indicizzatori anziché implementare la <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.SortedList%602.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Il recupero del valore di questa proprietà è un'operazione O (log `n`) operazione, dove n è <xref:System.Collections.Generic.SortedList%602.Count%2A>. Impostazione della proprietà è un'operazione O (log `n`) se la chiave è già nel <xref:System.Collections.Generic.SortedList%602>. Se la chiave non è presente nell'elenco, impostare la proprietà è un'operazione O (`n`) l'operazione per i dati non ordinati o O (log `n`) se il nuovo elemento viene aggiunto alla fine dell'elenco. Se l'inserimento comporta un ridimensionamento, l'operazione è O (`n`).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà (l'indicizzatore in c#) per recuperare i valori, dimostrando che un <xref:System.Collections.Generic.KeyNotFoundException> viene generata quando una chiave richiesta non è presente e che il valore associato alla chiave è possibile sostituire.  
  
 Nell'esempio viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> metodo in modo più efficiente per recuperare i valori se un programma deve provare spesso valori di chiave che non sono presenti nell'elenco ordinato.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#3)]
 [!code-csharp[Generic.SortedList#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#3)]
 [!code-vb[Generic.SortedList#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#3)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Durante il recupero della proprietà, la chiave indicata nel parametro <paramref name="key" /> non è stata trovata nella raccolta.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As IList(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;TKey&gt; ^ Keys { System::Collections::Generic::IList&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.IList&lt;'Key&gt;" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta contenente le chiavi in <see cref="T:System.Collections.Generic.SortedList`2" /> nell'ordine specificato.</summary>
        <value>Raccolta <see cref="T:System.Collections.Generic.IList`1" /> contenente le chiavi della classe <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine delle chiavi di <xref:System.Collections.Generic.IList%601> è lo stesso ordine nel <xref:System.Collections.Generic.SortedList%602>.  
  
 L'oggetto restituito <xref:System.Collections.Generic.IList%601> non è una copia statica, bensì il <xref:System.Collections.Generic.IList%601> non fa riferimento alle chiavi nell'originale <xref:System.Collections.Generic.SortedList%602>. Di conseguenza, le modifiche per il <xref:System.Collections.Generic.SortedList%602> continuano a essere riflessi nel <xref:System.Collections.Generic.IList%601>.  
  
 La raccolta restituita dal <xref:System.Collections.Generic.SortedList%602.Keys%2A> proprietà fornisce un modo efficiente per recuperare le chiavi in base all'indice. Non è necessario rigenerare l'elenco quando si accede alla proprietà, poiché l'elenco è un wrapper per la matrice interna delle chiavi. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.Keys%2A> proprietà per il recupero indicizzato di chiavi da un elenco ordinato di elementi con chiavi di stringa:  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come enumerare le chiavi presenti in elenco ordinato utilizzando il <xref:System.Collections.Generic.SortedList%602.Keys%2A> proprietà e come enumerare le chiavi e valori nell'elenco ordinato.  
  
 Nell'esempio viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.Keys%2A> proprietà per il recupero indicizzato efficiente delle chiavi.  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito. Vedere <xref:System.Collections.Generic.SortedList%602>.  
  
 [!code-cpp[Generic.SortedList#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#9)]
 [!code-csharp[Generic.SortedList#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#9)]
 [!code-vb[Generic.SortedList#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#9)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool&#xA;override this.Remove : 'Key -&gt; bool" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento con la chiave specificata da <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns>
          <see langword="true" /> se l'elemento viene rimosso correttamente; in caso contrario, <see langword="false" />.  Questo metodo restituisce anche <see langword="false" /> se <paramref name="key" /> non è stato trovato nell'interfaccia <see cref="T:System.Collections.Generic.SortedList`2" /> originale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una ricerca binaria; Tuttavia, gli elementi vengono spostati verso l'alto per riempire l'aperta, pertanto questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere una coppia chiave/valore dall'elenco ordinato utilizzando il <xref:System.Collections.Generic.SortedList%602.Remove%2A> metodo.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#10)]
 [!code-csharp[Generic.SortedList#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#10)]
 [!code-vb[Generic.SortedList#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento in corrispondenza dell'indice specificato di <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una ricerca binaria; Tuttavia, gli elementi vengono spostati verso l'alto per riempire l'aperta, pertanto questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero.  -oppure-  <paramref name="index" /> è uguale o maggiore di <see cref="P:System.Collections.Generic.SortedList`2.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), arrayIndex As Integer) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int arrayIndex) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="arrayIndex">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of TKey) Implements IDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TKey&gt; ^ System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of TValue) Implements IDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TValue&gt; ^ System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.ICollection" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.ICollection" /> in <see cref="T:System.Array" /> a partire da un particolare indice <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.ICollection> non può essere eseguire automaticamente il cast al tipo di destinazione `array`, le implementazioni non generica di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, mentre le implementazioni generiche generano <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  -oppure-  <paramref name="array" /> non ha indicizzazione a base zero.  -oppure-  Il numero di elementi nell'insieme di origine <see cref="T:System.Collections.ICollection" /> è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.  -oppure-  Non è possibile eseguire automaticamente il cast del tipo dell'insieme <see cref="T:System.Collections.ICollection" /> di origine nel tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.SortedList`2" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà restituisce un oggetto che può essere usato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread bloccano questo oggetto prima di accedere alla raccolta.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.SortedList`2" />, questa proprietà restituisce sempre l'istanza corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione. Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà restituisce un oggetto che può essere usato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread bloccano questo oggetto prima di accedere alla raccolta. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà per c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Oggetto <see cref="T:System.Object" /> da usare come chiave dell'elemento da aggiungere.</param>
        <param name="value">Oggetto <see cref="T:System.Object" /> da usare come valore dell'elemento da aggiungere.</param>
        <summary>Aggiunge un elemento con la chiave e il valore forniti all'interfaccia <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È anche possibile usare il <xref:System.Collections.IDictionary.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel dizionario; ad esempio, `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel dizionario, l'impostazione di <xref:System.Collections.IDictionary.Item%2A> proprietà sovrascrive il valore precedente. Al contrario, il <xref:System.Collections.IDictionary.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Questo metodo è un'operazione O (`n`) per dati non ordinati, dove `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>. È un'operazione O (log `n`) operazione se il nuovo elemento viene aggiunto alla fine dell'elenco. Se l'inserimento comporta un ridimensionamento, l'operazione è O (`n`).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come accedere il <xref:System.Collections.Generic.SortedList%602> classe tramite il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia. L'esempio di codice crea un oggetto vuoto <xref:System.Collections.Generic.SortedList%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata o quando viene fornita una chiave o il valore del tipo di dati non corretto.  
  
 L'esempio di codice illustra l'uso di diversi altri membri del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia.  
  
 [!code-csharp[Generic.SortedList.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il tipo della chiave indicata nel parametro <paramref name="key" /> non è assegnabile al tipo di chiave <paramref name="TKey" /> dell'insieme <see cref="T:System.Collections.IDictionary" />.  -oppure-  <paramref name="value" /> è un tipo che non è possibile assegnare al tipo di valore <paramref name="TValue" /> dell'oggetto <see cref="T:System.Collections.IDictionary" />.  -oppure-  In <see cref="T:System.Collections.IDictionary" /> è già presente un elemento con la stessa chiave.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.IDictionary" />.</param>
        <summary>Determina se <see cref="T:System.Collections.IDictionary" /> contiene un elemento con la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.IDictionary" /> contiene un elemento con la chiave; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce `false` se `key` è di un tipo che non è assegnabile al tipo di chiave `TKey` del <xref:System.Collections.Generic.SortedList%602>.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Contains%2A> metodo per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedList%602>. Nell'esempio viene illustrato che il metodo restituisce `false` se viene fornita una chiave del tipo di dati non corretto.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.SortedList.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce <see cref="T:System.Collections.IDictionaryEnumerator" /> per <see cref="T:System.Collections.IDictionary" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> per l'oggetto <see cref="T:System.Collections.IDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IDictionaryEnumerator.Entry%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IDictionaryEnumerator.Entry%2A>.  
  
 <xref:System.Collections.IDictionaryEnumerator.Entry%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IDictionaryEnumerator.Entry%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IDictionaryEnumerator.Entry%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come enumerare le coppie chiave/valore nell'elenco ordinato usando il `foreach` istruzione (`For Each` in Visual Basic `for each` in C++), che nasconde l'utilizzo dell'enumeratore. In particolare, si noti che l'enumeratore per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia restituisce <xref:System.Collections.DictionaryEntry> oggetti anziché <xref:System.Collections.Generic.KeyValuePair%602> oggetti.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IDictionary" /> ha dimensioni fisse.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IDictionary" /> è di dimensioni fisse; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.SortedList`2" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la sua creazione, ma consente la modifica degli elementi esistenti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.IDictionary.IsFixedSize" />
        <altmember cref="P:System.Collections.IDictionary.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IDictionary" /> è di sola lettura.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IDictionary" /> è di sola lettura; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.SortedList`2" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.IDictionary.IsReadOnly" />
        <altmember cref="P:System.Collections.IDictionary.IsFixedSize" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IDictionary.Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da ottenere o impostare.</param>
        <summary>Ottiene o imposta l'elemento con la chiave specificata.</summary>
        <value>L'elemento con la chiave specificata, o <see langword="null" /> se <paramref name="key" /> non è presente nel dizionario o se il tipo di <paramref name="key" /> non può essere assegnato al tipo di chiave <paramref name="TKey" /> della classe <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce `null` se `key` è di un tipo che non è assegnabile al tipo di chiave `TKey` del <xref:System.Collections.Generic.SortedList%602>.  
  
 Questa proprietà consente di accedere a un elemento specifico della raccolta utilizzando la sintassi seguente: `myCollection[key]`.  
  
 È anche possibile usare il <xref:System.Collections.IDictionary.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel dizionario; ad esempio, `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel dizionario, l'impostazione di <xref:System.Collections.IDictionary.Item%2A> proprietà sovrascrive il valore precedente. Al contrario, il <xref:System.Collections.IDictionary.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Nel linguaggio c# viene utilizzata la [ciò](~/docs/csharp/language-reference/keywords/this.md) (parola chiave) per definire gli indicizzatori anziché implementare la <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Il recupero del valore di questa proprietà è un'operazione O (log `n`) operazione, dove n è <xref:System.Collections.Generic.SortedList%602.Count%2A>. Impostazione della proprietà è un'operazione O (log `n`) se la chiave è già nel <xref:System.Collections.Generic.SortedList%602>. Se la chiave non è presente nell'elenco, impostare la proprietà è un'operazione O (`n`) l'operazione per i dati non ordinati o O (log `n`) se il nuovo elemento viene aggiunto alla fine dell'elenco. Se l'inserimento comporta un ridimensionamento, l'operazione è O (`n`).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> proprietà (l'indicizzatore in c#) del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedList%602>e la proprietà le differenze tra la <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> proprietà.  
  
 L'esempio mostra che, come le <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> proprietà, il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> proprietà possibile modificare il valore associato a una chiave esistente e può essere utilizzata per aggiungere una nuova coppia chiave/valore se la chiave specificata non è presente nell'elenco ordinato. L'esempio mostra anche che a differenza di <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> proprietà, il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> proprietà non genera un'eccezione se `key` non è presente nell'elenco ordinato, bensì restituisce un riferimento null. Infine, nell'esempio viene illustrato che quando si ottiene il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> proprietà restituisce un riferimento null se `key` non è il tipo di dati corretto e che l'impostazione della proprietà genera un'eccezione se `key` non corrisponde al tipo di dati corretto.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.SortedList.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedList.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedList.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Viene assegnato un valore e il tipo di <paramref name="key" /> non può essere assegnato al tipo di chiave <paramref name="TKey" /> della classe<see cref="T:System.Collections.Generic.SortedList`2" />.  -oppure-  Viene assegnato un valore e il tipo di <paramref name="value" /> non può essere assegnato al tipo di valore <paramref name="TValue" /> di <see cref="T:System.Collections.Generic.SortedList`2" />.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.ICollection" /> contenente le chiavi di <see cref="T:System.Collections.IDictionary" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.ICollection" /> contenente le chiavi dell'interfaccia <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine delle chiavi di <xref:System.Collections.ICollection> è lo stesso ordine nel <xref:System.Collections.Generic.SortedList%602>.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.IDictionary.Keys%2A> proprietà del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedDictionary%602>, per elencare le chiavi nel dizionario. Nell'esempio viene inoltre illustrato come enumerare le coppie chiave/valore nell'elenco ordinato; Si noti che l'enumeratore per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia restituisce <xref:System.Collections.DictionaryEntry> oggetti anziché <xref:System.Collections.Generic.KeyValuePair%602> oggetti.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.SortedList.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento con la chiave specificata da <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una ricerca binaria; Tuttavia, gli elementi vengono spostati verso l'alto per riempire l'aperta, pertanto questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Remove%2A> del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedList%602>.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.SortedList.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.ICollection" /> contenente i valori in <see cref="T:System.Collections.IDictionary" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.ICollection" /> contenente i valori dell'interfaccia <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei valori di <xref:System.Collections.ICollection> è lo stesso ordine nel <xref:System.Collections.Generic.SortedList%602>.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Values%2A> proprietà del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedList%602>, per elencare i valori nell'elenco ordinato. Nell'esempio viene inoltre illustrato come enumerare le coppie chiave/valore nell'elenco ordinato; Si noti che l'enumeratore per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia restituisce <xref:System.Collections.DictionaryEntry> oggetti anziché <xref:System.Collections.Generic.KeyValuePair%602> oggetti.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.SortedList.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori.  Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="sortedList.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta la capacità sul numero effettivo di elementi contenuti nell'oggetto <see cref="T:System.Collections.Generic.SortedList`2" />, se questo numero è inferiore al 90 per cento della capacità corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una raccolta se nessun nuovo elemento verrà aggiunto alla raccolta. Il costo di riallocazione e copia una grande <xref:System.Collections.Generic.SortedList%602> può essere considerevole, tuttavia, pertanto la <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> metodo non esegue alcuna operazione se l'elenco è in più del 90% della capacità. Questo evita di dover sostenere un costo di riallocazione elevato per un guadagno relativamente ridotto.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 Per reimpostare un <xref:System.Collections.Generic.SortedList%602> allo stato iniziale, chiamare il <xref:System.Collections.Generic.SortedList%602.Clear%2A> metodo prima di chiamare <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> metodo. L'eliminazione di un oggetto vuoto <xref:System.Collections.Generic.SortedList%602> imposta la capacità del <xref:System.Collections.Generic.SortedList%602> per la capacità predefinita.  
  
 La capacità può essere impostata anche utilizzando la <xref:System.Collections.Generic.SortedList%602.Capacity%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="sortedList.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Chiave di cui si deve ottenere il valore.</param>
        <param name="value">Quando il metodo termina, se la chiave specificata viene trovata, viene restituito il valore associato alla chiave; in caso contrario viene restituito il valore predefinito per il tipo del parametro <c>value</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Ottiene il valore associato alla chiave specificata.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.SortedList`2" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo combina la funzionalità del <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> metodo e il <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà.  
  
 Se la chiave non viene trovata, il `value` parametro ottiene il valore predefinito appropriato per il tipo di valore `TValue`, ad esempio, zero (0) per i tipi integer, `false` per i tipi Boolean e `null` per i tipi di riferimento.  
  
 Questo metodo esegue una ricerca binaria; Pertanto, questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> metodo in modo più efficiente per recuperare i valori in un programma che prova spesso chiavi che non sono presenti nell'elenco ordinato. Per contrasto, nell'esempio viene inoltre illustrato il modo in cui <xref:System.Collections.Generic.SortedList%602.Item%2A> proprietà (l'indicizzatore in c#) genera eccezioni durante il tentativo di recupero chiavi inesistenti.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
 [!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
 [!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As IList(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;TValue&gt; ^ Values { System::Collections::Generic::IList&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.IList&lt;'Value&gt;" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta contenente i valori di <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <value>Raccolta <see cref="T:System.Collections.Generic.IList`1" /> contenente i valori di <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei valori di <xref:System.Collections.Generic.IList%601> è lo stesso ordine nel <xref:System.Collections.Generic.SortedList%602>.  
  
 L'oggetto restituito <xref:System.Collections.Generic.IList%601> non è una copia statica, bensì il <xref:System.Collections.Generic.IList%601> non fa riferimento ai valori nell'originale <xref:System.Collections.Generic.SortedList%602>. Di conseguenza, le modifiche per il <xref:System.Collections.Generic.SortedList%602> continuano a essere riflessi nel <xref:System.Collections.Generic.IList%601>.  
  
 La raccolta restituita dal <xref:System.Collections.Generic.SortedList%602.Values%2A> proprietà fornisce un modo efficiente per recuperare i valori in base all'indice. Non è necessario rigenerare l'elenco quando si accede alla proprietà, poiché l'elenco è un wrapper per la matrice interna di valori. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.Values%2A> proprietà per il recupero indicizzato di valori da un elenco ordinato di stringhe:  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Questo esempio di codice viene illustrato come enumerare i valori nell'elenco ordinato utilizzando il <xref:System.Collections.Generic.SortedList%602.Values%2A> proprietà e come enumerare le chiavi e valori nell'elenco ordinato.  
  
 Nell'esempio viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.SortedList%602.Values%2A> proprietà per il recupero indicizzato efficiente dei valori.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#8)]
 [!code-csharp[Generic.SortedList#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#8)]
 [!code-vb[Generic.SortedList#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#8)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>