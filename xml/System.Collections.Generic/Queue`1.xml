<Type Name="Queue&lt;T&gt;" FullName="System.Collections.Generic.Queue&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a7bc186e6a40e180cd3bf8e904a90e097195fe7d" />
    <Meta Name="ms.sourcegitcommit" Value="850a55c780d5a95b534467969add0232fd3a6125" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/07/2018" />
    <Meta Name="ms.locfileid" Value="34829466" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Queue&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Queue`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Queue`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Queue(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Queue : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_QueueDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Specifica il tipo di elementi della coda.</typeparam>
    <summary>Rappresenta una raccolta di oggetti FIFO (First-In First-Out).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe implementa una coda generica come matrice circolare. Gli oggetti archiviati in un <xref:System.Collections.Generic.Queue%601> vengono inseriti in un'entità finale e rimossi da altra. Le code e stack sono utili quando è necessaria l'archiviazione temporanea per le informazioni; ovvero, quando si potrebbe desiderare di eliminare un elemento dopo aver recuperato il relativo valore. Utilizzare <xref:System.Collections.Generic.Queue%601> se è necessario accedere alle informazioni nello stesso ordine in cui sono archiviate nella raccolta. Utilizzare <xref:System.Collections.Generic.Stack%601> se è necessario accedere alle informazioni in ordine inverso. Utilizzare <xref:System.Collections.Concurrent.ConcurrentQueue%601> o <xref:System.Collections.Concurrent.ConcurrentStack%601> se è necessario accedere alla raccolta da più thread contemporaneamente.  
  
 Tre operazioni principali possono essere eseguite su un <xref:System.Collections.Generic.Queue%601> e i relativi elementi:  
  
-   <xref:System.Collections.Generic.Queue%601.Enqueue%2A> Aggiunge un elemento alla fine di <xref:System.Collections.Generic.Queue%601>.  
  
-   <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Rimuove l'elemento meno recente dall'inizio di <xref:System.Collections.Generic.Queue%601>.  
  
-   <xref:System.Collections.Generic.Queue%601.Peek%2A> Peek restituisce l'elemento meno recente all'inizio del <xref:System.Collections.Generic.Queue%601> , ma non rimuoverla dal <xref:System.Collections.Generic.Queue%601>.  
  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi di <xref:System.Collections.Generic.Queue%601> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Queue%601>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna. È possibile diminuire la capacità chiamando <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 <xref:System.Collections.Generic.Queue%601> accetta `null` come tipi di un valore valido per riferimento e consente elementi duplicati.  
  
   
  
## Examples  
 Esempio di codice seguente illustra i diversi metodi del <xref:System.Collections.Generic.Queue%601> classe generica. L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  Oggetto <see cref="T:System.Collections.Generic.Queue`1" /> può supportare più lettori contemporaneamente, fino a quando non è possibile modificare la raccolta.  Anche in questo caso, l'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Queue`1" /> vuota e con capacità iniziale predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi che la <xref:System.Collections.Generic.Queue%601> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Queue%601>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.Queue%601>.  
  
 È possibile diminuire la capacità chiamando <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato questo costruttore e diversi metodi della <xref:System.Collections.Generic.Queue%601> classe generica. L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Raccolta i cui elementi sono copiati nel nuovo oggetto <see cref="T:System.Collections.Generic.Queue`1" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Queue`1" /> che contiene gli elementi copiati dalla raccolta specificata e ha la capacità sufficiente per contenere il numero di elementi copiati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi che la <xref:System.Collections.Generic.Queue%601> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Queue%601>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.Queue%601>.  
  
 È possibile diminuire la capacità chiamando <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 Gli elementi vengono copiati nel <xref:System.Collections.Generic.Queue%601> nello stesso ordine in cui vengono letti dal <xref:System.Collections.Generic.IEnumerator%601> della raccolta.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `collection`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato questo costruttore e diversi metodi della <xref:System.Collections.Generic.Queue%601> classe generica. L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero iniziale degli elementi che <see cref="T:System.Collections.Generic.Queue`1" /> può contenere.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Queue`1" /> vuota e con capacità iniziale specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi che la <xref:System.Collections.Generic.Queue%601> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Queue%601>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.Queue%601>.  
  
 È possibile diminuire la capacità chiamando <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli oggetti da <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Queue%601.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 La capacità rimane invariata. Per reimpostare la capacità del <xref:System.Collections.Generic.Queue%601>, chiamare <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>. L'eliminazione di un oggetto vuoto <xref:System.Collections.Generic.Queue%601> imposta la capacità del <xref:System.Collections.Generic.Queue%601> per la capacità predefinita.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente illustra i diversi metodi del <xref:System.Collections.Generic.Queue%601> classe generica, inclusi il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo.  
  
 L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.TrimExcess" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.Queue`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Determina se un elemento è incluso in <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> è presente in <see cref="T:System.Collections.Generic.Queue`1" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nella coda.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente illustra i diversi metodi del <xref:System.Collections.Generic.Queue%601> classe generica, inclusi il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo.  
  
 L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.Queue`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.Generic.Queue`1" /> in un oggetto <see cref="T:System.Array" /> unidimensionale esistente, partendo dall'indice della matrice specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono copiati il <xref:System.Array> nello stesso ordine in cui l'enumeratore scorre la <xref:System.Collections.Generic.Queue%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi nell'oggetto <see cref="T:System.Collections.Generic.Queue`1" /> di origine è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di elementi contenuti in <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <value>Il numero di elementi contenuti in <see cref="T:System.Collections.Generic.Queue`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi che la <xref:System.Collections.Generic.Queue%601> può archiviare. <xref:System.Collections.Generic.Queue%601.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.Queue%601>.  
  
 La capacità è sempre maggiore di o uguale a <xref:System.Collections.Generic.Queue%601.Count%2A>. Se <xref:System.Collections.Generic.Queue%601.Count%2A> durante l'aggiunta di elementi supera la capacità, la capacità viene aumentata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente illustra molte proprietà e metodi del <xref:System.Collections.Generic.Queue%601> classe generica, inclusi il <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà.  
  
 L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dequeue">
      <MemberSignature Language="C#" Value="public T Dequeue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Dequeue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Dequeue" />
      <MemberSignature Language="VB.NET" Value="Public Function Dequeue () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Dequeue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente di rimuovere e restituire l'oggetto all'inizio della <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <returns>Oggetto rimosso dall'inizio della <see cref="T:System.Collections.Generic.Queue`1" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è analogo al metodo <xref:System.Collections.Generic.Queue%601.Peek%2A>, ma <xref:System.Collections.Generic.Queue%601.Peek%2A> non modifica la <xref:System.Collections.Generic.Queue%601>.  
  
 Se tipo `T` è un tipo riferimento, `null` possono essere aggiunti al <xref:System.Collections.Generic.Queue%601> come valore.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente illustra i diversi metodi del <xref:System.Collections.Generic.Queue%601> classe generica, inclusi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo.  
  
 L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La classe <see cref="T:System.Collections.Generic.Queue`1" /> è vuota.</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="Enqueue">
      <MemberSignature Language="C#" Value="public void Enqueue (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enqueue(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Enqueue (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Enqueue(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da aggiungere all'oggetto <see cref="T:System.Collections.Generic.Queue`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Aggiunge un oggetto alla fine di <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Collections.Generic.Queue%601.Count%2A> è già pari alla capacità, la capacità del <xref:System.Collections.Generic.Queue%601> viene aumentata automaticamente la riallocazione della matrice interna e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Se <xref:System.Collections.Generic.Queue%601.Count%2A> è minore della capacità della matrice interna, questo metodo è un'operazione o (1). Se la matrice interna deve essere riallocata per consentire il nuovo elemento, questo metodo diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente illustra i diversi metodi del <xref:System.Collections.Generic.Queue%601> classe generica, inclusi il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo.  
  
 L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Queue&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Queue`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Queue(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Queue&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Queue&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione di <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Queue`1.Enumerator" /> per l'oggetto <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A>.  
  
 La proprietà <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A>. <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e la successiva chiamata al <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> o <xref:System.Collections.Generic.Queue%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene dimostrato che la <xref:System.Collections.Generic.Queue%601> la classe generica. Il `foreach` istruzione (`For Each` in Visual Basic `for each` in C++) viene utilizzato per enumerare la coda.  
  
 L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Queue`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto all'inizio della <see cref="T:System.Collections.Generic.Queue`1" /> senza rimuoverlo.</summary>
        <returns>Oggetto all'inizio della <see cref="T:System.Collections.Generic.Queue`1" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è analogo al metodo <xref:System.Collections.Generic.Queue%601.Dequeue%2A>, ma <xref:System.Collections.Generic.Queue%601.Peek%2A> non modifica la <xref:System.Collections.Generic.Queue%601>.  
  
 Se tipo `T` è un tipo riferimento, `null` possono essere aggiunti al <xref:System.Collections.Generic.Queue%601> come valore.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente illustra i diversi metodi del <xref:System.Collections.Generic.Queue%601> classe generica, inclusi il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo.  
  
 L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La classe <see cref="T:System.Collections.Generic.Queue`1" /> è vuota.</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 La proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e la successiva chiamata al <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.ICollection" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="index">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.ICollection" /> in <see cref="T:System.Array" /> a partire da un particolare indice <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.ICollection> non può essere eseguire automaticamente il cast al tipo della destinazione `array`, le implementazioni non generica di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> generare <xref:System.InvalidCastException>, mentre le implementazioni generiche generano <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  -oppure-  <paramref name="array" /> non ha indicizzazione a base zero.  -oppure-  Il numero di elementi nell'insieme di origine <see cref="T:System.Collections.ICollection" /> è maggiore dello spazio disponibile tra <paramref name="index" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.  -oppure-  Non è possibile eseguire automaticamente il cast del tipo dell'insieme <see cref="T:System.Collections.ICollection" /> di origine nel tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.Queue`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso a <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread bloccano questo oggetto prima di accedere alla raccolta.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.Queue`1" />, questa proprietà restituisce sempre l'istanza corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso a <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread bloccano questo oggetto prima di accedere alla raccolta. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà per c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As IColletion = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e la successiva chiamata al <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>. 
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia gli elementi di <see cref="T:System.Collections.Generic.Queue`1" /> in una nuova matrice.</summary>
        <returns>Nuova matrice contenente gli elementi copiati dalla <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.Queue%601> non viene modificato. L'ordine degli elementi nella nuova matrice è identico all'ordine degli elementi dall'inizio del <xref:System.Collections.Generic.Queue%601> alla fine.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente illustra i diversi metodi del <xref:System.Collections.Generic.Queue%601> classe generica, inclusi il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo.  
  
 L'esempio di codice crea una coda di stringhe con la capacità predefinita e utilizza il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per inserire cinque stringhe nella coda. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo della coda e quindi la <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copiare gli elementi della coda, quindi la matrice viene passata per il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creazione di una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene utilizzato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda contenente tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> vengono visualizzate le proprietà che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta la capacità sul numero effettivo di elementi contenuti nell'oggetto <see cref="T:System.Collections.Generic.Queue`1" />, se questo numero è inferiore al 90 per cento della capacità corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una raccolta se nessun nuovo elemento verrà aggiunto alla raccolta. Il costo di riallocazione e copia di un <xref:System.Collections.Generic.Queue%601> può essere considerevole, tuttavia, pertanto la <xref:System.Collections.Generic.Queue%601.TrimExcess%2A> metodo non esegue alcuna operazione se l'elenco è in più del 90% della capacità. Questo evita di dover sostenere un costo di riallocazione elevato per un aumento di dimensioni relativamente ridotte.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
 Per reimpostare un <xref:System.Collections.Generic.Queue%601> lo stato iniziale, chiamare il metodo di <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo prima di chiamare <xref:System.Collections.Generic.Queue%601.TrimExcess%2A> metodo. L'eliminazione di un oggetto vuoto <xref:System.Collections.Generic.Queue%601> imposta la capacità del <xref:System.Collections.Generic.Queue%601> per la capacità predefinita.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Queue`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="public bool TryDequeue (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryDequeue([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryDequeue(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryDequeue (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryDequeue([Runtime::InteropServices::Out] T % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>