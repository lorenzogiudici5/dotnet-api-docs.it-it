<Type Name="Queue&lt;T&gt;" FullName="System.Collections.Generic.Queue&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="daef28e829e1db6957477f7c6d292e59ec71ea6b" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52254561" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Queue&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Queue`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Queue`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Queue(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Queue : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Queue&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_QueueDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Specifica il tipo di elementi della coda.</typeparam>
    <summary>Rappresenta una raccolta di oggetti FIFO (First-In First-Out).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe implementa una coda generica come matrice di circolare. Gli oggetti archiviati in un <xref:System.Collections.Generic.Queue%601> vengono inseriti in un'entità finale e rimossi da un altro. Code e stack sono utili quando necessaria l'archiviazione temporanea per le informazioni; vale a dire, quando si potrebbe desiderare di eliminare un elemento dopo il recupero il relativo valore. Usare <xref:System.Collections.Generic.Queue%601> se è necessario accedere alle informazioni nello stesso ordine in cui sono archiviate nell'insieme. Usare <xref:System.Collections.Generic.Stack%601> se è necessario accedere alle informazioni in ordine inverso. Uso <xref:System.Collections.Concurrent.ConcurrentQueue%601> o <xref:System.Collections.Concurrent.ConcurrentStack%601> se è necessario accedere alla raccolta da più thread contemporaneamente.  
  
 Principale e tre le operazioni eseguibili su un <xref:System.Collections.Generic.Queue%601> e i relativi elementi:  
  
-   <xref:System.Collections.Generic.Queue%601.Enqueue%2A> Aggiunge un elemento alla fine del <xref:System.Collections.Generic.Queue%601>.  
  
-   <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Rimuove gli elementi più vecchi dall'inizio del <xref:System.Collections.Generic.Queue%601>.  
  
-   <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo Peek restituisce il meno recente dell'elemento corrispondente all'inizio del <xref:System.Collections.Generic.Queue%601> ma non lo rimuove dal <xref:System.Collections.Generic.Queue%601>.  
  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi di <xref:System.Collections.Generic.Queue%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Queue%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna. La capacità può essere ridotto mediante una chiamata <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 <xref:System.Collections.Generic.Queue%601> accetta `null` come tipi di un valore valido per riferimento e consente gli elementi duplicati.  
  
   
  
## Examples  
 Esempio di codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Queue%601> classe generica. L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  
  
Oggetto <see cref="T:System.Collections.Generic.Queue`1" /> può supportare più lettori contemporaneamente, fino a quando non viene modificata la raccolta.  Anche in questo caso, l'enumerazione di una raccolta di per sé non è una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Queue`1" /> vuota e con capacità iniziale predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi che il <xref:System.Collections.Generic.Queue%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Queue%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna.  
  
 Se le dimensioni della raccolta possono essere stimata, che specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.Queue%601>.  
  
 La capacità può essere ridotto mediante una chiamata <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra questo costruttore e molti altri metodi del <xref:System.Collections.Generic.Queue%601> classe generica. L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Queue&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.Queue&lt;'T&gt;" Usage="new System.Collections.Generic.Queue&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Raccolta i cui elementi sono copiati nel nuovo oggetto <see cref="T:System.Collections.Generic.Queue`1" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Queue`1" /> che contiene gli elementi copiati dalla raccolta specificata e ha la capacità sufficiente per contenere il numero di elementi copiati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi che il <xref:System.Collections.Generic.Queue%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Queue%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna.  
  
 Se le dimensioni della raccolta possono essere stimata, che specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.Queue%601>.  
  
 La capacità può essere ridotto mediante una chiamata <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 Gli elementi vengono copiati nel <xref:System.Collections.Generic.Queue%601> nello stesso ordine in cui vengono letti dal <xref:System.Collections.Generic.IEnumerator%601> della raccolta.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `collection`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra questo costruttore e molti altri metodi del <xref:System.Collections.Generic.Queue%601> classe generica. L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Queue&lt;'T&gt; : int -&gt; System.Collections.Generic.Queue&lt;'T&gt;" Usage="new System.Collections.Generic.Queue&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero iniziale degli elementi che <see cref="T:System.Collections.Generic.Queue`1" /> può contenere.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Queue`1" /> vuota e con capacità iniziale specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi che il <xref:System.Collections.Generic.Queue%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Queue%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna.  
  
 Se le dimensioni della raccolta possono essere stimata, che specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.Queue%601>.  
  
 La capacità può essere ridotto mediante una chiamata <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="queue.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli oggetti da <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Queue%601.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 La capacità rimane invariata. Per reimpostare la capacità dei <xref:System.Collections.Generic.Queue%601>, chiamare <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>. Trimming di un oggetto vuoto <xref:System.Collections.Generic.Queue%601> imposta la capacità del <xref:System.Collections.Generic.Queue%601> alla capacità predefinita.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Queue%601> classe generica, tra cui il <xref:System.Collections.Generic.Queue%601.Clear%2A> (metodo).  
  
 L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.TrimExcess" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="member this.Contains : 'T -&gt; bool" Usage="queue.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.Queue`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Determina se un elemento è incluso in <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> è presente in <see cref="T:System.Collections.Generic.Queue`1" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nella coda.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Queue%601> classe generica, tra cui il <xref:System.Collections.Generic.Queue%601.Contains%2A> (metodo).  
  
 L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="queue.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.Queue`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <paramref name="array" /> in corrispondenza del quale viene avviata la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.Generic.Queue`1" /> in un oggetto <see cref="T:System.Array" /> unidimensionale esistente, partendo dall'indice della matrice specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vengono copiati gli elementi per il <xref:System.Array> nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.Generic.Queue%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi nell'oggetto <see cref="T:System.Collections.Generic.Queue`1" /> di origine è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Queue&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di elementi contenuti in <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <value>Il numero di elementi contenuti in <see cref="T:System.Collections.Generic.Queue`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Queue%601> è il numero di elementi che il <xref:System.Collections.Generic.Queue%601> può archiviare. <xref:System.Collections.Generic.Queue%601.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.Queue%601>.  
  
 La capacità è sempre maggiore di o uguale a <xref:System.Collections.Generic.Queue%601.Count%2A>. Se <xref:System.Collections.Generic.Queue%601.Count%2A> supera la capacità durante l'aggiunta di elementi, la capacità viene incrementata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiungere i nuovi elementi.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra molte proprietà e metodi del <xref:System.Collections.Generic.Queue%601> classe generica, tra cui il <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà.  
  
 L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dequeue">
      <MemberSignature Language="C#" Value="public T Dequeue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Dequeue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Dequeue" />
      <MemberSignature Language="VB.NET" Value="Public Function Dequeue () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Dequeue();" />
      <MemberSignature Language="F#" Value="member this.Dequeue : unit -&gt; 'T" Usage="queue.Dequeue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente di rimuovere e restituire l'oggetto all'inizio della <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <returns>Oggetto rimosso dall'inizio della <see cref="T:System.Collections.Generic.Queue`1" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è analogo al metodo <xref:System.Collections.Generic.Queue%601.Peek%2A>, ma <xref:System.Collections.Generic.Queue%601.Peek%2A> non modifica la <xref:System.Collections.Generic.Queue%601>.  
  
 Se tipo `T` è un tipo di riferimento `null` possono essere aggiunti al <xref:System.Collections.Generic.Queue%601> sotto forma di valore.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Queue%601> classe generica, tra cui il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> (metodo).  
  
 L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La classe <see cref="T:System.Collections.Generic.Queue`1" /> è vuota.</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="Enqueue">
      <MemberSignature Language="C#" Value="public void Enqueue (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enqueue(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Enqueue (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Enqueue(T item);" />
      <MemberSignature Language="F#" Value="member this.Enqueue : 'T -&gt; unit" Usage="queue.Enqueue item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da aggiungere all'oggetto <see cref="T:System.Collections.Generic.Queue`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Aggiunge un oggetto alla fine di <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Collections.Generic.Queue%601.Count%2A> già pari alla capacità, la capacità del <xref:System.Collections.Generic.Queue%601> viene incrementato automaticamente la riallocazione della matrice interna, e vengono copiati gli elementi esistenti nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Se <xref:System.Collections.Generic.Queue%601.Count%2A> è minore rispetto alla capacità della matrice interna, questo metodo è un'operazione o (1). Se la matrice interna deve essere riallocate in base al nuovo elemento, questo metodo diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Queue%601> classe generica, tra cui il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> (metodo).  
  
 L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Queue&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Queue`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Queue(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Queue&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Queue&lt;'T&gt;.Enumerator" Usage="queue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Queue&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione di <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Queue`1.Enumerator" /> per l'oggetto <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A>.  
  
 La proprietà <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A>. <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> oppure <xref:System.Collections.Generic.Queue%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene dimostrato che la <xref:System.Collections.Generic.Queue%601> la classe generica. Il `foreach` istruzione (`For Each` in Visual Basic `for each` in C++) viene usato per enumerare la coda.  
  
 L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Queue`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; 'T" Usage="queue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto all'inizio della <see cref="T:System.Collections.Generic.Queue`1" /> senza rimuoverlo.</summary>
        <returns>Oggetto all'inizio della <see cref="T:System.Collections.Generic.Queue`1" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è analogo al metodo <xref:System.Collections.Generic.Queue%601.Dequeue%2A>, ma <xref:System.Collections.Generic.Queue%601.Peek%2A> non modifica la <xref:System.Collections.Generic.Queue%601>.  
  
 Se tipo `T` è un tipo di riferimento `null` possono essere aggiunti al <xref:System.Collections.Generic.Queue%601> sotto forma di valore.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Queue%601> classe generica, tra cui il <xref:System.Collections.Generic.Queue%601.Peek%2A> (metodo).  
  
 L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La classe <see cref="T:System.Collections.Generic.Queue`1" /> è vuota.</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 La proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.ICollection" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="index">Indice in base zero in <paramref name="array" /> in corrispondenza del quale viene avviata la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.ICollection" /> in <see cref="T:System.Array" /> a partire da un particolare indice <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.ICollection> non può essere eseguire automaticamente il cast al tipo di destinazione `array`, le implementazioni non generica di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, mentre per le implementazioni generiche generano <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  
  
oppure 
 <paramref name="array" /> non ha un'indicizzazione in base zero.  
  
oppure 
Il numero di elementi nell'oggetto <see cref="T:System.Collections.ICollection" /> di origine è maggiore dello spazio disponibile tra <paramref name="index" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.  
  
oppure 
Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Collections.ICollection" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.Queue`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso a <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano questo oggetto prima di accedere alla raccolta.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.Queue`1" />, questa proprietà restituisce sempre l'istanza corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso a <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano questo oggetto prima di accedere alla raccolta. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As IColletion = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>. 
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="queue.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia gli elementi di <see cref="T:System.Collections.Generic.Queue`1" /> in una nuova matrice.</summary>
        <returns>Nuova matrice contenente gli elementi copiati dalla <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.Queue%601> non viene modificato. L'ordine degli elementi nella nuova matrice è lo stesso l'ordine degli elementi dall'inizio del <xref:System.Collections.Generic.Queue%601> alla fine.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Queue%601> classe generica, tra cui il <xref:System.Collections.Generic.Queue%601.ToArray%2A> (metodo).  
  
 L'esempio di codice crea una coda di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Queue%601.Enqueue%2A> metodo per accodare cinque stringhe. Vengono enumerati gli elementi della coda, che non cambia lo stato della coda. Il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per la prima stringa di rimozione dalla coda. Il <xref:System.Collections.Generic.Queue%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nella coda e quindi il <xref:System.Collections.Generic.Queue%601.Dequeue%2A> metodo viene utilizzato per rimuoverlo dalla coda.  
  
 Il <xref:System.Collections.Generic.Queue%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi della coda a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia della coda. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione della coda viene creata una matrice e il <xref:System.Collections.Generic.Queue%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Queue%601.%23ctor%2A> costruttore viene utilizzato per creare una seconda copia della coda che contiene tre elementi null all'inizio.  
  
 Il <xref:System.Collections.Generic.Queue%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è nella prima copia della coda, dopo il quale il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Queue%601.Count%2A> proprietà indica che la coda è vuota.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="queue.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta la capacità sul numero effettivo di elementi contenuti nell'oggetto <see cref="T:System.Collections.Generic.Queue`1" />, se questo numero è inferiore al 90 per cento della capacità corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una raccolta se nessun nuovo elemento verrà aggiunto alla raccolta. Il costo di riallocazione e copia una grande <xref:System.Collections.Generic.Queue%601> può essere notevole, tuttavia, in modo che il <xref:System.Collections.Generic.Queue%601.TrimExcess%2A> metodo non esegue alcuna operazione se l'elenco è in più del 90% della capacità. Questo evita di dover sostenere un costo elevato riallocazione a ottenere un miglioramento relativamente piccolo.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
 Per reimpostare un <xref:System.Collections.Generic.Queue%601> allo stato iniziale, chiamare il <xref:System.Collections.Generic.Queue%601.Clear%2A> metodo prima di chiamare <xref:System.Collections.Generic.Queue%601.TrimExcess%2A> (metodo). Trimming di un oggetto vuoto <xref:System.Collections.Generic.Queue%601> imposta la capacità del <xref:System.Collections.Generic.Queue%601> alla capacità predefinita.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Queue`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="public bool TryDequeue (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryDequeue([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryDequeue(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryDequeue (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryDequeue([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryDequeue :  -&gt; bool" Usage="queue.TryDequeue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPeek :  -&gt; bool" Usage="queue.TryPeek result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>