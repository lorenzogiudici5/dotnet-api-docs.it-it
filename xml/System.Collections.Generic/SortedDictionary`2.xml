<Type Name="SortedDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="568cfbb1cf4b44b712f54c6c14175646755981ed" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36645715" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SortedDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedDictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.SortedDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class SortedDictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedDictionary&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_DictionaryDebugView`2))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Tipo di chiavi nel dizionario.</typeparam>
    <typeparam name="TValue">Tipo di valori nel dizionario.</typeparam>
    <summary>Rappresenta una raccolta di coppie chiave/valore ordinate in base alla chiave.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.SortedDictionary%602> classe generica è una struttura ad albero di ricerca binaria con il recupero O (log n), dove n è il numero di elementi nel dizionario. In questo senso, è simile al <xref:System.Collections.Generic.SortedList%602> classe generica. Le due classi hanno modelli a oggetti simili ed entrambi hanno un recupero O (log n). In cui le due classi sono diversi è in uso della memoria e velocità di inserimento e rimozione:  
  
-   <xref:System.Collections.Generic.SortedList%602> Usa meno memoria <xref:System.Collections.Generic.SortedDictionary%602>.  
  
-   <xref:System.Collections.Generic.SortedDictionary%602> include operazioni di inserimento e rimozione più veloci per i dati non ordinati: O (log n) anziché o (n) per <xref:System.Collections.Generic.SortedList%602>.  
  
-   Se l'elenco viene popolato in una sola volta da dati ordinati, <xref:System.Collections.Generic.SortedList%602> è più veloce <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Ogni coppia chiave/valore può essere recuperato come un <xref:System.Collections.Generic.KeyValuePair%602> struttura, o come un <xref:System.Collections.DictionaryEntry> tramite il metodo non generico <xref:System.Collections.IDictionary> interfaccia.  
  
 Le chiavi devono essere non modificabile, purché vengono utilizzati come chiavi di <xref:System.Collections.Generic.SortedDictionary%602>. Ogni chiave in un <xref:System.Collections.Generic.SortedDictionary%602> devono essere univoci. Non può essere una chiave `null`, ma un valore può essere, se il valore di tipo `TValue` è un tipo riferimento.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> richiede un'implementazione di operatore di confronto per eseguire confronti con chiave. È possibile specificare un'implementazione del <xref:System.Collections.Generic.IComparer%601> interfaccia generica con un costruttore che accetta un `comparer` parametro; se non si specifica un'implementazione, il valore predefinito genericcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> viene utilizzato. Se tipo `TKey` implementa la <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia generica, l'operatore di confronto predefinito utilizza tale implementazione.  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) restituisce un oggetto di tipo degli elementi nella raccolta. Poiché ogni elemento del <xref:System.Collections.Generic.SortedDictionary%602> è una coppia chiave/valore, il tipo di elemento non è il tipo della chiave o il tipo del valore. Al contrario, il tipo di elemento è <xref:System.Collections.Generic.KeyValuePair%602>. Il codice seguente illustra la sintassi c#, C++ e Visual Basic.  
  
 [!code-cpp[Generic.Dictionary#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source2.cpp#11)]
 [!code-csharp[Generic.Dictionary#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source2.cs#11)]
 [!code-vb[Generic.Dictionary#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source2.vb#11)]  
  
 Il `foreach` istruzione è un wrapper per l'enumeratore, che consente solo di leggere dalla raccolta, non scrivere.  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.SortedDictionary%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Nell'esempio viene utilizzata la <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà (l'indicizzatore in c#) per recuperare i valori, dimostrando che un <xref:System.Collections.Generic.KeyNotFoundException> viene generata quando una chiave richiesta non è presente e che il valore associato alla chiave è possibile sostituire.  
  
 Nell'esempio viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> un modo più efficiente per recuperare i valori, se un programma deve provare valori di chiave che non sono presenti nel dizionario e viene illustrato come utilizzare il metodo di <xref:System.Collections.Generic.SortedDictionary%602.ContainsKey%2A> metodo per verificare se esiste una chiave prima di chiamare il <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo.  
  
 Nell'esempio viene illustrato come enumerare le chiavi e valori nel dizionario e come enumerare le chiavi e valori da soli utilizzando il <xref:System.Collections.Generic.SortedDictionary%602.Keys%2A> proprietà e il <xref:System.Collections.Generic.SortedDictionary%602.Values%2A> proprietà.  
  
 Infine, nell'esempio viene illustrato il <xref:System.Collections.Generic.SortedDictionary%602.Remove%2A> metodo.  
  
 [!code-csharp[Generic.SortedDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  Oggetto <see cref="T:System.Collections.Generic.SortedDictionary`2" /> può supportare più lettori contemporaneamente, fino a quando la raccolta non viene modificata.  Anche in questo caso, l'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</threadsafe>
    <altmember cref="T:System.Collections.SortedList" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" /> e usa l'implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> predefinita per il tipo di chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedDictionary%602> devono essere univoci in base all'operatore di confronto predefinito.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> richiede un'implementazione di operatore di confronto per eseguire confronti con chiave. Questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia generica, l'operatore di confronto predefinito utilizza tale implementazione. In alternativa, è possibile specificare un'implementazione del <xref:System.Collections.Generic.IComparer%601> interfaccia generica con un costruttore che accetta un `comparer` parametro.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.SortedDictionary%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedDictionary%602> classe.  
  
 [!code-csharp[Generic.SortedDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#2)]
 [!code-vb[Generic.SortedDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary (System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary(System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementazione di <see cref="T:System.Collections.Generic.IComparer`1" /> da usare per confrontare le chiavi oppure <see langword="null" /> per usare l'oggetto <see cref="T:System.Collections.Generic.Comparer`1" /> predefinito per il tipo di chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" /> e usa l'implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> specificata per il confronto delle chiavi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedDictionary%602> devono essere univoci in base all'operatore di confronto specificato.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> richiede un'implementazione di operatore di confronto per eseguire confronti con chiave. Se `comparer` viene `null`, questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia generica, l'operatore di confronto predefinito utilizza tale implementazione.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Collections.Generic.SortedDictionary%602> con un operatore di confronto tra maiuscole e minuscole per le impostazioni cultura correnti. L'esempio aggiunge quattro elementi, alcune con chiavi lettere minuscole e alcuni con chiavi di lettere maiuscole. Nell'esempio vengono quindi tenta di aggiungere un elemento con una chiave che differisce da una chiave esistente solo per i casi, intercetta l'eccezione risulta e visualizza un messaggio di errore. Infine, l'esempio mostra gli elementi di ordinamento tra maiuscole e minuscole.  
  
 [!code-csharp[Generic.SortedDictionary.ctor_IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.ctor_IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; dictionary" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Oggetto <see cref="T:System.Collections.Generic.IDictionary`2" /> i cui elementi sono copiati nel nuovo oggetto <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" /> contenente elementi copiati dalla classe <see cref="T:System.Collections.Generic.IDictionary`2" /> specificata e viene usata l'implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> predefinita per il tipo di chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedDictionary%602> devono essere univoci in base all'impostazione predefinita operatore di confronto, pertanto, ogni chiave nell'origine `dictionary` devono inoltre essere univoci in base all'operatore di confronto predefinito.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> richiede un'implementazione di operatore di confronto per eseguire confronti con chiave. Questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia generica, l'operatore di confronto predefinito utilizza tale implementazione. In alternativa, è possibile specificare un'implementazione del <xref:System.Collections.Generic.IComparer%601> interfaccia generica con un costruttore che accetta un `comparer` parametro.  
  
 Questo costruttore è un'operazione O (`n` registro `n`) operazione, in cui `n` è il numero di elementi in `dictionary`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare <xref:System.Collections.Generic.SortedDictionary%602> per creare una copia ordinata le informazioni contenute in un <xref:System.Collections.Generic.Dictionary%602>, passando il <xref:System.Collections.Generic.Dictionary%602> per il <xref:System.Collections.Generic.SortedDictionary%602.%23ctor%28System.Collections.Generic.IComparer%7B%600%7D%29> costruttore.  
  
 [!code-csharp[Generic.SortedDictionary.ctor_IDic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.ctor_IDic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> contiene una o più chiavi duplicate.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; (dictionary, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Oggetto <see cref="T:System.Collections.Generic.IDictionary`2" /> i cui elementi sono copiati nel nuovo oggetto <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</param>
        <param name="comparer">Implementazione di <see cref="T:System.Collections.Generic.IComparer`1" /> da usare per confrontare le chiavi oppure <see langword="null" /> per usare l'oggetto <see cref="T:System.Collections.Generic.Comparer`1" /> predefinito per il tipo di chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" /> contenente elementi copiati dalla classe <see cref="T:System.Collections.Generic.IDictionary`2" /> specificata e viene usata l'implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> specificata per confrontare le chiavi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.SortedDictionary%602> devono essere univoci in base all'oggetto specificato operatore di confronto, pertanto, ogni chiave nell'origine `dictionary` devono inoltre essere univoci in base all'operatore di confronto specificato.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> richiede un'implementazione di operatore di confronto per eseguire confronti con chiave. Se `comparer` viene `null`, questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia generica, l'operatore di confronto predefinito utilizza tale implementazione.  
  
 Questo costruttore è un'operazione O (`n` registro `n`) operazione, in cui `n` è il numero di elementi in `dictionary`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare <xref:System.Collections.Generic.SortedDictionary%602> per creare una distinzione tra maiuscole e ordinati copia delle informazioni in una distinzione <xref:System.Collections.Generic.Dictionary%602>, passando il <xref:System.Collections.Generic.Dictionary%602> per il <xref:System.Collections.Generic.SortedDictionary%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> costruttore. In questo esempio, gli operatori di confronto tra maiuscole e minuscole sono per le impostazioni cultura correnti.  
  
 [!code-csharp[Generic.SortedDictionary.ctor_IDicIComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDicIComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.ctor_IDicIComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDicIComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> contiene una o più chiavi duplicate.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit&#xA;override this.Add : 'Key * 'Value -&gt; unit" Usage="sortedDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da aggiungere.</param>
        <param name="value">Valore dell'elemento da aggiungere. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Aggiunge un elemento con la chiave e il valore specificati al metodo <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È anche possibile usare il <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave non esiste nel <xref:System.Collections.Generic.SortedDictionary%602>, ad esempio `myCollection["myNonexistentKey"] = myValue` (in Visual Basic `myCollection("myNonexistantKey") = myValue`). Tuttavia, se la chiave specificata esiste già nella <xref:System.Collections.Generic.SortedDictionary%602>, impostando il <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo genera un'eccezione se esiste già un elemento con la chiave specificata.  
  
 Non può essere una chiave `null`, ma un valore può essere, se il valore di tipo `TValue` è un tipo riferimento.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.SortedDictionary%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedDictionary%602> classe.  
  
 [!code-csharp[Generic.SortedDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#2)]
 [!code-vb[Generic.SortedDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Generic.SortedDictionary`2" /> è già presente un elemento con la stessa chiave.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli elementi da <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.SortedDictionary%602.Count%2A> è impostata su 0 e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 Questo metodo è un'operazione o (1), poiché la radice di strutture dati interne semplicemente viene rilasciata per operazione di garbage collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IComparer&lt;'Key&gt;" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'interfaccia <see cref="T:System.Collections.Generic.IComparer`1" /> usata per ordinare gli elementi della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.Generic.IComparer`1" /> utilizzata per ordinare gli elementi della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedDictionary%602> richiede un'implementazione di operatore di confronto per eseguire confronti con chiave. È possibile specificare un'implementazione del <xref:System.Collections.Generic.IComparer%601> interfaccia generica con un costruttore che accetta un `comparer` parametro. In caso contrario, il confronto di uguaglianza generico predefinito, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, viene utilizzato. Se tipo `TKey` implementa la <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia generica, l'operatore di confronto predefinito utilizza tale implementazione.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.SortedDictionary`2.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="sortedDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</param>
        <summary>Determina se <see cref="T:System.Collections.Generic.SortedDictionary`2" /> contiene un elemento con la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.SortedDictionary`2" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione O (log `n`) operazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.ContainsKey%2A> metodo per verificare se esiste una chiave prima di chiamare il <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo. Viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> metodo per recuperare valori che è un modo efficiente per recuperare i valori quando un programma prova spesso chiavi che non sono presenti nel dizionario. Infine, Mostra il modo meno efficiente per verificare se esistono chiavi, tramite il <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà (l'indicizzatore in c#).  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedDictionary%602> classe.  
  
 [!code-csharp[Generic.SortedDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#6)]
 [!code-vb[Generic.SortedDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#5)]
[!code-vb[Generic.SortedDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#5)]  
[!code-csharp[Generic.SortedDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.ContainsValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsValue (value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.ContainsValue : 'Value -&gt; bool" Usage="sortedDictionary.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Valore da individuare in <see cref="T:System.Collections.Generic.SortedDictionary`2" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Determina se la raccolta <see cref="T:System.Collections.Generic.SortedDictionary`2" /> contiene un elemento con il valore specificato.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.SortedDictionary`2" /> contiene un elemento con il valore specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per il tipo di valore `TValue`.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, è proporzionale al tempo medio di esecuzione di <xref:System.Collections.Generic.SortedDictionary%602.Count%2A> proprietà. Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;[] * int -&gt; unit&#xA;override this.CopyTo : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;[] * int -&gt; unit" Usage="sortedDictionary.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale di strutture <see cref="T:System.Collections.Generic.KeyValuePair`2" /> in cui effettuare la copia degli elementi della raccolta <see cref="T:System.Collections.Generic.SortedDictionary`2" /> corrente. La matrice deve avere indice in base zero.</param>
        <param name="index">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.Generic.SortedDictionary`2" /> nella matrice di strutture <see cref="T:System.Collections.Generic.KeyValuePair`2" /> indicata, a partire dall'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.Generic.SortedDictionary%602> non può essere eseguire automaticamente il cast al tipo di destinazione `array`, le implementazioni non generiche di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, mentre le implementazioni generiche generano <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi nell'oggetto <see cref="T:System.Collections.Generic.SortedDictionary`2" /> di origine è maggiore dello spazio disponibile tra <paramref name="index" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value>Numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.SortedDictionary`2/Enumerator&lt;!TKey, !TValue&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As SortedDictionary(Of TKey, TValue).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Enumerator" Usage="sortedDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione di <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.SortedDictionary`2.Enumerator" /> per <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ai fini dell'enumerazione, ogni elemento è un <xref:System.Collections.Generic.KeyValuePair%602> struttura che rappresenta un valore e la relativa chiave.  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Il dizionario viene mantenuto un ordinamento usando una struttura interna. Ogni nuovo elemento è posizionato in corrispondenza della posizione di ordinamento corretto e l'albero viene regolato per mantenere l'ordinamento ogni volta che un elemento viene rimosso. Durante l'enumerazione, viene mantenuto l'ordinamento.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> proprietà non è definita. Pertanto, è necessario chiamare il <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A>.  
  
 Il <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> proprietà restituisce lo stesso elemento finché il <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> metodo viene chiamato. <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> oppure <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (log n), dove n è count.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.SortedDictionary`2.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave del valore da ottenere o impostare.</param>
        <summary>Ottiene o imposta il valore associato alla chiave specificata.</summary>
        <value>Valore associato alla chiave specificata. Se la chiave specificata non viene trovata, un'operazione Get genera un'eccezione <see cref="T:System.Collections.Generic.KeyNotFoundException" />, mentre un'operazione Set crea una nuovo elemento con la chiave specificata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di accedere a un elemento specifico nella raccolta utilizzando la sintassi c# seguente: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
 È anche possibile usare il <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave non esiste nel <xref:System.Collections.Generic.SortedDictionary%602>, ad esempio `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nella <xref:System.Collections.Generic.SortedDictionary%602>, impostando il <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Non può essere una chiave `null`, ma un valore può essere, se il valore di tipo `TValue` è un tipo riferimento.  
  
 Nel linguaggio c# viene utilizzata la parola chiave per definire gli indicizzatori anziché implementare la <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Ottenere il valore di questa proprietà è un'operazione O (log `n`) operazione; anche l'impostazione della proprietà è un'operazione O (log `n`) operazione.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà (l'indicizzatore in c#) per recuperare i valori, dimostrando che un <xref:System.Collections.Generic.KeyNotFoundException> viene generata quando una chiave richiesta non è presente e che il valore associato alla chiave è possibile sostituire.  
  
 Nell'esempio viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> metodo in modo più efficiente per recuperare i valori se un programma deve provare spesso valori di chiave che non sono presenti nel dizionario.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedDictionary%602> classe.  
  
 [!code-csharp[Generic.SortedDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#3)]
 [!code-vb[Generic.SortedDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#5)]
[!code-vb[Generic.SortedDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Durante il recupero della proprietà, la chiave indicata nel parametro <paramref name="key" /> non è stata trovata nella raccolta.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;.KeyCollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedDictionary`2/KeyCollection&lt;!TKey, !TValue&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As SortedDictionary(Of TKey, TValue).KeyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::KeyCollection ^ Keys { System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::KeyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.KeyCollection" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;+KeyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta contenente le chiavi della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value>Raccolta <see cref="T:System.Collections.Generic.SortedDictionary`2.KeyCollection" /> contenente le chiavi della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le chiavi presenti nel <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> vengono ordinati in base al <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> proprietà e sono nello stesso ordine dei valori associati nel <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> restituito dal <xref:System.Collections.Generic.SortedDictionary%602.Values%2A> proprietà.  
  
 L'oggetto restituito <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> non è una copia statica, bensì il <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> non fa riferimento alle chiavi nell'originale <xref:System.Collections.Generic.SortedDictionary%602>. Di conseguenza, le modifiche per il <xref:System.Collections.Generic.SortedDictionary%602> continuano a essere riflessi nel <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection>.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come enumerare le chiavi nel dizionario usando il <xref:System.Collections.Generic.SortedDictionary%602.Keys%2A> proprietà e come enumerare le chiavi e valori nel dizionario.  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito. Vedere <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 [!code-csharp[Generic.SortedDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#9)]
 [!code-vb[Generic.SortedDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.SortedDictionary`2.KeyCollection" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool&#xA;override this.Remove : 'Key -&gt; bool" Usage="sortedDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento con la chiave specificata da <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <returns>
          <see langword="true" /> se l'elemento viene rimosso correttamente; in caso contrario, <see langword="false" />.  Questo metodo restituisce anche <see langword="false" /> se il parametro <paramref name="key" /> non viene trovato nella classe <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Collections.Generic.SortedDictionary%602> non contiene un elemento con la chiave specificata, il <xref:System.Collections.Generic.SortedDictionary%602> non subisce modifiche. Non viene generata alcuna eccezione.  
  
 Questo metodo è un'operazione O (log `n`) operazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere una coppia chiave/valore dal dizionario utilizzando il <xref:System.Collections.Generic.SortedDictionary%602.Remove%2A> metodo.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedDictionary%602> classe.  
  
 [!code-csharp[Generic.SortedDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#10)]
 [!code-vb[Generic.SortedDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.Add(`0,`1)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of TKey) Implements IDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TKey&gt; ^ System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of TValue) Implements IDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TValue&gt; ^ System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale che è la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.ICollection`1" />. La matrice deve avere un'indicizzazione in base zero.</param>
        <param name="index">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia gli elementi dell'interfaccia <see cref="T:System.Collections.Generic.ICollection`1" /> in una matrice, iniziando dall'indice di matrice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.ICollection> non può essere eseguire automaticamente il cast al tipo di destinazione `array`, le implementazioni non generiche di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> generano un <xref:System.InvalidCastException>, mentre le implementazioni generiche generano un <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  -oppure-  <paramref name="array" /> non ha indicizzazione a base zero.  -oppure-  Il numero di elementi nell'insieme di origine <see cref="T:System.Collections.Generic.ICollection`1" /> è maggiore dello spazio disponibile tra <paramref name="index" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.  -oppure-  Non è possibile eseguire automaticamente il cast del tipo dell'insieme <see cref="T:System.Collections.Generic.ICollection`1" /> di origine nel tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.SortedDictionary`2" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, altri thread può modificare la raccolta, che può causare l'enumeratore generare un'eccezione. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23ICollection%23SyncRoot%2A> proprietà restituisce un oggetto che può essere usato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano l'oggetto prima di accedere alla raccolta.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23ICollection%23SyncRoot%2A> proprietà restituisce un oggetto che può essere usato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano l'oggetto prima di accedere alla raccolta. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà per c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Oggetto da usare come chiave dell'elemento da aggiungere.</param>
        <param name="value">Oggetto da usare come valore dell'elemento da aggiungere.</param>
        <summary>Aggiunge un elemento con la chiave e il valore forniti all'interfaccia <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È anche possibile usare il <xref:System.Collections.IDictionary.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel dizionario; ad esempio, `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel dizionario, l'impostazione di <xref:System.Collections.IDictionary.Item%2A> proprietà sovrascrive il valore precedente. Al contrario, il <xref:System.Collections.IDictionary.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come accedere il <xref:System.Collections.Generic.SortedDictionary%602> classe tramite il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia. L'esempio di codice crea un oggetto vuoto <xref:System.Collections.Generic.SortedDictionary%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata o quando viene fornita una chiave o il valore del tipo di dati non corretto.  
  
 L'esempio di codice illustra l'uso di diversi altri membri del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il tipo della chiave indicata nel parametro <paramref name="key" /> non è assegnabile al tipo di chiave <paramref name="TKey" /> dell'insieme <see cref="T:System.Collections.IDictionary" />.  -oppure-  <paramref name="value" /> è un tipo che non è possibile assegnare al tipo di valore <paramref name="TValue" /> dell'oggetto <see cref="T:System.Collections.IDictionary" />.  -oppure-  In <see cref="T:System.Collections.IDictionary" /> è già presente un elemento con la stessa chiave.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.IDictionary" />.</param>
        <summary>Determina se <see cref="T:System.Collections.IDictionary" /> contiene un elemento con la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.IDictionary" /> contiene un elemento con la chiave; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce `false` se `key` è di un tipo che non è assegnabile al tipo di chiave `TKey` del <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Contains%2A> metodo per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedDictionary%602>. Nell'esempio viene illustrato che il metodo restituisce `false` se viene fornita una chiave del tipo di dati non corretto.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.SortedDictionary.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce <see cref="T:System.Collections.IDictionaryEnumerator" /> per <see cref="T:System.Collections.IDictionary" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> per l'oggetto <see cref="T:System.Collections.IDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ai fini dell'enumerazione, ogni elemento è un <xref:System.Collections.DictionaryEntry> struttura.  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Il <xref:System.Collections.IEnumerator.Reset%2A> metodo riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IDictionaryEnumerator.Entry%2A> è indefinita. Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IDictionaryEnumerator.Entry%2A>.  
  
 Il <xref:System.Collections.IDictionaryEnumerator.Entry%2A> proprietà restituisce lo stesso oggetto finché non <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> viene chiamato. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IDictionaryEnumerator.Entry%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IDictionaryEnumerator.Entry%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (log n), dove n è un numero di elementi in una raccolta.
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come enumerare le coppie chiave/valore nel dizionario mediante il `foreach` istruzione (`For Each` in Visual Basic `for each` in C++), che nasconde l'utilizzo dell'enumeratore. In particolare, si noti che l'enumeratore per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia restituisce <xref:System.Collections.DictionaryEntry> oggetti anziché <xref:System.Collections.Generic.KeyValuePair%602> oggetti.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IDictionary" /> ha dimensioni fisse.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IDictionary" /> è di dimensioni fisse; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.SortedDictionary`2" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la sua creazione, ma consente la modifica degli elementi esistenti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IDictionary" /> è di sola lettura.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IDictionary" /> è di sola lettura; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.SortedDictionary`2" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IDictionary.Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da ottenere.</param>
        <summary>Ottiene o imposta l'elemento con la chiave specificata.</summary>
        <value>L'elemento con la chiave specificata, o <see langword="null" /> se <paramref name="key" /> non è presente nel dizionario o se il tipo di <paramref name="key" /> non può essere assegnato al tipo di chiave <paramref name="TKey" /> della classe <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di accedere a un elemento specifico nella raccolta utilizzando la sintassi c# seguente: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
 È anche possibile usare il <xref:System.Collections.IDictionary.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel dizionario; ad esempio, `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel dizionario, l'impostazione di <xref:System.Collections.IDictionary.Item%2A> proprietà sovrascrive il valore precedente. Al contrario, il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo non modifica gli elementi esistenti.  
  
 Nel linguaggio c# viene utilizzata la [ciò](~/docs/csharp/language-reference/keywords/this.md) (parola chiave) per definire gli indicizzatori anziché implementare la <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Ottenere il valore di questa proprietà è un'operazione O (log `n`) operazione; anche l'impostazione della proprietà è un'operazione O (log `n`) operazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A> proprietà (l'indicizzatore in c#) del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedDictionary%602>e la proprietà le differenze tra la <xref:System.Collections.Generic.SortedDictionary%602.Item%2A?displayProperty=nameWithType> proprietà.  
  
 L'esempio mostra che, come le <xref:System.Collections.Generic.SortedDictionary%602.Item%2A?displayProperty=nameWithType> proprietà, il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> proprietà possibile modificare il valore associato a una chiave esistente e può essere utilizzata per aggiungere una nuova coppia chiave/valore se la chiave specificata non è presente nel dizionario. L'esempio mostra anche che a differenza di <xref:System.Collections.Generic.SortedDictionary%602.Item%2A?displayProperty=nameWithType> proprietà, il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> proprietà non genera un'eccezione se `key` non è presente nel dizionario, bensì restituisce un riferimento null. Infine, nell'esempio viene illustrato che quando si ottiene il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> proprietà restituisce un riferimento null se `key` non è il tipo di dati corretto e che l'impostazione della proprietà genera un'eccezione se `key` non corrisponde al tipo di dati corretto.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.SortedDictionary.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Viene assegnato un valore e il tipo di <paramref name="key" /> non può essere assegnato al tipo di chiave <paramref name="TKey" /> della classe<see cref="T:System.Collections.Generic.SortedDictionary`2" />.  -oppure-  Viene assegnato un valore e il tipo di <paramref name="value" /> non può essere assegnato al tipo di valore <paramref name="TValue" /> di <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.ICollection" /> contenente le chiavi di <see cref="T:System.Collections.IDictionary" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.ICollection" /> contenente le chiavi dell'interfaccia <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le chiavi nell'oggetto restituito <xref:System.Collections.ICollection> vengono ordinati in base al <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> proprietà e sono sicuramente nello stesso ordine dei valori corrispondenti nel <xref:System.Collections.ICollection> restituito dal <xref:System.Collections.IDictionary.Values%2A> proprietà.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.IDictionary.Keys%2A> proprietà del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedDictionary%602>, per elencare le chiavi nel dizionario. Nell'esempio viene inoltre illustrato come enumerare le coppie chiave/valore nel dizionario; Si noti che l'enumeratore per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia restituisce <xref:System.Collections.DictionaryEntry> oggetti anziché <xref:System.Collections.Generic.KeyValuePair%602> oggetti.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.SortedDictionary.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento con la chiave specificata da <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione O (log `n`) operazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Remove%2A> del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.SortedDictionary.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.ICollection" /> contenente i valori in <see cref="T:System.Collections.IDictionary" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.ICollection" /> contenente i valori dell'interfaccia <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori nell'oggetto restituito <xref:System.Collections.ICollection> vengono ordinati in base al <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> proprietà e sono sicuramente nello stesso ordine delle chiavi corrispondenti nel <xref:System.Collections.ICollection> restituito dal <xref:System.Collections.IDictionary.Keys%2A> proprietà.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Values%2A> proprietà del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.SortedDictionary%602>, per elencare i valori nel dizionario. Nell'esempio viene inoltre illustrato come enumerare le coppie chiave/valore nel dizionario; Si noti che l'enumeratore per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia restituisce <xref:System.Collections.DictionaryEntry> oggetti anziché <xref:System.Collections.Generic.KeyValuePair%602> oggetti.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.SortedDictionary.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la <xref:System.Collections.IEnumerator.Current%2A> proprietà non è definita. Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Il <xref:System.Collections.IEnumerator.Current%2A> proprietà restituisce lo stesso elemento finché il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo viene chiamato. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (log n), dove n è un numero di elementi in una raccolta.
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.GetEnumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="sortedDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Chiave del valore da ottenere.</param>
        <param name="value">Quando il metodo termina, se la chiave specificata viene trovata, viene restituito il valore associato alla chiave; in caso contrario viene restituito il valore predefinito per il tipo del parametro <c>value</c>.</param>
        <summary>Ottiene il valore associato alla chiave specificata.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.SortedDictionary`2" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo combina la funzionalità del <xref:System.Collections.Generic.SortedDictionary%602.ContainsKey%2A> metodo e il <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà.  
  
 Se la chiave non viene trovata, il `value` parametro ottiene il valore predefinito appropriato per il tipo di valore `TValue`, ad esempio, 0 (zero) per i tipi integer, `false` per i tipi Boolean e `null` per i tipi di riferimento.  
  
 Questo metodo è un'operazione O (log `n`) operazione.  
  
   
  
## Examples  
 Nell'esempio viene illustrato come utilizzare il <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> metodo in modo più efficiente per recuperare i valori in un programma che prova spesso chiavi che non sono presenti nel dizionario. Per contrasto, nell'esempio viene inoltre illustrato il modo in cui <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> proprietà (l'indicizzatore in c#) genera eccezioni durante il tentativo di recupero chiavi inesistenti.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedDictionary%602> classe.  
  
 [!code-csharp[Generic.SortedDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#5)]
 [!code-vb[Generic.SortedDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#5)]  
[!code-csharp[Generic.SortedDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;.ValueCollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedDictionary`2/ValueCollection&lt;!TKey, !TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As SortedDictionary(Of TKey, TValue).ValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::ValueCollection ^ Values { System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::ValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.ValueCollection" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;+ValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta contenente i valori di <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value>Raccolta <see cref="T:System.Collections.Generic.SortedDictionary`2.ValueCollection" /> contenente i valori di <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori nel <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> vengono ordinati in base al <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> proprietà e sono nello stesso ordine delle chiavi associate nel <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> restituito dal <xref:System.Collections.Generic.SortedDictionary%602.Keys%2A> proprietà.  
  
 L'oggetto restituito <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> non è una copia statica, bensì il <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> non fa riferimento ai valori nell'originale <xref:System.Collections.Generic.SortedDictionary%602>. Di conseguenza, le modifiche per il <xref:System.Collections.Generic.SortedDictionary%602> continuano a essere riflessi nel <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection>.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
   
  
## Examples  
 Questo esempio di codice viene illustrato come enumerare i valori nel dizionario usando il <xref:System.Collections.Generic.SortedDictionary%602.Values%2A> proprietà e come enumerare le chiavi e valori nel dizionario.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.SortedDictionary%602> classe.  
  
 [!code-csharp[Generic.SortedDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#8)]
 [!code-vb[Generic.SortedDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.SortedDictionary`2.ValueCollection" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>