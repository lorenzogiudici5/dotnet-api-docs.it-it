<Type Name="Stack&lt;T&gt;" FullName="System.Collections.Generic.Stack&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3974e97e893db48f241a47a19c02bfa795c7a260" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52353700" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Stack&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Stack`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Stack : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Stack&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_StackDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Specifica il tipo di elementi nello stack.</typeparam>
    <summary>Rappresenta una raccolta di istanze LIFO (last-in-first-out) a dimensione variabile dello stesso tipo specificato.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> viene implementato sotto forma di matrice.  
  
 Gli stack e code sono utili quando necessaria l'archiviazione temporanea per le informazioni; vale a dire, quando si potrebbe desiderare di eliminare un elemento dopo il recupero il relativo valore. Usare <xref:System.Collections.Generic.Queue%601> se è necessario accedere alle informazioni nello stesso ordine in cui sono archiviate nell'insieme. Usare <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> se è necessario accedere alle informazioni in ordine inverso.  
  
 Usare la <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> e <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> tipi quando è necessario accedere alla raccolta da più thread contemporaneamente.  
  
 In genere <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> consiste nel mantenere gli stati delle variabili durante le chiamate alle altre procedure.  
  
 Principale e tre le operazioni eseguibili su un <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> e i relativi elementi:  
  
-   <xref:System.Collections.Generic.Stack%601.Push%2A> Inserisce un elemento in cima il <xref:System.Collections.Stack>.  
  
-   <xref:System.Collections.Generic.Stack%601.Pop%2A> Rimuove un elemento dalla parte superiore del <xref:System.Collections.Generic.Stack%601>.  
  
-   <xref:System.Collections.Generic.Stack%601.Peek%2A> Restituisce un elemento che corrisponde all'inizio del <xref:System.Collections.Generic.Stack%601> ma non lo rimuove dal <xref:System.Collections.Generic.Stack%601>.  
  
 La capacità di un <xref:System.Collections.Generic.Stack%601> è il numero di elementi di <xref:System.Collections.Generic.Stack%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Stack%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna. La capacità può essere ridotto mediante una chiamata <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Se <xref:System.Collections.Generic.Stack%601.Count%2A> è minore rispetto alla capacità dello stack, <xref:System.Collections.Generic.Stack%601.Push%2A> è un'operazione o (1). Se la capacità deve essere incrementata per far posto al nuovo elemento, <xref:System.Collections.Generic.Stack%601.Push%2A> diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Stack%601.Count%2A>. <xref:System.Collections.Generic.Stack%601.Pop%2A> è un'operazione o (1).  
  
 <xref:System.Collections.Generic.Stack%601> accetta `null` come tipi di un valore valido per riferimento e consente gli elementi duplicati.  
  
   
  
## Examples  
 Esempio di codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Stack%601> classe generica. L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  
  
Oggetto <see cref="T:System.Collections.Generic.Stack`1" /> può supportare più lettori contemporaneamente, fino a quando non viene modificata la raccolta.  Anche in questo caso, l'enumerazione di una raccolta di per sé non è una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteratori (C# e Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Stack`1" /> vuota e con capacità iniziale predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Stack%601> è il numero di elementi che il <xref:System.Collections.Generic.Stack%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Stack%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna.  
  
 Se le dimensioni della raccolta possono essere stimata, che specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.Stack%601>.  
  
 La capacità può essere ridotto mediante una chiamata <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra questo costruttore e diversi metodi del <xref:System.Collections.Generic.Stack%601> classe generica.  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Raccolta da cui copiare gli elementi.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Stack`1" /> che contiene gli elementi copiati dalla raccolta specificata e ha la capacità sufficiente per contenere il numero di elementi copiati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Stack%601> è il numero di elementi che il <xref:System.Collections.Generic.Stack%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Stack%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna.  
  
 Se le dimensioni della raccolta possono essere stimata, che specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.Stack%601>.  
  
 La capacità può essere ridotto mediante una chiamata <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Gli elementi vengono copiati nel <xref:System.Collections.Generic.Stack%601> nello stesso ordine in cui vengono letti dal <xref:System.Collections.Generic.IEnumerator%601> della raccolta.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `collection`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra questo costruttore e diversi metodi del <xref:System.Collections.Generic.Stack%601> classe generica.  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : int -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero iniziale degli elementi che <see cref="T:System.Collections.Generic.Stack`1" /> può contenere.</param>
        <summary>Consente l'inizializzazione di una nuova istanza della classe <see cref="T:System.Collections.Generic.Stack`1" />, che è vuota e ha la capacità iniziale maggiore tra quella specificata e quella predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Stack%601> è il numero di elementi che il <xref:System.Collections.Generic.Stack%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Stack%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna.  
  
 Se le dimensioni della raccolta possono essere stimata, che specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.Stack%601>.  
  
 La capacità può essere ridotto mediante una chiamata <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="stack.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli oggetti da <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 La capacità rimane invariata. Per reimpostare la capacità dei <xref:System.Collections.Generic.Stack%601>, chiamare <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>. Trimming di un oggetto vuoto <xref:System.Collections.Generic.Stack%601> imposta la capacità del <xref:System.Collections.Generic.Stack%601> alla capacità predefinita.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Stack%601> classe generica, tra cui il <xref:System.Collections.Generic.Stack%601.Clear%2A> (metodo).  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="member this.Contains : 'T -&gt; bool" Usage="stack.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.Stack`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Determina se un elemento è incluso in <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> è presente in <see cref="T:System.Collections.Generic.Stack`1" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Stack%601> classe generica, tra cui il <xref:System.Collections.Generic.Stack%601.Contains%2A> (metodo).  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="stack.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.Stack`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <paramref name="array" /> in corrispondenza del quale viene avviata la copia.</param>
        <summary>Consente di copiare lo <see cref="T:System.Collections.Generic.Stack`1" /> in una <see cref="T:System.Array" /> unidimensionale esistente, partendo dall'indice della matrice specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono copiati nella matrice in last-in-first-out (LIFO) ordine, analogamente agli elementi restituiti da una sequenza di chiamate a <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Stack%601> classe generica, tra cui il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> (metodo).  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi nell'oggetto <see cref="T:System.Collections.Generic.Stack`1" /> di origine è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Stack&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di elementi contenuti in <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <value>Il numero di elementi contenuti in <see cref="T:System.Collections.Generic.Stack`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità dei <xref:System.Collections.Generic.Stack%601> è il numero di elementi che il <xref:System.Collections.Generic.Stack%601> può archiviare. <xref:System.Collections.Generic.Stack%601.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.Stack%601>.  
  
 La capacità è sempre maggiore di o uguale a <xref:System.Collections.Generic.Stack%601.Count%2A>. Se <xref:System.Collections.Generic.Stack%601.Count%2A> supera la capacità durante l'aggiunta di elementi, la capacità viene incrementata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiungere i nuovi elementi.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra molte proprietà e metodi del <xref:System.Collections.Generic.Stack%601> classe generica, tra cui il <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà.  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Stack&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Stack`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Stack(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Stack&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Stack&lt;'T&gt;.Enumerator" Usage="stack.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Stack&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore per l'insieme <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Stack`1.Enumerator" /> per l'oggetto <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A>.  
  
 La proprietà <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A>. <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> oppure <xref:System.Collections.Generic.Stack%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene dimostrato che la <xref:System.Collections.Generic.Stack%601> la classe generica. Il `foreach` istruzione (`For Each` in Visual Basic `for each` in C++) viene usato per enumerare la coda.  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Stack`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; 'T" Usage="stack.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Viene restituito l'oggetto all'inizio dello <see cref="T:System.Collections.Generic.Stack`1" /> senza rimuoverlo.</summary>
        <returns>Oggetto all'inizio dell'oggetto <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è analogo al metodo <xref:System.Collections.Generic.Stack%601.Pop%2A>, ma <xref:System.Collections.Generic.Stack%601.Peek%2A> non modifica la <xref:System.Collections.Generic.Stack%601>.  
  
 Se tipo `T` è un tipo di riferimento `null` può essere inserito il <xref:System.Collections.Generic.Stack%601> come segnaposto, se necessario.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Stack%601> classe generica, tra cui il <xref:System.Collections.Generic.Stack%601.Peek%2A> (metodo).  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La classe <see cref="T:System.Collections.Generic.Stack`1" /> è vuota.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public T Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Function Pop () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Pop();" />
      <MemberSignature Language="F#" Value="member this.Pop : unit -&gt; 'T" Usage="stack.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove e restituisce l'oggetto all'inizio dell'oggetto <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Oggetto rimosso dall'inizio dell'oggetto <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è analogo al metodo <xref:System.Collections.Generic.Stack%601.Peek%2A>, ma <xref:System.Collections.Generic.Stack%601.Peek%2A> non modifica la <xref:System.Collections.Generic.Stack%601>.  
  
 Se tipo `T` è un tipo di riferimento `null` può essere inserito il <xref:System.Collections.Generic.Stack%601> come segnaposto, se necessario.  
  
 <xref:System.Collections.Generic.Stack%601> viene implementato sotto forma di matrice. Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Stack%601> classe generica, tra cui il <xref:System.Collections.Generic.Stack%601.Pop%2A> (metodo).  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La classe <see cref="T:System.Collections.Generic.Stack`1" /> è vuota.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Push(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Push (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Push(T item);" />
      <MemberSignature Language="F#" Value="member this.Push : 'T -&gt; unit" Usage="stack.Push item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto di cui effettuare il push in <see cref="T:System.Collections.Generic.Stack`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Inserisce un oggetto all'inizio della classe <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> viene implementato sotto forma di matrice.  
  
 Se <xref:System.Collections.Generic.Stack%601.Count%2A> già pari alla capacità, la capacità del <xref:System.Collections.Generic.Stack%601> viene incrementato automaticamente la riallocazione della matrice interna, e vengono copiati gli elementi esistenti nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Se tipo `T` è un tipo di riferimento `null` può essere inserito il <xref:System.Collections.Generic.Stack%601> come segnaposto, se necessario. Occupa uno slot nello stack e viene considerato come qualsiasi altro oggetto.  
  
 Se <xref:System.Collections.Generic.Stack%601.Count%2A> è minore rispetto alla capacità dello stack, <xref:System.Collections.Generic.Stack%601.Push%2A> è un'operazione o (1). Se la capacità deve essere incrementata per far posto al nuovo elemento, <xref:System.Collections.Generic.Stack%601.Push%2A> diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Stack%601> classe generica, tra cui il <xref:System.Collections.Generic.Stack%601.Push%2A> (metodo).  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 La proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.ICollection" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <paramref name="array" /> in corrispondenza del quale viene avviata la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.ICollection" /> in <see cref="T:System.Array" /> a partire da un particolare indice <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.ICollection> non può essere eseguire automaticamente il cast al tipo di destinazione `array`, le implementazioni non generica di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, mentre per le implementazioni generiche generano <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  
  
oppure 
 <paramref name="array" /> non ha un'indicizzazione in base zero.  
  
oppure 
Il numero di elementi nell'oggetto <see cref="T:System.Collections.ICollection" /> di origine è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.  
  
oppure 
Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Collections.ICollection" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.Stack`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Nel raro caso in cui le enumerazioni competono accesso in scrittura, è necessario bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano questo oggetto prima di accedere alla raccolta.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.Stack`1" />, questa proprietà restituisce sempre l'istanza corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano questo oggetto prima di accedere alla raccolta. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzati.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="stack.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente di copiare lo <see cref="T:System.Collections.Generic.Stack`1" /> in una nuova matrice.</summary>
        <returns>Nuova matrice contenente le copie degli elementi dello <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono copiati nella matrice in last-in-first-out (LIFO) ordine, analogamente agli elementi restituiti da una sequenza di chiamate a <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Il codice seguente illustra vari metodi per il <xref:System.Collections.Generic.Stack%601> classe generica, tra cui il <xref:System.Collections.Generic.Stack%601.ToArray%2A> (metodo).  
  
 L'esempio di codice crea uno stack di stringhe con capacità predefinita e Usa il <xref:System.Collections.Generic.Stack%601.Push%2A> metodo per effettuare il push cinque stringhe nello stack. Vengono enumerati gli elementi dello stack, che non cambia lo stato dello stack. Il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarre la prima stringa dallo stack. Il <xref:System.Collections.Generic.Stack%601.Peek%2A> metodo viene utilizzato per esaminare l'elemento successivo nello stack e quindi il <xref:System.Collections.Generic.Stack%601.Pop%2A> metodo viene utilizzato per estrarlo.  
  
 Il <xref:System.Collections.Generic.Stack%601.ToArray%2A> metodo viene utilizzato per creare una matrice e copia gli elementi dello stack a esso, quindi la matrice viene passata per la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore che accetta <xref:System.Collections.Generic.IEnumerable%601>, creando una copia dello stack con l'ordine degli elementi invertiti. Vengono visualizzati gli elementi della copia.  
  
 Due volte la dimensione dello stack viene creata una matrice e il <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metodo viene usato per copiare gli elementi della matrice a partire dal centro della matrice. Il <xref:System.Collections.Generic.Stack%601.%23ctor%2A> costruttore viene utilizzato per creare una copia dello stack con l'ordine degli elementi invertito; di conseguenza, i tre elementi null sono alla fine.  
  
 Il <xref:System.Collections.Generic.Stack%601.Contains%2A> metodo viene utilizzato per indicare che la stringa "4" è la prima copia dello stack, dopo che il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo cancella la copia e <xref:System.Collections.Generic.Stack%601.Count%2A> proprietà indica che lo stack è vuoto.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="stack.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta la capacità sul numero effettivo di elementi contenuti nell'oggetto <see cref="T:System.Collections.Generic.Stack`1" />, se questo numero è inferiore al 90 per cento della capacità corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una raccolta se nessun nuovo elemento verrà aggiunto alla raccolta. Il costo di riallocazione e copia una grande <xref:System.Collections.Generic.Stack%601> può essere notevole, tuttavia, in modo che il <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> metodo non esegue alcuna operazione se l'elenco è in più del 90% della capacità. Questo evita di dover sostenere un costo elevato riallocazione a ottenere un miglioramento relativamente piccolo.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 Per reimpostare un <xref:System.Collections.Generic.Stack%601> allo stato iniziale, chiamare il <xref:System.Collections.Generic.Stack%601.Clear%2A> metodo prima di chiamare <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> (metodo). Trimming di un oggetto vuoto <xref:System.Collections.Generic.Stack%601> imposta la capacità del <xref:System.Collections.Generic.Stack%601> alla capacità predefinita.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Stack`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPeek :  -&gt; bool" Usage="stack.TryPeek result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPop(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPop (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPop([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPop :  -&gt; bool" Usage="stack.TryPop result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>