<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bd60a2feb07a08a4c2ff30ce143f1e02c4125256" />
    <Meta Name="ms.sourcegitcommit" Value="850a55c780d5a95b534467969add0232fd3a6125" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/07/2018" />
    <Meta Name="ms.locfileid" Value="34829128" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">
      <span data-ttu-id="11f1d-101">Tipo di elementi contenuti nel set di hash.</span>
      <span class="sxs-lookup">
        <span data-stu-id="11f1d-101">The type of elements in the hash set.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="11f1d-102">Rappresenta un insieme di valori.</span>
      <span class="sxs-lookup">
        <span data-stu-id="11f1d-102">Represents a set of values.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-103">La <xref:System.Collections.Generic.HashSet%601> classe fornisce operazioni ad alte prestazioni.</span><span class="sxs-lookup"><span data-stu-id="11f1d-103">The <xref:System.Collections.Generic.HashSet%601> class provides high-performance set operations.</span></span> <span data-ttu-id="11f1d-104">Un set è una raccolta che contiene elementi duplicati, e i cui elementi sono in nessun ordine particolare.</span><span class="sxs-lookup"><span data-stu-id="11f1d-104">A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="11f1d-105"><xref:System.Collections.Generic.HashSet%601> implementa il <xref:System.Collections.Generic.IReadOnlyCollection%601> a partire da interfaccia di [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; nelle versioni precedenti di .NET Framework, il <xref:System.Collections.Generic.HashSet%601> non ha implementato questa interfaccia.</span><span class="sxs-lookup"><span data-stu-id="11f1d-105"><xref:System.Collections.Generic.HashSet%601> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Generic.HashSet%601> class did not implement this interface.</span></span>  
  
 <span data-ttu-id="11f1d-106">La capacità di un <xref:System.Collections.Generic.HashSet%601> oggetto è il numero di elementi che è possibile inserire l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-106">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="11f1d-107">Oggetto <xref:System.Collections.Generic.HashSet%601> la capacità dell'oggetto aumentano automaticamente man mano gli elementi vengono aggiunti all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-107">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="11f1d-108">Il <xref:System.Collections.Generic.HashSet%601> classe è basata sul modello di insiemi matematici e fornisce ad alte prestazioni operazioni simili per le chiavi di accesso di <xref:System.Collections.Generic.Dictionary%602> o <xref:System.Collections.Hashtable> raccolte.</span><span class="sxs-lookup"><span data-stu-id="11f1d-108">The <xref:System.Collections.Generic.HashSet%601> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <xref:System.Collections.Generic.Dictionary%602> or <xref:System.Collections.Hashtable> collections.</span></span> <span data-ttu-id="11f1d-109">In altre parole, il <xref:System.Collections.Generic.HashSet%601> classe può essere considerata come un <xref:System.Collections.Generic.Dictionary%602> raccolta senza valori.</span><span class="sxs-lookup"><span data-stu-id="11f1d-109">In simple terms, the <xref:System.Collections.Generic.HashSet%601> class can be thought of as a <xref:System.Collections.Generic.Dictionary%602> collection without values.</span></span>  
  
 <span data-ttu-id="11f1d-110">Oggetto <xref:System.Collections.Generic.HashSet%601> raccolta non è ordinata e non può contenere elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="11f1d-110">A <xref:System.Collections.Generic.HashSet%601> collection is not sorted and cannot contain duplicate elements.</span></span> <span data-ttu-id="11f1d-111">Se la duplicazione di ordine o elemento è più importante delle prestazioni dell'applicazione, è consigliabile utilizzare il <xref:System.Collections.Generic.List%601> classe con il <xref:System.Collections.Generic.List%601.Sort%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-111">If order or element duplication is more important than performance for your application, consider using the <xref:System.Collections.Generic.List%601> class together with the <xref:System.Collections.Generic.List%601.Sort%2A> method.</span></span>  
  
 <span data-ttu-id="11f1d-112"><xref:System.Collections.Generic.HashSet%601> fornisce molti matematiche impostare operazioni, ad esempio addizione set (unioni) e sottrazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-112"><xref:System.Collections.Generic.HashSet%601> provides many mathematical set operations, such as set addition (unions) and set subtraction.</span></span> <span data-ttu-id="11f1d-113">Nella tabella seguente vengono forniti <xref:System.Collections.Generic.HashSet%601> operazioni e i relativi equivalenti matematici.</span><span class="sxs-lookup"><span data-stu-id="11f1d-113">The following table lists the provided <xref:System.Collections.Generic.HashSet%601> operations and their mathematical equivalents.</span></span>  
  
|<span data-ttu-id="11f1d-114">Operazione HashSet (Of T)</span><span class="sxs-lookup"><span data-stu-id="11f1d-114">HashSet(Of T) operation</span></span>|<span data-ttu-id="11f1d-115">Equivalente matematico</span><span class="sxs-lookup"><span data-stu-id="11f1d-115">Mathematical equivalent</span></span>|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<span data-ttu-id="11f1d-116">Aggiunta di unione o impostato</span><span class="sxs-lookup"><span data-stu-id="11f1d-116">Union or set addition</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<span data-ttu-id="11f1d-117">intersezione</span><span class="sxs-lookup"><span data-stu-id="11f1d-117">Intersection</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<span data-ttu-id="11f1d-118">Set di sottrazione</span><span class="sxs-lookup"><span data-stu-id="11f1d-118">Set subtraction</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="11f1d-119">Differenza simmetrica</span><span class="sxs-lookup"><span data-stu-id="11f1d-119">Symmetric difference</span></span>|  
  
 <span data-ttu-id="11f1d-120">Oltre alle operazioni set elencate, il <xref:System.Collections.Generic.HashSet%601> classe fornisce anche metodi per determinare l'uguaglianza, la sovrapposizione di set, e se un set è un subset o superset di un altro set.</span><span class="sxs-lookup"><span data-stu-id="11f1d-120">In addition to the listed set operations, the <xref:System.Collections.Generic.HashSet%601> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</span></span>  
  
 <span data-ttu-id="11f1d-121">Per grandi <xref:System.Collections.Generic.HashSet%601> oggetti, è possibile aumentare la capacità massima a 2 miliardi di elementi in un sistema a 64 bit impostando il `enabled` attributo dell'elemento di configurazione per `true` nell'ambiente di runtime.</span><span class="sxs-lookup"><span data-stu-id="11f1d-121">For very large <xref:System.Collections.Generic.HashSet%601> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the `enabled` attribute of the  configuration element to `true` in the run-time environment.</span></span>  
  
 <span data-ttu-id="11f1d-122">A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Collections.Generic.HashSet%601> classe implementa il <xref:System.Collections.Generic.ISet%601> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="11f1d-122">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Collections.Generic.HashSet%601> class implements the <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
## <a name="hashset-and-linq-set-operations"></a><span data-ttu-id="11f1d-123">Operazioni HashSet e sui set LINQ</span><span class="sxs-lookup"><span data-stu-id="11f1d-123">HashSet and LINQ Set Operations</span></span>  
 <span data-ttu-id="11f1d-124">LINQ fornisce l'accesso per il `Distinct`, `Union`, `Intersect` e `Except` impostate le operazioni in qualsiasi origine dati che implementa il <xref:System.Collections.IEnumerable> o <xref:System.Linq.IQueryable> interfacce.</span><span class="sxs-lookup"><span data-stu-id="11f1d-124">LINQ provides access to the `Distinct`, `Union`, `Intersect` and `Except` set operations on any data source that implements the <xref:System.Collections.IEnumerable> or <xref:System.Linq.IQueryable> interfaces.</span></span>  <span data-ttu-id="11f1d-125"><xref:System.Collections.Generic.HashSet%601> fornisce una raccolta di dimensioni maggiore e più affidabile di operazioni sui set.</span><span class="sxs-lookup"><span data-stu-id="11f1d-125"><xref:System.Collections.Generic.HashSet%601> provides a larger and more robust collection of set operations.</span></span> <span data-ttu-id="11f1d-126">Ad esempio, <xref:System.Collections.Generic.HashSet%601> fornisce i confronti, ad esempio <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> e <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-126">For example, <xref:System.Collections.Generic.HashSet%601> provides comparisons such as <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> and <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span></span>  
  
 <span data-ttu-id="11f1d-127">La differenza principale tra LINQ operazioni sui set e <xref:System.Collections.Generic.HashSet%601> operazioni è che le operazioni set LINQ restituiscono sempre un nuovo <xref:System.Collections.Generic.IEnumerable%601> insieme, mentre il <xref:System.Collections.Generic.HashSet%601> metodi equivalenti modificano la raccolta corrente.</span><span class="sxs-lookup"><span data-stu-id="11f1d-127">The primary difference between LINQ set operations and <xref:System.Collections.Generic.HashSet%601> operations is that LINQ set operations always return a new <xref:System.Collections.Generic.IEnumerable%601> collection, whereas the <xref:System.Collections.Generic.HashSet%601> equivalent methods modify the current collection.</span></span>  
  
 <span data-ttu-id="11f1d-128">In genere, se è necessario creare un nuovo set o se l'applicazione deve accedere solo alle operazioni del set specificato, utilizzare set LINQ operazioni su una qualsiasi <xref:System.Collections.Generic.IEnumerable%601> raccolta o una matrice saranno sufficienti.</span><span class="sxs-lookup"><span data-stu-id="11f1d-128">Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <xref:System.Collections.Generic.IEnumerable%601> collection or array will be sufficient.</span></span> <span data-ttu-id="11f1d-129">Tuttavia, se l'applicazione richiede l'accesso alle operazioni di impostazione aggiuntiva o non è preferibile o necessario creare una nuova raccolta, usare la <xref:System.Collections.Generic.HashSet%601> classe.</span><span class="sxs-lookup"><span data-stu-id="11f1d-129">However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <xref:System.Collections.Generic.HashSet%601> class.</span></span>  
  
 <span data-ttu-id="11f1d-130">La tabella seguente mostra il <xref:System.Collections.Generic.HashSet%601> operazioni e i relativi equivalenti sui set LINQ.</span><span class="sxs-lookup"><span data-stu-id="11f1d-130">The following table shows the <xref:System.Collections.Generic.HashSet%601> operations and their equivalent LINQ set operations.</span></span>  
  
|<span data-ttu-id="11f1d-131">Operazione HashSet (Of T)</span><span class="sxs-lookup"><span data-stu-id="11f1d-131">HashSet(Of T) operation</span></span>|<span data-ttu-id="11f1d-132">Equivalente LINQ</span><span class="sxs-lookup"><span data-stu-id="11f1d-132">LINQ equivalent</span></span>|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|<span data-ttu-id="11f1d-133">Non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="11f1d-133">Not provided.</span></span>|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="11f1d-134">Non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="11f1d-134">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|<span data-ttu-id="11f1d-135">Non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="11f1d-135">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|<span data-ttu-id="11f1d-136">Non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="11f1d-136">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|<span data-ttu-id="11f1d-137">Non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="11f1d-137">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|<span data-ttu-id="11f1d-138">Non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="11f1d-138">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|<span data-ttu-id="11f1d-139">Non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="11f1d-139">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|<span data-ttu-id="11f1d-140">Non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="11f1d-140">Not provided.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-141">Nell'esempio seguente viene illustrato come unire i due set diversi.</span><span class="sxs-lookup"><span data-stu-id="11f1d-141">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="11f1d-142">In questo esempio vengono create due <xref:System.Collections.Generic.HashSet%601> gli oggetti che vengono compilati con numeri pari e dispari, rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="11f1d-142">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="11f1d-143">Una terza <xref:System.Collections.Generic.HashSet%601> oggetto viene creato dal set che contiene i numeri pari.</span><span class="sxs-lookup"><span data-stu-id="11f1d-143">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="11f1d-144">Nell'esempio viene quindi chiamato il <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> metodo che aggiunge il set di numeri dispari al terzo insieme.</span><span class="sxs-lookup"><span data-stu-id="11f1d-144">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-145">Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-145">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-146">Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.HashSet`1" /> e usa l'operatore di confronto per l'uguaglianza per il tipo di insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-146">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-147">La capacità di un <xref:System.Collections.Generic.HashSet%601> oggetto è il numero di elementi che è possibile inserire l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-147">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="11f1d-148">Oggetto <xref:System.Collections.Generic.HashSet%601> la capacità dell'oggetto aumentano automaticamente man mano gli elementi vengono aggiunti all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-148">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="11f1d-149">Questo costruttore è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-149">This constructor is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-150">Nell'esempio riportato di seguito viene illustrato come creare e compilare due <xref:System.Collections.Generic.HashSet%601> oggetti.</span><span class="sxs-lookup"><span data-stu-id="11f1d-150">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="11f1d-151">In questo esempio fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-151">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">
          <span data-ttu-id="11f1d-152">Raccolta i cui elementi vengono copiati nel nuovo insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-152">The collection whose elements are copied to the new set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-153">Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.HashSet`1" /> che usa l'operatore di confronto per l'uguaglianza per il tipo di insieme, contiene gli elementi copiati dalla raccolta specificata e presenta una capacità sufficiente a contenere il numero di elementi copiati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-153">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-154">La capacità di un <xref:System.Collections.Generic.HashSet%601> oggetto è il numero di elementi che è possibile inserire l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-154">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="11f1d-155">Oggetto <xref:System.Collections.Generic.HashSet%601> la capacità dell'oggetto aumentano automaticamente man mano gli elementi vengono aggiunti all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-155">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="11f1d-156">Se `collection` contiene duplicati, il set conterrà uno di ogni elemento univoco.</span><span class="sxs-lookup"><span data-stu-id="11f1d-156">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="11f1d-157">Verrà generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-157">No exception will be thrown.</span></span> <span data-ttu-id="11f1d-158">Pertanto, le dimensioni del set risultante non sono identica a quella di `collection`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-158">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="11f1d-159">Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi di `collection` parametro.</span><span class="sxs-lookup"><span data-stu-id="11f1d-159">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-160">Nell'esempio seguente viene illustrato come creare un <xref:System.Collections.Generic.HashSet%601> raccolta da un set esistente.</span><span class="sxs-lookup"><span data-stu-id="11f1d-160">The following example shows how to create a <xref:System.Collections.Generic.HashSet%601> collection from an existing set.</span></span> <span data-ttu-id="11f1d-161">In questo esempio vengono creati due insiemi con numeri interi e dispari, rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="11f1d-161">In this example, two sets are created with even and odd integers, respectively.</span></span> <span data-ttu-id="11f1d-162">Una terza <xref:System.Collections.Generic.HashSet%601> oggetto viene quindi creato dall'insieme di numero intero pari.</span><span class="sxs-lookup"><span data-stu-id="11f1d-162">A third <xref:System.Collections.Generic.HashSet%601> object is then created from the even integer set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-163">
            <paramref name="collection" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-163">
              <paramref name="collection" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">
          <span data-ttu-id="11f1d-164">Implementazione di <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> da usare per confrontare i valori nel set oppure <see langword="null" /> per usare l'implementazione di <see cref="T:System.Collections.Generic.EqualityComparer`1" /> predefinita per il tipo di set.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-164">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-165">Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.HashSet`1" /> e usa l'operatore di confronto per l'uguaglianza specificato per il tipo di insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-165">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-166">La capacità di un <xref:System.Collections.Generic.HashSet%601> oggetto è il numero di elementi che è possibile inserire l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-166">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="11f1d-167">Oggetto <xref:System.Collections.Generic.HashSet%601> la capacità dell'oggetto aumentano automaticamente man mano gli elementi vengono aggiunti all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-167">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="11f1d-168">Questo costruttore è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-168">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <span data-ttu-id="11f1d-169">Dimensioni iniziali dell'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-169">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-170">Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.HashSet`1" />, che è vuota ma include spazio riservato per <paramref name="capacity" /> e usa l'operatore di confronto per l'uguaglianza per il tipo di set.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-170">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty, but has reserved space for <paramref name="capacity" /> items and uses the default equality comparer for the set type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-171">Poiché viene ridimensionato è relativamente costose (richiedono generando un nuovo hash), si tenta di ridurre al minimo la necessità di ridimensionare la capacità iniziale in base al valore dell'impostazione di `capacity`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-171">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">
          <span data-ttu-id="11f1d-172">Raccolta i cui elementi vengono copiati nel nuovo insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-172">The collection whose elements are copied to the new set.</span>
          </span>
        </param>
        <param name="comparer">
          <span data-ttu-id="11f1d-173">Implementazione di <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> da usare per confrontare i valori nel set oppure <see langword="null" /> per usare l'implementazione di <see cref="T:System.Collections.Generic.EqualityComparer`1" /> predefinita per il tipo di set.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-173">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-174">Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.HashSet`1" /> che usa l'operatore di confronto per l'uguaglianza specificato per il tipo di insieme, contiene gli elementi copiati dalla raccolta specificata e ha una capacità sufficiente a contenere il numero di elementi copiati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-174">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-175">La capacità di un <xref:System.Collections.Generic.HashSet%601> oggetto è il numero di elementi che è possibile inserire l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-175">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="11f1d-176">Oggetto <xref:System.Collections.Generic.HashSet%601> la capacità dell'oggetto aumentano automaticamente man mano gli elementi vengono aggiunti all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-176">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="11f1d-177">Se `collection` contiene duplicati, il set conterrà uno di ogni elemento univoco.</span><span class="sxs-lookup"><span data-stu-id="11f1d-177">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="11f1d-178">Verrà generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-178">No exception will be thrown.</span></span> <span data-ttu-id="11f1d-179">Pertanto, le dimensioni del set risultante non sono identica a quella di `collection`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-179">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="11f1d-180">Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi di `collection` parametro.</span><span class="sxs-lookup"><span data-stu-id="11f1d-180">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-181">L'esempio seguente usa una classe fornita <xref:System.Collections.Generic.IEqualityComparer%601> per consentire confronti tra maiuscole e minuscole degli elementi di un <xref:System.Collections.Generic.HashSet%601> raccolta di tipi veicolo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-181">The following example uses a supplied <xref:System.Collections.Generic.IEqualityComparer%601> to allow case-insensitive comparisons on the elements of a  <xref:System.Collections.Generic.HashSet%601> collection of vehicle types.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-182">
            <paramref name="collection" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-182">
              <paramref name="collection" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <span data-ttu-id="11f1d-183">Dimensioni iniziali dell'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-183">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span>
          </span>
        </param>
        <param name="comparer">
          <span data-ttu-id="11f1d-184">Implementazione di <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> da usare per confrontare i valori nel set oppure null (Nothing in Visual Basic) per usare l'implementazione predefinita di <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per il tipo di set.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-184">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null (Nothing in Visual Basic) to use the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation for the set type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-185">Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.HashSet`1" /> che usa l'operatore di confronto per l'uguaglianza specificato per il tipo di set e ha una capacità sufficiente a contenere gli elementi <paramref name="capacity" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-185">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, and has sufficient capacity to accommodate <paramref name="capacity" /> elements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-186">Poiché viene ridimensionato è relativamente costose (richiedono generando un nuovo hash), si tenta di ridurre al minimo la necessità di ridimensionare la capacità iniziale in base al valore dell'impostazione di `capacity`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-186">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="11f1d-187">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-187">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="11f1d-188">Struttura <see cref="T:System.Runtime.Serialization.StreamingContext" /> che contiene l'origine e la destinazione del flusso serializzato associato all'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-188">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-189">Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.HashSet`1" /> con dati serializzati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-189">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class with serialized data.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-190">Questo costruttore viene chiamato durante la deserializzazione per ricostituire l'oggetto che viene trasmesso in un flusso.</span><span class="sxs-lookup"><span data-stu-id="11f1d-190">This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</span></span> <span data-ttu-id="11f1d-191">Per ulteriori informazioni, vedere [serializzazione XML e SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="11f1d-191">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="11f1d-192">Elemento da aggiungere all'insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-192">The element to add to the set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-193">Aggiunge l'elemento specificato a un insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-193">Adds the specified element to a set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-194">
            <see langword="true" /> se l'elemento viene aggiunto all'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />, <see langword="false" /> se l'elemento è già presente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-194">
              <see langword="true" /> if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; <see langword="false" /> if the element is already present.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-195">Se <xref:System.Collections.Generic.HashSet%601.Count%2A> già pari alla capacità del <xref:System.Collections.Generic.HashSet%601> dell'oggetto, la capacità viene regolata automaticamente per contenere il nuovo elemento.</span><span class="sxs-lookup"><span data-stu-id="11f1d-195">If <xref:System.Collections.Generic.HashSet%601.Count%2A> already equals the capacity of the <xref:System.Collections.Generic.HashSet%601> object, the capacity is automatically adjusted to accommodate the new item.</span></span>  
  
 <span data-ttu-id="11f1d-196">Se <xref:System.Collections.Generic.HashSet%601.Count%2A> è minore della capacità della matrice interna, questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-196">If <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the capacity of the internal array, this method is an O(1) operation.</span></span> <span data-ttu-id="11f1d-197">Se il <xref:System.Collections.Generic.HashSet%601> oggetto deve essere ridimensionato, questo metodo diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-197">If the <xref:System.Collections.Generic.HashSet%601> object must be resized, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-198">Nell'esempio riportato di seguito viene illustrato come creare e compilare due <xref:System.Collections.Generic.HashSet%601> oggetti.</span><span class="sxs-lookup"><span data-stu-id="11f1d-198">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="11f1d-199">In questo esempio fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-199">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-200">Rimuove tutti gli elementi da un oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-200">Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.</span><span class="sxs-lookup"><span data-stu-id="11f1d-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> is set to zero and references to other objects from elements of the collection are also released.</span></span> <span data-ttu-id="11f1d-202">La capacità non subisce modifiche fino a quando una chiamata a <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> viene eseguita.</span><span class="sxs-lookup"><span data-stu-id="11f1d-202">The capacity remains unchanged until a call to <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> is made.</span></span>  
  
 <span data-ttu-id="11f1d-203">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-203">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-204">Nell'esempio seguente crea e popola un <xref:System.Collections.Generic.HashSet%601> della raccolta, quindi cancellato e rilascia la memoria a cui fa riferimento la raccolta.</span><span class="sxs-lookup"><span data-stu-id="11f1d-204">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, then clears it and releases the memory referenced by the collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-205">Ottiene l'oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, che viene usato per determinare l'uguaglianza dei valori nell'insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-205">Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="11f1d-206">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> usato per determinare l'uguaglianza dei valori nell'insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-206">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-207">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-207">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="11f1d-208">Elemento da individuare nell'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-208">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-209">Determina se un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> contiene l'elemento specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-209">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-210">
            <see langword="true" /> se l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> contiene l'elemento specificato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-210">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-211">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-211">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-212">Nell'esempio riportato di seguito viene illustrato come rimuovere i valori da un <xref:System.Collections.Generic.HashSet%601> insieme utilizzando la <xref:System.Collections.Generic.HashSet%601.Remove%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-212">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="11f1d-213">In questo esempio, il <xref:System.Collections.Generic.HashSet%601.Contains%2A> metodo verifica che il set contiene un valore prima di rimuoverlo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-213">In this example, the <xref:System.Collections.Generic.HashSet%601.Contains%2A> method verifies that the set contains a value before removing it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-214">Copia gli elementi di una raccolta <see cref="T:System.Collections.Generic.HashSet`1" /> in una matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-214">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> collection to an array.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="11f1d-215">Matrice unidimensionale che costituisce la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-215">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
          <span data-ttu-id="11f1d-216">La matrice deve avere un'indicizzazione in base zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-216">The array must have zero-based indexing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-217">Copia gli elementi di un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> in una matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-217">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-218">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-218">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-219">
            <paramref name="array" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-219">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="11f1d-220">Matrice unidimensionale che costituisce la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-220">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
          <span data-ttu-id="11f1d-221">La matrice deve avere un'indicizzazione in base zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-221">The array must have zero-based indexing.</span>
          </span>
        </param>
        <param name="arrayIndex">
          <span data-ttu-id="11f1d-222">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-222">The zero-based index in <c>array</c> at which copying begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-223">Copia gli elementi di un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> in una matrice, a partire da un indice di matrice specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-223">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-224">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-224">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-225">
            <paramref name="array" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-225">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="11f1d-226">
            <paramref name="arrayIndex" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-226">
              <paramref name="arrayIndex" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="11f1d-227">
            <paramref name="arrayIndex" /> è maggiore della lunghezza del parametro <paramref name="array" /> di destinazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-227">
              <paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="11f1d-228">Matrice unidimensionale che costituisce la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-228">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
          <span data-ttu-id="11f1d-229">La matrice deve avere un'indicizzazione in base zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-229">The array must have zero-based indexing.</span>
          </span>
        </param>
        <param name="arrayIndex">
          <span data-ttu-id="11f1d-230">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-230">The zero-based index in <c>array</c> at which copying begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="11f1d-231">Numero di elementi da copiare nella <c>matrice</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-231">The number of elements to copy to <c>array</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-232">Copia il numero specificato di elementi di un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> in una matrice, a partire da un indice di matrice specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-232">Copies the specified number of elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-233">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-233">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-234">
            <paramref name="array" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-234">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="11f1d-235">
            <paramref name="arrayIndex" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-235">
              <paramref name="arrayIndex" /> is less than 0.</span>
          </span>
          <span data-ttu-id="11f1d-236">-oppure-  <paramref name="count" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-236">-or-  <paramref name="count" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="11f1d-237">
            <paramref name="arrayIndex" /> è maggiore della lunghezza del parametro <paramref name="array" /> di destinazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-237">
              <paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span>
          </span>
          <span data-ttu-id="11f1d-238">-oppure-  <paramref name="count" /> è maggiore dello spazio disponibile tra <paramref name="index" /> e la fine del parametro <paramref name="array" /> di destinazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-238">-or-  <paramref name="count" /> is greater than the available space from the <paramref name="index" /> to the end of the destination <paramref name="array" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-239">Ottiene il numero di elementi contenuti in un insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-239">Gets the number of elements that are contained in a set.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="11f1d-240">Numero di elementi contenuti nell'insieme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-240">The number of elements that are contained in the set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-241">La capacità di un <xref:System.Collections.Generic.HashSet%601> oggetto è il numero di elementi che è possibile inserire l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-241">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="11f1d-242">Oggetto <xref:System.Collections.Generic.HashSet%601> la capacità dell'oggetto aumentano automaticamente man mano gli elementi vengono aggiunti all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-242">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="11f1d-243">La capacità è sempre maggiore di o uguale a <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-243">The capacity is always greater than or equal to <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span> <span data-ttu-id="11f1d-244">Se <xref:System.Collections.Generic.HashSet%601.Count%2A> durante l'aggiunta di elementi supera la capacità, la capacità è impostata per il primo numero primo è maggiore del doppio della capacità precedente.</span><span class="sxs-lookup"><span data-stu-id="11f1d-244">If <xref:System.Collections.Generic.HashSet%601.Count%2A> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</span></span>  
  
 <span data-ttu-id="11f1d-245">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-245">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-246">Nell'esempio riportato di seguito viene illustrato come creare, compilare e modificare due <xref:System.Collections.Generic.HashSet%601> oggetti.</span><span class="sxs-lookup"><span data-stu-id="11f1d-246">The following example demonstrates how to create, populate, and manipulate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="11f1d-247">In questo esempio, sia il contenuto del set e <xref:System.Collections.Generic.HashSet%601.Count%2A> visualizzare nella console.</span><span class="sxs-lookup"><span data-stu-id="11f1d-247">In this example, both the contents of the set and <xref:System.Collections.Generic.HashSet%601.Count%2A> display to the console.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-248">Restituisce un oggetto <see cref="T:System.Collections.IEqualityComparer" /> che può essere usato per test di uguaglianza di un oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-248">Returns an <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-249">Oggetto <see cref="T:System.Collections.IEqualityComparer" /> che può essere usato per test di uguaglianza approfonditi dell'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-249">An <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-250">Il <xref:System.Collections.IEqualityComparer> oggetto verifica l'uguaglianza a un solo livello; tuttavia, è possibile concatenare gli operatori di confronto a livelli aggiuntivi per eseguire il test di uguaglianza più approfondita.</span><span class="sxs-lookup"><span data-stu-id="11f1d-250">The <xref:System.Collections.IEqualityComparer> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</span></span>  
  
 <span data-ttu-id="11f1d-251">Chiamare questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-251">Calling this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-252">Raccolta di elementi da rimuovere dall'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-252">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-253">Rimuove tutti gli elementi della raccolta specificata dall'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-253">Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-254">Il <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> metodo è l'equivalente di una sottrazione matematica.</span><span class="sxs-lookup"><span data-stu-id="11f1d-254">The <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method is the equivalent of mathematical set subtraction.</span></span>  
  
 <span data-ttu-id="11f1d-255">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi di `other` parametro.</span><span class="sxs-lookup"><span data-stu-id="11f1d-255">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-256">L'esempio seguente crea due <xref:System.Collections.Generic.HashSet%601> raccolte con sovrapposizione dei set di dati.</span><span class="sxs-lookup"><span data-stu-id="11f1d-256">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="11f1d-257">L'intervallo di valori inferiore viene quindi rimosso dal set di dimensioni maggiori utilizzando il <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-257">The lower range of values is then removed from the larger set using the <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-258">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-258">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-259">Restituisce un enumeratore che consente di eseguire l'iterazione di un oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-259">Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-260">Oggetto <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> per l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-260">A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-261">Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori.</span><span class="sxs-lookup"><span data-stu-id="11f1d-261">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="11f1d-262">Pertanto, l'utilizzo `foreach` è consigliabile anziché la modifica diretta dell'enumeratore.</span><span class="sxs-lookup"><span data-stu-id="11f1d-262">Therefore, using `foreach` is recommended instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="11f1d-263">È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.</span><span class="sxs-lookup"><span data-stu-id="11f1d-263">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="11f1d-264">Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta.</span><span class="sxs-lookup"><span data-stu-id="11f1d-264">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="11f1d-265">In questa posizione, la <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> proprietà non è definita.</span><span class="sxs-lookup"><span data-stu-id="11f1d-265">At this position, the <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="11f1d-266">Pertanto, è necessario chiamare il <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta prima di leggere il valore di <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-266">Therefore, you must call the <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="11f1d-267">Il <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> proprietà restituisce lo stesso oggetto finché non <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="11f1d-267">The <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property returns the same object until <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="11f1d-268"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> sull'elemento successivo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-268"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> sets <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="11f1d-269">Se <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-269">If <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="11f1d-270">Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> restituire anche `false`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-270">When the enumerator is at this position, subsequent calls to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="11f1d-271">Se l'ultima chiamata a <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> è definito.</span><span class="sxs-lookup"><span data-stu-id="11f1d-271">If the last call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="11f1d-272">Non è possibile impostare <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> al primo elemento della raccolta è necessario creare invece un nuovo oggetto enumeratore.</span><span class="sxs-lookup"><span data-stu-id="11f1d-272">You cannot set <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="11f1d-273">Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche.</span><span class="sxs-lookup"><span data-stu-id="11f1d-273">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="11f1d-274">Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e la successiva chiamata al <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> o <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> genera un <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-274">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> or <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="11f1d-275">L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.</span><span class="sxs-lookup"><span data-stu-id="11f1d-275">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="11f1d-276">Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-276">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="11f1d-277">Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-277">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="11f1d-278">Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.</span><span class="sxs-lookup"><span data-stu-id="11f1d-278">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="11f1d-279">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-279">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="11f1d-280">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-280">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="11f1d-281">Struttura <see cref="T:System.Runtime.Serialization.StreamingContext" /> che contiene l'origine e la destinazione del flusso serializzato associato all'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-281">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-282">Implementa l'interfaccia <see cref="T:System.Runtime.Serialization.ISerializable" /> e restituisce i dati necessari per serializzare un oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-282">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-283">Chiamare questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-283">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-284">
            <paramref name="info" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-284">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="11f1d-285">per fornire servizi di serializzazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-285">for providing serialization services.</span>
          </span>
          <span data-ttu-id="11f1d-286">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-286">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="11f1d-287">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-287">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-288">Raccolta da confrontare con l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-288">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-289">Modifica l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente per contenere solo elementi presenti in tale oggetto e nella raccolta specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-289">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-290">Se la raccolta è rappresentato dal `other` parametro è un <xref:System.Collections.Generic.HashSet%601> raccolta con lo stesso operatore di confronto di uguaglianza corrente <xref:System.Collections.Generic.HashSet%601> dell'oggetto, questo metodo è un'operazione O (`n`) operazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-290">If the collection represented by the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="11f1d-291">In caso contrario, questo metodo è un'operazione O (`n` + `m`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A> e `m` è il numero di elementi in `other`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-291">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-292">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-292">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-293">Raccolta da confrontare con l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-293">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-294">Determina se un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> è un subset corretto della raccolta specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-294">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-295">
            <see langword="true" /> se l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> è un subset corretto di <paramref name="other" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-295">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-296">Un set vuoto è un subset corretto di qualsiasi altra raccolta.</span><span class="sxs-lookup"><span data-stu-id="11f1d-296">An empty set is a proper subset of any other collection.</span></span> <span data-ttu-id="11f1d-297">Pertanto, questo metodo restituisce `true` se la raccolta è rappresentata dall'oggetto corrente <xref:System.Collections.Generic.HashSet%601> oggetto è vuoto, a meno che il `other` parametro è anche un set vuoto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-297">Therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty unless the `other` parameter is also an empty set.</span></span>  
  
 <span data-ttu-id="11f1d-298">Questo metodo restituisce sempre `false` se <xref:System.Collections.Generic.HashSet%601.Count%2A> è maggiore o uguale al numero di elementi in `other`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-298">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="11f1d-299">Se la raccolta è rappresentato da `other` è un <xref:System.Collections.Generic.HashSet%601> raccolta con lo stesso operatore di confronto di uguaglianza corrente <xref:System.Collections.Generic.HashSet%601> dell'oggetto, questo metodo è un'operazione O (`n`) operazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-299">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, then this method is an O(`n`) operation.</span></span> <span data-ttu-id="11f1d-300">In caso contrario, questo metodo è un'operazione O (`n` + `m`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A> e `m` è il numero di elementi in `other`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-300">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-301">L'esempio seguente crea due diversi <xref:System.Collections.Generic.HashSet%601> gli oggetti che vengono quindi confrontati tra loro.</span><span class="sxs-lookup"><span data-stu-id="11f1d-301">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="11f1d-302">In questo esempio, `lowNumbers` è un subset sia un subset corretto di `allNumbers` fino a quando non `allNumbers` viene modificato, tramite il <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> (metodo), per contenere solo i valori presenti in entrambi i set.</span><span class="sxs-lookup"><span data-stu-id="11f1d-302">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="11f1d-303">Una volta `allNumbers` e `lowNumbers` sono identici, `lowNumbers` è ancora un sottoinsieme di `allNumbers` ma non è più un subset corretto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-303">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-304">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-304">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-305">Raccolta da confrontare con l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-305">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-306">Determina se un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> è un superset corretto della raccolta specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-306">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-307">
            <see langword="true" /> se l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> è un superset corretto di <paramref name="other" />, in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-307">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-308">Un set vuoto è un superset appropriato di qualsiasi altra raccolta.</span><span class="sxs-lookup"><span data-stu-id="11f1d-308">An empty set is a proper superset of any other collection.</span></span> <span data-ttu-id="11f1d-309">Pertanto, questo metodo restituisce `true` se la raccolta è rappresentato dal `other` parametro è vuoto a meno che non corrente <xref:System.Collections.Generic.HashSet%601> raccolta è vuota.</span><span class="sxs-lookup"><span data-stu-id="11f1d-309">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty unless the current <xref:System.Collections.Generic.HashSet%601> collection is also empty.</span></span>  
  
 <span data-ttu-id="11f1d-310">Questo metodo restituisce sempre `false` se <xref:System.Collections.Generic.HashSet%601.Count%2A> è minore o uguale al numero di elementi in `other`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-310">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="11f1d-311">Se la raccolta è rappresentato da `other` è un <xref:System.Collections.Generic.HashSet%601> raccolta con lo stesso operatore di confronto di uguaglianza corrente <xref:System.Collections.Generic.HashSet%601> dell'oggetto, questo metodo è un'operazione O (`n`) operazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-311">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="11f1d-312">In caso contrario, questo metodo è un'operazione O (`n` + `m`) operazione, in cui `n` è il numero di elementi in `other` e `m` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-312">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-313">L'esempio seguente crea due diversi <xref:System.Collections.Generic.HashSet%601> gli oggetti che vengono quindi confrontati tra loro.</span><span class="sxs-lookup"><span data-stu-id="11f1d-313">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="11f1d-314">In questo esempio, `allNumbers` è un superset e un superset appropriato di `lowNumbers` fino a quando non `allNumbers` viene modificato, tramite il <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> (metodo), per contenere solo i valori presenti in entrambi i set.</span><span class="sxs-lookup"><span data-stu-id="11f1d-314">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="11f1d-315">Una volta `allNumbers` e `lowNumbers` sono identici, `allNumbers` è ancora un superset di `lowNumbers` ma non è più un superset corretto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-315">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-316">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-316">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-317">Raccolta da confrontare con l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-317">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-318">Determina se un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> è un subset della raccolta specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-318">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-319">
            <see langword="true" /> se l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> è un subset di <paramref name="other" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-319">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-320">Un set vuoto è un subset di qualsiasi altra raccolta, tra cui un set vuoto; Pertanto, questo metodo restituisce `true` se la raccolta è rappresentata dall'oggetto corrente <xref:System.Collections.Generic.HashSet%601> oggetto è vuoto, anche se il `other` parametro è un set vuoto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-320">An empty set is a subset of any other collection, including an empty set; therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty, even if the `other` parameter is an empty set.</span></span>  
  
 <span data-ttu-id="11f1d-321">Questo metodo restituisce sempre `false` se <xref:System.Collections.Generic.HashSet%601.Count%2A> è maggiore del numero di elementi in `other`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-321">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="11f1d-322">Se la raccolta è rappresentato da `other` è un <xref:System.Collections.Generic.HashSet%601> raccolta con lo stesso operatore di confronto di uguaglianza corrente <xref:System.Collections.Generic.HashSet%601> dell'oggetto, questo metodo è un'operazione O (`n`) operazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-322">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="11f1d-323">In caso contrario, questo metodo è un'operazione O (`n` + `m`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A> e `m` è il numero di elementi in `other`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-323">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-324">L'esempio seguente crea due diversi <xref:System.Collections.Generic.HashSet%601> gli oggetti che vengono quindi confrontati tra loro.</span><span class="sxs-lookup"><span data-stu-id="11f1d-324">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="11f1d-325">In questo esempio, `lowNumbers` è un subset sia un subset corretto di `allNumbers` fino a quando non `allNumbers` viene modificato, tramite il <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> (metodo), per contenere solo i valori presenti in entrambi i set.</span><span class="sxs-lookup"><span data-stu-id="11f1d-325">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="11f1d-326">Una volta `allNumbers` e `lowNumbers` sono identici, `lowNumbers` è ancora un sottoinsieme di `allNumbers` ma non è più un subset corretto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-326">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-327">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-327">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-328">Raccolta da confrontare con l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-328">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-329">Determina se un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> è un superset della raccolta specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-329">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-330">
            <see langword="true" /> se l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> è un superset di <paramref name="other" />, in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-330">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-331">Tutte le raccolte, incluso il set vuoto, sono superset di un set vuoto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-331">All collections, including the empty set, are supersets of the empty set.</span></span> <span data-ttu-id="11f1d-332">Pertanto, questo metodo restituisce `true` se la raccolta è rappresentato dal `other` parametro è vuoto, anche se l'oggetto corrente <xref:System.Collections.Generic.HashSet%601> oggetto è vuoto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-332">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty, even if the current <xref:System.Collections.Generic.HashSet%601> object is empty.</span></span>  
  
 <span data-ttu-id="11f1d-333">Questo metodo restituisce sempre `false` se <xref:System.Collections.Generic.HashSet%601.Count%2A> è inferiore al numero di elementi in `other`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-333">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="11f1d-334">Se la raccolta è rappresentato da `other` è un <xref:System.Collections.Generic.HashSet%601> raccolta con lo stesso operatore di confronto di uguaglianza corrente <xref:System.Collections.Generic.HashSet%601> dell'oggetto, questo metodo è un'operazione O (`n`) operazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-334">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="11f1d-335">In caso contrario, questo metodo è un'operazione O (`n` + `m`) operazione, in cui `n` è il numero di elementi in `other` e `m` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-335">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-336">L'esempio seguente crea due diversi <xref:System.Collections.Generic.HashSet%601> gli oggetti che vengono quindi confrontati tra loro.</span><span class="sxs-lookup"><span data-stu-id="11f1d-336">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="11f1d-337">In questo esempio, `allNumbers` è un superset e un superset appropriato di `lowNumbers` fino a quando non `allNumbers` viene modificato, tramite il <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> (metodo), per contenere solo i valori presenti in entrambi i set.</span><span class="sxs-lookup"><span data-stu-id="11f1d-337">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="11f1d-338">Una volta `allNumbers` e `lowNumbers` sono identici, `allNumbers` è ancora un superset di `lowNumbers` ma non è più un superset corretto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-338">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-339">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-339">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">
          <span data-ttu-id="11f1d-340">Origine dell'evento di deserializzazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-340">The source of the deserialization event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-341">Implementa l'interfaccia <see cref="T:System.Runtime.Serialization.ISerializable" /> e genera l'evento di deserializzazione quando la deserializzazione è completa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-341">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and raises the deserialization event when the deserialization is complete.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-342">Chiamare questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-342">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <span data-ttu-id="11f1d-343">L'oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> associato all’oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-343">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" /> object is invalid.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-344">Raccolta da confrontare con l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-344">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-345">Determina se l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente e una raccolta specificata condividono elementi comuni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-345">Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object and a specified collection share common elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-346">
            <see langword="true" /> se l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> e il parametro <paramref name="other" /> condividono almeno un elemento comune; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-346">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and <paramref name="other" /> share at least one common element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-347">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `other`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-347">This method is an O(`n`) operation, where `n` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-348">L'esempio seguente crea due diversi <xref:System.Collections.Generic.HashSet%601> degli oggetti e vengono quindi confrontati.</span><span class="sxs-lookup"><span data-stu-id="11f1d-348">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="11f1d-349">In questo esempio, `allNumbers` e `lowNumbers` viene illustrato come condividere elementi comuni tramite il <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-349">In this example, `allNumbers` and `lowNumbers` are shown to share common elements using the <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-350">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-350">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="11f1d-351">Elemento da rimuovere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-351">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-352">Rimuove l'elemento specificato da un oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-352">Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-353">
            <see langword="true" /> se l'elemento viene trovato e rimosso; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-353">
              <see langword="true" /> if the element is successfully found and removed; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="11f1d-354">Questo metodo restituisce <see langword="false" /> se <paramref name="item" /> non viene trovato nell'oggetto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-354">This method returns <see langword="false" /> if <paramref name="item" /> is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-355">Se il <xref:System.Collections.Generic.HashSet%601> oggetto non contiene l'elemento specificato, l'oggetto rimane invariato.</span><span class="sxs-lookup"><span data-stu-id="11f1d-355">If the <xref:System.Collections.Generic.HashSet%601> object does not contain the specified element, the object remains unchanged.</span></span> <span data-ttu-id="11f1d-356">Non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-356">No exception is thrown.</span></span>  
  
 <span data-ttu-id="11f1d-357">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-357">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-358">Nell'esempio riportato di seguito viene illustrato come rimuovere i valori da un <xref:System.Collections.Generic.HashSet%601> insieme utilizzando la <xref:System.Collections.Generic.HashSet%601.Remove%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-358">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="11f1d-359">In questo esempio, zero arbitrariamente rimossa la <xref:System.Collections.Generic.HashSet%601> insieme.</span><span class="sxs-lookup"><span data-stu-id="11f1d-359">In this example, zero is arbitrarily removed from the <xref:System.Collections.Generic.HashSet%601> collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <span data-ttu-id="11f1d-360">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da rimuovere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-360">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-361">Rimuove tutti gli elementi che corrispondono alle condizioni definite dal predicato specificato da una raccolta <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-361">Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-362">Numero di elementi rimossi dalla raccolta <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-362">The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-363">Chiamare questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-363">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-364">Nell'esempio riportato di seguito viene illustrato come rimuovere i valori da un <xref:System.Collections.Generic.HashSet%601> insieme utilizzando la <xref:System.Collections.Generic.HashSet%601.Remove%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-364">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="11f1d-365">In questo esempio, tutti i valori interi dispari vengono rimossi dal <xref:System.Collections.Generic.HashSet%601> insieme come specificato nella `match` delegato.</span><span class="sxs-lookup"><span data-stu-id="11f1d-365">In this example, all odd integers are removed from the <xref:System.Collections.Generic.HashSet%601> collection as specified by the `match` delegate.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-366">
            <paramref name="match" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-366">
              <paramref name="match" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-367">Raccolta da confrontare con l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-367">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-368">Determina se un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> e la raccolta specificata contengono gli stessi elementi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-368">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object and the specified collection contain the same elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-369">
            <see langword="true" /> se l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> è uguale a <paramref name="other" />; in caso contrario, false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-369">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is equal to <paramref name="other" />; otherwise, false.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-370">Il <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> metodo ignora le voci duplicate e l'ordine degli elementi di `other` parametro.</span><span class="sxs-lookup"><span data-stu-id="11f1d-370">The <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method ignores duplicate entries and the order of elements in the `other` parameter.</span></span>  
  
 <span data-ttu-id="11f1d-371">Se la raccolta è rappresentato da `other` è un <xref:System.Collections.Generic.HashSet%601> raccolta con lo stesso operatore di confronto di uguaglianza corrente <xref:System.Collections.Generic.HashSet%601> dell'oggetto, questo metodo è un'operazione O (`n`) operazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-371">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="11f1d-372">In caso contrario, questo metodo è un'operazione O (`n` + `m`) operazione, in cui `n` è il numero di elementi in `other` e `m` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-372">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-373">L'esempio seguente crea due diversi <xref:System.Collections.Generic.HashSet%601> degli oggetti e vengono quindi confrontati.</span><span class="sxs-lookup"><span data-stu-id="11f1d-373">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="11f1d-374">Inizialmente, i due set non sono uguali, che viene dimostrata tramite il <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-374">Initially, the two sets are not equal, which is demonstrated by using the <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method.</span></span> <span data-ttu-id="11f1d-375">Il `allNumbers` <xref:System.Collections.Generic.HashSet%601> oggetto viene quindi modificato, dopo il quale i set sono uguali.</span><span class="sxs-lookup"><span data-stu-id="11f1d-375">The `allNumbers`<xref:System.Collections.Generic.HashSet%601> object is then modified, after which the sets are equal.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-376">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-376">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-377">Raccolta da confrontare con l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-377">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-378">Modifica l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente in modo che contenga solo elementi presenti in tale oggetto o nella raccolta specificata, ma non entrambi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-378">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-379">Se il `other` parametro è un <xref:System.Collections.Generic.HashSet%601> raccolta con lo stesso operatore di confronto di uguaglianza corrente <xref:System.Collections.Generic.HashSet%601> dell'oggetto, questo metodo è un'operazione O (`n`) operazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-379">If the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="11f1d-380">In caso contrario, questo metodo è un'operazione O (`n` + `m`) operazione, in cui `n` è il numero di elementi in `other` e `m` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-380">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-381">L'esempio seguente crea due <xref:System.Collections.Generic.HashSet%601> raccolte con sovrapposizione dei set di dati.</span><span class="sxs-lookup"><span data-stu-id="11f1d-381">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="11f1d-382">Il set che contiene i valori inferiori viene quindi modificato, tramite il <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> (metodo), per contenere solo i valori che non sono presenti in entrambi i set.</span><span class="sxs-lookup"><span data-stu-id="11f1d-382">The set that contains the lower values is then modified, using the <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> method, to contain only the values that are not present in both sets.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-383">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-383">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="11f1d-384">Oggetto da aggiungere all'oggetto <see cref="T:System.Collections.Generic.ICollection`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-384">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-385">Aggiunge un elemento a un oggetto <see cref="T:System.Collections.Generic.ICollection`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-385">Adds an item to an <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-386">Se <xref:System.Collections.Generic.List%601.Count%2A> è minore di <xref:System.Collections.Generic.List%601.Capacity%2A>, questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-386">If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation.</span></span> <span data-ttu-id="11f1d-387">Se è necessario aumentare la capacità per contenere il nuovo elemento, questo metodo diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.List%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-387">If the capacity must be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="11f1d-388">La classe <see cref="T:System.Collections.Generic.ICollection`1" /> è di sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-388">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-389">Ottiene un valore che indica se una raccolta è di sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-389">Gets a value indicating whether a collection is read-only.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="11f1d-390">
            <see langword="true" /> se la raccolta è di sola lettura; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-390">
              <see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-391">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-391">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-392">Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-392">Returns an enumerator that iterates through a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-393">Oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> che può essere usato per eseguire l'iterazione della raccolta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-393">An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-394">Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori.</span><span class="sxs-lookup"><span data-stu-id="11f1d-394">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="11f1d-395">Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.</span><span class="sxs-lookup"><span data-stu-id="11f1d-395">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="11f1d-396">È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.</span><span class="sxs-lookup"><span data-stu-id="11f1d-396">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="11f1d-397">Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta.</span><span class="sxs-lookup"><span data-stu-id="11f1d-397">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="11f1d-398">In questa posizione, la <xref:System.Collections.Generic.IEnumerator%601.Current%2A> proprietà non è definita.</span><span class="sxs-lookup"><span data-stu-id="11f1d-398">At this position, the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property is undefined.</span></span> <span data-ttu-id="11f1d-399">Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta prima di leggere il valore di <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-399">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span></span>  
  
 <span data-ttu-id="11f1d-400">Il <xref:System.Collections.Generic.IEnumerator%601.Current%2A> proprietà restituisce lo stesso oggetto finché non <xref:System.Collections.IEnumerator.MoveNext%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="11f1d-400">The <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property returns the same object until <xref:System.Collections.IEnumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="11f1d-401"><xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sull'elemento successivo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-401"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="11f1d-402">Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-402">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="11f1d-403">Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-403">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="11f1d-404">Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è definito.</span><span class="sxs-lookup"><span data-stu-id="11f1d-404">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> is undefined.</span></span> <span data-ttu-id="11f1d-405">Non è possibile impostare <xref:System.Collections.Generic.IEnumerator%601.Current%2A> al primo elemento della raccolta è necessario creare invece un nuovo oggetto enumeratore.</span><span class="sxs-lookup"><span data-stu-id="11f1d-405">You cannot set <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="11f1d-406">Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche.</span><span class="sxs-lookup"><span data-stu-id="11f1d-406">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="11f1d-407">In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.</span><span class="sxs-lookup"><span data-stu-id="11f1d-407">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="11f1d-408">L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.</span><span class="sxs-lookup"><span data-stu-id="11f1d-408">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="11f1d-409">Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-409">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="11f1d-410">Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-410">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="11f1d-411">Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.</span><span class="sxs-lookup"><span data-stu-id="11f1d-411">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="11f1d-412">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-412">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-413">Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-413">Returns an enumerator that iterates through a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-414">Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-414">An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-415">Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori.</span><span class="sxs-lookup"><span data-stu-id="11f1d-415">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="11f1d-416">Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.</span><span class="sxs-lookup"><span data-stu-id="11f1d-416">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="11f1d-417">È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.</span><span class="sxs-lookup"><span data-stu-id="11f1d-417">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="11f1d-418">Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta.</span><span class="sxs-lookup"><span data-stu-id="11f1d-418">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="11f1d-419">Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-419"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="11f1d-420">In questa posizione, la <xref:System.Collections.IEnumerator.Current%2A> proprietà non è definita.</span><span class="sxs-lookup"><span data-stu-id="11f1d-420">At this position, the <xref:System.Collections.IEnumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="11f1d-421">Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-421">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="11f1d-422">Il <xref:System.Collections.IEnumerator.Current%2A> proprietà restituisce lo stesso oggetto finché non <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="11f1d-422">The <xref:System.Collections.IEnumerator.Current%2A> property returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="11f1d-423"><xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-423"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="11f1d-424">Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-424">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="11f1d-425">Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`.</span><span class="sxs-lookup"><span data-stu-id="11f1d-425">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="11f1d-426">Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito.</span><span class="sxs-lookup"><span data-stu-id="11f1d-426">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="11f1d-427">Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-427">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="11f1d-428">Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche.</span><span class="sxs-lookup"><span data-stu-id="11f1d-428">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="11f1d-429">In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.</span><span class="sxs-lookup"><span data-stu-id="11f1d-429">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="11f1d-430">L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.</span><span class="sxs-lookup"><span data-stu-id="11f1d-430">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="11f1d-431">Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-431">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="11f1d-432">Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="11f1d-432">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="11f1d-433">Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.</span><span class="sxs-lookup"><span data-stu-id="11f1d-433">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="11f1d-434">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="11f1d-434">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="11f1d-435">Imposta la capacità di un oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> sul numero effettivo di elementi che contiene, arrotondato per eccesso a un valore vicino specifico dell'implementazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-435">Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-436">È possibile utilizzare il <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> per ridurre a icona una <xref:System.Collections.Generic.HashSet%601> overhead di memoria dell'oggetto quando si è certi che nessun nuovo elemento verrà aggiunto.</span><span class="sxs-lookup"><span data-stu-id="11f1d-436">You can use the <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> method to minimize a <xref:System.Collections.Generic.HashSet%601> object's memory overhead once it is known that no new elements will be added.</span></span> <span data-ttu-id="11f1d-437">Per cancellare completamente un <xref:System.Collections.Generic.HashSet%601> dell'oggetto e rilasciare la memoria a cui fa riferimento., chiamare questo metodo dopo la chiamata di <xref:System.Collections.Generic.HashSet%601.Clear%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="11f1d-437">To completely clear a <xref:System.Collections.Generic.HashSet%601> object and release all memory referenced by it, call this method after calling the <xref:System.Collections.Generic.HashSet%601.Clear%2A> method.</span></span>  
  
 <span data-ttu-id="11f1d-438">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="11f1d-438">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-439">Nell'esempio seguente crea e popola un <xref:System.Collections.Generic.HashSet%601> raccolta, quindi Cancella la raccolta e rilascia la memoria a cui fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="11f1d-439">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, and then clears the collection and releases the memory referenced by it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue">
          <span data-ttu-id="11f1d-440">Valore da cercare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-440">The value to search for.</span>
          </span>
        </param>
        <param name="actualValue">
          <span data-ttu-id="11f1d-441">Valore del set trovato dalla ricerca oppure il valore predefinito di T se la ricerca non ha restituito alcuna corrispondenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-441">The value from the set that the search found, or the default value of T when the search yielded no match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-442">Cerca un determinato valore nel set e restituisce il valore uguale eventualmente trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-442">Searches the set for a given value and returns the equal value it finds, if any.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="11f1d-443">Valore che indica se la ricerca è stata eseguita correttamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-443">A value indicating whether the search was successful.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-444">Può essere utile quando si desidera riutilizzare un riferimento anziché uno appena costruito memorizzato in precedenza (in modo che la condivisione dei riferimenti può verificarsi) o per cercare un valore che dispone di dati più completi rispetto al valore attualmente si dispone, anche se le relative funzioni di operatore di confronto indicare che i valori sono uguali.</span><span class="sxs-lookup"><span data-stu-id="11f1d-444">This can be useful when you want to reuse a previously stored reference instead of a newly constructed one (so that more sharing of references can occur) or to look up a value that has more complete data than the value you currently have, although their comparer functions indicate they are equal.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="11f1d-445">Raccolta da confrontare con l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-445">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11f1d-446">Modifica l'oggetto <see cref="T:System.Collections.Generic.HashSet`1" /> corrente per contenere tutti gli elementi presenti in tale oggetto, nella raccolta specificata o in entrambi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-446">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in itself, the specified collection, or both.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11f1d-447">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi di `other` parametro.</span><span class="sxs-lookup"><span data-stu-id="11f1d-447">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11f1d-448">Nell'esempio seguente viene illustrato come unire i due set diversi.</span><span class="sxs-lookup"><span data-stu-id="11f1d-448">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="11f1d-449">In questo esempio vengono create due <xref:System.Collections.Generic.HashSet%601> gli oggetti che vengono compilati con numeri pari e dispari, rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="11f1d-449">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="11f1d-450">Una terza <xref:System.Collections.Generic.HashSet%601> oggetto viene creato dal set che contiene i numeri pari.</span><span class="sxs-lookup"><span data-stu-id="11f1d-450">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="11f1d-451">Nell'esempio viene quindi chiamato il <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> metodo che aggiunge il set di numeri dispari al terzo insieme.</span><span class="sxs-lookup"><span data-stu-id="11f1d-451">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="11f1d-452">
            <paramref name="other" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11f1d-452">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>