<Type Name="Dictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4cece275bafe4e45d4d02fbe23343610312580f9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36714196" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Dictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Dictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Dictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Class Dictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDeserializationCallback, IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class Dictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Dictionary&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Tipo di chiavi nel dizionario.</typeparam>
    <typeparam name="TValue">Tipo di valori nel dizionario.</typeparam>
    <summary>Rappresenta una raccolta di chiavi e valori.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.Dictionary%602> classe generica fornisce un mapping da un set di chiavi a un set di valori. Ogni aggiunta al dizionario è costituita da un valore e dalla chiave associata corrispondente. Il recupero di un valore tramite la relativa chiave è molto veloce, chiudere o (1), poiché il <xref:System.Collections.Generic.Dictionary%602> classe viene implementata come una tabella hash.  
  
> [!NOTE]
>  La velocità di recupero dipende dalla qualità dell'algoritmo di hash del tipo specificato per `TKey`.  
  
 Fino a quando un oggetto viene utilizzato come una chiave di <xref:System.Collections.Generic.Dictionary%602>, non deve venire modificato in alcun modo che influisce sul relativo valore hash. Ogni chiave in un <xref:System.Collections.Generic.Dictionary%602> devono essere univoci in base all'operatore di confronto uguaglianze del dizionario. Non può essere una chiave `null`, ma un valore può essere, se il valore di tipo `TValue` è un tipo riferimento.  
  
 <xref:System.Collections.Generic.Dictionary%602> richiede un'implementazione di uguaglianza per determinare se le chiavi sono uguali. È possibile specificare un'implementazione del <xref:System.Collections.Generic.IEqualityComparer%601> interfaccia generica con un costruttore che accetta un `comparer` parametro; se non si specifica un'implementazione, l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> viene utilizzato. Se tipo `TKey` implementa la <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia generica, il confronto di uguaglianza predefinito utilizza tale implementazione.  
  
> [!NOTE]
>  Ad esempio, è possibile utilizzare gli operatori di confronto tra maiuscole e minuscole stringa fornite dal <xref:System.StringComparer> classe per creare dizionari con chiavi di stringa tra maiuscole e minuscole.  
  
 La capacità di un <xref:System.Collections.Generic.Dictionary%602> è il numero di elementi di <xref:System.Collections.Generic.Dictionary%602> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Dictionary%602>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Per grandi <xref:System.Collections.Generic.Dictionary%602> oggetti, è possibile aumentare la capacità massima a 2 miliardi di elementi in un sistema a 64 bit impostando il `enabled` attributo dell'elemento di configurazione per `true` nell'ambiente di runtime.  
  
 Ai fini dell'enumerazione, ogni elemento del dizionario viene trattato un <xref:System.Collections.Generic.KeyValuePair%602> struttura che rappresenta un valore e la relativa chiave. L'ordine in cui vengono restituiti gli elementi è definito.  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) restituisce un oggetto di tipo degli elementi nella raccolta. Poiché il <xref:System.Collections.Generic.Dictionary%602> è una raccolta di chiavi e valori, il tipo di elemento non è il tipo della chiave o il tipo del valore. Al contrario, il tipo di elemento è un <xref:System.Collections.Generic.KeyValuePair%602> del tipo di chiave e il tipo di valore. Ad esempio:  
  
 [!code-cpp[Generic.Dictionary#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source2.cpp#11)]
 [!code-csharp[Generic.Dictionary#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source2.cs#11)]
 [!code-vb[Generic.Dictionary#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source2.vb#11)]  
  
 Il `foreach` istruzione è un wrapper per l'enumeratore, che consente solo di leggere dalla raccolta, non scrivere.  
  
> [!NOTE]
>  Poiché le chiavi possono essere ereditate e relativo comportamento modificato, univocità assoluta non può essere garantita dal confronti usando il <xref:System.Type.Equals%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.Dictionary%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Nell'esempio viene utilizzata la <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà (l'indicizzatore in c#) per recuperare i valori, dimostrando che un <xref:System.Collections.Generic.KeyNotFoundException> viene generata quando una chiave richiesta non è presente e che il valore associato alla chiave è possibile sostituire.  
  
 Nell'esempio viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> un modo più efficiente per recuperare i valori, se un programma deve provare valori di chiave che non sono presenti nel dizionario e viene illustrato come utilizzare il metodo di <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> metodo per verificare se esiste una chiave prima di chiamare il <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo.  
  
 Nell'esempio viene illustrato come enumerare le chiavi e valori nel dizionario e come enumerare le chiavi e valori da soli utilizzando il <xref:System.Collections.Generic.Dictionary%602.Keys%2A> proprietà e il <xref:System.Collections.Generic.Dictionary%602.Values%2A> proprietà.  
  
 Infine, nell'esempio viene illustrato il <xref:System.Collections.Generic.Dictionary%602.Remove%2A> metodo.  
  
 [!code-cpp[Generic.Dictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#1)]
 [!code-csharp[Generic.Dictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> può supportare più lettori contemporaneamente, fino a quando la raccolta non viene modificata. Anche in questo caso, l'enumerazione di una raccolta non è quindi una procedura thread-safe. Nel raro caso in cui un'enumerazione condivida accessi in scrittura, è necessario bloccare la raccolta durante l'intera enumerazione. Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  Per le alternative thread-safe, vedere la classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> o <see cref="T:System.Collections.Immutable.ImmutableDictionary`2" />.  Statici pubblici (<see langword="Shared" /> in Visual Basic) di questo tipo sono thread-safe.</threadsafe>
    <altmember cref="T:System.Collections.Generic.IDictionary`2" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
    <altmember cref="T:System.Collections.Generic.KeyValuePair`2" />
    <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.Dictionary`2" />, con capacità iniziale predefinita e che usa l'operatore di confronto di eguaglianza predefinito per il tipo di chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.Dictionary%602> devono essere univoci in base all'operatore di uguaglianza predefinito.  
  
 <xref:System.Collections.Generic.Dictionary%602> richiede un'implementazione di uguaglianza per determinare se le chiavi sono uguali. Questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia generica, il confronto di uguaglianza predefinito utilizza tale implementazione. In alternativa, è possibile specificare un'implementazione del <xref:System.Collections.Generic.IEqualityComparer%601> interfaccia generica con un costruttore che accetta un `comparer` parametro.  
  
> [!NOTE]
>  Se è possibile stimare le dimensioni della raccolta, usando un costruttore che specifichi la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.Generic.Dictionary%602>.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.Dictionary%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.Dictionary%602> classe.  
  
 [!code-cpp[Generic.Dictionary#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.Dictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#2)]
 [!code-vb[Generic.Dictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Immutable.IImmutableDictionary`2" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; dictionary" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Oggetto <see cref="T:System.Collections.Generic.IDictionary`2" /> i cui elementi sono copiati nel nuovo oggetto <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Dictionary`2" /> che contiene elementi copiati dall'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" /> specificata e che usa l'operatore di confronto uguaglianze predefinito per il tipo di chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.Dictionary%602> devono essere univoci in base all'impostazione predefinita di confronto uguaglianze; in modo analogo, ogni chiave nell'origine `dictionary` devono inoltre essere univoci in base all'operatore di uguaglianza predefinito.  
  
 La capacità iniziale del nuovo <xref:System.Collections.Generic.Dictionary%602> sia abbastanza grande per contenere tutti gli elementi di `dictionary`.  
  
 <xref:System.Collections.Generic.Dictionary%602> richiede un'implementazione di uguaglianza per determinare se le chiavi sono uguali. Questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia generica, il confronto di uguaglianza predefinito utilizza tale implementazione. In alternativa, è possibile specificare un'implementazione del <xref:System.Collections.Generic.IEqualityComparer%601> interfaccia generica con un costruttore che accetta un `comparer` parametro.  
  
 Questo costruttore è un'operazione o (n), dove n è il numero di elementi in `dictionary`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> costruttore per inizializzare un <xref:System.Collections.Generic.Dictionary%602> con contenuto di un altro dizionario ordinato. L'esempio di codice crea un <xref:System.Collections.Generic.SortedDictionary%602> popolarla con i dati in ordine casuale, quindi passa il <xref:System.Collections.Generic.SortedDictionary%602> per il <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> costruttore, la creazione di un <xref:System.Collections.Generic.Dictionary%602> che viene ordinato. Ciò è utile se è necessario creare un dizionario ordinato che a un certo punto diventa statico. copiare i dati da un <xref:System.Collections.Generic.SortedDictionary%602> a un <xref:System.Collections.Generic.Dictionary%602> migliora la velocità di recupero.  
  
 [!code-csharp[Generic.Dictionary.ctor_IDic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_IDic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> contiene una o più chiavi duplicate.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementazione di <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> da usare per confrontare le chiavi oppure <see langword="null" /> per usare l'oggetto <see cref="T:System.Collections.Generic.EqualityComparer`1" /> predefinito per il tipo di chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.Dictionary`2" />, con la capacità iniziale predefinita e che usa l'interfaccia <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore con gli operatori di confronto tra maiuscole e minuscole stringa fornite dal <xref:System.StringComparer> classe per creare dizionari con chiavi di stringa tra maiuscole e minuscole.  
  
 Ogni chiave in un <xref:System.Collections.Generic.Dictionary%602> devono essere univoci in base all'operatore di confronto specificato.  
  
 <xref:System.Collections.Generic.Dictionary%602> richiede un'implementazione di uguaglianza per determinare se le chiavi sono uguali. Se `comparer` viene `null`, questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia generica, il confronto di uguaglianza predefinito utilizza tale implementazione.  
  
> [!NOTE]
>  Se è possibile stimare le dimensioni della raccolta, usando un costruttore che specifichi la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.Generic.Dictionary%602>.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Collections.Generic.Dictionary%602> con un operatore di uguaglianza tra maiuscole e minuscole per le impostazioni cultura correnti. L'esempio aggiunge quattro elementi, alcune con chiavi lettere minuscole e alcuni con chiavi di lettere maiuscole. Nell'esempio vengono quindi tenta di aggiungere un elemento con una chiave che differisce da una chiave esistente solo per i casi, intercetta l'eccezione risulta e visualizza un messaggio di errore. Infine, l'esempio mostra gli elementi nel dizionario.  
  
 [!code-csharp[Generic.Dictionary.ctor_IEqC#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_IEqC/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_IEqC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_IEqC/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : int -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero iniziale degli elementi che <see cref="T:System.Collections.Generic.Dictionary`2" /> può contenere.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.Dictionary`2" />, con capacità iniziale specificata e che usa l'operatore di confronto di eguaglianza predefinito per il tipo di chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave in un <xref:System.Collections.Generic.Dictionary%602> devono essere univoci in base all'operatore di uguaglianza predefinito.  
  
 La capacità di un <xref:System.Collections.Generic.Dictionary%602> è il numero di elementi che possono essere aggiunti al <xref:System.Collections.Generic.Dictionary%602> prima che sia necessario un ridimensionamento. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Dictionary%602>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.Generic.Dictionary%602>.  
  
 <xref:System.Collections.Generic.Dictionary%602> richiede un'implementazione di uguaglianza per determinare se le chiavi sono uguali. Questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia generica, il confronto di uguaglianza predefinito utilizza tale implementazione. In alternativa, è possibile specificare un'implementazione del <xref:System.Collections.Generic.IEqualityComparer%601> interfaccia generica con un costruttore che accetta un `comparer` parametro.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene creato un dizionario con una capacità iniziale pari a 4 e lo popola con 4 voci.  
  
 [!code-csharp[Generic.Dictionary.ctor_Int32#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_Int32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di 0.</exception>
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; (dictionary, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Oggetto <see cref="T:System.Collections.Generic.IDictionary`2" /> i cui elementi sono copiati nel nuovo oggetto <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="comparer">Implementazione di <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> da usare per confrontare le chiavi oppure <see langword="null" /> per usare l'oggetto <see cref="T:System.Collections.Generic.EqualityComparer`1" /> predefinito per il tipo di chiave.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Dictionary`2" /> che contiene gli elementi copiati dall'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" /> specificata e che usa l'interfaccia <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> indicata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore con gli operatori di confronto tra maiuscole e minuscole stringa fornite dal <xref:System.StringComparer> classe per creare dizionari con chiavi di stringa tra maiuscole e minuscole.  
  
 Ogni chiave in un <xref:System.Collections.Generic.Dictionary%602> devono essere univoci in base all'oggetto specificato operatore di confronto; in modo analogo, ogni chiave nell'origine `dictionary` devono inoltre essere univoci in base all'operatore di confronto specificato.  
  
> [!NOTE]
>  Ad esempio, le chiavi duplicate possono verificarsi se `comparer` è uno degli operatori di confronto tra maiuscole e minuscole stringa fornite dal <xref:System.StringComparer> classe e `dictionary` non utilizza una chiave di confronto.  
  
 La capacità iniziale del nuovo <xref:System.Collections.Generic.Dictionary%602> sia abbastanza grande per contenere tutti gli elementi di `dictionary`.  
  
 <xref:System.Collections.Generic.Dictionary%602> richiede un'implementazione di uguaglianza per determinare se le chiavi sono uguali. Se `comparer` viene `null`, questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia generica, il confronto di uguaglianza predefinito utilizza tale implementazione.  
  
 Questo costruttore è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi in `dictionary`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%600%7D%29> costruttore per inizializzare un <xref:System.Collections.Generic.Dictionary%602> con contenuto ordinato senza distinzione di un altro dizionario. Nell'esempio di codice viene creata una <xref:System.Collections.Generic.SortedDictionary%602> con un operatore di confronto tra maiuscole e minuscole e popolarla con i dati in ordine casuale, quindi passa il <xref:System.Collections.Generic.SortedDictionary%602> per il <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%600%7D%29> costruttore, insieme a un operatore di confronto, la creazione di un <xref:System.Collections.Generic.Dictionary%602> che viene ordinato. Ciò è utile se è necessario creare un dizionario ordinato che a un certo punto diventa statico. copiare i dati da un <xref:System.Collections.Generic.SortedDictionary%602> a un <xref:System.Collections.Generic.Dictionary%602> migliora la velocità di recupero.  
  
> [!NOTE]
>  Quando si crea un nuovo dizionario con un operatore di confronto tra maiuscole e minuscole e viene popolato con le voci da un dizionario che usa un operatore di confronto tra maiuscole e minuscole, come nel seguente esempio, si verifica un'eccezione se il dizionario di input contiene chiavi che differiscono solo dalle maiuscole o minuscole.  
  
 [!code-csharp[Generic.Dictionary.ctor_IDicIEqC#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_IDicIEqC/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_IDicIEqC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_IDicIEqC/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> contiene una o più chiavi duplicate.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (int capacity, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(int capacity, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : int * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero iniziale degli elementi che <see cref="T:System.Collections.Generic.Dictionary`2" /> può contenere.</param>
        <param name="comparer">Implementazione di <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> da usare per confrontare le chiavi oppure <see langword="null" /> per usare l'oggetto <see cref="T:System.Collections.Generic.EqualityComparer`1" /> predefinito per il tipo di chiave.</param>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.Dictionary`2" />, con la capacità iniziale specificata e che usa l'interfaccia <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore con gli operatori di confronto tra maiuscole e minuscole stringa fornite dal <xref:System.StringComparer> classe per creare dizionari con chiavi di stringa tra maiuscole e minuscole.  
  
 Ogni chiave in un <xref:System.Collections.Generic.Dictionary%602> devono essere univoci in base all'operatore di confronto specificato.  
  
 La capacità di un <xref:System.Collections.Generic.Dictionary%602> è il numero di elementi che possono essere aggiunti al <xref:System.Collections.Generic.Dictionary%602> prima che sia necessario un ridimensionamento. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.Dictionary%602>, incrementata automaticamente come richiesto dalla riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi per il <xref:System.Collections.Generic.Dictionary%602>.  
  
 <xref:System.Collections.Generic.Dictionary%602> richiede un'implementazione di uguaglianza per determinare se le chiavi sono uguali. Se `comparer` viene `null`, questo costruttore utilizza l'operatore di confronto di uguaglianza predefinito, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Se tipo `TKey` implementa la <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia generica, il confronto di uguaglianza predefinito utilizza tale implementazione.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Collections.Generic.Dictionary%602> con una capacità iniziale pari a 5 e un operatore di confronto per le impostazioni cultura correnti. L'esempio aggiunge quattro elementi, alcune con chiavi lettere minuscole e alcuni con chiavi di lettere maiuscole. Nell'esempio vengono quindi tenta di aggiungere un elemento con una chiave che differisce da una chiave esistente solo per i casi, intercetta l'eccezione risulta e visualizza un messaggio di errore. Infine, l'esempio mostra gli elementi nel dizionario.  
  
 [!code-csharp[Generic.Dictionary.ctor_Int32IEqC#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32IEqC/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_Int32IEqC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32IEqC/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di 0.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Dictionary (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Dictionary(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="context">Struttura <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato alla classe <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.Dictionary`2" /> con dati serializzati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene chiamato durante la deserializzazione per ricostituire l'oggetto trasmesso su un flusso. Per altre informazioni, vedere [serializzazione XML e SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Runtime.Serialization" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit&#xA;override this.Add : 'Key * 'Value -&gt; unit" Usage="dictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da aggiungere.</param>
        <param name="value">Valore dell'elemento da aggiungere. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Aggiunge la chiave e il valore specificati al dizionario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È anche possibile usare il <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave non esiste nel <xref:System.Collections.Generic.Dictionary%602>, ad esempio `myCollection[myKey] = myValue` (in Visual Basic `myCollection(myKey) = myValue`). Tuttavia, se la chiave specificata esiste già nella <xref:System.Collections.Generic.Dictionary%602>, impostando il <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo genera un'eccezione se un valore con la chiave specificata esiste già.  
  
 Se il <xref:System.Collections.Generic.Dictionary%602.Count%2A> valore della proprietà è già pari alla capacità, la capacità del <xref:System.Collections.Generic.Dictionary%602> viene aumentata automaticamente la riallocazione della matrice interna, e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Non può essere una chiave `null`, ma un valore può essere, se `TValue` è un tipo riferimento.  
  
 Se <xref:System.Collections.Generic.Dictionary%602.Count%2A> è minore della capacità, questo metodo si avvicina a un'operazione o (1). Se è necessario aumentare la capacità per contenere il nuovo elemento, questo metodo diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.Dictionary%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.Dictionary%602> classe.  
  
 [!code-cpp[Generic.Dictionary#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.Dictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#2)]
 [!code-vb[Generic.Dictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Generic.Dictionary`2" /> è già presente un elemento con la stessa chiave.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="dictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutte le chiavi e i valori della raccolta <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.Dictionary%602.Count%2A> è impostata su 0 e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta. La capacità non subisce modifiche.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la capacità del dizionario.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, che viene usato per determinare l'uguaglianza delle chiavi per il dizionario.</summary>
        <value>Implementazione dell'interfaccia generica <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> che viene usata per determinare l'uguaglianza fra chiavi del dizionario <see cref="T:System.Collections.Generic.Dictionary`2" /> corrente e per fornire i valori hash delle chiavi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Dictionary%602> richiede un'implementazione di uguaglianza per determinare se le chiavi sono uguali. È possibile specificare un'implementazione del <xref:System.Collections.Generic.IEqualityComparer%601> interfaccia generica con un costruttore che accetta un `comparer` parametro; se non si specifica uno, l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> viene utilizzato.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="dictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <summary>Determina se la raccolta <see cref="T:System.Collections.Generic.Dictionary`2" /> contiene la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.Dictionary`2" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si avvicina a un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> metodo per verificare se esiste una chiave prima di chiamare il <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo. Viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> metodo per recuperare valori che è un modo efficiente per recuperare i valori quando un programma prova spesso chiavi che non sono presenti nel dizionario. Infine, Mostra il modo meno efficiente per verificare se esistono chiavi, tramite il <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà (l'indicizzatore in c#).  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.Dictionary%602> classe (`openWith` è il nome del dizionario utilizzato in questo esempio).  
  
 [!code-cpp[Generic.Dictionary#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#6)]
 [!code-csharp[Generic.Dictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#6)]
 [!code-vb[Generic.Dictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#6)]  
[!code-cpp[Generic.Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#5)]
[!code-vb[Generic.Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#5)]  
[!code-cpp[Generic.Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.ContainsValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsValue (value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.ContainsValue : 'Value -&gt; bool" Usage="dictionary.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Valore da individuare in <see cref="T:System.Collections.Generic.Dictionary`2" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Stabilisce se <see cref="T:System.Collections.Generic.Dictionary`2" /> contiene un valore specifico.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.Dictionary`2" /> contiene un elemento con il valore specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `TValue`, il tipo di valori nel dizionario.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, è proporzionale al tempo di esecuzione medio <xref:System.Collections.Generic.Dictionary%602.Count%2A>. Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <value>Numero di coppie chiave/valore contenute in <see cref="T:System.Collections.Generic.Dictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.Dictionary%602> è il numero di elementi che la <xref:System.Collections.Generic.Dictionary%602> può archiviare. Il <xref:System.Collections.Generic.Dictionary%602.Count%2A> proprietà è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.Dictionary%602>.  
  
 La capacità è sempre maggiore o uguale a <xref:System.Collections.Generic.Dictionary%602.Count%2A>. Se <xref:System.Collections.Generic.Dictionary%602.Count%2A> durante l'aggiunta di elementi supera la capacità, la capacità viene aumentata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="dictionary.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Dictionary`2/Enumerator&lt;!TKey, !TValue&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Dictionary(Of TKey, TValue).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Enumerator" Usage="dictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione di <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <returns>Struttura <see cref="T:System.Collections.Generic.Dictionary`2.Enumerator" /> della raccolta <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ai fini dell'enumerazione, ogni elemento è un <xref:System.Collections.Generic.KeyValuePair%602> struttura che rappresenta un valore e la relativa chiave.  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> è indefinita. È necessario chiamare il <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A>.  
  
 Il <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> proprietà restituisce lo stesso elemento finché il <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> metodo viene chiamato. <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> oppure <xref:System.Collections.Generic.Dictionary%602.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Dictionary`2.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dictionary.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene le informazioni necessarie a serializzare l'istanza di <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="context">Struttura <see cref="T:System.Runtime.Serialization.StreamingContext" /> che contiene l'origine e la destinazione del flusso serializzato associato all'istanza della raccolta <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <summary>Implementa l'interfaccia <see cref="T:System.Runtime.Serialization.ISerializable" /> e restituisce i dati necessari a serializzare l'istanza di <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire servizi di serializzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /> azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede attendibilità totale per il chiamante immediato. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.Dictionary`2.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave del valore da ottenere o impostare.</param>
        <summary>Ottiene o imposta il valore associato alla chiave specificata.</summary>
        <value>Valore associato alla chiave specificata. Se la chiave specificata non viene trovata, un'operazione Get genera un'eccezione <see cref="T:System.Collections.Generic.KeyNotFoundException" />, mentre un'operazione Set crea una nuovo elemento con la chiave specificata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di accedere a un elemento specifico nella raccolta utilizzando la sintassi c# seguente: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
 È anche possibile usare il <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave non esiste nel <xref:System.Collections.Generic.Dictionary%602>. Quando si imposta il valore della proprietà se la chiave nel <xref:System.Collections.Generic.Dictionary%602>, il valore associato a tale chiave viene sostituito dal valore assegnato. Se la chiave non è nel <xref:System.Collections.Generic.Dictionary%602>, la chiave e il valore vengono aggiunti al dizionario. Al contrario, il <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Non può essere una chiave `null`, ma un valore può essere, se il valore di tipo `TValue` è un tipo riferimento.  
  
 Nel linguaggio c# viene utilizzata la parola chiave per definire gli indicizzatori anziché implementare la <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.Dictionary%602.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Ottenere o impostare il valore di questa proprietà si avvicina a un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà (l'indicizzatore in c#) per recuperare i valori, dimostrando che un <xref:System.Collections.Generic.KeyNotFoundException> viene generata quando una chiave richiesta non è presente e che il valore associato alla chiave è possibile sostituire.  
  
 Nell'esempio viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> metodo in modo più efficiente per recuperare i valori se un programma deve provare spesso valori di chiave che non sono presenti nel dizionario.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.Dictionary%602> classe. `openWith` è il nome del dizionario utilizzato in questo esempio.  
  
 [!code-cpp[Generic.Dictionary#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.Dictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#2)]
 [!code-vb[Generic.Dictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#2)]  
[!code-cpp[Generic.Dictionary#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#3)]
[!code-csharp[Generic.Dictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#3)]
[!code-vb[Generic.Dictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#3)]  
[!code-cpp[Generic.Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#4)]  
[!code-cpp[Generic.Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#5)]
[!code-vb[Generic.Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Durante il recupero della proprietà, la chiave indicata nel parametro <paramref name="key" /> non è stata trovata nella raccolta.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.KeyCollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.Dictionary`2/KeyCollection&lt;!TKey, !TValue&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As Dictionary(Of TKey, TValue).KeyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::KeyCollection ^ Keys { System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::KeyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.KeyCollection" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+KeyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta contenente le chiavi della classe <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <value>Raccolta <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection" /> contenente le chiavi della classe <see cref="T:System.Collections.Generic.Dictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine delle chiavi nel <xref:System.Collections.Generic.Dictionary%602.KeyCollection> non è specificato, ma è lo stesso ordine dei valori associati nel <xref:System.Collections.Generic.Dictionary%602.ValueCollection> restituito dal <xref:System.Collections.Generic.Dictionary%602.Values%2A> proprietà.  
  
 L'oggetto restituito <xref:System.Collections.Generic.Dictionary%602.KeyCollection> non è una copia statica, bensì il <xref:System.Collections.Generic.Dictionary%602.KeyCollection> non fa riferimento alle chiavi nell'originale <xref:System.Collections.Generic.Dictionary%602>. Di conseguenza, le modifiche per il <xref:System.Collections.Generic.Dictionary%602> continuano a essere riflessi nel <xref:System.Collections.Generic.Dictionary%602.KeyCollection>.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come enumerare le chiavi nel dizionario usando il <xref:System.Collections.Generic.Dictionary%602.Keys%2A> proprietà e come enumerare le chiavi e valori nel dizionario.  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito (`openWith` è il nome del dizionario utilizzato in questo esempio). Vedere <xref:System.Collections.Generic.Dictionary%602>.  
  
 [!code-cpp[Generic.Dictionary#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#9)]
 [!code-csharp[Generic.Dictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#9)]
 [!code-vb[Generic.Dictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#9)]  
[!code-cpp[Generic.Dictionary#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#7)]
[!code-csharp[Generic.Dictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Dictionary`2.KeyCollection" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="dictionary.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Origine dell'evento di deserializzazione.</param>
        <summary>Implementa l'interfaccia <see cref="T:System.Runtime.Serialization.ISerializable" /> e genera l'evento di deserializzazione quando la deserializzazione è completa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">L'oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> associato all'istanza corrente di <see cref="T:System.Collections.Generic.Dictionary`2" /> non è valido.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.Dictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool&#xA;override this.Remove : 'Key -&gt; bool" Usage="dictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da rimuovere.</param>
        <summary>Rimuove il valore con la chiave specificata dalla raccolta <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <returns>
          <see langword="true" /> se l'elemento viene trovato e rimosso; in caso contrario, <see langword="false" />.  Questo metodo restituisce anche <see langword="false" /> se <paramref name="key" /> non viene trovato in <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Collections.Generic.Dictionary%602> non contiene un elemento con la chiave specificata, il <xref:System.Collections.Generic.Dictionary%602> non subisce modifiche. Non viene generata alcuna eccezione.  
  
 Questo metodo si avvicina a un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere una coppia chiave/valore da un dizionario tramite il <xref:System.Collections.Generic.Dictionary%602.Remove%2A> metodo.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.Dictionary%602> classe (`openWith` è il nome del dizionario utilizzato in questo esempio).  
  
 [!code-cpp[Generic.Dictionary#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#10)]
 [!code-csharp[Generic.Dictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#10)]
 [!code-vb[Generic.Dictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Remove(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key *  -&gt; bool" Usage="dictionary.Remove (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), index As Integer) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int index) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of TKey) Implements IDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TKey&gt; ^ System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of TValue) Implements IDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TValue&gt; ^ System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.ICollection`1" />. La matrice deve avere un'indicizzazione in base zero.</param>
        <param name="index">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia gli elementi dell'interfaccia <see cref="T:System.Collections.Generic.ICollection`1" /> in una matrice, iniziando dall'indice di matrice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni elemento copiato da un <xref:System.Collections.Generic.Dictionary%602> è un <xref:System.Collections.Generic.KeyValuePair%602> struttura che rappresenta un valore e la relativa chiave.  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.ICollection> non può essere eseguire automaticamente il cast al tipo di destinazione `array`, le implementazioni non generiche di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> generano un <xref:System.InvalidCastException>, mentre le implementazioni generiche generano un <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  -oppure-  <paramref name="array" /> non ha indicizzazione a base zero.  -oppure-  Il numero di elementi nell'insieme di origine <see cref="T:System.Collections.Generic.ICollection`1" /> è maggiore dello spazio disponibile tra <paramref name="index" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.  -oppure-  Non è possibile eseguire automaticamente il cast del tipo dell'insieme <see cref="T:System.Collections.Generic.ICollection`1" /> di origine nel tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.Dictionary`2" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, altri thread può modificare la raccolta, che può causare l'enumeratore generare un'eccezione. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà restituisce un oggetto che può essere usato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano l'oggetto prima di accedere alla raccolta.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà restituisce un oggetto che può essere usato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano l'oggetto prima di accedere alla raccolta. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà per c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Oggetto da usare come chiave.</param>
        <param name="value">Oggetto da usare come valore.</param>
        <summary>Aggiunge la chiave e il valore specificati al dizionario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È anche possibile usare il <xref:System.Collections.IDictionary.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel dizionario; ad esempio, `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel dizionario, l'impostazione di <xref:System.Collections.IDictionary.Item%2A> proprietà sovrascrive il valore precedente. Al contrario, il <xref:System.Collections.IDictionary.Add%2A> metodo genera un'eccezione se la chiave specificata esiste già.  
  
 Se <xref:System.Collections.Generic.Dictionary%602.Count%2A> è minore della capacità, questo metodo si avvicina a un'operazione o (1). Se la capacità deve essere incrementata per far posto al nuovo elemento, questo metodo diventa un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come accedere il <xref:System.Collections.Generic.Dictionary%602> classe tramite il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia. L'esempio di codice crea un oggetto vuoto <xref:System.Collections.Generic.Dictionary%602> delle stringhe con chiavi string e viene utilizzato il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene dimostrato che la <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata o quando viene fornita una chiave o il valore del tipo di dati non corretto.  
  
 L'esempio di codice illustra l'uso di diversi altri membri del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il tipo della chiave indicata nel parametro <paramref name="key" /> non è assegnabile al tipo di chiave <paramref name="TKey" /> dell'insieme <see cref="T:System.Collections.Generic.Dictionary`2" />.  -oppure-  Il tipo di <paramref name="value" /> non è assegnabile a <paramref name="TValue" />, il tipo di valori in <see cref="T:System.Collections.Generic.Dictionary`2" />.  -oppure-  Nell'insieme <see cref="T:System.Collections.Generic.Dictionary`2" /> è già presente un valore con la stessa chiave.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.IDictionary" />.</param>
        <summary>Determina se <see cref="T:System.Collections.IDictionary" /> contiene un elemento con la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.IDictionary" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce `false` se `key` è di un tipo che non è assegnabile al tipo di chiave `TKey` del <xref:System.Collections.Generic.Dictionary%602>.  
  
 Questo metodo si avvicina a un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Contains%2A> metodo per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.Dictionary%602>. Nell'esempio viene illustrato che il metodo restituisce `false` se viene fornita una chiave del tipo di dati non corretto.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.Dictionary.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce <see cref="T:System.Collections.IDictionaryEnumerator" /> per <see cref="T:System.Collections.IDictionary" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> per l'oggetto <see cref="T:System.Collections.IDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ai fini dell'enumerazione, ogni elemento è un <xref:System.Collections.DictionaryEntry> struttura.  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Il <xref:System.Collections.IEnumerator.Reset%2A> metodo riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IDictionaryEnumerator.Entry%2A> è indefinita. Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IDictionaryEnumerator.Entry%2A>.  
  
 Il <xref:System.Collections.IDictionaryEnumerator.Entry%2A> proprietà restituisce lo stesso elemento finché non il <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> metodo viene chiamato. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IDictionaryEnumerator.Entry%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IDictionaryEnumerator.Entry%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come enumerare le coppie chiave/valore nel dizionario mediante il `foreach` istruzione (`For Each` in Visual Basic `for each` in C++), che nasconde l'utilizzo dell'enumeratore. In particolare, si noti che l'enumeratore per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia restituisce <xref:System.Collections.DictionaryEntry> oggetti anziché <xref:System.Collections.Generic.KeyValuePair%602> oggetti.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IDictionary" /> ha dimensioni fisse.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IDictionary" /> è di dimensioni fisse; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.Dictionary`2" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la sua creazione, ma consente la modifica degli elementi esistenti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IDictionary" /> è di sola lettura.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IDictionary" /> è di sola lettura; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.Dictionary`2" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IDictionary.Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave del valore da ottenere.</param>
        <summary>Ottiene o imposta il valore con la chiave specificata.</summary>
        <value>Valore associato alla chiave specificata o <see langword="null" /> se <paramref name="key" /> non è presente nel dizionario o se il tipo di <paramref name="key" /> non può essere assegnato al tipo di chiave <paramref name="TKey" /> di <see cref="T:System.Collections.Generic.Dictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di accedere a un valore specifico nella raccolta utilizzando la sintassi c# seguente: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
 È anche possibile usare il <xref:System.Collections.IDictionary.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel dizionario; ad esempio, `myCollection["myNonexistentKey"] = myValue`. Tuttavia, se la chiave specificata esiste già nel dizionario, l'impostazione di <xref:System.Collections.IDictionary.Item%2A> proprietà sovrascrive il valore precedente. Al contrario, il <xref:System.Collections.IDictionary.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Nel linguaggio c# viene utilizzata la [ciò](~/docs/csharp/language-reference/keywords/this.md) (parola chiave) per definire gli indicizzatori anziché implementare la <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Ottenere o impostare il valore di questa proprietà si avvicina a un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A> proprietà (l'indicizzatore in c#) del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.Dictionary%602>e la proprietà le differenze tra la <xref:System.Collections.Generic.Dictionary%602.Item%2A?displayProperty=nameWithType> proprietà.  
  
 L'esempio mostra che, come le <xref:System.Collections.Generic.Dictionary%602.Item%2A?displayProperty=nameWithType> proprietà, il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> proprietà possibile modificare il valore associato a una chiave esistente e può essere utilizzata per aggiungere una nuova coppia chiave/valore se la chiave specificata non è presente nel dizionario. L'esempio mostra anche che a differenza di <xref:System.Collections.Generic.Dictionary%602.Item%2A?displayProperty=nameWithType> proprietà, il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> proprietà non genera un'eccezione se `key` non è presente nel dizionario, bensì restituisce un riferimento null. Infine, nell'esempio viene illustrato che quando si ottiene il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> proprietà restituisce un riferimento null se `key` non è il tipo di dati corretto e che l'impostazione della proprietà genera un'eccezione se `key` non corrisponde al tipo di dati corretto.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.Dictionary.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.Dictionary.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Viene assegnato un valore e il tipo di <paramref name="key" /> non può essere assegnato al tipo di chiave <paramref name="TKey" /> della classe<see cref="T:System.Collections.Generic.Dictionary`2" />.  -oppure-  Viene assegnato un valore e il tipo di <paramref name="value" /> non può essere assegnato al tipo di valore <paramref name="TValue" /> di <see cref="T:System.Collections.Generic.Dictionary`2" />.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.ICollection" /> contenente le chiavi di <see cref="T:System.Collections.IDictionary" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.ICollection" /> contenente le chiavi dell'interfaccia <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine delle chiavi nell'oggetto restituito <xref:System.Collections.ICollection> non è specificato, ma è sicuramente identico all'ordine dei valori corrispondenti nel <xref:System.Collections.ICollection> restituito dal <xref:System.Collections.IDictionary.Values%2A> proprietà.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Keys%2A> proprietà del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.Dictionary%602>, per elencare le chiavi nel dizionario. Nell'esempio viene inoltre illustrato come enumerare le coppie chiave/valore nel dizionario; Si noti che l'enumeratore per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia restituisce <xref:System.Collections.DictionaryEntry> oggetti anziché <xref:System.Collections.Generic.KeyValuePair%602> oggetti.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.Dictionary.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.Dictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento con la chiave specificata da <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si avvicina a un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Remove%2A> del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.Dictionary%602>.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.Dictionary.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.ICollection" /> contenente i valori in <see cref="T:System.Collections.IDictionary" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.ICollection" /> contenente i valori dell'interfaccia <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei valori nell'oggetto restituito <xref:System.Collections.ICollection> non è specificato, ma è sicuramente identico all'ordine delle chiavi corrispondenti nel <xref:System.Collections.ICollection> restituito dal <xref:System.Collections.IDictionary.Keys%2A> proprietà.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Values%2A> proprietà del <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfacciarsi con un <xref:System.Collections.Generic.Dictionary%602>, per elencare i valori nel dizionario. Nell'esempio viene inoltre illustrato come enumerare le coppie chiave/valore nel dizionario; Si noti che l'enumeratore per il <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfaccia restituisce <xref:System.Collections.DictionaryEntry> oggetti anziché <xref:System.Collections.Generic.KeyValuePair%602> oggetti.  
  
 L'esempio di codice fa parte di un esempio più esaustivo, tra cui output, fornito per il <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> metodo.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.Dictionary.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.Dictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di scorrere la raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Il <xref:System.Collections.IEnumerator.Reset%2A> metodo riporta l'enumeratore in questa posizione.  In questa posizione, la <xref:System.Collections.IEnumerator.Current%2A> proprietà non è definita. Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Il <xref:System.Collections.IEnumerator.Current%2A> proprietà restituisce lo stesso elemento finché non il <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> metodo viene chiamato. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive alle <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituiti `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta, pertanto il processo di enumerazione di una raccolta non è di per sé thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="dictionary.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TrimExcess(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess(int capacity);" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : int -&gt; unit" Usage="dictionary.TrimExcess capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TryAdd(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (key As TKey, value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'Key * 'Value -&gt; bool" Usage="dictionary.TryAdd (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="dictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Chiave del valore da ottenere.</param>
        <param name="value">Quando termina, questo metodo restituisce il valore associato alla chiave specificata, se la chiave viene trovata; in caso contrario, restituisce il valore predefinito per il tipo del parametro <c>value</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Ottiene il valore associato alla chiave specificata.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.Dictionary`2" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo combina la funzionalità del <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> metodo e il <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà.  
  
 Se la chiave non viene trovata, il parametro `value` ottiene il valore predefinito per il tipo `TValue`; ad esempio 0 (zero) per i tipi Integer, `false` per i tipi Boolean e `null` per i tipi di riferimento.  
  
 Utilizzare il <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> metodo se il codice spesso tenta di accedere alle chiavi che non sono presenti nel dizionario. Utilizzando questo metodo è più efficiente rilevamento il <xref:System.Collections.Generic.KeyNotFoundException> generate dal <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà.  
  
 Questo metodo si avvicina a un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio viene illustrato come utilizzare il <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> metodo in modo più efficiente per recuperare i valori in un programma che prova spesso chiavi che non sono presenti nel dizionario. Per contrasto, nell'esempio viene inoltre illustrato il modo in cui <xref:System.Collections.Generic.Dictionary%602.Item%2A> proprietà (l'indicizzatore in c#) genera eccezioni durante il tentativo di recupero chiavi inesistenti.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.Dictionary%602> classe (`openWith` è il nome del dizionario utilizzato in questo esempio).  
  
 [!code-cpp[Generic.Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#5)]
 [!code-csharp[Generic.Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#5)]
 [!code-vb[Generic.Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#5)]  
[!code-cpp[Generic.Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.ValueCollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.Dictionary`2/ValueCollection&lt;!TKey, !TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As Dictionary(Of TKey, TValue).ValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::ValueCollection ^ Values { System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::ValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.ValueCollection" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+ValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta contenente i valori di <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <value>Raccolta <see cref="T:System.Collections.Generic.Dictionary`2.ValueCollection" /> contenente i valori di <see cref="T:System.Collections.Generic.Dictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei valori in <xref:System.Collections.Generic.Dictionary%602.ValueCollection> non è specificato, ma è lo stesso delle chiavi associate in <xref:System.Collections.Generic.Dictionary%602.KeyCollection> restituito dalla proprietà <xref:System.Collections.Generic.Dictionary%602.Keys%2A>.  
  
 L'oggetto restituito <xref:System.Collections.Generic.Dictionary%602.ValueCollection> non è una copia statica, bensì il <xref:System.Collections.Generic.Dictionary%602.ValueCollection> non fa riferimento ai valori nell'originale <xref:System.Collections.Generic.Dictionary%602>. Di conseguenza, le modifiche per il <xref:System.Collections.Generic.Dictionary%602> continuano a essere riflessi nel <xref:System.Collections.Generic.Dictionary%602.ValueCollection>.  
  
 Ottenere il valore di questa proprietà è un'operazione o (1).  
  
   
  
## Examples  
 Questo esempio di codice viene illustrato come enumerare i valori nel dizionario usando il <xref:System.Collections.Generic.Dictionary%602.Values%2A> proprietà e come enumerare le chiavi e valori nel dizionario.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Collections.Generic.Dictionary%602> classe (`openWith` è il nome del dizionario utilizzato in questo esempio).  
  
 [!code-cpp[Generic.Dictionary#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#8)]
 [!code-csharp[Generic.Dictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#8)]
 [!code-vb[Generic.Dictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#8)]  
[!code-cpp[Generic.Dictionary#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#7)]
[!code-csharp[Generic.Dictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Dictionary`2.ValueCollection" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>