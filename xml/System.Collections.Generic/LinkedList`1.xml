<Type Name="LinkedList&lt;T&gt;" FullName="System.Collections.Generic.LinkedList&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f4f915bbf25b5784d684d30fa9b51ea4c57557ac" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30370865" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class LinkedList&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit LinkedList`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.LinkedList`1" />
  <TypeSignature Language="VB.NET" Value="Public Class LinkedList(Of T)&#xA;Implements ICollection, ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class LinkedList : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Specifica il tipo di elemento dell'elenco collegato.</typeparam>
    <summary>Rappresenta un elenco a doppio collegamento.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> è un elenco collegato di uso generale. Supporta gli enumeratori e implementa il <xref:System.Collections.ICollection> interfaccia, in modo coerente con altre classi di raccolte in .NET Framework.  
  
 <xref:System.Collections.Generic.LinkedList%601> fornisce nodi separati di tipo <xref:System.Collections.Generic.LinkedListNode%601>, pertanto l'inserimento e rimozione sono operazioni o (1).  
  
 È possibile rimuovere i nodi e inserirli nell'elenco dello stesso o in un altro elenco, con conseguente non allocati nell'heap di oggetti aggiuntivi. Poiché l'elenco anche mantiene un conteggio interno, ottenere il <xref:System.Collections.Generic.LinkedList%601.Count%2A> proprietà è un'operazione o (1).  
  
 Ogni nodo in un <xref:System.Collections.Generic.LinkedList%601> oggetto è di tipo <xref:System.Collections.Generic.LinkedListNode%601>. Poiché il <xref:System.Collections.Generic.LinkedList%601> doppio è collegato, ogni nodo punta in avanti per il <xref:System.Collections.Generic.LinkedListNode%601.Next%2A> nodo e con le versioni precedenti per il <xref:System.Collections.Generic.LinkedListNode%601.Previous%2A> nodo.  
  
 Gli elenchi che contengono i tipi di riferimento prestazioni migliori quando un nodo e il relativo valore vengono creati nello stesso momento. <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> tipi di proprietà per riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuota, il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A> contengono proprietà `null`.  
  
 La <xref:System.Collections.Generic.LinkedList%601> classe non supporta il concatenamento, divisione, cicli o altre funzionalità che è possibile lasciare l'elenco in uno stato incoerente. L'elenco rimane coerenza su un thread singolo. L'unico scenario multithreading supportato da <xref:System.Collections.Generic.LinkedList%601> è multithreading le operazioni di lettura.  
  
   
  
## Examples  
 Esempio di codice seguente illustra molte funzionalità della <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 [!code-cpp[Generic.LinkedList#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.LinkedList/cpp/source.cpp#1)]
 [!code-csharp[Generic.LinkedList#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.LinkedList/cs/source.cs#1)]
 [!code-vb[Generic.LinkedList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.LinkedList/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo non è thread-safe. Se il <see cref="T:System.Collections.Generic.LinkedList`1" /> deve essere accessibile da più thread, è necessario implementare il proprio meccanismo di sincronizzazione.  
  
 Oggetto <see cref="T:System.Collections.Generic.LinkedList`1" /> può supportare più lettori contemporaneamente, fino a quando non è possibile modificare la raccolta. Anche in questo caso, l'enumerazione di una raccolta non è quindi una procedura thread-safe. In rari casi in cui un'enumerazione condivida accessi in scrittura, è necessario bloccare la raccolta durante l'intera enumerazione. Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</threadsafe>
    <altmember cref="T:System.Collections.Generic.LinkedListNode`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LinkedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LinkedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuota, il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A> contengono proprietà `null`.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente crea e Inizializza un <xref:System.Collections.Generic.LinkedList%601> di tipo <xref:System.String>, vengono aggiunti diversi nodi e viene visualizzato il contenuto.  
  
 [!code-cpp[System.Collections.Generic.LinkedList.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.LinkedList.ctor/CPP/llctor.cpp#1)]
 [!code-csharp[System.Collections.Generic.LinkedList.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.LinkedList.ctor/CS/llctor.cs#1)]
 [!code-vb[System.Collections.Generic.LinkedList.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.LinkedList.ctor/VB/llctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LinkedList (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LinkedList(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Oggetto <see cref="T:System.Collections.IEnumerable" /> i cui elementi sono copiati nel nuovo oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.LinkedList`1" /> contenente gli elementi copiati dalla classe <see cref="T:System.Collections.IEnumerable" /> specificata e la cui capacità è sufficiente a contenere il numero di elementi copiati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se `collection` non ha elementi, il nuovo <xref:System.Collections.Generic.LinkedList%601> è vuoto e <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A> contengono proprietà `null`.  
  
 Questo costruttore è un'operazione o (n), in cui `n` è il numero di elementi in `collection`.  
  
   
  
## Examples  
 Per un esempio che include questo costruttore, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected LinkedList (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; LinkedList(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato a <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.LinkedList`1" /> serializzabile con gli oggetti <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" /> specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuota, il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A> contengono proprietà `null`.  
  
 Questo costruttore è un'operazione o (n).  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Runtime.Serialization" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAfter">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un nuovo nodo o valore dopo un nodo esistente nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAfter">
      <MemberSignature Language="C#" Value="public void AddAfter (System.Collections.Generic.LinkedListNode&lt;T&gt; node, System.Collections.Generic.LinkedListNode&lt;T&gt; newNode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfter(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node, class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; newNode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfter (node As LinkedListNode(Of T), newNode As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfter(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node, System::Collections::Generic::LinkedListNode&lt;T&gt; ^ newNode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
        <Parameter Name="newNode" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Elemento <see cref="T:System.Collections.Generic.LinkedListNode`1" /> dopo il quale inserire <c>newNode</c>.</param>
        <param name="newNode">Nuovo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> da aggiungere all'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Aggiunge il nuovo nodo specificato dopo il nodo esistente indicato nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="newNode" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> non è presente nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" /> corrente.  
  
 oppure  
  
 <paramref name="newNode" /> appartiene a un altro oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
      </Docs>
    </Member>
    <Member MemberName="AddAfter">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; AddAfter (System.Collections.Generic.LinkedListNode&lt;T&gt; node, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; AddAfter(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node, !T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddAfter (node As LinkedListNode(Of T), value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ AddAfter(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="node">Elemento <see cref="T:System.Collections.Generic.LinkedListNode`1" /> dopo il quale inserire un nuovo elemento <see cref="T:System.Collections.Generic.LinkedListNode`1" /> contenente <c>value</c>.</param>
        <param name="value">Valore da aggiungere all'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Aggiunge un nuovo nodo che contiene il valore specificato dopo il nodo esistente indicato nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <returns>Nuovo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> contenente il valore indicato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> non è presente nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" /> corrente.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBefore">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un nuovo nodo o valore prima di un nodo esistente nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBefore">
      <MemberSignature Language="C#" Value="public void AddBefore (System.Collections.Generic.LinkedListNode&lt;T&gt; node, System.Collections.Generic.LinkedListNode&lt;T&gt; newNode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBefore(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node, class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; newNode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddBefore(System.Collections.Generic.LinkedListNode{`0},System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBefore (node As LinkedListNode(Of T), newNode As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBefore(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node, System::Collections::Generic::LinkedListNode&lt;T&gt; ^ newNode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
        <Parameter Name="newNode" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Elemento <see cref="T:System.Collections.Generic.LinkedListNode`1" /> prima del quale inserire <c>newNode</c>.</param>
        <param name="newNode">Nuovo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> da aggiungere all'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Aggiunge il nuovo nodo specificato prima del nodo esistente indicato nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="newNode" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> non è presente nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" /> corrente.  
  
 oppure  
  
 <paramref name="newNode" /> appartiene a un altro oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
      </Docs>
    </Member>
    <Member MemberName="AddBefore">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; AddBefore (System.Collections.Generic.LinkedListNode&lt;T&gt; node, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; AddBefore(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node, !T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddBefore(System.Collections.Generic.LinkedListNode{`0},`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddBefore (node As LinkedListNode(Of T), value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ AddBefore(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="node">Elemento <see cref="T:System.Collections.Generic.LinkedListNode`1" /> prima del quale inserire un nuovo elemento <see cref="T:System.Collections.Generic.LinkedListNode`1" /> contenente <c>value</c>.</param>
        <param name="value">Valore da aggiungere all'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Aggiunge un nuovo nodo che contiene il valore specificato prima del nodo esistente indicato nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <returns>Nuovo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> contenente il valore indicato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> non è presente nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" /> corrente.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFirst">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un nuovo nodo o valore all'inizio dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFirst">
      <MemberSignature Language="C#" Value="public void AddFirst (System.Collections.Generic.LinkedListNode&lt;T&gt; node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFirst(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddFirst(System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFirst (node As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFirst(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Nuovo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> da aggiungere all'inizio dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Aggiunge il nuovo nodo specificato all'inizio dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuoto, il nuovo nodo diventa il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> appartiene a un altro oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="AddFirst">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; AddFirst (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; AddFirst(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddFirst(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddFirst (value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ AddFirst(T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Valore da aggiungere all'inizio dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Aggiunge un nuovo nodo contenente il valore specificato all'inizio dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <returns>Nuovo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> contenente il valore indicato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuoto, il nuovo nodo diventa il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLast">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un nuovo nodo o valore alla fine dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLast">
      <MemberSignature Language="C#" Value="public void AddLast (System.Collections.Generic.LinkedListNode&lt;T&gt; node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLast(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddLast(System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLast (node As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLast(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Nuovo oggetto <see cref="T:System.Collections.Generic.LinkedListNode`1" /> da aggiungere alla fine dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Aggiunge il nodo specificato alla fine dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuoto, il nuovo nodo diventa il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> appartiene a un altro oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
      </Docs>
    </Member>
    <Member MemberName="AddLast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; AddLast (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; AddLast(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddLast(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddLast (value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ AddLast(T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Valore da aggiungere alla fine dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Aggiunge un nuovo nodo contenente il valore specificato alla fine dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <returns>Nuovo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> contenente il valore indicato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuoto, il nuovo nodo diventa il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti i nodi dall'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601.Count%2A> è impostato su zero e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A> sono impostate su `null`.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Valore da individuare in <see cref="T:System.Collections.Generic.LinkedList`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Determina se un valore è incluso nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> è presente in <see cref="T:System.Collections.Generic.LinkedList`1" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Find(`0)" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.FindLast(`0)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="index">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia l'intero oggetto <see cref="T:System.Collections.Generic.LinkedList`1" /> in un oggetto <see cref="T:System.Array" /> compatibile unidimensionale, a partire dall'indice specificato della matrice di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono copiati il <xref:System.Array> nello stesso ordine in cui l'enumeratore scorre la <xref:System.Collections.Generic.LinkedList%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" /> di origine è maggiore dello spazio disponibile tra <paramref name="index" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di nodi effettivamente contenuti nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <value>Numero di nodi effettivamente contenuti nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Per un esempio che include questa proprietà, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; Find (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; Find(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Find(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ Find(T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Valore da individuare in <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Trova il primo nodo che contiene il valore specificato.</summary>
        <returns>Primo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> contenente il valore specificato, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.LinkedList%601> viene eseguita la ricerca in avanti a partire da <xref:System.Collections.Generic.LinkedList%601.First%2A> e fine <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.FindLast(`0)" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; FindLast (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; FindLast(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.FindLast(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ FindLast(T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Valore da individuare in <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Trova l'ultimo nodo che contiene il valore specificato.</summary>
        <returns>Ultimo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> contenente il valore specificato, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.LinkedList%601> viene eseguita con le versioni precedenti a partire dall'indice <xref:System.Collections.Generic.LinkedList%601.Last%2A> e fine <xref:System.Collections.Generic.LinkedList%601.First%2A>.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Find(`0)" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="First">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; First { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; First" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.First" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property First As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::LinkedListNode&lt;T&gt; ^ First { System::Collections::Generic::LinkedListNode&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il primo nodo dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <value>Primo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuota, il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A> contengono proprietà `null`.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Per un esempio che include questa proprietà, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedList&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.LinkedList`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As LinkedList(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedList&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedList&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione di <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.LinkedList`1.Enumerator" /> per l'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A>.  
  
 La proprietà <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A>. <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.LinkedList`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che contiene le informazioni necessarie a serializzare l'istanza di <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> che contiene l'origine e la destinazione del flusso serializzato associato all'istanza di <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Implementa l'interfaccia <see cref="T:System.Runtime.Serialization.ISerializable" /> e restituisce i dati necessari a serializzare l'istanza di <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire servizi di serializzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /> azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Last">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; Last { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; Last" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.Last" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Last As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::LinkedListNode&lt;T&gt; ^ Last { System::Collections::Generic::LinkedListNode&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'ultimo nodo dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <value>Ultimo nodo <see cref="T:System.Collections.Generic.LinkedListNode`1" /> dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuota, il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A> contengono proprietà `null`.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Per un esempio che include questa proprietà, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Origine dell'evento di deserializzazione.</param>
        <summary>Implementa l'interfaccia <see cref="T:System.Runtime.Serialization.ISerializable" /> e genera l'evento di deserializzazione quando la deserializzazione è completa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">L'oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> associato all'istanza corrente di <see cref="T:System.Collections.Generic.LinkedList`1" /> non è valido.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove la prima occorrenza di un nodo o di un valore dall'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Collections.Generic.LinkedListNode&lt;T&gt; node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Remove(System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (node As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Oggetto <see cref="T:System.Collections.Generic.LinkedListNode`1" /> da rimuovere da <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Rimuove il nodo specificato da <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> non è presente nell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" /> corrente.</exception>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Clear" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Valore da rimuovere dall'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Rimuove dall'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" /> la prima occorrenza del valore specificato.</summary>
        <returns>
          <see langword="true" /> se l'elemento contenente il valore indicato nel parametro <paramref name="value" /> viene rimosso correttamente; in caso contrario, <see langword="false" />.  Questo metodo restituisce anche <see langword="false" /> se <paramref name="value" /> non è stato trovato nell'interfaccia <see cref="T:System.Collections.Generic.LinkedList`1" /> originale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Clear" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFirst">
      <MemberSignature Language="C#" Value="public void RemoveFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFirst ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove il nodo all'inizio dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La classe <see cref="T:System.Collections.Generic.LinkedList`1" /> è vuota.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Clear" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLast">
      <MemberSignature Language="C#" Value="public void RemoveLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveLast ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove il nodo alla fine dell'oggetto <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La classe <see cref="T:System.Collections.Generic.LinkedList`1" /> è vuota.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Clear" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (value As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T value) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Valore da aggiungere alla fine dell'oggetto <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        <summary>Aggiunge un elemento alla fine dell'oggetto <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> accetta `null` come valido <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> per tipi di riferimento e consente valori duplicati.  
  
 Se il <xref:System.Collections.Generic.LinkedList%601> è vuoto, il nuovo nodo diventa il <xref:System.Collections.Generic.LinkedList%601.First%2A> e <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Per un esempio che include questo metodo, vedere la <xref:System.Collections.Generic.LinkedList%601> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.Generic.ICollection`1" /> è di sola lettura.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.ICollection`1" /> è di sola lettura; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.LinkedList`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 La proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.ICollection" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="index">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.ICollection" /> in <see cref="T:System.Array" /> a partire da un particolare indice <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.ICollection> non può essere eseguire automaticamente il cast al tipo della destinazione `array`, le implementazioni non generica di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> generare <xref:System.InvalidCastException>, mentre le implementazioni generiche generano <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="array" /> non dispone di indicizzazione in base zero.  
  
 oppure  
  
 Il numero di elementi nell'oggetto <see cref="T:System.Collections.ICollection" /> di origine è maggiore dello spazio disponibile tra <paramref name="index" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.  
  
 oppure  
  
 Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Collections.ICollection" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.LinkedList`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread bloccano questo oggetto prima di accedere alla raccolta.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.LinkedList`1" />, questa proprietà restituisce sempre l'istanza corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread bloccano questo oggetto prima di accedere alla raccolta. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà per c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di scorrere l'elenco collegato come una raccolta.</summary>
        <returns>Interfaccia <see cref="T:System.Collections.IEnumerator" /> che può essere utilizzata per scorrere l'elenco collegato come una raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte in <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>