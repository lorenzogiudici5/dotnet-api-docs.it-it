<Type Name="IDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e43824f0ab9f1a742e94324c7b888b62c65b0d2" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51303515" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDictionary`2&lt;TKey, TValue&gt; implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.IDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IEnumerable(Of KeyValuePair(Of TKey, TValue))" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public interface class IDictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;" />
  <TypeSignature Language="F#" Value="type IDictionary&lt;'Key, 'Value&gt; = interface&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TKey">Tipo delle chiavi nel dizionario.</typeparam>
    <typeparam name="TValue">Tipo dei valori nel dizionario.</typeparam>
    <summary>Rappresenta una raccolta generica di coppie chiave/valore.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.IDictionary%602> è l'interfaccia di base per le raccolte generiche di coppie chiave/valore.  
  
 Ogni elemento è una coppia chiave/valore archiviata in un <xref:System.Collections.Generic.KeyValuePair%602> oggetto.  
  
 Ogni coppia deve avere una chiave univoca. Le implementazioni possono variare nel fatto che consentano `key` essere `null`. Il valore può essere `null` e non deve essere univoco. Il <xref:System.Collections.Generic.IDictionary%602> interfaccia consente alle chiavi e contenuti i valori da enumerare, ma non implica alcun ordine particolare.  
  
 Il `foreach` istruzione del linguaggio c# (`For Each` in Visual Basic `for each` in C++) restituisce un oggetto del tipo degli elementi nella raccolta. Poiché ogni elemento del <xref:System.Collections.Generic.IDictionary%602> è una coppia chiave/valore, il tipo di elemento non è il tipo della chiave o il tipo del valore. Al contrario, il tipo di elemento è <xref:System.Collections.Generic.KeyValuePair%602>. Ad esempio:  
  
 [!code-cpp[Generic.IDictionary#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source2.cpp#11)]
 [!code-csharp[Generic.IDictionary#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source2.cs#11)]
 [!code-vb[Generic.IDictionary#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source2.vb#11)]  
  
 Il `foreach` istruzione è un wrapper per l'enumeratore, che consente solo di leggere da, non la scrittura, la raccolta.  
  
> [!NOTE]
>  Poiché le chiavi possono essere ereditate e relativo comportamento modificato, non può essere garantirne l'univocità assoluta da confronti con i <xref:System.Type.Equals%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.Dictionary%602> delle stringhe, con stringa di chiavi e vi accede tramite il <xref:System.Collections.Generic.IDictionary%602> interfaccia.  
  
 Nell'esempio di codice viene usato il <xref:System.Collections.Generic.IDictionary%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene illustrato che il <xref:System.Collections.Generic.IDictionary%602.Add%2A> Genera metodo <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 L'esempio Usa la <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà (l'indicizzatore in c#) per recuperare i valori, che illustra un <xref:System.Collections.Generic.KeyNotFoundException> viene generata quando una chiave richiesta non è presente, e che mostra che il valore associato alla chiave può essere sostituito.  
  
 L'esempio illustra come usare il <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> metodo come un modo più efficiente per recuperare i valori se un programma deve provare spesso valori di chiave che non sono presenti nel dizionario e su come usare il <xref:System.Collections.Generic.IDictionary%602.ContainsKey%2A> metodo per verificare se esiste una chiave prima di chiamare il <xref:System.Collections.Generic.IDictionary%602.Add%2A>metodo.  
  
 Infine, nell'esempio viene illustrato come enumerare le chiavi e valori nel dizionario e come enumerare solo i valori tramite la <xref:System.Collections.Generic.IDictionary%602.Values%2A> proprietà.  
  
 [!code-cpp[Generic.IDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#1)]
 [!code-csharp[Generic.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>La classe di implementazione deve avere un modo per confrontare le chiavi.</para>
    </block>
    <altmember cref="T:System.Collections.Generic.ICollection`1" />
    <altmember cref="N:System.Collections" />
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit" Usage="iDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Oggetto da usare come chiave dell'elemento da aggiungere.</param>
        <param name="value">Oggetto da usare come valore dell'elemento da aggiungere.</param>
        <summary>Aggiunge un elemento con la chiave e il valore forniti all'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È anche possibile usare la <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel dizionario; ad esempio `myCollection["myNonexistentKey"] = myValue` in c# (`myCollection("myNonexistentKey") = myValue` in Visual Basic). Tuttavia, se la chiave specificata esiste già nel dizionario, impostando il <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Generic.IDictionary%602.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Le implementazioni possono variare nella modalità con cui viene determinata l'uguaglianza degli oggetti. ad esempio, il <xref:System.Collections.Generic.List%601> utilizzato dalla classe <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, mentre le <xref:System.Collections.Generic.Dictionary%602> classe consente all'utente di specificare il <xref:System.Collections.Generic.IComparer%601> implementazione da usare per confrontare le chiavi.  
  
 Le implementazioni possono variare nel fatto che consentano `key` essere `null`.  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto vuoto <xref:System.Collections.Generic.Dictionary%602> di stringhe, con le chiavi integer e vi accede tramite il <xref:System.Collections.Generic.IDictionary%602> interfaccia. Nell'esempio di codice viene usato il <xref:System.Collections.Generic.IDictionary%602.Add%2A> metodo per aggiungere alcuni elementi. Nell'esempio viene illustrato che il <xref:System.Collections.Generic.IDictionary%602.Add%2A> metodo genera un <xref:System.ArgumentException> durante il tentativo di aggiungere una chiave duplicata.  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito. Vedere <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.IDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#2)]
 [!code-vb[Generic.IDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Generic.IDictionary`2" /> è già presente un elemento con la stessa chiave.</exception>
        <exception cref="T:System.NotSupportedException">La classe <see cref="T:System.Collections.Generic.IDictionary`2" /> è di sola lettura.</exception>
        <altmember cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
        <altmember cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool" Usage="iDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave da individuare in <see cref="T:System.Collections.Generic.IDictionary`2" />.</param>
        <summary>Determina se <see cref="T:System.Collections.Generic.IDictionary`2" /> contiene un elemento con la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.IDictionary`2" /> contiene un elemento con la chiave; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni possono variare nella modalità con cui viene determinata l'uguaglianza degli oggetti. ad esempio, il <xref:System.Collections.Generic.List%601> utilizzato dalla classe <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, mentre le <xref:System.Collections.Generic.Dictionary%602> classe consente all'utente di specificare il <xref:System.Collections.Generic.IComparer%601> implementazione da usare per confrontare le chiavi.  
  
 Le implementazioni possono variare nel fatto che consentano `key` essere `null`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.IDictionary%602.ContainsKey%2A> metodo per verificare se esiste una chiave prima di chiamare il <xref:System.Collections.Generic.IDictionary%602.Add%2A> (metodo). Viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> metodo, che può essere un modo più efficiente per recuperare i valori se un programma tenta spesso valori di chiave che non sono presenti nel dizionario. Infine, viene illustrato come inserire elementi utilizzando <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà (l'indicizzatore in c#).  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito. Vedere <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#6)]
 [!code-csharp[Generic.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#6)]
 [!code-vb[Generic.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#6)]  
[!code-cpp[Generic.IDictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.IDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#5)]
[!code-vb[Generic.IDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#5)]  
[!code-cpp[Generic.IDictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da ottenere o impostare.</param>
        <summary>Ottiene o imposta l'elemento con la chiave specificata.</summary>
        <value>Elemento con la chiave specificata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di accedere a un elemento specifico nella raccolta usando la sintassi seguente: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
 È anche possibile usare la <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà per aggiungere nuovi elementi impostando il valore di una chiave che non esiste nel dizionario; ad esempio `myCollection["myNonexistentKey"] = myValue` in c# (`myCollection("myNonexistentKey") = myValue` in Visual Basic). Tuttavia, se la chiave specificata esiste già nel dizionario, impostando il <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà sovrascrive il vecchio valore. Al contrario, il <xref:System.Collections.Generic.IDictionary%602.Add%2A> metodo non modifica gli elementi esistenti.  
  
 Le implementazioni possono variare nella modalità con cui viene determinata l'uguaglianza degli oggetti. ad esempio, il <xref:System.Collections.Generic.List%601> utilizzato dalla classe <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, mentre le <xref:System.Collections.Generic.Dictionary%602> classe consente all'utente di specificare il <xref:System.Collections.Generic.IComparer%601> implementazione da usare per confrontare le chiavi.  
  
 Il linguaggio c# usa la parola chiave per definire gli indicizzatori anziché implementare il <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.IDictionary%602.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Le implementazioni possono variare nel fatto che consentano `key` essere `null`.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà (l'indicizzatore in c#) per recuperare i valori, che illustra un <xref:System.Collections.Generic.KeyNotFoundException> viene generata quando una chiave richiesta non è presente, e che mostra che il valore associato alla chiave può essere sostituito.  
  
 Nell'esempio viene inoltre illustrato come utilizzare il <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> metodo come un modo più efficiente per recuperare i valori se un programma deve provare spesso valori di chiave che non sono presenti nel dizionario.  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito. Vedere <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#3)]
 [!code-csharp[Generic.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#3)]
 [!code-vb[Generic.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#3)]  
[!code-cpp[Generic.IDictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#4)]  
[!code-cpp[Generic.IDictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.IDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#5)]
[!code-vb[Generic.IDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">La proprietà viene recuperata e <paramref name="key" /> non viene trovato.</exception>
        <exception cref="T:System.NotSupportedException">La proprietà è stata impostata e l'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" /> è in sola lettura.</exception>
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TKey&gt; ^ Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.ICollection&lt;'Key&gt;" Usage="System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.Generic.ICollection`1" /> contenente le chiavi di <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.Generic.ICollection`1" /> contenente le chiavi dell'oggetto che implementa l'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine delle chiavi nell'oggetto restituito <xref:System.Collections.Generic.ICollection%601> non è specificato, ma è sicuramente identico all'ordine dei valori corrispondenti nel <xref:System.Collections.Generic.ICollection%601> restituiti dal <xref:System.Collections.Generic.IDictionary%602.Values%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come enumerare le sole chiavi utilizzando i <xref:System.Collections.Generic.IDictionary%602.Keys%2A> proprietà.  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito. Vedere <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#9)]
 [!code-csharp[Generic.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#9)]
 [!code-vb[Generic.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool" Usage="iDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento con la chiave specificata da <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <returns>
          <see langword="true" /> se l'elemento viene rimosso correttamente; in caso contrario, <see langword="false" />.  Questo metodo restituisce anche <see langword="false" /> se <paramref name="key" /> non è stato trovato nell'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" /> originale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni possono variare nella modalità con cui viene determinata l'uguaglianza degli oggetti. ad esempio, il <xref:System.Collections.Generic.List%601> utilizzato dalla classe <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, mentre le <xref:System.Collections.Generic.Dictionary%602> classe consente all'utente di specificare il <xref:System.Collections.Generic.IComparer%601> implementazione da usare per confrontare le chiavi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come rimuovere una coppia chiave/valore da un dizionario tramite il <xref:System.Collections.Generic.IDictionary%602.Remove%2A> (metodo).  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito. Vedere <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#10)]
 [!code-csharp[Generic.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#10)]
 [!code-vb[Generic.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La classe <see cref="T:System.Collections.Generic.IDictionary`2" /> è di sola lettura.</exception>
        <altmember cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool" Usage="iDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Chiave di cui si deve ottenere il valore.</param>
        <param name="value">Quando il metodo termina, se la chiave specificata viene trovata, viene restituito il valore associato alla chiave; in caso contrario viene restituito il valore predefinito per il tipo del parametro <c>value</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Ottiene il valore associato alla chiave specificata.</summary>
        <returns>
          <see langword="true" /> se l'oggetto che implementa l'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" /> contiene un elemento con la chiave specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo combina la funzionalità dei <xref:System.Collections.Generic.IDictionary%602.ContainsKey%2A> metodo e <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà.  
  
 Se la chiave non viene trovata, il parametro `value` ottiene il valore predefinito per il tipo `TValue`; ad esempio zero (0) per i tipi Integer, `false` per i tipi Boolean e `null` per i tipi di riferimento.  
  
   
  
## Examples  
 Nell'esempio viene illustrato come utilizzare il <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> metodo per recuperare i valori. Se un programma tenta spesso valori di chiave che non sono in un dizionario, la <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> metodo può essere più efficiente rispetto all'uso di <xref:System.Collections.Generic.IDictionary%602.Item%2A> proprietà (l'indicizzatore in c#), che genera eccezioni quando si prova a recuperare le chiavi non esistenti.  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito. Vedere <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#5)]
 [!code-csharp[Generic.IDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#5)]
 [!code-vb[Generic.IDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#5)]  
[!code-cpp[Generic.IDictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TValue&gt; ^ Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.ICollection&lt;'Value&gt;" Usage="System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Collections.Generic.ICollection`1" /> contenente i valori in <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <value>Interfaccia <see cref="T:System.Collections.Generic.ICollection`1" /> contenente i valori nell'oggetto che implementa l'interfaccia <see cref="T:System.Collections.Generic.IDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine dei valori nell'oggetto restituito <xref:System.Collections.Generic.ICollection%601> non è specificato, ma è sicuramente identico all'ordine in cui le chiavi nel <xref:System.Collections.Generic.ICollection%601> restituiti dai <xref:System.Collections.Generic.IDictionary%602.Keys%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come enumerare solo con valori di <xref:System.Collections.Generic.IDictionary%602.Values%2A> proprietà.  
  
 Questo codice è parte di un esempio più grande che può essere compilato ed eseguito. Vedere <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#8)]
 [!code-csharp[Generic.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#8)]
 [!code-vb[Generic.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
      </Docs>
    </Member>
  </Members>
</Type>