<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="47ae3da1b2bf50d9dceb876a96986d68c4c2edf0" />
    <Meta Name="ms.sourcegitcommit" Value="9f18ecaf63382fa565dfaeb7274bc1a9e81c35e9" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/19/2018" />
    <Meta Name="ms.locfileid" Value="36208874" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo di elementi contenuti nell'elenco.</typeparam>
    <summary>Rappresenta un elenco di oggetti fortemente tipizzato accessibile per indice. Fornisce metodi per la ricerca, l'ordinamento e la modifica degli elenchi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> classe è l'equivalente generico della <xref:System.Collections.ArrayList> classe. Implementa il <xref:System.Collections.Generic.IList%601> interfaccia generica usando una matrice le cui dimensioni sono incrementate in modo dinamico come richiesto.  
  
 È possibile aggiungere elementi a un <xref:System.Collections.Generic.List%601> utilizzando il <xref:System.Collections.Generic.List%601.Add%2A> o <xref:System.Collections.Generic.List%601.AddRange%2A> metodi.  
  
 La <xref:System.Collections.Generic.List%601> classe Usa un operatore di uguaglianza sia un confronto di ordinamento.  
  
-   I metodi come <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, e <xref:System.Collections.Generic.Dictionary%602.Remove%2A> usano un confronto di uguaglianza per gli elementi dell'elenco. Operatore di uguaglianza predefinito per il tipo `T` viene determinata come segue. Se tipo `T` implementa il <xref:System.IEquatable%601> interfaccia generica, il confronto di uguaglianza è il <xref:System.IEquatable%601.Equals%28%600%29> metodo dell'interfaccia; in caso contrario, l'operatore di confronto predefinito è <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   I metodi come <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> usano un confronto di ordinamento per gli elementi di elenco. Operatore di confronto predefinito per il tipo `T` viene determinata come segue.  Se tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica, l'operatore di confronto predefinito è il <xref:System.IComparable%601.CompareTo%28%600%29> metodo dell'interfaccia; in caso contrario, se tipo `T` implementa il metodo non generico <xref:System.IComparable> interfaccia, quindi il valore predefinito operatore di confronto è il <xref:System.IComparable.CompareTo%28System.Object%29> metodo di interfaccia. Se tipo `T` implementata alcuna interfaccia, non vi è alcun operatore di confronto predefinito e deve essere fornito in modo esplicito un delegato di confronto o operatore di confronto.  
  
 Il <xref:System.Collections.Generic.List%601> non è garantito da ordinare.  È necessario ordinare il <xref:System.Collections.Generic.List%601> prima di eseguire operazioni (ad esempio <xref:System.Collections.Generic.List%601.BinarySearch%2A>) che richiedono il <xref:System.Collections.Generic.List%601> da ordinare.  
  
 Elementi nella raccolta è accessibile tramite un indice intero.  Gli indici in questa raccolta sono in base zero.  
  
 Per grandi <xref:System.Collections.Generic.List%601> oggetti, è possibile aumentare la capacità massima a 2 miliardi di elementi in un sistema a 64 bit impostando il `enabled` attributo dell'elemento di configurazione per `true` nell'ambiente di runtime.  
  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente elementi duplicati.  
  
 Per una versione non modificabile del <xref:System.Collections.Generic.List%601> classe, vedere <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Decidere se utilizzare il <xref:System.Collections.Generic.List%601> o <xref:System.Collections.ArrayList> (classe), che dispongono di una funzionalità simile, tenere presente che il <xref:System.Collections.Generic.List%601> prestazioni migliori nella maggior parte dei casi e indipendente dai tipi di classe. Se viene utilizzato un tipo di riferimento per il tipo `T` del <xref:System.Collections.Generic.List%601> (classe), il comportamento delle due classi è identico. Tuttavia, se un tipo di valore viene utilizzato per il tipo `T`, è necessario considerare i problemi di conversione boxing e implementazione.  
  
 Se un tipo di valore viene utilizzato per il tipo `T`, il compilatore genera un'implementazione del <xref:System.Collections.Generic.List%601> classe in modo specifico per tale tipo di valore. Ciò significa che un elemento di elenco di un <xref:System.Collections.Generic.List%601> oggetto non deve essere sottoposto a boxing prima l'elemento può essere utilizzato e, dopo aver creati gli elementi dell'elenco di circa 500 la memoria salvata non eseguirne il boxing degli elementi di elenco è maggiore della memoria usata per generare l'implementazione della classe.  
  
 Accertarsi che il tipo di valore utilizzato per il tipo `T` implementa il <xref:System.IEquatable%601> interfaccia generica. Se non, metodi, ad esempio <xref:System.Collections.Generic.List%601.Contains%2A> deve chiamare il <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo, che l'elemento di elenco interessato caselle. Se il tipo di valore implementa il <xref:System.IComparable> interfaccia e si è proprietari del codice sorgente, implementare anche il <xref:System.IComparable%601> interfaccia generica per impedire la <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> metodi di conversione boxing di elementi dell'elenco. Se non si è proprietari del codice sorgente, passare un <xref:System.Collections.Generic.IComparer%601> dell'oggetto per il <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> metodi  
  
 È un vantaggio di usare l'implementazione specifica del tipo del <xref:System.Collections.Generic.List%601> classe anziché la <xref:System.Collections.ArrayList> classe o scrivere una raccolta di wrapper fortemente tipizzato. Il motivo è necessario eseguire l'implementazione di .NET Framework cosa è già, e common language runtime può condividere codice Microsoft intermediate language e metadati, non è l'implementazione.  
  
## <a name="f-considerations"></a>Considerazioni di F #  
 La <xref:System.Collections.Generic.List%601> classe viene utilizzata raramente nel codice F #.  In alternativa, [Elenca](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), che sono elenchi collegati singolarmente e non modificabili, sono in genere consigliabile. Un elenco di F # fornisce una serie ordinata e non modificabile di valori ed è supportato l'utilizzo nello sviluppo di stile funzionale. Quando viene utilizzata da F #, il <xref:System.Collections.Generic.List%601> classe viene in genere a cui il [ResizeArray\<' t >](https://msdn.microsoft.com/library/ee353447.aspx) digitare abbreviazione per evitare conflitti con gli elenchi di F #  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 L'esempio seguente illustra i diversi metodi e proprietà del <xref:System.Collections.Generic.List%601> classe generica di tipo stringa. (Per un esempio di un <xref:System.Collections.Generic.List%601> di tipi complessi, vedere il <xref:System.Collections.Generic.List%601.Contains%2A> metodo.)  
  
 Il costruttore predefinito viene utilizzato per creare un elenco di stringhe con la capacità predefinita. Il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata e quindi la <xref:System.Collections.Generic.List%601.Add%2A> consente di aggiungere più elementi. Sono elencati gli elementi e <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata nuovamente, insieme al <xref:System.Collections.Generic.List%601.Count%2A> proprietà, per mostrare che la capacità è stata aumentata in base alle esigenze.  
  
 Il <xref:System.Collections.Generic.List%601.Contains%2A> metodo viene utilizzato per verificare la presenza di un elemento nell'elenco, il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserire un nuovo elemento al centro dell'elenco e viene visualizzato nuovamente il contenuto dell'elenco.  
  
 Il valore predefinito <xref:System.Collections.Generic.List%601.Item%2A> proprietà (l'indicizzatore in c#) viene utilizzato per recuperare un elemento, il <xref:System.Collections.Generic.List%601.Remove%2A> viene usato il metodo per rimuovere la prima istanza dell'elemento duplicato aggiunto in precedenza e viene visualizzato nuovamente il contenuto. Il <xref:System.Collections.Generic.List%601.Remove%2A> metodo rimuove sempre la prima istanza rilevata.  
  
 Il <xref:System.Collections.Generic.List%601.TrimExcess%2A> consente di ridurre la capacità in modo che corrisponda al conteggio e <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> vengono visualizzate le proprietà. Se la capacità inutilizzata fosse stata inferiore al 10% della capacità totale, l'elenco potrebbe non stato ridimensionato.  
  
 Infine, il <xref:System.Collections.Generic.List%601.Clear%2A> metodo viene utilizzato per rimuovere tutti gli elementi nell'elenco e <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> vengono visualizzate le proprietà.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  È possibile eseguire più operazioni di lettura su un <see cref="T:System.Collections.Generic.List`1" />, ma possono verificarsi i problemi se la raccolta viene modificata durante la lettura. Per garantire la thread safety, bloccare la raccolta durante un'operazione di lettura o l'operazione di scrittura. Per abilitare una raccolta a cui accedere da più thread per la lettura e scrittura, è necessario implementare la propria sincronizzazione. Per le raccolte con sincronizzazione incorporato, vedere le classi di <see cref="N:System.Collections.Concurrent" /> dello spazio dei nomi. Per un'alternativa intrinsecamente thread-safe, vedere la <see cref="T:System.Collections.Immutable.ImmutableList`1" /> classe.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.List`1" /> vuota e con capacità iniziale predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.List%601> è il numero di elementi che la <xref:System.Collections.Generic.List%601> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.List%601>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.  
  
 Se le dimensioni della raccolta possono essere stimata tramite il <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> costruttore e specificando la capacità iniziale Elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.List%601>.  
  
 È possibile diminuire la capacità chiamando il <xref:System.Collections.Generic.List%601.TrimExcess%2A> (metodo) o impostando la <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà in modo esplicito. La riduzione della capacità, la memoria viene riallocata e copia tutti gli elementi di <xref:System.Collections.Generic.List%601>.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio seguente illustra il costruttore predefinito di <xref:System.Collections.Generic.List%601> classe generica. Il costruttore predefinito crea un elenco con la capacità predefinita, come illustrato visualizzando il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà.  
  
 L'esempio aggiunge, inserisce e rimuove gli elementi, che mostra come la capacità cambia mentre questi metodi vengono usati.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Raccolta i cui elementi vengono copiati nel nuovo elenco.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.List`1" /> che contiene gli elementi copiati dalla raccolta specificata e ha la capacità sufficiente per contenere il numero di elementi copiati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono copiati il <xref:System.Collections.Generic.List%601> nello stesso ordine in cui vengono letti dall'enumeratore della raccolta.  
  
 Questo costruttore è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi in `collection`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.%23ctor%2A> costruttore e diversi metodi della <xref:System.Collections.Generic.List%601> classe che agiscono su intervalli. Una matrice di stringhe viene creata e passata al costruttore, popolamento dell'elenco con gli elementi della matrice. Il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene quindi visualizzata, per indicare che la capacità iniziale è esattamente ciò che è richiesto per contenere gli elementi di input.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero di elementi che possono essere archiviati inizialmente nel nuovo elenco.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.List`1" /> vuota e con capacità iniziale specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.List%601> è il numero di elementi che la <xref:System.Collections.Generic.List%601> può contenere. Quando gli elementi vengono aggiunti a un <xref:System.Collections.Generic.List%601>, incrementata automaticamente come richiesto tramite la riallocazione della matrice interna.  
  
 Se è possibile stimare le dimensioni della raccolta, specificando la capacità iniziale Elimina la necessità di eseguire numerose operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.List%601>.  
  
 È possibile diminuire la capacità chiamando il <xref:System.Collections.Generic.List%601.TrimExcess%2A> (metodo) o impostando la <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà in modo esplicito. La riduzione della capacità, la memoria viene riallocata e copia tutti gli elementi di <xref:System.Collections.Generic.List%601>.  
  
 Questo costruttore è un'operazione O (*n*) operazione, in cui *n* è `capacity`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> costruttore. Oggetto <xref:System.Collections.Generic.List%601> di stringhe con una capacità pari a 4 viene creato, poiché la dimensione finale dell'elenco è esattamente 4. L'elenco viene popolato con quattro stringhe e viene creata una copia di sola lettura tramite il <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metodo.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da aggiungere alla fine di <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Aggiunge un oggetto alla fine di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente elementi duplicati.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> è già uguale <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacità del <xref:System.Collections.Generic.List%601> viene aumentata automaticamente la riallocazione della matrice interna e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> è minore di <xref:System.Collections.Generic.List%601.Capacity%2A>, questo metodo è un'operazione o (1). Se la capacità deve essere incrementata per far posto al nuovo elemento, questo metodo diventa un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 L'esempio seguente illustra i diversi metodi e proprietà del <xref:System.Collections.Generic.List%601> classe generica, inclusi il <xref:System.Collections.Generic.List%601.Add%2A> metodo. Il costruttore predefinito viene utilizzato per creare un elenco di stringhe con una capacità pari a 0. Il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata, quindi il <xref:System.Collections.Generic.List%601.Add%2A> consente di aggiungere più elementi. Sono elencati gli elementi e <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata nuovamente, insieme al <xref:System.Collections.Generic.List%601.Count%2A> proprietà, per mostrare che la capacità è stata aumentata in base alle esigenze.  
  
 Altre proprietà e metodi utilizzati per cercare, inserire e rimuovere elementi dall'elenco e infine per cancellare l'elenco.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Raccolta i cui elementi devono essere aggiunti alla fine di <see cref="T:System.Collections.Generic.List`1" />. La raccolta non può essere <see langword="null" /> ma può contenere elementi <see langword="null" /> se il tipo <c>T</c> è un tipo di riferimento.</param>
        <summary>Aggiunge gli elementi della raccolta specificata alla fine di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene mantenuto l'ordine degli elementi nella raccolta di <xref:System.Collections.Generic.List%601>.  
  
 Se il nuovo <xref:System.Collections.Generic.List%601.Count%2A> (corrente <xref:System.Collections.Generic.List%601.Count%2A> più le dimensioni della raccolta) sarà maggiore <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacità del <xref:System.Collections.Generic.List%601> viene aumentata automaticamente la riallocazione della matrice interna per contenere i nuovi elementi e gli elementi esistenti vengono copiati nella nuova matrice prima vengono aggiunti nuovi elementi.  
  
 Se il <xref:System.Collections.Generic.List%601> può contenere i nuovi elementi senza aumentare la <xref:System.Collections.Generic.List%601.Capacity%2A>, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi da aggiungere. Se la capacità deve essere incrementata per far posto i nuovi elementi, questo metodo diventa un'operazione O (*n* + *m*) operazione, in cui *n* è il numero di elementi deve essere aggiunto e *m* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.AddRange%2A> (metodo) e diversi altri metodi del <xref:System.Collections.Generic.List%601> classe che agiscono su intervalli. Una matrice di stringhe viene creata e passata al costruttore, popolamento dell'elenco con gli elementi della matrice. Il <xref:System.Collections.Generic.List%601.AddRange%2A> metodo viene chiamato con l'elenco come argomento. Il risultato è che gli elementi correnti dell'elenco vengono aggiunti alla fine dell'elenco di tutti gli elementi di duplicazione.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di sola lettura per la raccolta corrente.</summary>
        <returns>Oggetto che fa da wrapper di sola lettura per l'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per evitare che venga modificato il <xref:System.Collections.Generic.List%601> di oggetto, espongono solo tramite il wrapper. Oggetto <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> oggetto non espone i metodi che modificano la raccolta. Tuttavia, se vengono apportate modifiche alla sottostante <xref:System.Collections.Generic.List%601> dell'oggetto, la raccolta di sola lettura riflette le modifiche.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe con una capacità pari a 4 viene creato, poiché la dimensione finale dell'elenco è esattamente 4. L'elenco viene popolato con quattro stringhe e <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metodo viene utilizzato per ottenere una proprietà di sola lettura <xref:System.Collections.Generic.IList%601> implementazione dell'interfaccia generica che include l'elenco originale.  
  
 Un elemento dell'elenco originale è impostato su "Coelophysis" mediante la <xref:System.Collections.Generic.List%601.Item%2A> proprietà (l'indicizzatore in c#) e il contenuto dell'elenco di sola lettura viene visualizzato nuovamente per dimostrare che si tratta di un wrapper per l'elenco originale.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Viene usato un algoritmo di ricerca binario per individuare un elemento specifico nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato o in una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Cerca un elemento nell'intero <see cref="T:System.Collections.Generic.List`1" /> ordinato usando l'operatore di confronto predefinito e restituisce l'indice in base zero dell'elemento.</summary>
        <returns>Indice in base zero di <paramref name="item" /> nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato, se <paramref name="item" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="item" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> per tipo `T` per determinare l'ordine degli elementi di elenco. Il <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> proprietà verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa l'interfaccia, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Collections.Generic.List%601> deve essere già ordinato in base all'implementazione dell'operatore di confronto; in caso contrario, il risultato non è corretto.  
  
 Confronto tra `null` con qualsiasi riferimento tipo è consentito e non genera un'eccezione quando si utilizza il <xref:System.IComparable%601> interfaccia generica. Durante l'ordinamento, `null` viene considerato minore rispetto a qualsiasi altro oggetto.  
  
 Se il <xref:System.Collections.Generic.List%601> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze e potrebbe essere una qualsiasi delle occorrenze, non necessariamente il primo.  
  
 Se il <xref:System.Collections.Generic.List%601> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca. Quando si inserisce il valore nel <xref:System.Collections.Generic.List%601>, l'indice deve essere utilizzato come punto di inserimento per gestire l'ordinamento.  
  
 Questo metodo è un'operazione O (log *n*) operazione, in cui *n* è il numero di elementi nell'intervallo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> overload del metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, in nessun ordine particolare. L'elenco è visualizzato, ordinato e visualizzato di nuovo.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> overload del metodo viene quindi utilizzato per eseguire la ricerca di due stringhe che non sono presenti nell'elenco, e <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserirli. Il valore restituito di <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> metodo è negativo in ogni caso, poiché le stringhe non sono presenti nell'elenco. Prendendo il complemento bit per bit (il ~ (operatore) in c# e Visual C++, `Xor` -1 in Visual Basic) di questo numero negativo produce l'indice del primo elemento nell'elenco che è maggiore della stringa di ricerca e l'inserimento in questa posizione conserva l'ordinamento ordine. La seconda stringa di ricerca è maggiore di qualsiasi elemento nell'elenco, pertanto la posizione di inserimento si trova alla fine dell'elenco.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Mediante la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto predefinito non è possibile rilevare un'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o dell'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare quando si confrontano gli elementi.  -o-  <see langword="null" /> per usare la proprietà dell'operatore di confronto predefinito <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Cerca un elemento nell'intero <see cref="T:System.Collections.Generic.List`1" /> ordinato usando l'operatore di confronto specificato e restituisce l'indice in base zero dell'elemento.</summary>
        <returns>Indice in base zero di <paramref name="item" /> nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato, se <paramref name="item" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="item" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'operatore di confronto consente di personalizzare la modalità di confronto di elementi. Ad esempio, è possibile utilizzare un <xref:System.Collections.CaseInsensitiveComparer> istanza come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` viene fornito, gli elementi del <xref:System.Collections.Generic.List%601> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione.  
  
 Se `comparer` è `null`, l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa l'interfaccia, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Collections.Generic.List%601> deve essere già ordinato in base all'implementazione dell'operatore di confronto; in caso contrario, il risultato non è corretto.  
  
 Confronto tra `null` con qualsiasi riferimento tipo è consentito e non genera un'eccezione quando si utilizza il <xref:System.IComparable%601> interfaccia generica. Durante l'ordinamento, `null` viene considerato minore rispetto a qualsiasi altro oggetto.  
  
 Se il <xref:System.Collections.Generic.List%601> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze e potrebbe essere una qualsiasi delle occorrenze, non necessariamente il primo.  
  
 Se il <xref:System.Collections.Generic.List%601> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca. Quando si inserisce il valore nel <xref:System.Collections.Generic.List%601>, l'indice deve essere utilizzato come punto di inserimento per gestire l'ordinamento.  
  
 Questo metodo è un'operazione O (log *n*) operazione, in cui *n* è il numero di elementi nell'intervallo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un operatore di confronto alternativo per le stringhe denominato DinoCompare, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. L'operatore di confronto funziona nel modo seguente: prima di tutto, i termini di confronto da testare per `null`, e un riferimento null viene considerato minore rispetto a un valore non null. In secondo luogo, vengono confrontate le lunghezze di stringa e la stringa più lunga è considerata maggiore. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, in nessun ordine particolare. L'elenco viene visualizzato, ordinato usando l'operatore di confronto alternativo e visualizzata nuovamente.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo viene quindi utilizzato per eseguire la ricerca di più stringhe non in elenco, utilizzando l'operatore di confronto alternativo. Il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserire le stringhe. Questi due metodi si trovano nella funzione denominata `SearchAndInsert`, insieme al codice per utilizzare il complemento bit per bit (il ~ (operatore) in c# e Visual C++, `Xor` -1 in Visual Basic) del numero negativo restituito da <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> e utilizzarlo come indice per inserimento della nuova stringa.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e mediante la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto predefinito non è possibile rilevare un'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o dell'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Indice iniziale in base zero dell'intervallo in cui eseguire la ricerca.</param>
        <param name="count">Lunghezza dell'intervallo in cui eseguire la ricerca.</param>
        <param name="item">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare durante il confronto di elementi oppure <see langword="null" /> per usare la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto.</param>
        <summary>Cerca un elemento in un intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato usando l'operatore di confronto specificato e restituisce l'indice in base zero dell'elemento.</summary>
        <returns>Indice in base zero di <paramref name="item" /> nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato, se <paramref name="item" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="item" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'operatore di confronto consente di personalizzare la modalità di confronto di elementi. Ad esempio, è possibile utilizzare un <xref:System.Collections.CaseInsensitiveComparer> istanza come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` viene fornito, gli elementi del <xref:System.Collections.Generic.List%601> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione.  
  
 Se `comparer` è `null`, l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa l'interfaccia, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Collections.Generic.List%601> deve essere già ordinato in base all'implementazione dell'operatore di confronto; in caso contrario, il risultato non è corretto.  
  
 Confronto tra `null` con qualsiasi riferimento tipo è consentito e non genera un'eccezione quando si utilizza il <xref:System.IComparable%601> interfaccia generica. Durante l'ordinamento, `null` viene considerato minore rispetto a qualsiasi altro oggetto.  
  
 Se il <xref:System.Collections.Generic.List%601> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze e potrebbe essere una qualsiasi delle occorrenze, non necessariamente il primo.  
  
 Se il <xref:System.Collections.Generic.List%601> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca. Quando si inserisce il valore nel <xref:System.Collections.Generic.List%601>, l'indice deve essere utilizzato come punto di inserimento per gestire l'ordinamento.  
  
 Questo metodo è un'operazione O (log *n*) operazione, in cui *n* è il numero di elementi nell'intervallo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un operatore di confronto alternativo per le stringhe denominato DinoCompare, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. L'operatore di confronto funziona nel modo seguente: prima di tutto, i termini di confronto da testare per `null`, e un riferimento null viene considerato minore rispetto a un valore non null. In secondo luogo, vengono confrontate le lunghezze di stringa e la stringa più lunga è considerata maggiore. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con i nomi dei cinque dinosauri erbivori e tre dinosauri carnivori. All'interno di ognuno dei due gruppi, i nomi non sono in alcun ordinamento particolare. Viene visualizzato l'elenco, l'intervallo di erbivori viene ordinato utilizzando l'operatore di confronto alternativo e viene nuovamente visualizzato l'elenco.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo viene quindi utilizzato per la ricerca solo l'intervallo di erbivori "Brachiosaurus". La stringa non viene trovata e il complemento bit per bit (il ~ (operatore) in c# e Visual C++, `Xor` -1 in Visual Basic) del numero negativo restituito dal <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metodo viene utilizzato come indice per l'inserimento della nuova stringa.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  -o-  <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e mediante la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto predefinito non è possibile rilevare un'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o dell'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero totale di elementi che la struttura dati interna è in grado di contenere senza alcun ridimensionamento.</summary>
        <value>Numero di elementi che <see cref="T:System.Collections.Generic.List`1" /> può contenere prima che sia necessario un ridimensionamento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> è il numero di elementi che la <xref:System.Collections.Generic.List%601> consente di archiviare prima di ridimensionamento è obbligatorio, mentre <xref:System.Collections.Generic.List%601.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> è sempre maggiore di o uguale a <xref:System.Collections.Generic.List%601.Count%2A>. Se <xref:System.Collections.Generic.List%601.Count%2A> supera <xref:System.Collections.Generic.List%601.Capacity%2A> durante l'aggiunta di elementi, la capacità viene aumentata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 Se la capacità è notevolmente superiore rispetto al numero e si desidera ridurre la memoria utilizzata dal <xref:System.Collections.Generic.List%601>, è possibile ridurre la capacità chiamando il <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo o impostando la <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà in modo esplicito su un valore inferiore. Quando il valore di <xref:System.Collections.Generic.List%601.Capacity%2A> è impostato in modo esplicito, la matrice interna viene riallocata anche per consentire la capacità specificata e tutti gli elementi vengono copiati.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è un'operazione O (*n*) operazione, in cui *n* è la nuova capacità.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come controllare la capacità e conteggio di un <xref:System.Collections.Generic.List%601> che contiene un semplice oggetto business e viene illustrato l'utilizzo di <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo per rimuovere una capacità aggiuntiva.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Nell'esempio seguente il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà in diversi momenti della vita di un elenco. Il costruttore predefinito viene utilizzato per creare un elenco di stringhe con una capacità pari a 0 e <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata per dimostrare questo concetto. Dopo il <xref:System.Collections.Generic.List%601.Add%2A> metodo è stato utilizzato per aggiungere più elementi, gli elementi vengono elencati, quindi il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata nuovamente, insieme al <xref:System.Collections.Generic.List%601.Count%2A> proprietà, per mostrare che la capacità è stata aumentata in base alle esigenze.  
  
 Il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata dopo il <xref:System.Collections.Generic.List%601.TrimExcess%2A> consente di ridurre la capacità di corrispondere al numero. Infine, il <xref:System.Collections.Generic.List%601.Clear%2A> metodo viene utilizzato per rimuovere tutti gli elementi nell'elenco e <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> nuovamente, vengono visualizzate le proprietà.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'oggetto <see cref="P:System.Collections.Generic.List`1.Capacity" /> è impostato su un valore minore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile nel sistema non è sufficiente.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli elementi da <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> è impostato su 0, e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> rimane invariato. Per reimpostare la capacità del <xref:System.Collections.Generic.List%601>, chiamare il <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo o un insieme di <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà direttamente. La riduzione della capacità, la memoria viene riallocata e copia tutti gli elementi di <xref:System.Collections.Generic.List%601>. L'eliminazione di un oggetto vuoto <xref:System.Collections.Generic.List%601> imposta la capacità del <xref:System.Collections.Generic.List%601> per la capacità predefinita.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Clear%2A> (metodo) e varie altre proprietà e metodi del <xref:System.Collections.Generic.List%601> classe generica. Il <xref:System.Collections.Generic.List%601.Clear%2A> metodo viene utilizzato alla fine del programma, per rimuovere tutti gli elementi nell'elenco e <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> verranno quindi visualizzate le proprietà.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Determina se un elemento è incluso in <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> è presente in <see cref="T:System.Collections.Generic.List`1" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito, come definito dall'implementazione dell'oggetto del <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metodo per `T` (il tipo di valori nell'elenco).  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Contains%2A> e <xref:System.Collections.Generic.List%601.Exists%2A> metodi su un <xref:System.Collections.Generic.List%601> contenente un semplice oggetto business che implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Nell'esempio seguente contiene un elenco di oggetti complessi, di tipo `Cube`. Il `Cube` classe implementa il <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metodo in modo che due cubi sono considerati uguali se hanno le stesse dimensioni. In questo esempio, il <xref:System.Collections.Generic.List%601.Contains%2A> restituisce `true`, perché è già di un cubo con le dimensioni specificate nella raccolta.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Tipo degli elementi della matrice di destinazione.</typeparam>
        <param name="converter">Delegato <see cref="T:System.Converter`2" /> che converte ogni elemento da un tipo in un altro.</param>
        <summary>Converte gli elementi dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrente in un altro tipo e restituisce un elenco contenente gli elementi convertiti.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.List`1" /> del tipo di destinazione contenente gli elementi convertiti dall'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Converter%602> è un delegato a un metodo che converte un oggetto per il tipo di destinazione.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Converter%602> delegato e gli elementi convertiti vengono salvati nella nuova <xref:System.Collections.Generic.List%601>.  
  
 Corrente <xref:System.Collections.Generic.List%601> rimane invariato.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente definisce un metodo denominato `PointFToPoint` che converte un <xref:System.Drawing.PointF> struttura in un <xref:System.Drawing.Point> struttura. Nell'esempio viene quindi creato un <xref:System.Collections.Generic.List%601> di <xref:System.Drawing.PointF> strutture, crea un `Converter\<PointF, Point>` delegato (`Converter(Of PointF, Point)` in Visual Basic) per rappresentare il `PointFToPoint` , metodo e passa il delegato per il <xref:System.Collections.Generic.List%601.ConvertAll%2A> (metodo). Il <xref:System.Collections.Generic.List%601.ConvertAll%2A> metodo passa ogni elemento dell'elenco di input per il `PointFToPoint` (metodo) e inserisce gli elementi convertiti in un nuovo elenco di <xref:System.Drawing.Point> strutture. Entrambi gli elenchi vengono visualizzati.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="converter" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia <see cref="T:System.Collections.Generic.List`1" /> o una parte di esso in una matrice.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.List`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <summary>Copia l'intero oggetto <see cref="T:System.Collections.Generic.List`1" /> in una matrice compatibile unidimensionale, a partire dall'inizio della matrice di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza <xref:System.Array.Copy%2A?displayProperty=nameWithType> per copiare gli elementi.  
  
 Gli elementi vengono copiati il <xref:System.Array> nello stesso ordine in cui l'enumeratore scorre la <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i tre overload del <xref:System.Collections.Generic.List%601.CopyTo%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con 5 stringhe. Creazione di una matrice di stringa vuota di 15 elementi e <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> overload del metodo utilizzato per copiare tutti gli elementi dell'elenco nella matrice a partire dal primo elemento della matrice. Il <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> overload del metodo utilizzato per copiare tutti gli elementi dell'elenco nella matrice a partire dall'indice 6 (lasciando vuoto l'indice 5). Infine, il <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo viene utilizzato per copiare i 3 elementi nell'elenco a partire dall'indice 2, la matrice a partire dall'array indice 12 (lasciando vuoto l'indice 11). Il contenuto della matrice viene quindi visualizzato.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine è maggiore del numero di elementi che l'oggetto <paramref name="array" /> di destinazione può contenere.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.List`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia l'intero oggetto <see cref="T:System.Collections.Generic.List`1" /> in una matrice compatibile unidimensionale, a partire dall'indice specificato della matrice di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza <xref:System.Array.Copy%2A?displayProperty=nameWithType> per copiare gli elementi.  
  
 Gli elementi vengono copiati il <xref:System.Array> nello stesso ordine in cui l'enumeratore scorre la <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i tre overload del <xref:System.Collections.Generic.List%601.CopyTo%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con 5 stringhe. Creazione di una matrice di stringa vuota di 15 elementi e <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> overload del metodo utilizzato per copiare tutti gli elementi dell'elenco nella matrice a partire dal primo elemento della matrice. Il <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> overload del metodo utilizzato per copiare tutti gli elementi dell'elenco nella matrice a partire dall'indice 6 (lasciando vuoto l'indice 5). Infine, il <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo viene utilizzato per copiare i 3 elementi nell'elenco a partire dall'indice 2, la matrice a partire dall'array indice 12 (lasciando vuoto l'indice 11). Il contenuto della matrice viene quindi visualizzato.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine a partire dal quale viene effettuata la copia.</param>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.List`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <param name="count">Numero degli elementi da copiare.</param>
        <summary>Copia un intervallo di elementi da <see cref="T:System.Collections.Generic.List`1" /> in una matrice compatibile unidimensionale, a partire dall'indice specificato della matrice di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza <xref:System.Array.Copy%2A?displayProperty=nameWithType> per copiare gli elementi.  
  
 Gli elementi vengono copiati il <xref:System.Array> nello stesso ordine in cui l'enumeratore scorre la <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente illustra i tre overload del <xref:System.Collections.Generic.List%601.CopyTo%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con 5 stringhe. Creazione di una matrice di stringa vuota di 15 elementi e <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> overload del metodo utilizzato per copiare tutti gli elementi dell'elenco nella matrice a partire dal primo elemento della matrice. Il <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> overload del metodo utilizzato per copiare tutti gli elementi dell'elenco nella matrice a partire dall'indice 6 (lasciando vuoto l'indice 5). Infine, il <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo viene utilizzato per copiare i 3 elementi nell'elenco a partire dall'indice 2, la matrice a partire dall'array indice 12 (lasciando vuoto l'indice 11). Il contenuto della matrice viene quindi visualizzato.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  - oppure - <paramref name="arrayIndex" /> è minore di 0.  -oppure-  <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> è maggiore o uguale al valore di <see cref="P:System.Collections.Generic.List`1.Count" /> dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine.  -oppure- Il numero di elementi da <paramref name="index" /> alla fine dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine è maggiore dello spazio disponibile da <paramref name="arrayIndex" /> alla fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di elementi contenuti in <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>Il numero di elementi contenuti in <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> è il numero di elementi che la <xref:System.Collections.Generic.List%601> può archiviare prima che sia necessario un ridimensionamento. <xref:System.Collections.Generic.List%601.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> è sempre maggiore di o uguale a <xref:System.Collections.Generic.List%601.Count%2A>. Se <xref:System.Collections.Generic.List%601.Count%2A> supera <xref:System.Collections.Generic.List%601.Capacity%2A> durante l'aggiunta di elementi, la capacità viene aumentata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiunta di nuovi elementi.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come controllare la capacità e conteggio di un <xref:System.Collections.Generic.List%601> che contiene un semplice oggetto business e viene illustrato l'utilizzo di <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo per rimuovere una capacità aggiuntiva.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene mostrato il valore di <xref:System.Collections.Generic.List%601.Count%2A> proprietà in vari punti in tutta la durata di un elenco. Dopo che è stato creato e popolato l'elenco e i relativi elementi visualizzati, il <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> vengono visualizzate le proprietà. Queste proprietà vengono visualizzate dopo le <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo è stato chiamato e dopo il contenuto dell'elenco viene cancellato.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da cercare.</param>
        <summary>Determina se <see cref="T:System.Collections.Generic.List`1" /> contiene gli elementi che corrispondono alle condizioni definite dal predicato specificato.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.List`1" /> contiene uno o più elementi che corrispondono alle condizioni definite dal predicato specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato e l'elaborazione viene arrestata quando viene trovata una corrispondenza.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Contains%2A> e <xref:System.Collections.Generic.List%601.Exists%2A> metodi su un <xref:System.Collections.Generic.List%601> contenente un semplice oggetto business che implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Exists%2A> (metodo) e diversi metodi che utilizzano il <xref:System.Predicate%601> delegato generico.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato, che contiene 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus". Viene inoltre definito un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, e <xref:System.Collections.Generic.List%601.FindAll%2A> vengono utilizzati metodi per eseguire ricerche nell'elenco con il metodo di predicato di ricerca, quindi il <xref:System.Collections.Generic.List%601.RemoveAll%2A> consente di rimuovere tutte le voci che terminano con "saurus".  
  
 Infine, il <xref:System.Collections.Generic.List%601.Exists%2A> metodo viene chiamato. Scorre l'elenco a partire dall'inizio, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo. La ricerca si interrompe e il metodo restituisce `true` se il `EndsWithSaurus` restituisce `true` per qualsiasi elemento. Il <xref:System.Collections.Generic.List%601.Exists%2A> restituisce `false` perché sono stati rimossi tutti gli elementi.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce la prima occorrenza all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Primo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente al <xref:System.Predicate%601> delegato, lo spostamento in avanti <xref:System.Collections.Generic.List%601>, a partire dal primo elemento e terminando con l'ultimo elemento.  L'elaborazione viene arrestata quando viene trovata una corrispondenza.  
  
> [!IMPORTANT]
>  Quando la ricerca in un elenco contenente i tipi di valore, accertarsi che il valore predefinito per il tipo non soddisfa il predicato di ricerca. In caso contrario, non è possibile distinguere tra un valore predefinito, che indica che è stata trovata alcuna corrispondenza e un elemento di elenco con il valore predefinito per il tipo. Se il valore predefinito soddisfa il predicato di ricerca, utilizzare il <xref:System.Collections.Generic.List%601.FindIndex%2A> metodo invece.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il metodo <xref:System.Collections.Generic.List%601.Find%2A> su un <xref:System.Collections.Generic.List%601> contenente un oggetto complesso semplice.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 L'esempio seguente illustra i metodi di ricerca per la <xref:System.Collections.Generic.List%601> classe. L'esempio per il <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, utilizzando i dati di [File XML di esempio: libri (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dai dati XML per i valori delle proprietà di `book` oggetti.  
  
 Nella tabella seguente vengono descritti gli esempi forniti per i metodi di ricerca.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri il cui `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta con una data di pubblicazione prima del 2001, utilizzando il `PubBefore2001` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da cercare.</param>
        <summary>Recupera tutti gli elementi che soddisfano le condizioni definite nel predicato specificato.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.List`1" /> contenente tutti gli elementi che corrispondono alle condizioni definite dal predicato specificato, se presente; in caso contrario, un oggetto <see cref="T:System.Collections.Generic.List`1" /> vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato e gli elementi che soddisfano le condizioni vengono salvati nell'oggetto restituito <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i metodi di ricerca per la <xref:System.Collections.Generic.List%601> classe. L'esempio per il <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, utilizzando i dati di [File XML di esempio: libri (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dai dati XML per i valori delle proprietà di `book` oggetti.  
  
 Nella tabella seguente vengono descritti gli esempi forniti per i metodi di ricerca.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri il cui `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta con una data di pubblicazione prima del 2001, utilizzando il `PubBefore2001` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cerca un elemento che corrisponda alle condizioni definite da un predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di <see cref="T:System.Collections.Generic.List`1" /> o di una parte di esso. Questo metodo restituisce -1 se non viene trovato alcun articolo che soddisfa le condizioni.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che corrisponda alle condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> avanti al primo elemento fino all'ultimo elemento, viene eseguita la ricerca.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato. Il delegato ha la firma:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente definisce un `Employee` classe con due campi, `Name` e `Id`. Definisce inoltre un `EmployeeSearch` classe con un singolo metodo, `StartsWith`, che indica se il `Employee.Name` campo inizia con una sottostringa specificata che viene fornita per il `EmployeeSearch` costruttore della classe. Si noti la firma del metodo  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corrisponde alla firma del delegato che può essere passato al <xref:System.Collections.Generic.List%601.FindIndex%2A> metodo. Nell'esempio viene creata un'istanza un `List<Employee>` oggetto, aggiunge un numero di `Employee` oggetti, e quindi chiama il <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metodo due volte per la ricerca dell'intera raccolta, la prima volta per la prima `Employee` i cui `Name` di inizio del campo con "J" e la seconda volta per la prima `Employee` i cui `Name` campo inizia con "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Indice iniziale in base zero della ricerca.</param>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> compreso tra l'indice specificato e l'ultimo elemento.</summary>
        <returns>Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca in avanti a partire da `startIndex` e termina con l'ultimo elemento.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato. Il delegato ha la firma:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi compresi tra `startIndex` alla fine del <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 L'esempio seguente definisce un `Employee` classe con due campi, `Name` e `Id`. Definisce inoltre un `EmployeeSearch` classe con un singolo metodo, `StartsWith`, che indica se il `Employee.Name` campo inizia con una sottostringa specificata che viene fornita per il `EmployeeSearch` costruttore della classe. Si noti la firma del metodo  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corrisponde alla firma del delegato che può essere passato al <xref:System.Collections.Generic.List%601.FindIndex%2A> metodo. Nell'esempio viene creata un'istanza di un `List<Employee>` oggetto, aggiunge un numero di `Employee` oggetti, e quindi chiama il <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metodo due volte per cercare nella raccolta a partire da relativo membro quinto (ovvero, il membro in corrispondenza dell'indice 4). La prima volta, viene cercato il primo `Employee` i cui `Name` campo inizia con "J"; la seconda volta, viene cercato il primo `Employee` i cui `Name` campo inizia con "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Indice iniziale in base zero della ricerca.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> che inizia dall'indice specificato e contiene il numero indicato di elementi.</summary>
        <returns>Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca in avanti a partire da `startIndex` e fine `startIndex` più `count` -1, se `count` è maggiore di 0.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato. Il delegato ha la firma:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente definisce un `Employee` classe con due campi, `Name` e `Id`. Definisce inoltre un `EmployeeSearch` classe con un singolo metodo, `StartsWith`, che indica se il `Employee.Name` campo inizia con una sottostringa specificata che viene fornita per il `EmployeeSearch` costruttore della classe. Si noti la firma del metodo  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corrisponde alla firma del delegato che può essere passato al <xref:System.Collections.Generic.List%601.FindIndex%2A> metodo. Nell'esempio viene creata un'istanza di un `List<Employee>` oggetto, aggiunge un numero di `Employee` oggetti, e quindi chiama il <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metodo due volte per la ricerca dell'intera raccolta (, ovvero i membri dall'indice 0 all'indice <xref:System.Collections.Generic.List%601.Count%2A> - 1). La prima volta, viene cercato il primo `Employee` i cui `Name` campo inizia con "J"; la seconda volta, viene cercato il primo `Employee` i cui `Name` campo inizia con "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.  -oppure-  <paramref name="count" /> è minore di 0.  -oppure-  <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce l'ultima occorrenza all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Ultimo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato, lo spostamento all'indietro <xref:System.Collections.Generic.List%601>, a partire dall'ultimo elemento e terminando con il primo elemento.  L'elaborazione viene arrestata quando viene trovata una corrispondenza.  
  
> [!IMPORTANT]
>  Quando la ricerca in un elenco contenente i tipi di valore, accertarsi che il valore predefinito per il tipo non soddisfa il predicato di ricerca. In caso contrario, non è possibile distinguere tra un valore predefinito, che indica che è stata trovata alcuna corrispondenza e un elemento di elenco con il valore predefinito per il tipo. Se il valore predefinito soddisfa il predicato di ricerca, utilizzare il <xref:System.Collections.Generic.List%601.FindLastIndex%2A> metodo invece.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i metodi di ricerca per la <xref:System.Collections.Generic.List%601> classe. L'esempio per il <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, utilizzando i dati di [File XML di esempio: libri (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dai dati XML per i valori delle proprietà di `book` oggetti.  
  
 Nella tabella seguente vengono descritti gli esempi forniti per i metodi di ricerca.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri il cui `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta con una data di pubblicazione prima del 2001, utilizzando il `PubBefore2001` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno di <see cref="T:System.Collections.Generic.List`1" /> o di una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i metodi di ricerca per la <xref:System.Collections.Generic.List%601> classe. L'esempio per il <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, utilizzando i dati di [File XML di esempio: libri (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dai dati XML per i valori delle proprietà di `book` oggetti.  
  
 Nella tabella seguente vengono descritti gli esempi forniti per i metodi di ricerca.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri il cui `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta con una data di pubblicazione prima del 2001, utilizzando il `PubBefore2001` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Indice iniziale in base zero della ricerca all'indietro.</param>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <see cref="T:System.Collections.Generic.List`1" /> compreso tra il primo elemento e l'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e termina in corrispondenza del primo elemento.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi dall'inizio della <xref:System.Collections.Generic.List%601> a `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Indice iniziale in base zero della ricerca all'indietro.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <see cref="T:System.Collections.Generic.List`1" /> che contiene il numero indicato di elementi e termina in corrispondenza dell'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e fine `startIndex` meno `count` + 1, se `count` è maggiore di 0.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente illustra i metodi di ricerca per la <xref:System.Collections.Generic.List%601> classe. L'esempio per il <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, utilizzando i dati di [File XML di esempio: libri (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dai dati XML per i valori delle proprietà di `book` oggetti.  
  
 Nella tabella seguente vengono descritti gli esempi forniti per i metodi di ricerca.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri il cui `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta con una data di pubblicazione prima del 2001, utilizzando il `PubBefore2001` delegato predicato.<br /><br /> Nell'esempio c# viene utilizzato un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo computer libro nella seconda metà della raccolta, usando il `FindComputer` delegato predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.  -oppure-  <paramref name="count" /> è minore di 0.  -oppure-  <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">Delegato <see cref="T:System.Action`1" /> da eseguire su ogni elemento di <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Esegue l'azione specificata su ogni elemento di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Action%601> un delegato a un metodo che esegue un'azione per l'oggetto passato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Action%601> delegato.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Modifica la raccolta sottostante nel corpo del <xref:System.Action%601> delegato non è supportato e causa un comportamento indefinito.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Action%601> delegato per stampare il contenuto di un <xref:System.Collections.Generic.List%601> oggetto. In questo esempio il `Print` consente di visualizzare il contenuto dell'elenco nella console.  
  
> [!NOTE]
>  Oltre a visualizzare il contenuto utilizzando il `Print` (metodo), l'esempio c# viene illustrato l'utilizzo di per visualizzare i risultati alla console.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un elemento nella raccolta è stato modificato.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.List`1.Enumerator" /> per <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> proprietà non è definita. Pertanto, è necessario chiamare il <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta prima di leggere il valore di <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 Il <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> proprietà restituisce lo stesso oggetto finché non <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> viene chiamato. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e la successiva chiamata al <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> o <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero di <see cref="T:System.Collections.Generic.List`1" /> in corrispondenza del quale inizia la serie.</param>
        <param name="count">Numero di elementi nell'intervallo.</param>
        <summary>Crea una copia dei riferimenti di un intervallo di elementi nella classe <see cref="T:System.Collections.Generic.List`1" /> di origine.</summary>
        <returns>Copia dei riferimenti di un intervallo di elementi nella classe <see cref="T:System.Collections.Generic.List`1" /> di origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficiale di una raccolta di tipi di riferimento o un sottoinsieme di quell ' insieme, contiene solo i riferimenti agli elementi della raccolta. Non vengono copiati gli oggetti stessi. I riferimenti nel nuovo elenco puntano agli stessi oggetti come i riferimenti nell'elenco originale.  
  
 Una copia superficiale di una raccolta di tipi di valore o un sottoinsieme di quell ' insieme, contiene gli elementi della raccolta. Tuttavia, se gli elementi della raccolta possono contenere riferimenti ad altri oggetti, tali oggetti non vengono copiati. I riferimenti negli elementi della nuova raccolta puntano agli stessi oggetti come i riferimenti negli elementi della raccolta originale.  
  
 Al contrario, una copia completa di una raccolta copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.GetRange%2A> metodo e altri metodi del <xref:System.Collections.Generic.List%601> classe che agiscono su intervalli. Alla fine dell'esempio, il <xref:System.Collections.Generic.List%601.GetRange%2A> metodo viene utilizzato per ottenere tre elementi dall'elenco, a partire dalla posizione dell'indice 2. Il <xref:System.Collections.Generic.List%601.ToArray%2A> metodo viene chiamato su risultante <xref:System.Collections.Generic.List%601>, creando una matrice di tre elementi. Vengono visualizzati gli elementi della matrice.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  -oppure-  <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido di elementi in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'indice in base zero della prima occorrenza di un valore in <see cref="T:System.Collections.Generic.List`1" /> o in una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero della prima occorrenza nell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indice in base zero della prima occorrenza di <paramref name="item" /> all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> avanti al primo elemento fino all'ultimo elemento, viene eseguita la ricerca.  
  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i tre overload del <xref:System.Collections.Generic.List%601.IndexOf%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> overload del metodo cerca nell'elenco a partire dall'inizio e trova la prima occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nell'elenco a partire dalla posizione dell'indice 3 e continuando fino alla fine dell'elenco e trova la seconda occorrenza della stringa. Infine, il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 poiché non siano presenti istanze della stringa di ricerca in tale intervallo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="index">Indice iniziale in base zero della ricerca. 0 (zero) è valido in un elenco vuoto.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> che è compreso tra l'indice specificato e l'ultimo elemento.</summary>
        <returns>Indice in base zero della prima occorrenza di <paramref name="item" /> all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> compreso tra <paramref name="index" /> e l'ultimo elemento, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca in avanti a partire da `index` e termina con l'ultimo elemento.  
  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi compresi tra `index` alla fine del <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 L'esempio seguente illustra i tre overload del <xref:System.Collections.Generic.List%601.IndexOf%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> overload del metodo cerca nell'elenco a partire dall'inizio e trova la prima occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nell'elenco a partire dalla posizione dell'indice 3 e continuando fino alla fine dell'elenco e trova la seconda occorrenza della stringa. Infine, il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 poiché non siano presenti istanze della stringa di ricerca in tale intervallo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="index">Indice iniziale in base zero della ricerca. 0 (zero) è valido in un elenco vuoto.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> che inizia in corrispondenza dell'indice specificato e contiene il numero di elementi specificato.</summary>
        <returns>Indice in base zero della prima occorrenza di <paramref name="item" /> all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> che inizia da <paramref name="index" /> e contiene il numero di elementi corrispondente a <paramref name="count" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca in avanti a partire da `index` e fine `index` più `count` -1, se `count` è maggiore di 0.  
  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente illustra i tre overload del <xref:System.Collections.Generic.List%601.IndexOf%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> overload del metodo cerca nell'elenco a partire dall'inizio e trova la prima occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nell'elenco a partire dalla posizione dell'indice 3 e continuando fino alla fine dell'elenco e trova la seconda occorrenza della stringa. Infine, il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 poiché non siano presenti istanze della stringa di ricerca in tale intervallo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.  -oppure-  <paramref name="count" /> è minore di 0.  -oppure-  <paramref name="index" /> e <paramref name="count" /> non specificano una sezione valida in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero in corrispondenza del quale deve essere inserito <c>item</c>.</param>
        <param name="item">Oggetto da inserire. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Inserisce un elemento in <see cref="T:System.Collections.Generic.List`1" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente elementi duplicati.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> è già uguale <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacità del <xref:System.Collections.Generic.List%601> viene aumentata automaticamente la riallocazione della matrice interna e gli elementi esistenti vengono copiati nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Se `index` è uguale a <xref:System.Collections.Generic.List%601.Count%2A>, `item` viene aggiunto alla fine di <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Insert%2A> metodo, insieme a diversi altri metodi e proprietà del <xref:System.Collections.Generic.List%601> classe generica. Dopo aver creato l'elenco, vengono aggiunti elementi. Il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserire un elemento all'interno dell'elenco. L'elemento inserito è un duplicato, che viene successivamente rimosso mediante il <xref:System.Collections.Generic.List%601.Remove%2A> metodo.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  -oppure-  <paramref name="index" /> è maggiore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero in corrispondenza del quale devono essere inseriti i nuovi elementi.</param>
        <param name="collection">Raccolta i cui elementi devono essere inseriti in <see cref="T:System.Collections.Generic.List`1" />. La raccolta non può essere <see langword="null" /> ma può contenere elementi <see langword="null" /> se il tipo <c>T</c> è un tipo di riferimento.</param>
        <summary>Inserisce gli elementi di una raccolta in <see cref="T:System.Collections.Generic.List`1" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente elementi duplicati.  
  
 Se il nuovo <xref:System.Collections.Generic.List%601.Count%2A> (corrente <xref:System.Collections.Generic.List%601.Count%2A> più le dimensioni della raccolta) sarà maggiore <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacità del <xref:System.Collections.Generic.List%601> viene aumentata automaticamente la riallocazione della matrice interna per contenere i nuovi elementi e gli elementi esistenti vengono copiati nella nuova matrice prima vengono aggiunti nuovi elementi.  
  
 Se `index` è uguale a <xref:System.Collections.Generic.List%601.Count%2A>, gli elementi vengono aggiunti alla fine di <xref:System.Collections.Generic.List%601>.  
  
 Viene mantenuto l'ordine degli elementi nella raccolta di <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n* * *m*) operazione, in cui *n* è il numero di elementi da aggiungere e *m* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato <xref:System.Collections.Generic.List%601.InsertRange%2A> (metodo) e diversi altri metodi del <xref:System.Collections.Generic.List%601> classe che agiscono su intervalli. Dopo aver creato e popolato con i nomi dei diversi pacifici impianto feroci, l'elenco di <xref:System.Collections.Generic.List%601.InsertRange%2A> metodo viene utilizzato per inserire una matrice di tre dinosauri carne feroci nell'elenco, a partire dalla posizione di indice 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  -oppure-  <paramref name="index" /> è maggiore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'elemento da ottenere o impostare.</param>
        <summary>Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</summary>
        <value>Elemento in corrispondenza dell'indice specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente elementi duplicati.  
  
 Questa proprietà consente di accedere a un elemento specifico della raccolta utilizzando la sintassi seguente: `myCollection[index]`.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1). l'impostazione della proprietà è un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio di questa sezione viene illustrato il <xref:System.Collections.Generic.List%601.Item%2A> proprietà (l'indicizzatore in c#) e varie altre proprietà e metodi del <xref:System.Collections.Generic.List%601> classe generica. Dopo l'elenco è stato creato e popolato mediante il <xref:System.Collections.Generic.List%601.Add%2A> (metodo), un elemento viene recuperato e visualizzato tramite il <xref:System.Collections.Generic.List%601.Item%2A> proprietà. (Per un esempio che utilizza il <xref:System.Collections.Generic.List%601.Item%2A> proprietà per impostare il valore di un elemento di elenco, vedere <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, c# e C++ tutti hanno una sintassi per l'accesso di <xref:System.Collections.Generic.List%601.Item%2A> proprietà senza usare il relativo nome. Al contrario, la variabile contenente il <xref:System.Collections.Generic.List%601> viene utilizzato come se fosse una matrice.  
  
 Nel linguaggio c# viene utilizzata la parola chiave per definire gli indicizzatori anziché implementare la <xref:System.Collections.Generic.List%601.Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.List%601.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  -oppure-  <paramref name="index" /> è uguale o maggiore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'indice in base zero dell'ultima occorrenza di un valore in <see cref="T:System.Collections.Generic.List`1" /> o in una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero dell'ultima occorrenza nell'intera classe <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di <paramref name="item" /> all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.  
  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i tre overload del <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> overload del metodo cerca nell'intero elenco dalla fine e trova la seconda occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nell'elenco all'indietro a partire dalla posizione dell'indice 3 e continuando fino all'inizio dell'elenco, in modo che trova la prima occorrenza della stringa nell'elenco. Infine, il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, viene eseguita la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1 perché non siano presenti istanze della ricerca stringa in tale intervallo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="index">Indice iniziale in base zero della ricerca all'indietro.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi nella classe <see cref="T:System.Collections.Generic.List`1" /> che è compresa tra il primo elemento e l'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di <paramref name="item" /> all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> compreso tra il primo elemento e <paramref name="index" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita con le versioni precedenti a partire dall'indice `index` e termina in corrispondenza del primo elemento.  
  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi dall'inizio della <xref:System.Collections.Generic.List%601> a `index`.  
  
   
  
## Examples  
 L'esempio seguente illustra i tre overload del <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> overload del metodo cerca nell'intero elenco dalla fine e trova la seconda occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nell'elenco all'indietro a partire dalla posizione dell'indice 3 e continuando fino all'inizio dell'elenco, in modo che trova la prima occorrenza della stringa nell'elenco. Infine, il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, viene eseguita la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1 perché non siano presenti istanze della ricerca stringa in tale intervallo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="index">Indice iniziale in base zero della ricerca all'indietro.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi della classe <see cref="T:System.Collections.Generic.List`1" /> che contiene il numero di elementi specificato e termina in corrispondenza dell'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di <paramref name="item" /> all'interno dell'intervallo di elementi in <see cref="T:System.Collections.Generic.List`1" /> che contiene un numero di elementi corrispondente a <paramref name="count" /> e termina in corrispondenza di <paramref name="index" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita con le versioni precedenti a partire dall'indice `index` e fine `index` meno `count` + 1, se `count` è maggiore di 0.  
  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente illustra i tre overload del <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> overload del metodo cerca nell'intero elenco dalla fine e trova la seconda occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nell'elenco all'indietro a partire dalla posizione dell'indice 3 e continuando fino all'inizio dell'elenco, in modo che trova la prima occorrenza della stringa nell'elenco. Infine, il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di 4 voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, viene eseguita la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1 perché non siano presenti istanze della ricerca stringa in tale intervallo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.  -oppure-  <paramref name="count" /> è minore di 0.  -oppure-  <paramref name="index" /> e <paramref name="count" /> non specificano una sezione valida in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da rimuovere da <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Rimuove la prima occorrenza di un oggetto specifico da <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> viene rimosso correttamente; in caso contrario, <see langword="false" />.  Questo metodo restituisce anche <see langword="false" /> se <paramref name="item" /> non è stato trovato nell'oggetto <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `T` implementa il <xref:System.IEquatable%601> interfaccia generica, l'operatore di confronto di uguaglianza è il <xref:System.IEquatable%601.Equals%2A> metodo dell'interfaccia; in caso contrario, l'operatore di confronto predefinito è <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Nell'esempio seguente viene illustrato <xref:System.Collections.Generic.List%601.Remove%2A> metodo. Molte proprietà e metodi del <xref:System.Collections.Generic.List%601> classe generica vengono utilizzati per aggiungere, inserire e ricerca nell'elenco. Dopo aver eseguito queste operazioni, l'elenco contiene un duplicato. Il <xref:System.Collections.Generic.List%601.Remove%2A> viene usato il metodo per rimuovere la prima istanza dell'elemento duplicato e viene visualizzato il contenuto. Il <xref:System.Collections.Generic.List%601.Remove%2A> metodo rimuove sempre la prima istanza rilevata.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da rimuovere.</param>
        <summary>Rimuove tutti gli elementi che corrispondono alle condizioni definite dal predicato specificato.</summary>
        <returns>Numero di elementi rimossi da <see cref="T:System.Collections.Generic.List`1" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato e gli elementi che soddisfano le condizioni vengono rimossi dal <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.RemoveAll%2A> (metodo) e diversi metodi che utilizzano il <xref:System.Predicate%601> delegato generico.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato, che contiene 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus". Viene inoltre definito un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, e <xref:System.Collections.Generic.List%601.FindAll%2A> vengono utilizzati metodi per eseguire ricerche nell'elenco con il metodo di predicato di ricerca.  
  
 Il <xref:System.Collections.Generic.List%601.RemoveAll%2A> consente di rimuovere tutte le voci che terminano con "saurus". Scorre l'elenco a partire dall'inizio, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo. L'elemento viene rimosso se il `EndsWithSaurus` restituisce `true`.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.  
  
 Infine, il <xref:System.Collections.Generic.List%601.Exists%2A> metodo verifica che sono non presenti nell'elenco stringhe che terminano con "saurus".  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento in corrispondenza dell'indice specificato di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama <xref:System.Collections.Generic.List%601.RemoveAt%2A> per rimuovere un elemento, gli elementi rimanenti nell'elenco sono numerati per sostituire l'elemento rimosso. Ad esempio, se si rimuove l'elemento in corrispondenza dell'indice 3, l'elemento in corrispondenza dell'indice 4 viene spostato nella posizione 3. Inoltre, il numero di elementi nell'elenco (rappresentati dal <xref:System.Collections.Generic.List%601.Count%2A> proprietà) viene diminuito di 1.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  -oppure-  <paramref name="index" /> è uguale o maggiore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice iniziale in base zero dell'intervallo di elementi da rimuovere.</param>
        <param name="count">Numero di elementi da rimuovere.</param>
        <summary>Rimuove un intervallo di elementi da <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono rimossi e tutti gli elementi in seguito il <xref:System.Collections.Generic.List%601> hanno i relativi indici ridotti di `count`.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.RemoveRange%2A> (metodo) e diversi altri metodi del <xref:System.Collections.Generic.List%601> classe che agiscono su intervalli. Dopo aver creato e modificato, l'elenco di <xref:System.Collections.Generic.List%601.RemoveRange%2A> metodo viene utilizzato per rimuovere i due elementi dall'elenco, a partire dalla posizione dell'indice 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  -oppure-  <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido di elementi in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inverte l'ordine degli elementi di <see cref="T:System.Collections.Generic.List`1" /> o di una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inverte l'ordine degli elementi nell'intero <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza <xref:System.Array.Reverse%2A?displayProperty=nameWithType> per invertire l'ordine degli elementi.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra entrambi gli overload di <xref:System.Collections.Generic.List%601.Reverse%2A> metodo. Nell'esempio viene creato un <xref:System.Collections.Generic.List%601> di stringhe e vengono aggiunte sei stringhe. Il <xref:System.Collections.Generic.List%601.Reverse> overload del metodo viene utilizzato per invertire l'elenco, quindi il <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> overload del metodo viene utilizzato per invertire il centro dell'elenco, a partire dall'elemento 1 e comprendendo quattro elementi.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice iniziale in base zero dell'intervallo da invertire.</param>
        <param name="count">Numero di elementi nell'intervallo da invertire.</param>
        <summary>Inverte l'ordine degli elementi nell'intervallo specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza <xref:System.Array.Reverse%2A?displayProperty=nameWithType> per invertire l'ordine degli elementi.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra entrambi gli overload di <xref:System.Collections.Generic.List%601.Reverse%2A> metodo. Nell'esempio viene creato un <xref:System.Collections.Generic.List%601> di stringhe e vengono aggiunte sei stringhe. Il <xref:System.Collections.Generic.List%601.Reverse> overload del metodo viene utilizzato per invertire l'elenco, quindi il <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> overload del metodo viene utilizzato per invertire il centro dell'elenco, a partire dall'elemento 1 e comprendendo quattro elementi.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  -oppure-  <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non identificano un intervallo valido di elementi in <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordina gli elementi di <see cref="T:System.Collections.Generic.List`1" /> o di una parte di esso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overloaded-method-syntax"></a>Sintassi del metodo di overload  
 Il <xref:System.Collections.Generic.List%601.Sort%2A> metodi consentono di eseguire l'ordinamento con l'operatore di confronto predefinito per il tipo di oggetto nell'elenco oppure specificare un metodo di ordinamento del cliente.  
  
 [Elenco\<T >. Sort](xref:System.Collections.Generic.List`1.Sort*) Ordina gli elementi nell'intero elenco utilizzando l'operatore di confronto del tipo di oggetto contenuti nell'elenco.  
  
 [Elenco\<T >. Ordinamento M (confronto\<T > confronto)](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29) Ordina gli elementi nell'intero elenco usando l'operatore di confronto specificato.  
  
 [Elenco\<T >. Sort (IComparer\<T > operatore di confronto)](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29) Ordina gli elementi nell'intero elenco utilizzando il parametro specificato <xref:System.Comparison%601?displayProperty=nameWithType>.  
  
 [Elenco\<T >. Ordinamento (indice Int32, conteggio Int32, IComparer\<T > operatore di confronto)](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29) Ordina gli elementi in un intervallo di elementi nell'elenco usando l'operatore di confronto specificato.  
  
## <a name="parameters"></a>Parametri  
  
|Parametro|Tipo|Descrizione|  
|---------------|----------|-----------------|  
|`comparison`|<xref:System.Comparison%601>|Il metodo delegato da usare quando si confrontano gli elementi|  
|operatore di confronto|<xref:System.Collections.Generic.IComparer%601>|Il <xref:System.Collections.Generic.IComparer%601> implementazione da usare quando si confrontano gli elementi oppure null per usare l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default>.|  
|`index`|<xref:System.Int32>|Indice iniziale in base zero dell'intervallo da ordinare.|  
|`count`|<xref:System.Int32>|Lunghezza dell'intervallo da ordinare.|  
  
## <a name="exceptions"></a>Eccezioni  
  
|Eccezione|Condizione|  
|---------------|---------------|  
|<xref:System.InvalidOperationException>|`comparer` non è specificato o `null`e l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Impossibile trovare l'implementazione del <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia generica o <xref:System.IComparable?displayProperty=nameWithType> interfaccia per il tipo T.|  
|<xref:System.ArgumentNullException>|`comparison` è `null`.|  
|<xref:System.ArgumentException>|L'implementazione di `comparison` o `comparer` ha causato un errore durante l'ordinamento. Ad esempio, `comparison` potrebbe non restituire 0 quando si confronta un elemento con se stesso.<br /><br /> oppure<br /><br /> `index` e `count` non specificano un intervallo valido in <xref:System.Collections.Generic.List%601>.|  
|<xref:System.ArgumentOutOfRangeException>|`index` è minore di 0 o `count` è minore di 0.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ordina gli elementi dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" /> usando l'operatore di confronto predefinito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> per tipo `T` per determinare l'ordine degli elementi di elenco. Il <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> proprietà verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa l'interfaccia, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un <xref:System.InvalidOperationException>.  
  
 Questo metodo Usa il <xref:System.Array.Sort%2A?displayProperty=nameWithType> metodo, che applica l'ordinamento interiorizzata come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un algoritmo di ordinamento di inserimento.  
  
-   Se il numero di partizioni supera log 2 *n*, dove *n* è l'intervallo della matrice di input, viene utilizzato un algoritmo Heapsort.  
  
-   In caso contrario, viene utilizzato un algoritmo di Quicksort.  
  
 Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 In Media, questo metodo è un'operazione O (*n* log *n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>; nel peggiore dei casi è un'operazione O (*n* <sup>2</sup>) operazione.  
  
   
  
## Examples  
 L'esempio seguente aggiunge alcuni nomi per un `List<String>` (oggetto), consente di visualizzare l'elenco in ordine casuale, chiama il <xref:System.Collections.Generic.List%601.Sort%2A> (metodo) e quindi Visualizza l'elenco ordinato.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 Il codice seguente illustra il <xref:System.Collections.Generic.List%601.Sort> e <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> overload del metodo su un semplice oggetto business. La chiamata di <xref:System.Collections.Generic.List%601.Sort> metodo comporta l'utilizzo dell'operatore di confronto predefinito per il tipo di parte e <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> metodo viene implementato utilizzando un metodo anonimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> overload del metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, in nessun ordine particolare. L'elenco è visualizzato, ordinato e visualizzato di nuovo.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> overload del metodo viene quindi utilizzato per eseguire la ricerca di due stringhe che non sono presenti nell'elenco, e <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserirli. Il valore restituito di <xref:System.Collections.Generic.List%601.BinarySearch%2A> metodo è negativo in ogni caso, poiché le stringhe non sono presenti nell'elenco. Prendendo il complemento bit per bit (il ~ (operatore) in c# e Visual C++, `Xor` -1 in Visual Basic) di questo numero negativo produce l'indice del primo elemento nell'elenco che è maggiore della stringa di ricerca e l'inserimento in questa posizione conserva l'ordinamento ordine. La seconda stringa di ricerca è maggiore di qualsiasi elemento nell'elenco, pertanto la posizione di inserimento si trova alla fine dell'elenco.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Mediante la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto predefinito non è possibile rilevare un'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o dell'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare durante il confronto di elementi oppure <see langword="null" /> per usare la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto.</param>
        <summary>Ordina gli elementi dell'intero <see cref="T:System.Collections.Generic.List`1" /> usando l'operatore di confronto specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` viene fornito, gli elementi del <xref:System.Collections.Generic.List%601> vengono ordinati usando l'oggetto <xref:System.Collections.Generic.IComparer%601> implementazione.  
  
 Se `comparer` è `null`, l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa l'interfaccia, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un <xref:System.InvalidOperationException>.  
  
 Questo metodo Usa il <xref:System.Array.Sort%2A?displayProperty=nameWithType> metodo, che applica l'ordinamento interiorizzata come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un algoritmo di ordinamento di inserimento.  
  
-   Se il numero di partizioni supera log 2 *n*, dove *n* è l'intervallo della matrice di input, viene utilizzato un algoritmo Heapsort.  
  
-   In caso contrario, viene utilizzato un algoritmo di Quicksort.  
  
 Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 In Media, questo metodo è un'operazione O (*n* log *n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>; nel peggiore dei casi è un'operazione O (*n* <sup>2</sup>) operazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un operatore di confronto alternativo per le stringhe denominato DinoCompare, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. L'operatore di confronto funziona nel modo seguente: prima di tutto, i termini di confronto da testare per `null`, e un riferimento null viene considerato minore rispetto a un valore non null. In secondo luogo, vengono confrontate le lunghezze di stringa e la stringa più lunga è considerata maggiore. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, in nessun ordine particolare. L'elenco viene visualizzato, ordinato usando l'operatore di confronto alternativo e visualizzata nuovamente.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo viene quindi utilizzato per eseguire la ricerca di più stringhe non in elenco, utilizzando l'operatore di confronto alternativo. Il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserire le stringhe. Questi due metodi si trovano nella funzione denominata `SearchAndInsert`, insieme al codice per utilizzare il complemento bit per bit (il ~ (operatore) in c# e Visual C++, `Xor` -1 in Visual Basic) del numero negativo restituito da <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> e utilizzarlo come indice per inserimento della nuova stringa.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e l'operatore di confronto predefinito <see cref="P:System.Collections.Generic.Comparer`1.Default" /> non riesce a trovare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o l'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">Oggetto <see cref="T:System.Comparison`1" /> da usare quando si confrontano gli elementi.</param>
        <summary>Ordina gli elementi nell'intera classe <see cref="T:System.Collections.Generic.List`1" /> usando l'oggetto <see cref="T:System.Comparison`1" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparison` viene fornito, gli elementi del <xref:System.Collections.Generic.List%601> vengono ordinati usando il metodo rappresentato dal delegato.  
  
 Se `comparison` è `null`, un <xref:System.ArgumentNullException> viene generata un'eccezione.  
  
 Questo metodo utilizza <xref:System.Array.Sort%2A?displayProperty=nameWithType>, che si applica l'ordinamento interiorizzata come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un algoritmo di ordinamento di inserimento  
  
-   Se il numero di partizioni supera log 2 *n*, dove *n* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, viene utilizzato un algoritmo di Quicksort.  
  
 Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 In Media, questo metodo è un'operazione O (*n* log *n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>; nel peggiore dei casi è un'operazione O (*n* <sup>2</sup>) operazione.  
  
   
  
## Examples  
 Il codice seguente illustra il <xref:System.Collections.Generic.List%601.Sort%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> overload del metodo su un semplice oggetto business. La chiamata di <xref:System.Collections.Generic.List%601.Sort%2A> metodo comporta l'utilizzo dell'operatore di confronto predefinito per il tipo di parte e <xref:System.Collections.Generic.List%601.Sort%2A> metodo viene implementato usando un metodo anonimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un metodo di confronto alternativo per le stringhe, denominato `CompareDinosByLength`. Questo metodo funziona nel modo seguente: prima di tutto, i termini di confronto da testare per `null`, e un riferimento null viene considerato minore rispetto a un valore non null. In secondo luogo, vengono confrontate le lunghezze di stringa e la stringa più lunga è considerata maggiore. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, in nessun ordine particolare. L'elenco include anche una stringa vuota e un riferimento null. Viene visualizzato l'elenco e ordinato utilizzando un <xref:System.Comparison%601> delegato generico che rappresenta il `CompareDinosByLength` (metodo), quindi viene nuovamente visualizzato.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'implementazione di <paramref name="comparison" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparison" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <altmember cref="T:System.Comparison`1" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Indice iniziale in base zero dell'intervallo da ordinare.</param>
        <param name="count">Lunghezza dell'intervallo da ordinare.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare durante il confronto di elementi oppure <see langword="null" /> per usare la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto.</param>
        <summary>Ordina gli elementi di un intervallo di elementi di <see cref="T:System.Collections.Generic.List`1" /> usando l'operatore di confronto specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` viene fornito, gli elementi del <xref:System.Collections.Generic.List%601> vengono ordinati usando l'oggetto <xref:System.Collections.Generic.IComparer%601> implementazione.  
  
 Se `comparer` è `null`, l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa l'interfaccia, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un <xref:System.InvalidOperationException>.  
  
 Questo metodo utilizza <xref:System.Array.Sort%2A?displayProperty=nameWithType>, che si applica l'ordinamento interiorizzata come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un algoritmo di ordinamento di inserimento  
  
-   Se il numero di partizioni supera log 2 *n*, dove *n* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, viene utilizzato un algoritmo di Quicksort.  
  
 Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 In Media, questo metodo è un'operazione O (*n* log *n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>; nel peggiore dei casi è un'operazione O (*n* <sup>2</sup>) operazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un operatore di confronto alternativo per le stringhe denominato DinoCompare, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. L'operatore di confronto funziona nel modo seguente: prima di tutto, i termini di confronto da testare per `null`, e un riferimento null viene considerato minore rispetto a un valore non null. In secondo luogo, vengono confrontate le lunghezze di stringa e la stringa più lunga è considerata maggiore. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con i nomi dei cinque dinosauri erbivori e tre dinosauri carnivori. All'interno di ognuno dei due gruppi, i nomi non sono in alcun ordinamento particolare. Viene visualizzato l'elenco, l'intervallo di erbivori viene ordinato utilizzando l'operatore di confronto alternativo e viene nuovamente visualizzato l'elenco.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo viene quindi utilizzato per la ricerca solo l'intervallo di erbivori "Brachiosaurus". La stringa non viene trovata e il complemento bit per bit (il ~ (operatore) in c# e Visual C++, `Xor` -1 in Visual Basic) del numero negativo restituito dal <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metodo viene utilizzato come indice per l'inserimento della nuova stringa.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  -oppure-  <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non specificano un intervallo valido in <see cref="T:System.Collections.Generic.List`1" />.  -oppure-  L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e l'operatore di confronto predefinito <see cref="P:System.Collections.Generic.Comparer`1.Default" /> non riesce a trovare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o l'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.Generic.ICollection`1" /> è di sola lettura.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.ICollection`1" /> è di sola lettura; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la <xref:System.Collections.Generic.IEnumerator%601.Current%2A> proprietà non è definita. Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta prima di leggere il valore di <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 Il <xref:System.Collections.Generic.IEnumerator%601.Current%2A> proprietà restituisce lo stesso oggetto finché non <xref:System.Collections.IEnumerator.MoveNext%2A> viene chiamato. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e la successiva chiamata al <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.ICollection" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.ICollection" /> in <see cref="T:System.Array" /> a partire da un particolare indice <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.ICollection> non può essere eseguire automaticamente il cast al tipo della destinazione `array`, le implementazioni non generiche di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> generare <xref:System.InvalidCastException>, mentre le implementazioni generiche generano <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  -oppure-  <paramref name="array" /> non ha indicizzazione a base zero.  -oppure-   Il numero di elementi nell'insieme di origine <see cref="T:System.Collections.ICollection" /> è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.  -oppure-   Non è possibile eseguire automaticamente il cast del tipo dell'insieme <see cref="T:System.Collections.ICollection" /> di origine nel tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  In rari casi in cui enumerazione condivida accessi in scrittura, è possibile bloccare la raccolta per l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread bloccano questo oggetto prima di accedere alla raccolta.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre l'istanza corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread bloccano questo oggetto prima di accedere alla raccolta. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà per c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la <xref:System.Collections.IEnumerator.Current%2A> proprietà non è definita. Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> metodo per passare l'enumeratore al primo elemento della raccolta prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Il <xref:System.Collections.IEnumerator.Current%2A> proprietà restituisce lo stesso oggetto finché non <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> viene chiamato. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio aggiungendo, modificando o eliminando elementi, l'enumeratore viene invalidato in modo irreversibile e la successiva chiamata al <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto <see cref="T:System.Object" /> da aggiungere a <see cref="T:System.Collections.IList" />.</param>
        <summary>Aggiunge un elemento a <see cref="T:System.Collections.IList" />.</summary>
        <returns>Posizione in cui è stato inserito il nuovo elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Collections.Generic.List%601.Count%2A> è minore di <xref:System.Collections.Generic.List%601.Capacity%2A>, questo metodo è un'operazione o (1). Se la capacità deve essere incrementata per far posto al nuovo elemento, questo metodo diventa un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> è un tipo non assegnabile all'oggetto <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto <see cref="T:System.Object" /> da individuare in <see cref="T:System.Collections.IList" />.</param>
        <summary>Stabilisce se <see cref="T:System.Collections.IList" /> contiene un valore specifico.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> è presente in <see cref="T:System.Collections.IList" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.IList" />.</param>
        <summary>Determina l'indice di un elemento specifico in <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indice di <paramref name="item" />, se presente nell'elenco; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> è un tipo non assegnabile all'oggetto <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero in corrispondenza del quale deve essere inserito <c>item</c>.</param>
        <param name="item">Oggetto da inserire in <see cref="T:System.Collections.IList" />.</param>
        <summary>Inserisce un elemento in <see cref="T:System.Collections.IList" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `index` è uguale al numero di elementi in <xref:System.Collections.IList>, `item` viene aggiunto alla fine.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è un indice valido nell'interfaccia <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> è un tipo non assegnabile all'oggetto <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IList" /> ha dimensioni fisse.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IList" /> è di dimensioni fisse; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la sua creazione, ma consente la modifica degli elementi esistenti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o la rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IList" /> è di sola lettura.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IList" /> è di sola lettura; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'elemento da ottenere o impostare.</param>
        <summary>Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</summary>
        <value>Elemento in corrispondenza dell'indice specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel linguaggio c# viene utilizzata la [questo](~/docs/csharp/language-reference/keywords/this.md) (parola chiave) per definire gli indicizzatori anziché implementare la <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1). l'impostazione della proprietà è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è un indice valido nell'interfaccia <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà viene impostata e il tipo del parametro <paramref name="value" /> non è assegnabile all'interfaccia <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da rimuovere da <see cref="T:System.Collections.IList" />.</param>
        <summary>Rimuove la prima occorrenza di un oggetto specifico da <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza utilizzando l'operatore di confronto di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo di valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. Pertanto, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> è un tipo non assegnabile all'oggetto <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia gli elementi di <see cref="T:System.Collections.Generic.List`1" /> in una nuova matrice.</summary>
        <returns>Matrice contenente le copie degli elementi di <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono copiati mediante <xref:System.Array.Copy%2A?displayProperty=nameWithType>, che è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.ToArray%2A> metodo e altri metodi del <xref:System.Collections.Generic.List%601> classe che agiscono su intervalli. Alla fine dell'esempio, il <xref:System.Collections.Generic.List%601.GetRange%2A> metodo viene utilizzato per ottenere tre elementi dall'elenco, a partire dalla posizione dell'indice 2. Il <xref:System.Collections.Generic.List%601.ToArray%2A> metodo viene chiamato su risultante <xref:System.Collections.Generic.List%601>, creando una matrice di tre elementi. Vengono visualizzati gli elementi della matrice.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta la capacità sul numero reale di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" />, se tale numero è inferiore a un valore soglia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una raccolta se nessun nuovo elemento verrà aggiunto alla raccolta. Il costo di riallocazione e copia di un <xref:System.Collections.Generic.List%601> può essere considerevole, tuttavia, pertanto la <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo non esegue alcuna operazione se l'elenco è in più del 90% della capacità. Questo evita di dover sostenere un costo di riallocazione elevato per un aumento di dimensioni relativamente ridotte.  
  
> [!NOTE]
>  La soglia corrente di 90 percento potrebbe cambiare nelle versioni future.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Per reimpostare un <xref:System.Collections.Generic.List%601> lo stato iniziale, chiamare il metodo di <xref:System.Collections.Generic.List%601.Clear%2A> metodo prima di chiamare il <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo. L'eliminazione di un oggetto vuoto <xref:System.Collections.Generic.List%601> imposta la capacità del <xref:System.Collections.Generic.List%601> per la capacità predefinita.  
  
 La capacità può anche essere impostata utilizzando il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come controllare la capacità e conteggio di un <xref:System.Collections.Generic.List%601> che contiene un semplice oggetto business e viene illustrato l'utilizzo di <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo per rimuovere una capacità aggiuntiva.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo. Molte proprietà e metodi del <xref:System.Collections.Generic.List%601> classe consentono di aggiungere, inserire e rimuovere elementi da un elenco di stringhe. Il <xref:System.Collections.Generic.List%601.TrimExcess%2A> consente di ridurre la capacità in modo che corrisponda al conteggio e <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> vengono visualizzate le proprietà. Se la capacità inutilizzata fosse stata inferiore al 10% della capacità totale, l'elenco potrebbe non stato ridimensionato. Infine, il contenuto dell'elenco viene cancellato.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni per verificare gli elementi.</param>
        <summary>Determina se ogni elemento nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrisponde alle condizioni definite dal predicato specificato.</summary>
        <returns>
          <see langword="true" /> se ogni elemento nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrisponde alle condizioni definite dal predicato specificato; in caso contrario, <see langword="false" />. Se l'elenco è privo di elementi, il valore restituito è <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato e l'elaborazione viene arrestata quando il delegato restituisce `false` per qualsiasi elemento. Gli elementi vengono elaborati in ordine, e tutte le chiamate vengono eseguite su un thread singolo.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.TrueForAll%2A> (metodo) e diversi metodi che utilizzano <xref:System.Predicate%601> delegato generico.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato, che contiene 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus". Viene inoltre definito un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Collections.Generic.List%601.TrueForAll%2A> consente di scorrere l'elenco dall'inizio, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo. La ricerca si interrompe quando il `EndsWithSaurus` restituisce `false`.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>