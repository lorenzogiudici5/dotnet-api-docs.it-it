<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9136a331e3d60d7fbfbdec6c6af6d62811171f34" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52594157" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo di elementi contenuti nell'elenco.</typeparam>
    <summary>Rappresenta un elenco di oggetti fortemente tipizzato accessibile per indice. Fornisce metodi per la ricerca, l'ordinamento e la modifica degli elenchi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> classe è l'interfaccia equivalente generica del <xref:System.Collections.ArrayList> classe. Implementa il <xref:System.Collections.Generic.IList%601> interfaccia generica usando una matrice le cui dimensioni sono incrementate in modo dinamico come richiesto.  
  
 È possibile aggiungere elementi a un <xref:System.Collections.Generic.List%601> usando il <xref:System.Collections.Generic.List%601.Add%2A> o <xref:System.Collections.Generic.List%601.AddRange%2A> metodi.  
  
 Il <xref:System.Collections.Generic.List%601> classe Usa un operatore di confronto di uguaglianze sia un confronto di ordinamento.  
  
-   I metodi come <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, e <xref:System.Collections.Generic.Dictionary%602.Remove%2A> usano un confronto di uguaglianza per gli elementi dell'elenco. Operatore di uguaglianza predefinito per il tipo `T` viene determinata come segue. Se tipo `T` implementa la <xref:System.IEquatable%601> generico interfaccia, l'operatore di confronto di uguaglianza è il <xref:System.IEquatable%601.Equals%28%600%29> metodo di tale interfaccia; in caso contrario, l'operatore di uguaglianza predefinito è <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   I metodi come <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> usano un confronto di ordinamento per gli elementi di elenco. L'operatore di confronto predefinito per il tipo `T` viene determinata come segue.  Se tipo `T` implementa la <xref:System.IComparable%601> generico interfaccia, l'operatore di confronto predefinito è la <xref:System.IComparable%601.CompareTo%28%600%29> metodo di tale interfaccia; in caso contrario, se tipo `T` implementa il metodo non generico <xref:System.IComparable> interfaccia e quindi il valore predefinito operatore di confronto è il <xref:System.IComparable.CompareTo%28System.Object%29> metodo di tale interfaccia. Se tipo `T` implementa alcuna interfaccia, non vi è alcun operatore di confronto predefinito, quindi è necessario specificare un delegato di confronto o operatore di confronto in modo esplicito.  
  
 Il <xref:System.Collections.Generic.List%601> non è garantito a essere ordinati.  È necessario ordinare il <xref:System.Collections.Generic.List%601> prima di eseguire operazioni (ad esempio <xref:System.Collections.Generic.List%601.BinarySearch%2A>) che richiedono il <xref:System.Collections.Generic.List%601> da ordinare.  
  
 Gli elementi in questa raccolta sono accessibile tramite un indice integer.  Gli indici in questa raccolta sono in base zero.  
  
 Per grandi <xref:System.Collections.Generic.List%601> oggetti, è possibile aumentare la capacità massima a 2 miliardi di elementi in un sistema a 64 bit impostando il `enabled` attributo dell'elemento di configurazione da `true` nell'ambiente di runtime.  
  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente gli elementi duplicati.  
  
 Per una versione non modificabile del <xref:System.Collections.Generic.List%601> classe, vedere <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Decidere se usare la <xref:System.Collections.Generic.List%601> oppure <xref:System.Collections.ArrayList> (classe), che dispongono di una funzionalità simile, tenere presente che il <xref:System.Collections.Generic.List%601> classe offre prestazioni migliori nella maggior parte dei casi ed è indipendente dai tipi. Se un tipo riferimento viene usato per il tipo `T` del <xref:System.Collections.Generic.List%601> (classe), il comportamento delle due classi è identico. Tuttavia, se un tipo di valore viene usato per il tipo `T`, è necessario considerare problemi di conversione boxing e implementazione.  
  
 Se un tipo di valore viene usato per il tipo `T`, il compilatore genera un'implementazione del <xref:System.Collections.Generic.List%601> classe in modo specifico per quel tipo di valore. Ciò significa che un elemento di elenco di un <xref:System.Collections.Generic.List%601> oggetto non deve essere sottoposto a boxing prima che l'elemento può essere usato, e dopo circa 500 elementi dell'elenco vengono creati la memoria salvata non conversione boxing di elementi dell'elenco è maggiore della memoria usata per generare l'implementazione della classe.  
  
 Accertarsi che il tipo di valore utilizzato per il tipo `T` implementa il <xref:System.IEquatable%601> interfaccia generica. Se non, metodi, ad esempio <xref:System.Collections.Generic.List%601.Contains%2A> necessario chiamare il <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo, che boxing dell'elemento di elenco interessata. Se il tipo di valore implementa il <xref:System.IComparable> interfaccia e si è proprietari del codice sorgente, implementare anche il <xref:System.IComparable%601> generico interfaccia per impedire il <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> metodi di conversione boxing di elementi dell'elenco. Se non si è proprietari del codice sorgente, passare un <xref:System.Collections.Generic.IComparer%601> dell'oggetto per il <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> metodi  
  
 È a proprio vantaggio di usare l'implementazione di tipi specifici del <xref:System.Collections.Generic.List%601> classe invece di usare il <xref:System.Collections.ArrayList> classe o la scrittura di una raccolta di wrapper fortemente tipizzata manualmente. Il motivo è l'implementazione deve eseguire operazioni quali .NET Framework esegue automaticamente già e common language runtime può condividere codice Microsoft intermediate language e metadati che non è l'implementazione.  
  
## <a name="f-considerations"></a>F#Considerazioni  
 Il <xref:System.Collections.Generic.List%601> classe viene utilizzata raramente in F# codice.  Al contrario, [Elenca](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), che sono elenchi non modificabili, collegati singolarmente, sono generalmente quello preferito. Un F# fornisce una serie ordinata e non modificabile di valori di elenco ed è supportato l'utilizzo nello sviluppo di stile funzionale. Quando vengono utilizzati da F#, il <xref:System.Collections.Generic.List%601> classe viene in genere definita con il [ResizeArray\<l ' >](https://msdn.microsoft.com/library/ee353447.aspx) abbreviazione per evitare conflitti con di denominazione di tipo F# Elenca  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 L'esempio seguente illustra numerose proprietà e metodi del <xref:System.Collections.Generic.List%601> classe generica di tipo stringa. (Per un esempio di un <xref:System.Collections.Generic.List%601> dei tipi complessi, vedere il <xref:System.Collections.Generic.List%601.Contains%2A> (metodo).)  
  
 Il costruttore predefinito viene utilizzato per creare un elenco di stringhe con la capacità predefinita. Il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata e quindi il <xref:System.Collections.Generic.List%601.Add%2A> metodo consente di aggiungere diversi elementi. Vengono elencati gli elementi e il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata anche in questo caso, insieme al <xref:System.Collections.Generic.List%601.Count%2A> proprietà, per mostrare che la capacità è stata aumentata in base alle esigenze.  
  
 Il <xref:System.Collections.Generic.List%601.Contains%2A> metodo viene utilizzato per verificare la presenza di un elemento nell'elenco, il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserire un nuovo elemento al centro dell'elenco e viene visualizzato nuovamente il contenuto dell'elenco.  
  
 Il valore predefinito <xref:System.Collections.Generic.List%601.Item%2A> proprietà (l'indicizzatore in c#) viene utilizzata per recuperare un elemento, il <xref:System.Collections.Generic.List%601.Remove%2A> viene usato il metodo per rimuovere la prima istanza dell'elemento duplicato aggiunto in precedenza e viene visualizzato nuovamente il contenuto. Il <xref:System.Collections.Generic.List%601.Remove%2A> metodo rimuove sempre la prima istanza viene rilevato.  
  
 Il <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo viene utilizzato per ridurre la capacità in modo che corrisponda al conteggio e la <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> verranno visualizzate le proprietà. Se la capacità inutilizzata fosse stato inferiore al 10% della capacità totale, l'elenco potrebbe non stato ridimensionato.  
  
 Infine, il <xref:System.Collections.Generic.List%601.Clear%2A> metodo viene utilizzato per rimuovere tutti gli elementi dall'elenco e il <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> verranno visualizzate le proprietà.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  
  
È consigliabile eseguire più operazioni di lettura su un <see cref="T:System.Collections.Generic.List`1" />, ma possono verificarsi problemi se la raccolta viene modificata mentre viene letto. Per garantire la thread safety, bloccare la raccolta durante un'operazione di lettura o operazione di scrittura. Per abilitare una raccolta a cui accedono più thread per la lettura e scrittura, è necessario implementare la propria sincronizzazione. Per le raccolte con la sincronizzazione predefinita, vedere le classi di <see cref="N:System.Collections.Concurrent" /> dello spazio dei nomi. Per un'alternativa intrinsecamente thread-safe, vedere il <see cref="T:System.Collections.Immutable.ImmutableList`1" /> classe.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteratori (C# e Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.List`1" /> vuota e con capacità iniziale predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.List%601> è il numero di elementi che il <xref:System.Collections.Generic.List%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.List%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna.  
  
 Se le dimensioni della raccolta possono essere stimata tramite il <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> costruttore e specificando la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.List%601>.  
  
 La capacità può essere ridotto mediante una chiamata di <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo oppure impostando il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà in modo esplicito. La riduzione della capacità la memoria viene riallocata e copia tutti gli elementi di <xref:System.Collections.Generic.List%601>.  
  
 Questo costruttore è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio seguente illustra il costruttore predefinito del <xref:System.Collections.Generic.List%601> classe generica. Il costruttore predefinito crea un elenco con la capacità predefinita, come dimostrato visualizzando il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà.  
  
 L'esempio aggiunge inserisce e rimuove gli elementi, che illustra come la capacità cambia mentre questi metodi vengono usati.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Raccolta i cui elementi vengono copiati nel nuovo elenco.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.List`1" /> che contiene gli elementi copiati dalla raccolta specificata e ha la capacità sufficiente per contenere il numero di elementi copiati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono copiati nel <xref:System.Collections.Generic.List%601> nello stesso ordine in cui vengono letti dall'enumeratore della raccolta.  
  
 Questo costruttore è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi in `collection`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.%23ctor%2A> costruttore e vari metodi del <xref:System.Collections.Generic.List%601> classi che agiscono su intervalli. Una matrice di stringhe viene creata e passata al costruttore, popolamento dell'elenco con gli elementi della matrice. Il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene quindi visualizzata, per mostrare che la capacità iniziale è esattamente ciò che è richiesto per contenere gli elementi di input.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Numero di elementi che possono essere archiviati inizialmente nel nuovo elenco.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Generic.List`1" /> vuota e con capacità iniziale specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacità di un <xref:System.Collections.Generic.List%601> è il numero di elementi che il <xref:System.Collections.Generic.List%601> può contenere. Man mano che gli elementi vengono aggiunti a un <xref:System.Collections.Generic.List%601>, la capacità viene aumentata automaticamente come richiesto da la riallocazione della matrice interna.  
  
 Se le dimensioni della raccolta possono essere stimata, che specifica la capacità iniziale evita di dover eseguire alcune operazioni di ridimensionamento durante l'aggiunta di elementi di <xref:System.Collections.Generic.List%601>.  
  
 La capacità può essere ridotto mediante una chiamata di <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo oppure impostando il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà in modo esplicito. La riduzione della capacità la memoria viene riallocata e copia tutti gli elementi di <xref:System.Collections.Generic.List%601>.  
  
 Questo costruttore è un'operazione O (*n*) operazione, in cui *n* è `capacity`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> costruttore. Oggetto <xref:System.Collections.Generic.List%601> di stringhe con una capacità pari a 4 viene creato, poiché la dimensione finale dell'elenco è noto per essere esattamente di 4. L'elenco viene popolato con quattro stringhe e viene creata una copia di sola lettura usando la <xref:System.Collections.Generic.List%601.AsReadOnly%2A> (metodo).  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da aggiungere alla fine di <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Aggiunge un oggetto alla fine di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente gli elementi duplicati.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> è già pari <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacità del <xref:System.Collections.Generic.List%601> viene incrementato automaticamente la riallocazione della matrice interna, e vengono copiati gli elementi esistenti nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> è minore di <xref:System.Collections.Generic.List%601.Capacity%2A>, questo metodo è un'operazione o (1). Se la capacità deve essere incrementata per far posto al nuovo elemento, questo metodo diventa un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 L'esempio seguente illustra numerose proprietà e metodi del <xref:System.Collections.Generic.List%601> classe generica, tra cui la <xref:System.Collections.Generic.List%601.Add%2A> (metodo). Il costruttore predefinito viene utilizzato per creare un elenco di stringhe con una capacità pari a 0. Il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata e quindi il <xref:System.Collections.Generic.List%601.Add%2A> metodo consente di aggiungere diversi elementi. Vengono elencati gli elementi e il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata anche in questo caso, insieme al <xref:System.Collections.Generic.List%601.Count%2A> proprietà, per mostrare che la capacità è stata aumentata in base alle esigenze.  
  
 Altri metodi e proprietà consentono di cercare, inserire e rimuovere elementi dall'elenco e infine per cancellare l'elenco.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Raccolta i cui elementi devono essere aggiunti alla fine di <see cref="T:System.Collections.Generic.List`1" />. La raccolta non può essere <see langword="null" />, ma può contenere elementi <see langword="null" />, se il tipo <paramref name="T" /> è un tipo di riferimento.</param>
        <summary>Aggiunge gli elementi della raccolta specificata alla fine di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene mantenuto l'ordine degli elementi nella raccolta di <xref:System.Collections.Generic.List%601>.  
  
 Se il nuovo <xref:System.Collections.Generic.List%601.Count%2A> (corrente <xref:System.Collections.Generic.List%601.Count%2A> oltre le dimensioni della raccolta) sarà maggiore <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacità del <xref:System.Collections.Generic.List%601> viene incrementato automaticamente la riallocazione della matrice interna per contenere i nuovi elementi e il gli elementi esistenti vengono copiati nella nuova matrice prima dell'aggiunta di nuovi elementi.  
  
 Se il <xref:System.Collections.Generic.List%601> può contenere i nuovi elementi senza aumentare il <xref:System.Collections.Generic.List%601.Capacity%2A>, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi da aggiungere. Se la capacità deve essere incrementata per far posto i nuovi elementi, questo metodo diventa un'operazione O (*n* + *m*) operazione, in cui *n* è il numero di elementi da aggiungere e *m* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.AddRange%2A> metodo e vari altri metodi del <xref:System.Collections.Generic.List%601> classi che agiscono su intervalli. Una matrice di stringhe viene creata e passata al costruttore, popolamento dell'elenco con gli elementi della matrice. Il <xref:System.Collections.Generic.List%601.AddRange%2A> metodo viene chiamato, con l'elenco come argomento. Il risultato è che alla fine dell'elenco, la duplicazione di tutti gli elementi vengono aggiunti gli elementi dell'elenco correnti.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di sola lettura per la raccolta corrente.</summary>
        <returns>Oggetto che fa da wrapper di sola lettura per l'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per evitare che venga modificato il <xref:System.Collections.Generic.List%601> oggetto, viene esposto solo tramite questo wrapper. Oggetto <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> oggetto non espone i metodi che modificano la raccolta. Tuttavia, se vengono apportate modifiche sottostanti <xref:System.Collections.Generic.List%601> dell'oggetto, la raccolta di sola lettura riflette le modifiche.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.AsReadOnly%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe con una capacità pari a 4 viene creato, poiché la dimensione finale dell'elenco è noto per essere esattamente di 4. L'elenco viene popolato con quattro stringhe e il <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metodo viene utilizzato per ottenere una sola lettura <xref:System.Collections.Generic.IList%601> implementazione dell'interfaccia generica che include l'elenco originale.  
  
 Un elemento dell'elenco originale viene impostato su "Coelophysis" utilizzando il <xref:System.Collections.Generic.List%601.Item%2A> proprietà (l'indicizzatore in c#) e il contenuto dell'elenco di sola lettura viene visualizzati anche in questo caso per dimostrare che si tratta di un wrapper per l'elenco originale.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Viene usato un algoritmo di ricerca binario per individuare un elemento specifico nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato o in una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Cerca un elemento nell'intero <see cref="T:System.Collections.Generic.List`1" /> ordinato usando l'operatore di confronto predefinito e restituisce l'indice in base zero dell'elemento.</summary>
        <returns>Indice in base zero di <paramref name="item" /> nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato, se <paramref name="item" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="item" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> per il tipo `T` per determinare l'ordine degli elementi dell'elenco. Il <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> proprietà verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa una delle due interfacce <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Collections.Generic.List%601> devono già essere ordinati in base all'implementazione dell'operatore di confronto; in caso contrario, il risultato non è corretto.  
  
 Confronto tra `null` con qualsiasi riferimento di tipo è consentito e non genera un'eccezione quando si usa il <xref:System.IComparable%601> interfaccia generica. Durante l'ordinamento, `null` è considerata minore rispetto a qualsiasi altro oggetto.  
  
 Se il <xref:System.Collections.Generic.List%601> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze che potrebbe essere una qualsiasi delle occorrenze, non necessariamente quella del primo.  
  
 Se il <xref:System.Collections.Generic.List%601> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca. Quando si inserisce il valore nel <xref:System.Collections.Generic.List%601>, questo indice deve essere utilizzato come il punto di inserimento per mantenere l'ordinamento.  
  
 Questo metodo è un'operazione O (log *n*) operazione, in cui *n* è il numero di elementi nell'intervallo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> overload del metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, senza alcun ordine specifico. L'elenco è visualizzato, ordinato e visualizzato nuovamente.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> overload del metodo viene quindi usato per eseguire la ricerca di due stringhe che non sono presenti nell'elenco, e il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene usato per inserirli. Il valore restituito del <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> metodo è negativo in ogni caso, poiché le stringhe non sono presenti nell'elenco. Prendendo il complemento bit per bit (di ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) di questo numero negativo produce l'indice del primo elemento nell'elenco che in questa posizione è maggiore della stringa di ricerca e inserimento preserva l'ordinamento ordine. La seconda stringa di ricerca è maggiore di qualsiasi elemento nell'elenco, in modo che la posizione di inserimento si trova alla fine dell'elenco.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'operatore di confronto predefinito <see cref="P:System.Collections.Generic.Comparer`1.Default" /> non riesce a trovare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o l'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare quando si confrontano gli elementi.  
  
oppure 
 <see langword="null" /> per usare la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto predefinito.</param>
        <summary>Cerca un elemento nell'intero <see cref="T:System.Collections.Generic.List`1" /> ordinato usando l'operatore di confronto specificato e restituisce l'indice in base zero dell'elemento.</summary>
        <returns>Indice in base zero di <paramref name="item" /> nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato, se <paramref name="item" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="item" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'operatore di confronto consente di personalizzare la modalità di confronto di elementi. Ad esempio, è possibile usare un <xref:System.Collections.CaseInsensitiveComparer> istanza come l'operatore di confronto per eseguire le ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` viene specificato, gli elementi del <xref:System.Collections.Generic.List%601> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione.  
  
 Se `comparer` viene `null`, l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa una delle due interfacce <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un'eccezione <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Collections.Generic.List%601> devono già essere ordinati in base all'implementazione dell'operatore di confronto; in caso contrario, il risultato non è corretto.  
  
 Confronto tra `null` con qualsiasi riferimento di tipo è consentito e non genera un'eccezione quando si usa il <xref:System.IComparable%601> interfaccia generica. Durante l'ordinamento, `null` è considerata minore rispetto a qualsiasi altro oggetto.  
  
 Se il <xref:System.Collections.Generic.List%601> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze che potrebbe essere una qualsiasi delle occorrenze, non necessariamente quella del primo.  
  
 Se il <xref:System.Collections.Generic.List%601> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca. Quando si inserisce il valore nel <xref:System.Collections.Generic.List%601>, questo indice deve essere utilizzato come il punto di inserimento per mantenere l'ordinamento.  
  
 Questo metodo è un'operazione O (log *n*) operazione, in cui *n* è il numero di elementi nell'intervallo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un operatore alternativo per le stringhe denominata DinoCompare, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. L'operatore di confronto funziona nel modo seguente: in primo luogo, i termini del confronto sono testate per `null`, e un riferimento null viene considerato minore rispetto a un diverso da null. In secondo luogo, vengono confrontati con le lunghezze di stringa e la stringa più lunga viene considerata maggiore di. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, senza alcun ordine specifico. L'elenco viene visualizzato, ordinato usando l'operatore di confronto alternativo e visualizzata nuovamente.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo viene quindi usato per cercare più stringhe non in elenco, utilizzando l'operatore di confronto alternativo. Il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserire le stringhe. Questi due metodi si trovano nella funzione denominata `SearchAndInsert`, insieme al codice per utilizzare il complemento bit per bit (il ~ operatore in c# e Visual C++ `Xor` -1 in Visual Basic) del numero negativo restituito da <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> e usarlo come un indice per inserimento della nuova stringa.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e l'operatore di confronto predefinito <see cref="P:System.Collections.Generic.Comparer`1.Default" /> non riesce a trovare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o l'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Indice iniziale in base zero dell'intervallo in cui eseguire la ricerca.</param>
        <param name="count">Lunghezza dell'intervallo in cui eseguire la ricerca.</param>
        <param name="item">Oggetto da individuare. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare durante il confronto di elementi oppure <see langword="null" /> per usare la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto.</param>
        <summary>Cerca un elemento in un intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato usando l'operatore di confronto specificato e restituisce l'indice in base zero dell'elemento.</summary>
        <returns>Indice in base zero di <paramref name="item" /> nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> ordinato, se <paramref name="item" /> viene trovato; in caso contrario, un numero negativo che rappresenta il complemento bit per bit dell'indice dell'elemento successivo maggiore di <paramref name="item" /> o, se non è disponibile alcun elemento maggiore, il complemento bit per bit di <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'operatore di confronto consente di personalizzare la modalità di confronto di elementi. Ad esempio, è possibile usare un <xref:System.Collections.CaseInsensitiveComparer> istanza come l'operatore di confronto per eseguire le ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` viene specificato, gli elementi del <xref:System.Collections.Generic.List%601> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione.  
  
 Se `comparer` viene `null`, l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa una delle due interfacce <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un'eccezione <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Collections.Generic.List%601> devono già essere ordinati in base all'implementazione dell'operatore di confronto; in caso contrario, il risultato non è corretto.  
  
 Confronto tra `null` con qualsiasi riferimento di tipo è consentito e non genera un'eccezione quando si usa il <xref:System.IComparable%601> interfaccia generica. Durante l'ordinamento, `null` è considerata minore rispetto a qualsiasi altro oggetto.  
  
 Se il <xref:System.Collections.Generic.List%601> contiene più di un elemento con lo stesso valore, il metodo restituisce solo una delle occorrenze che potrebbe essere una qualsiasi delle occorrenze, non necessariamente quella del primo.  
  
 Se il <xref:System.Collections.Generic.List%601> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operazione di complemento bit per bit (~) per questo numero intero negativo per ottenere l'indice del primo elemento che è maggiore del valore di ricerca. Quando si inserisce il valore nel <xref:System.Collections.Generic.List%601>, questo indice deve essere utilizzato come il punto di inserimento per mantenere l'ordinamento.  
  
 Questo metodo è un'operazione O (log *n*) operazione, in cui *n* è il numero di elementi nell'intervallo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un operatore alternativo per le stringhe denominata DinoCompare, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. L'operatore di confronto funziona nel modo seguente: in primo luogo, i termini del confronto sono testate per `null`, e un riferimento null viene considerato minore rispetto a un diverso da null. In secondo luogo, vengono confrontati con le lunghezze di stringa e la stringa più lunga viene considerata maggiore di. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con i nomi di cinque dinosaurs dinosauri e dinosaurs dinosauri tre. All'interno di ognuno dei due gruppi, i nomi non sono in alcun ordine particolare. Viene visualizzato l'elenco, l'intervallo di erbivori viene ordinato utilizzando l'operatore di confronto alternativo e viene nuovamente visualizzato l'elenco.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo viene quindi usato per cercare solo l'intervallo di erbivori "Brachiosaurus". La stringa non viene trovata, il complemento bit per bit e (i ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) del numero negativo restituito dal <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metodo viene utilizzato come indice per l'inserimento della nuova stringa.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido nell'oggetto <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e l'operatore di confronto predefinito <see cref="P:System.Collections.Generic.Comparer`1.Default" /> non riesce a trovare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o l'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero totale di elementi che la struttura dati interna è in grado di contenere senza alcun ridimensionamento.</summary>
        <value>Numero di elementi che <see cref="T:System.Collections.Generic.List`1" /> può contenere prima che sia necessario un ridimensionamento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> è il numero di elementi che il <xref:System.Collections.Generic.List%601> consente di archiviare prima che il ridimensionamento è obbligatorio, mentre <xref:System.Collections.Generic.List%601.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> è sempre maggiore di o uguale a <xref:System.Collections.Generic.List%601.Count%2A>. Se <xref:System.Collections.Generic.List%601.Count%2A> supera <xref:System.Collections.Generic.List%601.Capacity%2A> durante l'aggiunta di elementi, la capacità viene incrementata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiungere i nuovi elementi.  
  
 Se la capacità è notevolmente superiore rispetto al numero e si vuole ridurre la memoria usata dal <xref:System.Collections.Generic.List%601>, è possibile ridurre la capacità chiamando il <xref:System.Collections.Generic.List%601.TrimExcess%2A> (metodo) oppure impostando il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà in modo esplicito su un valore inferiore. Quando il valore di <xref:System.Collections.Generic.List%601.Capacity%2A> è impostato in modo esplicito, la matrice interna viene riallocata anche per consentire la capacità specificata e tutti gli elementi vengono copiati.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è un'operazione O (*n*) operazione, in cui *n* è la nuova capacità.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come controllare la capacità e conteggio di una <xref:System.Collections.Generic.List%601> che contiene un semplice oggetto business e viene illustrato l'utilizzo di <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo per rimuovere capacità aggiuntiva.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 L'esempio seguente illustra il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà in vari punti della vita di un elenco. Il costruttore predefinito viene utilizzato per creare un elenco di stringhe con una capacità pari a 0 e il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata per dimostrare questo concetto. Dopo il <xref:System.Collections.Generic.List%601.Add%2A> metodo è stato usato per aggiungere diversi elementi, vengono elencati gli elementi e quindi il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata anche in questo caso, insieme al <xref:System.Collections.Generic.List%601.Count%2A> proprietà, per mostrare che la capacità è stata aumentata in base alle esigenze.  
  
 Il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà viene visualizzata nuovamente dopo la <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo viene utilizzato per ridurre la capacità in modo che corrisponda il conteggio. Infine, il <xref:System.Collections.Generic.List%601.Clear%2A> metodo viene utilizzato per rimuovere tutti gli elementi dall'elenco e il <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> proprietà vengono visualizzate anche in questo caso.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'oggetto <see cref="P:System.Collections.Generic.List`1.Capacity" /> è impostato su un valore minore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile nel sistema non è sufficiente.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli elementi da <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> è impostato su 0, e vengono rilasciati anche i riferimenti ad altri oggetti da elementi della raccolta.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> rimane invariato. Per reimpostare la capacità dei <xref:System.Collections.Generic.List%601>, chiamare il <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo o un set di <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà direttamente. La riduzione della capacità la memoria viene riallocata e copia tutti gli elementi di <xref:System.Collections.Generic.List%601>. Trimming di un oggetto vuoto <xref:System.Collections.Generic.List%601> imposta la capacità del <xref:System.Collections.Generic.List%601> alla capacità predefinita.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Clear%2A> (metodo) e varie altre proprietà e metodi del <xref:System.Collections.Generic.List%601> classe generica. Il <xref:System.Collections.Generic.List%601.Clear%2A> metodo viene utilizzato alla fine del programma, per rimuovere tutti gli elementi dall'elenco e il <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> verranno quindi visualizzate le proprietà.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Determina se un elemento è incluso in <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> è presente in <see cref="T:System.Collections.Generic.List`1" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza con l'operatore di confronto uguaglianze predefinito, come definito dall'implementazione dell'oggetto del <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metodo per `T` (il tipo dei valori nell'elenco).  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Contains%2A> e <xref:System.Collections.Generic.List%601.Exists%2A> metodi su un <xref:System.Collections.Generic.List%601> che contiene un semplice oggetto business che implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 L'esempio seguente contiene un elenco di oggetti complessi, di tipo `Cube`. Il `Cube` classe implementa il <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metodo in modo che due cubi vengono considerati uguali se hanno le stesse dimensioni. In questo esempio, il <xref:System.Collections.Generic.List%601.Contains%2A> restituzione del metodo `true`, in quanto un cubo con le dimensioni specificate si trova già nella raccolta.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Tipo degli elementi della matrice di destinazione.</typeparam>
        <param name="converter">Delegato <see cref="T:System.Converter`2" /> che converte ogni elemento da un tipo in un altro.</param>
        <summary>Converte gli elementi dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrente in un altro tipo e restituisce un elenco contenente gli elementi convertiti.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.List`1" /> del tipo di destinazione contenente gli elementi convertiti dall'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Converter%602> è un delegato a un metodo che converte un oggetto nel tipo di destinazione.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Converter%602> delegato e gli elementi convertiti vengono salvati nel nuovo <xref:System.Collections.Generic.List%601>.  
  
 Corrente <xref:System.Collections.Generic.List%601> rimane invariato.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente definisce un metodo denominato `PointFToPoint` che converte un <xref:System.Drawing.PointF> struttura per un <xref:System.Drawing.Point> struttura. Viene quindi creato un <xref:System.Collections.Generic.List%601> dei <xref:System.Drawing.PointF> strutture, crea un `Converter\<PointF, Point>` delegare (`Converter(Of PointF, Point)` in Visual Basic) per rappresentare il `PointFToPoint` metodo e passa il delegato per il <xref:System.Collections.Generic.List%601.ConvertAll%2A> (metodo). Il <xref:System.Collections.Generic.List%601.ConvertAll%2A> metodo passa ogni elemento dell'elenco di input per il `PointFToPoint` metodo e inserisce gli elementi convertiti in un nuovo elenco di <xref:System.Drawing.Point> strutture. Entrambi gli elenchi vengono visualizzati.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="converter" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia <see cref="T:System.Collections.Generic.List`1" /> o una parte di esso in una matrice.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.List`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <summary>Copia l'intero oggetto <see cref="T:System.Collections.Generic.List`1" /> in una matrice compatibile unidimensionale, a partire dall'inizio della matrice di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> copiare gli elementi.  
  
 Vengono copiati gli elementi per il <xref:System.Array> nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti e tre gli overload del <xref:System.Collections.Generic.List%601.CopyTo%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato e popolato con le stringhe di 5. Viene creata una matrice di stringa vuota di 15 elementi e il <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> overload del metodo viene usato per copiare tutti gli elementi dell'elenco per la matrice, iniziando dal primo elemento della matrice. Il <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> overload del metodo viene usato per copiare tutti gli elementi dell'elenco per la matrice, iniziando dall'indice 6 (lasciando vuoto l'indice 5). Infine, il <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo viene usato per copiare 3 elementi nell'elenco a partire dall'indice 2, per la matrice iniziando in corrispondenza di matrice indice 12 (lasciando vuoto l'indice 11). Il contenuto della matrice viene quindi visualizzato.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine è maggiore del numero di elementi che l'oggetto <paramref name="array" /> di destinazione può contenere.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.List`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <paramref name="array" /> in corrispondenza del quale viene avviata la copia.</param>
        <summary>Copia l'intero oggetto <see cref="T:System.Collections.Generic.List`1" /> in una matrice compatibile unidimensionale, a partire dall'indice specificato della matrice di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> copiare gli elementi.  
  
 Vengono copiati gli elementi per il <xref:System.Array> nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti e tre gli overload del <xref:System.Collections.Generic.List%601.CopyTo%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato e popolato con le stringhe di 5. Viene creata una matrice di stringa vuota di 15 elementi e il <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> overload del metodo viene usato per copiare tutti gli elementi dell'elenco per la matrice, iniziando dal primo elemento della matrice. Il <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> overload del metodo viene usato per copiare tutti gli elementi dell'elenco per la matrice, iniziando dall'indice 6 (lasciando vuoto l'indice 5). Infine, il <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo viene usato per copiare 3 elementi nell'elenco a partire dall'indice 2, per la matrice iniziando in corrispondenza di matrice indice 12 (lasciando vuoto l'indice 11). Il contenuto della matrice viene quindi visualizzato.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine a partire dal quale viene effettuata la copia.</param>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.Generic.List`1" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <paramref name="array" /> in corrispondenza del quale viene avviata la copia.</param>
        <param name="count">Numero degli elementi da copiare.</param>
        <summary>Copia un intervallo di elementi da <see cref="T:System.Collections.Generic.List`1" /> in una matrice compatibile unidimensionale, a partire dall'indice specificato della matrice di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> copiare gli elementi.  
  
 Vengono copiati gli elementi per il <xref:System.Array> nello stesso ordine in cui l'enumeratore esegue l'iterazione attraverso la <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti e tre gli overload del <xref:System.Collections.Generic.List%601.CopyTo%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato e popolato con le stringhe di 5. Viene creata una matrice di stringa vuota di 15 elementi e il <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> overload del metodo viene usato per copiare tutti gli elementi dell'elenco per la matrice, iniziando dal primo elemento della matrice. Il <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> overload del metodo viene usato per copiare tutti gli elementi dell'elenco per la matrice, iniziando dall'indice 6 (lasciando vuoto l'indice 5). Infine, il <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo viene usato per copiare 3 elementi nell'elenco a partire dall'indice 2, per la matrice iniziando in corrispondenza di matrice indice 12 (lasciando vuoto l'indice 11). Il contenuto della matrice viene quindi visualizzato.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="arrayIndex" /> è minore di 0.  
  
oppure 
 <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> è maggiore o uguale al valore di <see cref="P:System.Collections.Generic.List`1.Count" /> dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine.  
  
oppure 
Il numero di elementi da <paramref name="index" /> alla fine dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> di origine è maggiore dello spazio disponibile da <paramref name="arrayIndex" /> alla fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di elementi contenuti in <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>Il numero di elementi contenuti in <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> è il numero di elementi che il <xref:System.Collections.Generic.List%601> archiviabili prima che sia necessario un ridimensionamento. <xref:System.Collections.Generic.List%601.Count%2A> è il numero di elementi effettivamente contenuti nella <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> è sempre maggiore di o uguale a <xref:System.Collections.Generic.List%601.Count%2A>. Se <xref:System.Collections.Generic.List%601.Count%2A> supera <xref:System.Collections.Generic.List%601.Capacity%2A> durante l'aggiunta di elementi, la capacità viene incrementata automaticamente la riallocazione della matrice interna prima di copiare gli elementi e aggiungere i nuovi elementi.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come controllare la capacità e conteggio di una <xref:System.Collections.Generic.List%601> che contiene un semplice oggetto business e viene illustrato l'utilizzo di <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo per rimuovere capacità aggiuntiva.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene mostrato il valore di <xref:System.Collections.Generic.List%601.Count%2A> proprietà in vari punti della vita di un elenco. Dopo che viene creato e popolato l'elenco e i relativi elementi visualizzati, il <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> verranno visualizzate le proprietà. Queste proprietà vengono visualizzate dopo le <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo è stato chiamato e dopo il contenuto dell'elenco viene cancellato.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da cercare.</param>
        <summary>Determina se <see cref="T:System.Collections.Generic.List`1" /> contiene gli elementi che corrispondono alle condizioni definite dal predicato specificato.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.List`1" /> contiene uno o più elementi che corrispondono alle condizioni definite dal predicato specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente al <xref:System.Predicate%601> delegato e l'elaborazione viene arrestata quando viene trovata una corrispondenza.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Contains%2A> e <xref:System.Collections.Generic.List%601.Exists%2A> metodi su un <xref:System.Collections.Generic.List%601> che contiene un semplice oggetto business che implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Exists%2A> metodo e diversi altri metodi che usano il <xref:System.Predicate%601> delegato generico.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato, contenente nomi divorasse 8, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, e <xref:System.Collections.Generic.List%601.FindAll%2A> vengono utilizzati metodi per eseguire una ricerca nell'elenco con il metodo di predicato di ricerca, quindi il <xref:System.Collections.Generic.List%601.RemoveAll%2A> metodo viene utilizzato per rimuovere tutte le voci che terminano con "saurus".  
  
 Infine, il <xref:System.Collections.Generic.List%601.Exists%2A> viene chiamato il metodo. Attraversa l'elenco a partire dall'inizio, passando ogni elemento, a sua volta la `EndsWithSaurus` (metodo). Arresta la ricerca e il metodo restituisce `true` se il `EndsWithSaurus` restituzione del metodo `true` per qualsiasi elemento. Il <xref:System.Collections.Generic.List%601.Exists%2A> restituzione del metodo `false` perché sono stati rimossi tutti gli elementi.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce la prima occorrenza all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Primo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato, lo spostamento in avanti <xref:System.Collections.Generic.List%601>, inizia il primo elemento e termina con l'ultimo elemento.  L'elaborazione viene arrestata quando viene trovata una corrispondenza.  
  
> [!IMPORTANT]
>  Quando si esegue la ricerca di un elenco contenente i tipi di valore, assicurarsi che il valore predefinito per il tipo non soddisfa il predicato di ricerca. In caso contrario, non è possibile distinguere tra un elemento di elenco che ha il valore predefinito per il tipo e un valore predefinito che indica che è stata trovata alcuna corrispondenza. Se il valore predefinito soddisfa il predicato di ricerca, usare il <xref:System.Collections.Generic.List%601.FindIndex%2A> metodo invece.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il metodo <xref:System.Collections.Generic.List%601.Find%2A> su un <xref:System.Collections.Generic.List%601> contenente un oggetto complesso semplice.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 L'esempio seguente illustra i metodi find per la <xref:System.Collections.Generic.List%601> classe. L'esempio per la <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, usando i dati di [File XML di esempio: libri (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dal file XML per i valori della proprietà di `book` oggetti.  
  
 La tabella seguente descrive gli esempi forniti per i metodi find.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri che la cui proprietà `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta che dispone di una data di pubblicazione prima del 2001, usando il `PubBefore2001` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da cercare.</param>
        <summary>Recupera tutti gli elementi che soddisfano le condizioni definite nel predicato specificato.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.List`1" /> contenente tutti gli elementi che corrispondono alle condizioni definite dal predicato specificato, se presente; in caso contrario, un oggetto <see cref="T:System.Collections.Generic.List`1" /> vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato e gli elementi che soddisfano le condizioni vengono salvati nell'oggetto restituito <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i metodi find per la <xref:System.Collections.Generic.List%601> classe. L'esempio per la <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, usando i dati di [File XML di esempio: libri (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dal file XML per i valori della proprietà di `book` oggetti.  
  
 La tabella seguente descrive gli esempi forniti per i metodi find.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri che la cui proprietà `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta che dispone di una data di pubblicazione prima del 2001, usando il `PubBefore2001` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cerca un elemento che corrisponda alle condizioni definite da un predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di <see cref="T:System.Collections.Generic.List`1" /> o di una parte di esso. Questo metodo restituisce -1 se non viene trovato alcun articolo che soddisfa le condizioni.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che corrisponda alle condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> avanti al primo elemento fino all'ultimo elemento, viene eseguita la ricerca.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente al <xref:System.Predicate%601> delegare. Il delegato ha la firma:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente definisce un `Employee` classe con due campi `Name` e `Id`. Definisce anche un `EmployeeSearch` classe con un singolo metodo, `StartsWith`, che indica se il `Employee.Name` campo inizia con una sottostringa specificata che viene fornita il `EmployeeSearch` costruttore della classe. Si noti la firma del metodo  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corrisponde alla firma del delegato che può essere passato al <xref:System.Collections.Generic.List%601.FindIndex%2A> (metodo). L'esempio crea un'istanza una `List<Employee>` oggetto, aggiunge il numero di `Employee` oggetti, e quindi chiama il <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metodo due volte per eseguire la ricerca dell'intera raccolta, la prima volta per la prima `Employee` il cui `Name` di inizio del campo con "J" e la seconda volta per i primi `Employee` il cui `Name` campo inizia con "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Indice iniziale in base zero della ricerca.</param>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> compreso tra l'indice specificato e l'ultimo elemento.</summary>
        <returns>Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca in avanti partire `startIndex` fino all'ultimo elemento.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente al <xref:System.Predicate%601> delegare. Il delegato ha la firma:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi da `startIndex` alla fine del <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 L'esempio seguente definisce un `Employee` classe con due campi `Name` e `Id`. Definisce anche un `EmployeeSearch` classe con un singolo metodo, `StartsWith`, che indica se il `Employee.Name` campo inizia con una sottostringa specificata che viene fornita il `EmployeeSearch` costruttore della classe. Si noti la firma del metodo  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corrisponde alla firma del delegato che può essere passato al <xref:System.Collections.Generic.List%601.FindIndex%2A> (metodo). L'esempio crea un'istanza una `List<Employee>` dell'oggetto, aggiunge il numero di `Employee` oggetti, e quindi chiama il <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metodo due volte da cercare nella raccolta inizia con il relativo membro quinto (vale a dire, il membro in corrispondenza dell'indice 4). La prima volta, viene cercato il primo `Employee` dell'oggetto la cui proprietà `Name` campo inizia con "J"; la seconda volta, viene cercato il primo `Employee` cui `Name` campo inizia con "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Indice iniziale in base zero della ricerca.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> che inizia dall'indice specificato e contiene il numero indicato di elementi.</summary>
        <returns>Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca in avanti partire `startIndex` a `startIndex` plus `count` meno 1, se `count` è maggiore di 0.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente al <xref:System.Predicate%601> delegare. Il delegato ha la firma:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente definisce un `Employee` classe con due campi `Name` e `Id`. Definisce anche un `EmployeeSearch` classe con un singolo metodo, `StartsWith`, che indica se il `Employee.Name` campo inizia con una sottostringa specificata che viene fornita il `EmployeeSearch` costruttore della classe. Si noti la firma del metodo  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corrisponde alla firma del delegato che può essere passato al <xref:System.Collections.Generic.List%601.FindIndex%2A> (metodo). L'esempio crea un'istanza un `List<Employee>` oggetto, aggiunge il numero di `Employee` oggetti al servizio e quindi chiama il <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> due volte per cercare l'intera raccolta (vale a dire, i membri dall'indice 0 all'indice <xref:System.Collections.Generic.List%601.Count%2A> - 1). La prima volta, viene cercato il primo `Employee` dell'oggetto la cui proprietà `Name` campo inizia con "J"; la seconda volta, viene cercato il primo `Employee` cui `Name` campo inizia con "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.  
  
oppure 
 <paramref name="count" /> è minore di 0.  
  
oppure 
 <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce l'ultima occorrenza all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Ultimo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato, lo spostamento all'indietro <xref:System.Collections.Generic.List%601>, iniziando all'ultimo elemento e terminando con il primo elemento.  L'elaborazione viene arrestata quando viene trovata una corrispondenza.  
  
> [!IMPORTANT]
>  Quando si esegue la ricerca di un elenco contenente i tipi di valore, assicurarsi che il valore predefinito per il tipo non soddisfa il predicato di ricerca. In caso contrario, non è possibile distinguere tra un elemento di elenco che ha il valore predefinito per il tipo e un valore predefinito che indica che è stata trovata alcuna corrispondenza. Se il valore predefinito soddisfa il predicato di ricerca, usare il <xref:System.Collections.Generic.List%601.FindLastIndex%2A> metodo invece.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i metodi find per la <xref:System.Collections.Generic.List%601> classe. L'esempio per la <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, usando i dati di [File XML di esempio: libri (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dal file XML per i valori della proprietà di `book` oggetti.  
  
 La tabella seguente descrive gli esempi forniti per i metodi find.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri che la cui proprietà `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta che dispone di una data di pubblicazione prima del 2001, usando il `PubBefore2001` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno di <see cref="T:System.Collections.Generic.List`1" /> o di una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente al <xref:System.Predicate%601> delegare.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra i metodi find per la <xref:System.Collections.Generic.List%601> classe. L'esempio per la <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, usando i dati di [File XML di esempio: libri (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dal file XML per i valori della proprietà di `book` oggetti.  
  
 La tabella seguente descrive gli esempi forniti per i metodi find.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri che la cui proprietà `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta che dispone di una data di pubblicazione prima del 2001, usando il `PubBefore2001` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Indice iniziale in base zero della ricerca all'indietro.</param>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <see cref="T:System.Collections.Generic.List`1" /> compreso tra il primo elemento e l'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e termina in corrispondenza del primo elemento.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente al <xref:System.Predicate%601> delegare.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi dall'inizio del <xref:System.Collections.Generic.List%601> a `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Indice iniziale in base zero della ricerca all'indietro.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <see cref="T:System.Collections.Generic.List`1" /> che contiene il numero indicato di elementi e termina in corrispondenza dell'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` a `startIndex` meno `count` + 1, se `count` è maggiore di 0.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente al <xref:System.Predicate%601> delegare.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente illustra i metodi find per la <xref:System.Collections.Generic.List%601> classe. L'esempio per la <xref:System.Collections.Generic.List%601> classe contiene `book` oggetti della classe `Book`, usando i dati di [File XML di esempio: libri (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Il `FillList` metodo nell'esempio viene utilizzato [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) per analizzare i valori dal file XML per i valori della proprietà di `book` oggetti.  
  
 La tabella seguente descrive gli esempi forniti per i metodi find.  
  
|Metodo|Esempio|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Trova un libro usando un ID di `IDToFind` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Trova tutti i libri che la cui proprietà `Genre` proprietà è "Computer" utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Trova l'ultimo libro nella raccolta che dispone di una data di pubblicazione prima del 2001, usando il `PubBefore2001` delegato di predicato.<br /><br /> Esempio di c# usa un delegato anonimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer utilizzando il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice del primo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Trova l'indice dell'ultimo libro di computer nella seconda metà della raccolta, uso il `FindComputer` delegato di predicato.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.  
  
oppure 
 <paramref name="count" /> è minore di 0.  
  
oppure 
 <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">Delegato <see cref="T:System.Action`1" /> da eseguire su ogni elemento di <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Esegue l'azione specificata su ogni elemento di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Action%601> viene delegato a un metodo che esegue un'azione nell'oggetto passato al metodo.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente al <xref:System.Action%601> delegare.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 La modifica dell'insieme sottostante nel corpo del <xref:System.Action%601> delegato non è supportato e genera un comportamento indefinito.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Action%601> delegato per stampare il contenuto di un <xref:System.Collections.Generic.List%601> oggetto. In questo esempio il `Print` metodo viene utilizzato per visualizzare il contenuto dell'elenco nella console.  
  
> [!NOTE]
>  Oltre a visualizzare il contenuto usando la `Print` (metodo), nell'esempio c# viene illustrato l'utilizzo di per visualizzare i risultati nella console.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un elemento nella raccolta è stato modificato.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.List`1.Enumerator" /> per <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> proprietà non è definita. Pertanto, è necessario chiamare il <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> per passare l'enumeratore al primo elemento della raccolta prima di leggere il valore del metodo <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 Il <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> lo stesso oggetto finché non viene restituita la <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> viene chiamato. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> oppure <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero di <see cref="T:System.Collections.Generic.List`1" /> in corrispondenza del quale inizia la serie.</param>
        <param name="count">Numero di elementi nell'intervallo.</param>
        <summary>Crea una copia dei riferimenti di un intervallo di elementi nella classe <see cref="T:System.Collections.Generic.List`1" /> di origine.</summary>
        <returns>Copia dei riferimenti di un intervallo di elementi nella classe <see cref="T:System.Collections.Generic.List`1" /> di origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficiale di una raccolta di tipi di riferimento o un sottoinsieme di tale insieme, contiene solo i riferimenti agli elementi della raccolta. Non vengono copiati gli oggetti stessi. I riferimenti nel nuovo elenco puntano agli stessi oggetti come i riferimenti nell'elenco originale.  
  
 Una copia superficiale di una raccolta di tipi di valore o un sottoinsieme di tale insieme, contiene gli elementi della raccolta. Tuttavia, se gli elementi della raccolta contengano riferimenti ad altri oggetti, tali oggetti non vengono copiati. I riferimenti negli elementi della nuova raccolta puntano agli stessi oggetti come i riferimenti negli elementi della raccolta originale.  
  
 Al contrario, una copia completa di una raccolta copia gli elementi e tutti gli elementi direttamente o indirettamente fa riferimento gli elementi.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.GetRange%2A> metodo e altri metodi del <xref:System.Collections.Generic.List%601> classi che agiscono su intervalli. Alla fine dell'esempio, il <xref:System.Collections.Generic.List%601.GetRange%2A> metodo viene utilizzato per ottenere tre elementi dall'elenco, a partire dalla posizione dell'indice 2. Il <xref:System.Collections.Generic.List%601.ToArray%2A> metodo viene chiamato su risultante <xref:System.Collections.Generic.List%601>, creazione di una matrice di tre elementi. Vengono visualizzati gli elementi della matrice.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'indice in base zero della prima occorrenza di un valore in <see cref="T:System.Collections.Generic.List`1" /> o in una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero della prima occorrenza nell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indice in base zero della prima occorrenza di <paramref name="item" /> all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> avanti al primo elemento fino all'ultimo elemento, viene eseguita la ricerca.  
  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti e tre gli overload del <xref:System.Collections.Generic.List%601.IndexOf%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> overload del metodo cerca nell'elenco a partire dall'inizio e trova la prima occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nell'elenco a partire dalla posizione dell'indice 3 e continuando fino alla fine dell'elenco e consente di trovare la seconda occorrenza della stringa. Infine, il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 perché non sono presenti istanze della stringa di ricerca in tale intervallo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="index">Indice iniziale in base zero della ricerca. 0 (zero) è valido in un elenco vuoto.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> che è compreso tra l'indice specificato e l'ultimo elemento.</summary>
        <returns>Indice in base zero della prima occorrenza di <paramref name="item" /> all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> compreso tra <paramref name="index" /> e l'ultimo elemento, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca in avanti partire `index` fino all'ultimo elemento.  
  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi da `index` alla fine del <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti e tre gli overload del <xref:System.Collections.Generic.List%601.IndexOf%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> overload del metodo cerca nell'elenco a partire dall'inizio e trova la prima occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nell'elenco a partire dalla posizione dell'indice 3 e continuando fino alla fine dell'elenco e consente di trovare la seconda occorrenza della stringa. Infine, il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 perché non sono presenti istanze della stringa di ricerca in tale intervallo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="index">Indice iniziale in base zero della ricerca. 0 (zero) è valido in un elenco vuoto.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> che inizia in corrispondenza dell'indice specificato e contiene il numero di elementi specificato.</summary>
        <returns>Indice in base zero della prima occorrenza di <paramref name="item" /> all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> che inizia da <paramref name="index" /> e contiene il numero di elementi corrispondente a <paramref name="count" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca in avanti partire `index` a `index` plus `count` meno 1, se `count` è maggiore di 0.  
  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti e tre gli overload del <xref:System.Collections.Generic.List%601.IndexOf%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> overload del metodo cerca nell'elenco a partire dall'inizio e trova la prima occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nell'elenco a partire dalla posizione dell'indice 3 e continuando fino alla fine dell'elenco e consente di trovare la seconda occorrenza della stringa. Infine, il <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 perché non sono presenti istanze della stringa di ricerca in tale intervallo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.  
  
oppure 
 <paramref name="count" /> è minore di 0.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non specificano una sezione valida in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero nel quale <paramref name="item" /> deve essere inserito.</param>
        <param name="item">Oggetto da inserire. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Inserisce un elemento in <see cref="T:System.Collections.Generic.List`1" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente gli elementi duplicati.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> è già pari <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacità del <xref:System.Collections.Generic.List%601> viene incrementato automaticamente la riallocazione della matrice interna, e vengono copiati gli elementi esistenti nella nuova matrice prima che venga aggiunto il nuovo elemento.  
  
 Se `index` è uguale a <xref:System.Collections.Generic.List%601.Count%2A>, `item` viene aggiunto alla fine della <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Insert%2A> metodo, insieme a diverse altre proprietà e metodi del <xref:System.Collections.Generic.List%601> classe generica. Dopo aver creato l'elenco, vengono aggiunti gli elementi. Il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserire un elemento al centro dell'elenco. L'elemento inserito è un duplicato, che viene successivamente rimosso usando il <xref:System.Collections.Generic.List%601.Remove%2A> (metodo).  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="index" /> è maggiore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero in corrispondenza del quale devono essere inseriti i nuovi elementi.</param>
        <param name="collection">Raccolta i cui elementi devono essere inseriti in <see cref="T:System.Collections.Generic.List`1" />. La raccolta non può essere <see langword="null" />, ma può contenere elementi <see langword="null" />, se il tipo <paramref name="T" /> è un tipo di riferimento.</param>
        <summary>Inserisce gli elementi di una raccolta in <see cref="T:System.Collections.Generic.List`1" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente gli elementi duplicati.  
  
 Se il nuovo <xref:System.Collections.Generic.List%601.Count%2A> (corrente <xref:System.Collections.Generic.List%601.Count%2A> oltre le dimensioni della raccolta) sarà maggiore <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacità del <xref:System.Collections.Generic.List%601> viene incrementato automaticamente la riallocazione della matrice interna per contenere i nuovi elementi e il gli elementi esistenti vengono copiati nella nuova matrice prima dell'aggiunta di nuovi elementi.  
  
 Se `index` è uguale a <xref:System.Collections.Generic.List%601.Count%2A>, gli elementi vengono aggiunti alla fine della <xref:System.Collections.Generic.List%601>.  
  
 Viene mantenuto l'ordine degli elementi nella raccolta di <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo è un'operazione O (*n* * *m*) operazione, in cui *n* è il numero di elementi da aggiungere e *m* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra <xref:System.Collections.Generic.List%601.InsertRange%2A> metodo e vari altri metodi del <xref:System.Collections.Generic.List%601> classi che agiscono su intervalli. Dopo aver creato e popolato con i nomi dei diversi sia rigenerante impianto feroci, l'elenco di <xref:System.Collections.Generic.List%601.InsertRange%2A> metodo viene utilizzato per inserire una matrice di tre dinosauri carne feroci nell'elenco, a partire dalla posizione di indice 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="index" /> è maggiore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'elemento da ottenere o impostare.</param>
        <summary>Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</summary>
        <value>Elemento in corrispondenza dell'indice specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accetta `null` come tipi di un valore valido per riferimento e consente gli elementi duplicati.  
  
 Questa proprietà consente di accedere a un elemento specifico della raccolta utilizzando la sintassi seguente: `myCollection[index]`.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è anche un'operazione o (1).  
  
   
  
## Examples  
 L'esempio in questa sezione illustra i <xref:System.Collections.Generic.List%601.Item%2A> proprietà (l'indicizzatore in c#) e varie altre proprietà e metodi del <xref:System.Collections.Generic.List%601> classe generica. Dopo che l'elenco è stato creato e popolato usando il <xref:System.Collections.Generic.List%601.Add%2A> metodo, un elemento viene recuperato e visualizzato tramite il <xref:System.Collections.Generic.List%601.Item%2A> proprietà. (Per un esempio che usa il <xref:System.Collections.Generic.List%601.Item%2A> proprietà per impostare il valore di un elemento di elenco, vedere <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, c# e C++ tutti hanno la sintassi per l'accesso al <xref:System.Collections.Generic.List%601.Item%2A> proprietà senza utilizzare il relativo nome. Al contrario, la variabile contenente il <xref:System.Collections.Generic.List%601> viene usato come se fosse una matrice.  
  
 Il linguaggio c# usa la parola chiave per definire gli indicizzatori anziché implementare il <xref:System.Collections.Generic.List%601.Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.List%601.Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="index" /> è uguale a o maggiore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'indice in base zero dell'ultima occorrenza di un valore in <see cref="T:System.Collections.Generic.List`1" /> o in una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero dell'ultima occorrenza nell'intera classe <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di <paramref name="item" /> all'interno dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.  
  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti e tre gli overload del <xref:System.Collections.Generic.List%601.LastIndexOf%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> overload del metodo cerca nell'intero elenco dalla fine e consente di trovare la seconda occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> overload del metodo viene utilizzato per eseguire ricerche nell'elenco con le versioni precedenti a partire dalla posizione dell'indice 3 e continuando fino all'inizio dell'elenco, in modo che trova la prima occorrenza della stringa nell'elenco. Infine, il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce -1, perché non sono presenti istanze di ricerca stringa in tale intervallo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="index">Indice iniziale in base zero della ricerca all'indietro.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi nella classe <see cref="T:System.Collections.Generic.List`1" /> che è compresa tra il primo elemento e l'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di <paramref name="item" /> all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Collections.Generic.List`1" /> compreso tra il primo elemento e <paramref name="index" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita con le versioni precedenti a partire dall'indice `index` e termina in corrispondenza del primo elemento.  
  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è il numero di elementi dall'inizio del <xref:System.Collections.Generic.List%601> a `index`.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti e tre gli overload del <xref:System.Collections.Generic.List%601.LastIndexOf%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> overload del metodo cerca nell'intero elenco dalla fine e consente di trovare la seconda occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> overload del metodo viene utilizzato per eseguire ricerche nell'elenco con le versioni precedenti a partire dalla posizione dell'indice 3 e continuando fino all'inizio dell'elenco, in modo che trova la prima occorrenza della stringa nell'elenco. Infine, il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce -1, perché non sono presenti istanze di ricerca stringa in tale intervallo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <param name="index">Indice iniziale in base zero della ricerca all'indietro.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi della classe <see cref="T:System.Collections.Generic.List`1" /> che contiene il numero di elementi specificato e termina in corrispondenza dell'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di <paramref name="item" /> all'interno dell'intervallo di elementi in <see cref="T:System.Collections.Generic.List`1" /> che contiene un numero di elementi corrispondente a <paramref name="count" /> e termina in corrispondenza di <paramref name="index" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Collections.Generic.List%601> viene eseguita con le versioni precedenti a partire dall'indice `index` a `index` meno `count` + 1, se `count` è maggiore di 0.  
  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è `count`.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti e tre gli overload del <xref:System.Collections.Generic.List%601.LastIndexOf%2A> (metodo). Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> overload del metodo cerca nell'intero elenco dalla fine e consente di trovare la seconda occorrenza della stringa. Il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> overload del metodo viene utilizzato per eseguire ricerche nell'elenco con le versioni precedenti a partire dalla posizione dell'indice 3 e continuando fino all'inizio dell'elenco, in modo che trova la prima occorrenza della stringa nell'elenco. Infine, il <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di 4 voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce -1, perché non sono presenti istanze di ricerca stringa in tale intervallo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per <see cref="T:System.Collections.Generic.List`1" />.  
  
oppure 
 <paramref name="count" /> è minore di 0.  
  
oppure 
 <paramref name="index" /> e <paramref name="count" /> non specificano una sezione valida in <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da rimuovere da <see cref="T:System.Collections.Generic.List`1" />. Il valore può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Rimuove la prima occorrenza di un oggetto specifico da <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> viene rimosso correttamente; in caso contrario, <see langword="false" />.  Questo metodo restituisce anche <see langword="false" /> se <paramref name="item" /> non è stato trovato nell'oggetto <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `T` implementa la <xref:System.IEquatable%601> generico interfaccia, l'operatore di confronto di uguaglianza è il <xref:System.IEquatable%601.Equals%2A> metodo di tale interfaccia; in caso contrario, l'operatore di uguaglianza predefinito è <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 L'esempio seguente illustra <xref:System.Collections.Generic.List%601.Remove%2A> (metodo). Molte proprietà e metodi del <xref:System.Collections.Generic.List%601> classe generica vengono utilizzati per aggiungere, inserire e cercare l'elenco. Al termine di queste operazioni, l'elenco conterrà un duplicato. Il <xref:System.Collections.Generic.List%601.Remove%2A> viene usato il metodo per rimuovere la prima istanza dell'elemento duplicato e viene visualizzato il contenuto. Il <xref:System.Collections.Generic.List%601.Remove%2A> metodo rimuove sempre la prima istanza viene rilevato.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da rimuovere.</param>
        <summary>Rimuove tutti gli elementi che corrispondono alle condizioni definite dal predicato specificato.</summary>
        <returns>Numero di elementi rimossi da <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato e gli elementi che soddisfano le condizioni vengono rimossi dal <xref:System.Collections.Generic.List%601>.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.RemoveAll%2A> metodo e diversi altri metodi che usano il <xref:System.Predicate%601> delegato generico.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato, contenente nomi divorasse 8, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, e <xref:System.Collections.Generic.List%601.FindAll%2A> metodi vengono usati per eseguire una ricerca nell'elenco con il metodo di predicato di ricerca.  
  
 Il <xref:System.Collections.Generic.List%601.RemoveAll%2A> metodo viene utilizzato per rimuovere tutte le voci che terminano con "saurus". Attraversa l'elenco a partire dall'inizio, passando ogni elemento, a sua volta la `EndsWithSaurus` (metodo). L'elemento viene rimosso se il `EndsWithSaurus` restituzione del metodo `true`.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Infine, il <xref:System.Collections.Generic.List%601.Exists%2A> metodo verifica che non esistono Nessun stringhe che terminano con "saurus" nell'elenco.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento in corrispondenza dell'indice specificato di <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama <xref:System.Collections.Generic.List%601.RemoveAt%2A> per rimuovere un elemento, gli elementi rimanenti nell'elenco sono numerati per sostituire l'elemento rimosso. Ad esempio, se si rimuove l'elemento in corrispondenza dell'indice 3, l'elemento in corrispondenza dell'indice 4 viene spostato nella posizione 3. Inoltre, il numero di elementi nell'elenco (come rappresentata dal <xref:System.Collections.Generic.List%601.Count%2A> proprietà) viene diminuito di 1.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere, rimuovere e inserire un semplice oggetto business in un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="index" /> è uguale a o maggiore di <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice iniziale in base zero dell'intervallo di elementi da rimuovere.</param>
        <param name="count">Numero di elementi da rimuovere.</param>
        <summary>Rimuove un intervallo di elementi da <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono rimossi e tutti gli elementi seguenti nel <xref:System.Collections.Generic.List%601> dispone i relativi indici ridotti `count`.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.RemoveRange%2A> metodo e vari altri metodi del <xref:System.Collections.Generic.List%601> classi che agiscono su intervalli. Dopo aver creato e modificato, l'elenco di <xref:System.Collections.Generic.List%601.RemoveRange%2A> metodo viene utilizzato per rimuovere i due elementi nell'elenco a partire dalla posizione di indice 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inverte l'ordine degli elementi di <see cref="T:System.Collections.Generic.List`1" /> o di una parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inverte l'ordine degli elementi nell'intero <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> per invertire l'ordine degli elementi.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra entrambi gli overload del <xref:System.Collections.Generic.List%601.Reverse%2A> (metodo). Nell'esempio viene creato un <xref:System.Collections.Generic.List%601> di stringhe e aggiunge sei stringhe. Il <xref:System.Collections.Generic.List%601.Reverse> overload del metodo viene utilizzato per invertire l'elenco, quindi il <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> overload del metodo viene utilizzato per invertire il centro dell'elenco, a partire dall'elemento 1 e che comprende quattro elementi.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice iniziale in base zero dell'intervallo da invertire.</param>
        <param name="count">Numero di elementi nell'intervallo da invertire.</param>
        <summary>Inverte l'ordine degli elementi nell'intervallo specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> per invertire l'ordine degli elementi.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L'esempio seguente illustra entrambi gli overload del <xref:System.Collections.Generic.List%601.Reverse%2A> (metodo). Nell'esempio viene creato un <xref:System.Collections.Generic.List%601> di stringhe e aggiunge sei stringhe. Il <xref:System.Collections.Generic.List%601.Reverse> overload del metodo viene utilizzato per invertire l'elenco, quindi il <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> overload del metodo viene utilizzato per invertire il centro dell'elenco, a partire dall'elemento 1 e che comprende quattro elementi.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non indicano un intervallo valido di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordina gli elementi o una parte degli elementi in <see cref="T:System.Collections.Generic.List`1" /> usando l'implementazione specificata o <see cref="T:System.Collections.Generic.IComparer`1" /> predefinita oppure un delegato <see cref="T:System.Comparison`1" /> specificato per confrontare gli elementi dell'elenco.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ordina gli elementi dell'intero oggetto <see cref="T:System.Collections.Generic.List`1" /> usando l'operatore di confronto predefinito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo Usa l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> per il tipo `T` per determinare l'ordine degli elementi dell'elenco. Il <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> proprietà verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa una delle due interfacce <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un <xref:System.InvalidOperationException>.  
  
 Questo metodo Usa il <xref:System.Array.Sort%2A?displayProperty=nameWithType> metodo, che si applica l'ordinamento introspettivo come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un algoritmo di ordinamento di inserimento.  
  
-   Se il numero di partizioni supera log 2 *n*, dove *n* è l'intervallo della matrice di input, viene utilizzato un algoritmo Heapsort.  
  
-   In caso contrario, viene utilizzato un algoritmo Quicksort.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 In Media, questo metodo è un'operazione O (*n* registro *n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>; nel caso peggiore è un'operazione O (*n* <sup>2</sup>) operazione.  
  
   
  
## Examples  
 L'esempio seguente aggiunge alcuni nomi per un `List<String>` object, viene visualizzato l'elenco in ordine casuale, chiama il <xref:System.Collections.Generic.List%601.Sort%2A> (metodo) e quindi Visualizza l'elenco ordinato.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 Il codice seguente illustra il <xref:System.Collections.Generic.List%601.Sort> e <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> overload del metodo su un semplice oggetto business. Chiama il <xref:System.Collections.Generic.List%601.Sort> metodo risulterà nell'uso dell'operatore di confronto predefinito per il tipo di parte e <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> metodo viene implementato usando un metodo anonimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> overload del metodo. Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, senza alcun ordine specifico. L'elenco è visualizzato, ordinato e visualizzato nuovamente.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> overload del metodo viene quindi usato per eseguire la ricerca di due stringhe che non sono presenti nell'elenco, e il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene usato per inserirli. Il valore restituito del <xref:System.Collections.Generic.List%601.BinarySearch%2A> metodo è negativo in ogni caso, poiché le stringhe non sono presenti nell'elenco. Prendendo il complemento bit per bit (di ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) di questo numero negativo produce l'indice del primo elemento nell'elenco che in questa posizione è maggiore della stringa di ricerca e inserimento preserva l'ordinamento ordine. La seconda stringa di ricerca è maggiore di qualsiasi elemento nell'elenco, in modo che la posizione di inserimento si trova alla fine dell'elenco.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'operatore di confronto predefinito <see cref="P:System.Collections.Generic.Comparer`1.Default" /> non riesce a trovare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o l'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare durante il confronto di elementi oppure <see langword="null" /> per usare la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto.</param>
        <summary>Ordina gli elementi dell'intero <see cref="T:System.Collections.Generic.List`1" /> usando l'operatore di confronto specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` viene specificato, gli elementi del <xref:System.Collections.Generic.List%601> vengono ordinate usando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione.  
  
 Se `comparer` viene `null`, l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa una delle due interfacce <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un <xref:System.InvalidOperationException>.  
  
 Questo metodo Usa il <xref:System.Array.Sort%2A?displayProperty=nameWithType> metodo, che si applica l'ordinamento introspettivo come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un algoritmo di ordinamento di inserimento.  
  
-   Se il numero di partizioni supera log 2 *n*, dove *n* è l'intervallo della matrice di input, viene utilizzato un algoritmo Heapsort.  
  
-   In caso contrario, viene utilizzato un algoritmo Quicksort.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 In Media, questo metodo è un'operazione O (*n* registro *n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>; nel caso peggiore è un'operazione O (*n* <sup>2</sup>) operazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un operatore alternativo per le stringhe denominata DinoCompare, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. L'operatore di confronto funziona nel modo seguente: in primo luogo, i termini del confronto sono testate per `null`, e un riferimento null viene considerato minore rispetto a un diverso da null. In secondo luogo, vengono confrontati con le lunghezze di stringa e la stringa più lunga viene considerata maggiore di. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, senza alcun ordine specifico. L'elenco viene visualizzato, ordinato usando l'operatore di confronto alternativo e visualizzata nuovamente.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo viene quindi usato per cercare più stringhe non in elenco, utilizzando l'operatore di confronto alternativo. Il <xref:System.Collections.Generic.List%601.Insert%2A> metodo viene utilizzato per inserire le stringhe. Questi due metodi si trovano nella funzione denominata `SearchAndInsert`, insieme al codice per utilizzare il complemento bit per bit (il ~ operatore in c# e Visual C++ `Xor` -1 in Visual Basic) del numero negativo restituito da <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> e usarlo come un indice per inserimento della nuova stringa.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e l'operatore di confronto predefinito <see cref="P:System.Collections.Generic.Comparer`1.Default" /> non riesce a trovare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o l'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">Oggetto <see cref="T:System.Comparison`1" /> da usare quando si confrontano gli elementi.</param>
        <summary>Ordina gli elementi nell'intera classe <see cref="T:System.Collections.Generic.List`1" /> usando l'oggetto <see cref="T:System.Comparison`1" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparison` viene specificato, gli elementi del <xref:System.Collections.Generic.List%601> vengono ordinate usando il metodo rappresentato dal delegato.  
  
 Se `comparison` viene `null`, un <xref:System.ArgumentNullException> viene generata un'eccezione.  
  
 Questo metodo Usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, cui viene applicato l'ordinamento introspettivo come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un algoritmo di ordinamento di inserimento  
  
-   Se il numero di partizioni supera log 2 *n*, dove *n* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, viene utilizzato un algoritmo Quicksort.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 In Media, questo metodo è un'operazione O (*n* registro *n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>; nel caso peggiore è un'operazione O (*n* <sup>2</sup>) operazione.  
  
   
  
## Examples  
 Il codice seguente illustra il <xref:System.Collections.Generic.List%601.Sort%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> overload del metodo su un semplice oggetto business. Chiama il <xref:System.Collections.Generic.List%601.Sort%2A> metodo risulterà nell'uso dell'operatore di confronto predefinito per il tipo di parte e <xref:System.Collections.Generic.List%601.Sort%2A> metodo viene implementato usando un metodo anonimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un metodo alternativo di confronto per le stringhe, denominato `CompareDinosByLength`. Questo metodo funziona nel modo seguente: in primo luogo, i termini del confronto sono testate per `null`, e un riferimento null viene considerato minore rispetto a un diverso da null. In secondo luogo, vengono confrontati con le lunghezze di stringa e la stringa più lunga viene considerata maggiore di. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con quattro stringhe, senza alcun ordine specifico. L'elenco include anche una stringa vuota e un riferimento null. Viene visualizzato l'elenco, ordinato utilizzando un <xref:System.Comparison%601> delegato generico che rappresenta il `CompareDinosByLength` (metodo), quindi viene nuovamente visualizzato.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'implementazione di <paramref name="comparison" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparison" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Indice iniziale in base zero dell'intervallo da ordinare.</param>
        <param name="count">Lunghezza dell'intervallo da ordinare.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare durante il confronto di elementi oppure <see langword="null" /> per usare la proprietà <see cref="P:System.Collections.Generic.Comparer`1.Default" /> dell'operatore di confronto.</param>
        <summary>Ordina gli elementi di un intervallo di elementi di <see cref="T:System.Collections.Generic.List`1" /> usando l'operatore di confronto specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` viene specificato, gli elementi del <xref:System.Collections.Generic.List%601> vengono ordinate usando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione.  
  
 Se `comparer` viene `null`, l'operatore di confronto <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable%601> interfaccia generica e utilizza tale implementazione, se disponibile.  In caso contrario, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se il tipo `T` implementa il <xref:System.IComparable> interfaccia.  Se tipo `T` non implementa una delle due interfacce <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> genera un <xref:System.InvalidOperationException>.  
  
 Questo metodo Usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, cui viene applicato l'ordinamento introspettivo come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un algoritmo di ordinamento di inserimento  
  
-   Se il numero di partizioni supera log 2 *n*, dove *n* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, viene utilizzato un algoritmo Quicksort.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 In Media, questo metodo è un'operazione O (*n* registro *n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>; nel caso peggiore è un'operazione O (*n* <sup>2</sup>) operazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo e <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo.  
  
 L'esempio definisce un operatore alternativo per le stringhe denominata DinoCompare, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. L'operatore di confronto funziona nel modo seguente: in primo luogo, i termini del confronto sono testate per `null`, e un riferimento null viene considerato minore rispetto a un diverso da null. In secondo luogo, vengono confrontati con le lunghezze di stringa e la stringa più lunga viene considerata maggiore di. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creata e popolata con i nomi di cinque dinosaurs dinosauri e dinosaurs dinosauri tre. All'interno di ognuno dei due gruppi, i nomi non sono in alcun ordine particolare. Viene visualizzato l'elenco, l'intervallo di erbivori viene ordinato utilizzando l'operatore di confronto alternativo e viene nuovamente visualizzato l'elenco.  
  
 Il <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> overload del metodo viene quindi usato per cercare solo l'intervallo di erbivori "Brachiosaurus". La stringa non viene trovata, il complemento bit per bit e (i ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) del numero negativo restituito dal <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metodo viene utilizzato come indice per l'inserimento della nuova stringa.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0.  
  
oppure 
 <paramref name="count" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> non specificano un intervallo valido in <see cref="T:System.Collections.Generic.List`1" />.  
  
oppure 
L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e l'operatore di confronto predefinito <see cref="P:System.Collections.Generic.Comparer`1.Default" /> non riesce a trovare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> o l'interfaccia <see cref="T:System.IComparable" /> per il tipo <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle raccolte</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.Generic.ICollection`1" /> è di sola lettura.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.Generic.ICollection`1" /> è di sola lettura; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta che è di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. In questa posizione, la <xref:System.Collections.Generic.IEnumerator%601.Current%2A> proprietà non è definita. Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> per passare l'enumeratore al primo elemento della raccolta prima di leggere il valore del metodo <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 Il <xref:System.Collections.Generic.IEnumerator%601.Current%2A> lo stesso oggetto finché non viene restituita la <xref:System.Collections.IEnumerator.MoveNext%2A> viene chiamato. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> è definito. Non è possibile impostare nuovamente la proprietà <xref:System.Collections.Generic.IEnumerator%601.Current%2A> sul primo elemento della raccolta; è necessario creare una nuova istanza di enumeratore.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe. Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale che rappresenta la destinazione degli elementi copiati dall'oggetto <see cref="T:System.Collections.ICollection" />. L'indicizzazione di <see cref="T:System.Array" /> deve essere in base zero.</param>
        <param name="arrayIndex">Indice in base zero in <paramref name="array" /> in corrispondenza del quale viene avviata la copia.</param>
        <summary>Copia gli elementi di <see cref="T:System.Collections.ICollection" /> in <see cref="T:System.Array" /> a partire da un particolare indice <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se il tipo di origine <xref:System.Collections.ICollection> non può essere eseguire automaticamente il cast al tipo di destinazione `array`, le implementazioni non generiche di <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, mentre per le implementazioni generiche generano <xref:System.ArgumentException>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> è minore di 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  
  
oppure 
 <paramref name="array" /> non ha un'indicizzazione in base zero.  
  
oppure 
Il numero di elementi nell'oggetto <see cref="T:System.Collections.ICollection" /> di origine è maggiore dello spazio disponibile tra <paramref name="arrayIndex" /> e la fine dell'oggetto <paramref name="array" /> di destinazione.  
  
oppure 
Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Collections.ICollection" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe).</summary>
        <value>
          <see langword="true" /> se l'accesso a <see cref="T:System.Collections.ICollection" /> è sincronizzato (thread-safe); in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Nel raro caso in cui enumerazione condivida accesso in scrittura, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano questo oggetto prima di accedere alla raccolta.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre l'istanza corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 L'enumerazione di una raccolta non è di per sé una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Restituisce un oggetto che può essere utilizzato per sincronizzare l'accesso al <xref:System.Collections.ICollection>. La sincronizzazione è efficace solo se tutti i thread di bloccano questo oggetto prima di accedere alla raccolta. Il codice seguente viene illustrato come utilizzare il <xref:System.Collections.ICollection.SyncRoot%2A> proprietà c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che consente di eseguire l'iterazione di una raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che può essere usato per eseguire l'iterazione della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la <xref:System.Collections.IEnumerator.Current%2A> proprietà non è definita. Pertanto, è necessario chiamare il <xref:System.Collections.IEnumerator.MoveNext%2A> per passare l'enumeratore al primo elemento della raccolta prima di leggere il valore del metodo <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Il <xref:System.Collections.IEnumerator.Current%2A> proprietà restituisce lo stesso oggetto fino al completamento <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> viene chiamato. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. Se vengono apportate modifiche alla raccolta, ad esempio l'aggiunta, modifica, o l'eliminazione di elementi, l'enumeratore viene invalidato in modo irreversibile e alla successiva chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> oppure <xref:System.Collections.IEnumerator.Reset%2A> genera un <xref:System.InvalidOperationException>.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta. L'enumerazione di una raccolta non è quindi una procedura thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Le implementazioni predefinite di raccolte nello spazio dei nomi <xref:System.Collections.Generic?displayProperty=nameWithType> non sono sincronizzate.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto <see cref="T:System.Object" /> da aggiungere a <see cref="T:System.Collections.IList" />.</param>
        <summary>Aggiunge un elemento a <see cref="T:System.Collections.IList" />.</summary>
        <returns>Posizione in cui è stato inserito il nuovo elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Collections.Generic.List%601.Count%2A> è minore di <xref:System.Collections.Generic.List%601.Capacity%2A>, questo metodo è un'operazione o (1). Se la capacità deve essere incrementata per far posto al nuovo elemento, questo metodo diventa un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il tipo di <paramref name="item" /> non può essere assegnato a <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto <see cref="T:System.Object" /> da individuare in <see cref="T:System.Collections.IList" />.</param>
        <summary>Stabilisce se <see cref="T:System.Collections.IList" /> contiene un valore specifico.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> è presente in <see cref="T:System.Collections.IList" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da individuare nella raccolta <see cref="T:System.Collections.IList" />.</param>
        <summary>Determina l'indice di un elemento specifico in <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indice di <paramref name="item" />, se presente nell'elenco; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il tipo di <paramref name="item" /> non può essere assegnato a <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero nel quale <paramref name="item" /> deve essere inserito.</param>
        <param name="item">Oggetto da inserire in <see cref="T:System.Collections.IList" />.</param>
        <summary>Inserisce un elemento in <see cref="T:System.Collections.IList" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `index` è uguale al numero di elementi in <xref:System.Collections.IList>, `item` viene aggiunto alla fine.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è un indice valido nell'interfaccia <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Il tipo di <paramref name="item" /> non può essere assegnato a <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IList" /> ha dimensioni fisse.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IList" /> è di dimensioni fisse; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la sua creazione, ma consente la modifica degli elementi esistenti.  
  
 Una raccolta con una dimensione fissa è semplicemente una raccolta con un wrapper che impedisce l'aggiunta e rimozione di elementi. Pertanto, se vengono apportate modifiche alla raccolta sottostante, incluse l'aggiunta o rimozione di elementi, la raccolta a dimensione fissa riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Collections.IList" /> è di sola lettura.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Collections.IList" /> è di sola lettura; in caso contrario, <see langword="false" />.  Nell'implementazione predefinita di <see cref="T:System.Collections.Generic.List`1" />, questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una raccolta di sola lettura non consente l'aggiunta, la rimozione o la modifica di elementi dopo la sua creazione.  
  
 Una raccolta che è di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'elemento da ottenere o impostare.</param>
        <summary>Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</summary>
        <value>Elemento in corrispondenza dell'indice specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il linguaggio c# usa la [ciò](~/docs/csharp/language-reference/keywords/this.md) parola chiave per definire gli indicizzatori anziché implementare il <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> proprietà. In Visual Basic la proprietà <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> viene implementata come predefinita per fornire la stessa funzionalità di indicizzazione.  
  
 Il recupero del valore di questa proprietà è un'operazione o (1); impostazione della proprietà è anche un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è un indice valido nell'interfaccia <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà viene impostata e il tipo del parametro <paramref name="value" /> non è assegnabile all'interfaccia <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da rimuovere da <see cref="T:System.Collections.IList" />.</param>
        <summary>Rimuove la prima occorrenza di un oggetto specifico da <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina l'uguaglianza con l'operatore di uguaglianza predefinito <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> per `T`, il tipo dei valori nell'elenco.  
  
 Questo metodo esegue una ricerca lineare. di conseguenza, questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il tipo di <paramref name="item" /> non può essere assegnato a <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia gli elementi di <see cref="T:System.Collections.Generic.List`1" /> in una nuova matrice.</summary>
        <returns>Matrice contenente le copie degli elementi di <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi vengono copiati mediante <xref:System.Array.Copy%2A?displayProperty=nameWithType>, che è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.ToArray%2A> metodo e altri metodi del <xref:System.Collections.Generic.List%601> classi che agiscono su intervalli. Alla fine dell'esempio, il <xref:System.Collections.Generic.List%601.GetRange%2A> metodo viene utilizzato per ottenere tre elementi dall'elenco, a partire dalla posizione dell'indice 2. Il <xref:System.Collections.Generic.List%601.ToArray%2A> metodo viene chiamato su risultante <xref:System.Collections.Generic.List%601>, creazione di una matrice di tre elementi. Vengono visualizzati gli elementi della matrice.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta la capacità sul numero reale di elementi nell'oggetto <see cref="T:System.Collections.Generic.List`1" />, se tale numero è inferiore a un valore soglia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per ridurre il sovraccarico della memoria di una raccolta se nessun nuovo elemento verrà aggiunto alla raccolta. Il costo di riallocazione e copia una grande <xref:System.Collections.Generic.List%601> può essere notevole, tuttavia, in modo che il <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo non esegue alcuna operazione se l'elenco è in più del 90% della capacità. Questo evita di dover sostenere un costo elevato riallocazione a ottenere un miglioramento relativamente piccolo.  
  
> [!NOTE]
>  La soglia del 90% corrente potrebbe cambiare nelle versioni future.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Per reimpostare un <xref:System.Collections.Generic.List%601> allo stato iniziale, chiamare il <xref:System.Collections.Generic.List%601.Clear%2A> metodo prima di chiamare il <xref:System.Collections.Generic.List%601.TrimExcess%2A> (metodo). Trimming di un oggetto vuoto <xref:System.Collections.Generic.List%601> imposta la capacità del <xref:System.Collections.Generic.List%601> alla capacità predefinita.  
  
 La capacità può essere impostata inoltre mediante il <xref:System.Collections.Generic.List%601.Capacity%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come controllare la capacità e conteggio di una <xref:System.Collections.Generic.List%601> che contiene un semplice oggetto business e viene illustrato l'utilizzo di <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo per rimuovere capacità aggiuntiva.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.TrimExcess%2A> (metodo). Molte proprietà e metodi del <xref:System.Collections.Generic.List%601> classe vengono utilizzate per aggiungere, inserire e rimuovere elementi da un elenco di stringhe. Il <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodo viene utilizzato per ridurre la capacità in modo che corrisponda al conteggio e la <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> verranno visualizzate le proprietà. Se la capacità inutilizzata fosse stato inferiore al 10% della capacità totale, l'elenco potrebbe non stato ridimensionato. Infine, il contenuto dell'elenco viene cancellato.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegato <see cref="T:System.Predicate`1" /> che definisce le condizioni per verificare gli elementi.</param>
        <summary>Determina se ogni elemento nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrisponde alle condizioni definite dal predicato specificato.</summary>
        <returns>
          <see langword="true" /> se ogni elemento nell'oggetto <see cref="T:System.Collections.Generic.List`1" /> corrisponde alle condizioni definite dal predicato specificato; in caso contrario, <see langword="false" />. Se l'elenco è privo di elementi, il valore restituito è <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi dell'oggetto corrente <xref:System.Collections.Generic.List%601> vengono passati singolarmente per il <xref:System.Predicate%601> delegato e l'elaborazione viene arrestata al ritorno del delegato `false` per qualsiasi elemento. Gli elementi vengono elaborati in ordine e tutte le chiamate vengono effettuate in un unico thread.  
  
 Questo metodo è un'operazione O (*n*) operazione, in cui *n* è <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Collections.Generic.List%601.TrueForAll%2A> metodo e diversi altri metodi che usano <xref:System.Predicate%601> delegato generico.  
  
 Oggetto <xref:System.Collections.Generic.List%601> di stringhe viene creato, contenente nomi divorasse 8, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Collections.Generic.List%601.TrueForAll%2A> metodo attraversa l'elenco a partire dall'inizio, passando ogni elemento, a sua volta la `EndsWithSaurus` (metodo). La ricerca termina quando la `EndsWithSaurus` restituzione del metodo `false`.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>