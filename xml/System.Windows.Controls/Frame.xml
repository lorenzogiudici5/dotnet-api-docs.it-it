<Type Name="Frame" FullName="System.Windows.Controls.Frame">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="72d3016656e748b569c77bb8087b5058a7f6ca39" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694815" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Frame : System.Windows.Controls.ContentControl, System.Windows.Markup.IAddChild, System.Windows.Markup.IUriContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Frame extends System.Windows.Controls.ContentControl implements class System.Windows.Markup.IAddChild, class System.Windows.Markup.IUriContext" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Frame" />
  <TypeSignature Language="VB.NET" Value="Public Class Frame&#xA;Inherits ContentControl&#xA;Implements IAddChild, IUriContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class Frame : System::Windows::Controls::ContentControl, System::Windows::Markup::IAddChild, System::Windows::Markup::IUriContext" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IUriContext</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Navigated")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Source")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_FrameCP", Type=typeof(System.Windows.Controls.ContentPresenter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Il frame è un controllo contenuto che supporta la navigazione.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Frame> è un controllo contenuto che consente di individuare e visualizzare il contenuto. <xref:System.Windows.Controls.Frame> possono essere ospitati all'interno di altro contenuto con altri controlli e gli elementi.  
  
> [!CAUTION]
>  Quando il <xref:System.Windows.Controls.Frame> controllo si sposta il contenuto HTML, il <xref:System.Windows.Controls.Frame> controllo crea internamente un'istanza del controllo WebBrowser ActiveX nativo. WPF abilita le funzionalità di sicurezza applicando controlli di funzionalità per il controllo WebBrowser ActiveX. I controlli di funzionalità che vengono applicati differiscono per applicazioni autonome e XBAP. Alcune applicazioni, applicare i controlli di funzionalità aggiuntive per impedire l'esecuzione di contenuto dannoso. Per ulteriori informazioni, vedere la sezione "Controllo WebBrowser e controlli Feature" in [sicurezza (WPF)](~/docs/framework/wpf/security-wpf.md) e [WebBrowser controllo panoramiche ed esercitazioni](http://go.microsoft.com/fwlink/?LinkId=179388).  
  
 Il contenuto può essere qualsiasi tipo di oggetto .NET Framework e file HTML. In generale, tuttavia, le pagine sono il contenuto del pacchetto per la navigazione verso (vedere <xref:System.Windows.Controls.Page>).  
  
 Possibile spostarsi sul contenuto impostando il <xref:System.Windows.Controls.Frame.Source%2A> proprietà con l'URI per il contenuto desiderato. Inoltre, è possibile spostarsi sul contenuto utilizzando uno degli overload seguenti del <xref:System.Windows.Controls.Frame.Navigate%2A> metodo:  
  
-   <xref:System.Windows.Controls.Frame.Navigate%28System.Uri%29>  
  
-   <xref:System.Windows.Controls.Frame.Navigate%28System.Uri%2CSystem.Object%29>  
  
 Quando si accede contenuto dall'URI <xref:System.Windows.Controls.Frame> restituisce un oggetto che contiene il contenuto. In alternativa, è possibile spostarsi sul contenuto utilizzando uno del <xref:System.Windows.Controls.Frame.Navigate%2A> overload del metodo che accetta un oggetto:  
  
-   <xref:System.Windows.Controls.Frame.Navigate%28System.Object%29>  
  
-   <xref:System.Windows.Controls.Frame.Navigate%28System.Object%2CSystem.Object%29>  
  
 La durata di un'operazione di navigazione è possibile tenere traccia tramite gli eventi seguenti:  
  
-   <xref:System.Windows.Controls.Frame.Navigating>  
  
-   <xref:System.Windows.Controls.Frame.Navigated>  
  
-   <xref:System.Windows.Controls.Frame.NavigationProgress>  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed>  
  
-   <xref:System.Windows.Controls.Frame.NavigationStopped>  
  
-   <xref:System.Windows.Controls.Frame.LoadCompleted>  
  
-   <xref:System.Windows.Controls.Frame.FragmentNavigation>  
  
 Non tutti gli eventi ogni volta che si verifica un'operazione di navigazione; il set di eventi che vengono generati è determinato dal tipo di navigazione che si verifica (contenuto o frammento di contenuto) e modalità di completamento di navigazione (annullato, arrestato o non riuscito).  
  
 Nella figura seguente viene illustrata la sequenza in cui vengono generati questi eventi:  
  
 ![Diagramma di flusso di navigazione pagina](~/add/media/navigationoverviewfigure11.png "grafico del flusso di navigazione pagina")  
  
 Durante o dopo una navigazione <xref:System.Windows.Controls.Frame> vengono fornite informazioni sul contenuto che viene esplorato, inclusi l'URI del contenuto a cui si accede (<xref:System.Windows.Controls.Frame.Source%2A>), l'URI del contenuto corrente (<xref:System.Windows.Controls.Frame.CurrentSource%2A>) e un oggetto che contiene il contenuto che è stato aperto (<xref:System.Windows.Controls.ContentControl.Content%2A>).  
  
 Quando ci si sposta il contenuto, <xref:System.Windows.Controls.Frame> registra lo spostamento di una voce nella cronologia di navigazione. Viene aggiunta una voce per eseguire il backup di cronologia di navigazione quando si verifica una nuova navigazione, chiamando la <xref:System.Windows.Controls.Frame.Navigate%2A> metodo, o passando a una voce nella cronologia di navigazione in avanti, chiamando <xref:System.Windows.Controls.Frame.GoForward%2A>. Viene aggiunta una voce alla cronologia di navigazione in avanti, passare a una voce nella cronologia di navigazione, chiamando <xref:System.Windows.Controls.Frame.GoBack%2A>. <xref:System.Windows.Controls.Frame.CanGoBack%2A> e <xref:System.Windows.Controls.Frame.CanGoForward%2A> report se sono presenti voci presenti nella cronologia di navigazione in avanti, rispettivamente.  
  
 La prima volta che una parte di contenuto si accede da un'altra parte del contenuto, <xref:System.Windows.Controls.Frame> automaticamente Visualizza un'interfaccia utente che consente agli utenti di spostarsi avanti e indietro nella cronologia di navigazione di spostamento. È possibile configurare quando lo spostamento dell'interfaccia utente viene visualizzato impostando il <xref:System.Windows.Controls.Frame.NavigationUIVisibility%2A> proprietà.  
  
 Per impostazione predefinita, <xref:System.Windows.Controls.Frame> userà la propria cronologia di navigazione solo se uno strumento di navigazione padre (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) con la propria di spostamento non è possibile trovare la cronologia. Ciò significa che le voci della cronologia di navigazione per il frame vengono mescolate con le voci della cronologia di navigazione per lo strumento di navigazione padre. Per specificare che un <xref:System.Windows.Controls.Frame> gestisce la propria cronologia di navigazione, impostare il <xref:System.Windows.Controls.Frame.JournalOwnership%2A> proprietà <xref:System.Windows.Navigation.JournalOwnership.OwnsJournal>.  
  
 La voce più recente nella cronologia di navigazione può essere rimossa chiamando <xref:System.Windows.Controls.Frame.RemoveBackEntry%2A>.  
  
 <xref:System.Windows.Controls.Frame> non archivia un'istanza di un oggetto contenuto nella cronologia di navigazione. In alternativa, <xref:System.Windows.Controls.Frame> crea una nuova istanza dell'oggetto contenuto ogni volta si accede tramite la cronologia di navigazione. Questo comportamento è progettato per evitare il consumo di memoria eccessiva quando un numero elevato e grandi porzioni di contenuto sono a cui si accede. Di conseguenza, lo stato del contenuto non viene memorizzato da uno spostamento a quella successiva. Tuttavia, WPF offre diverse tecniche che consente di archiviare uno stato di una parte del contenuto nella cronologia di navigazione.  
  
 Utilizzando <xref:System.Windows.Controls.Frame.AddBackEntry%2A>, è anche possibile memorizzare più insiemi di stato per un'istanza singola pagina.  
  
## <a name="customizing-the-frame-control"></a>Personalizzazione del controllo Frame  
 Per applicare le stesse impostazioni di proprietà a più <xref:System.Windows.Controls.Frame> controlli, utilizzare il <xref:System.Windows.FrameworkElement.Style%2A> proprietà. È possibile modificare il valore predefinito <xref:System.Windows.Controls.ControlTemplate> per fornire al controllo un aspetto univoco. Per ulteriori informazioni sulla creazione di un <xref:System.Windows.Controls.ControlTemplate>, vedere [personalizzazione dell'aspetto di un controllo esistente tramite la creazione di ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Per visualizzare le parti e stati specifici di <xref:System.Windows.Controls.Frame>, vedere [Frame stili e modelli](~/docs/framework/wpf/controls/frame-styles-and-templates.md).  
  
 Proprietà di dipendenza per questo controllo potrebbe essere impostata dallo stile predefinito del controllo.  Se una proprietà viene impostata da uno stile predefinito, la proprietà può variare rispetto al valore predefinito quando il controllo viene visualizzato nell'applicazione. Lo stile predefinito è determinato dal tema del desktop viene utilizzato quando l'applicazione è in esecuzione.  Per ulteriori informazioni, vedere [temi WPF predefiniti](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  L'impostazione di una proprietà visiva può avere effetto solo se tale proprietà è sia presente nel <xref:System.Windows.Controls.Frame> controllo del modello predefinito e viene impostata tramite una. È possibile trovare un elenco di proprietà visive nella sezione "Modifica la struttura Visual di un controllo" [personalizzazione dell'aspetto di un controllo esistente tramite la creazione di ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un semplice <xref:System.Windows.Controls.Frame> controllare e specificare il contenuto di origine iniziale da caricare da un URI usando il <xref:System.Windows.Controls.Frame.Source%2A> proprietà.  
  
 [!code-xaml[FrameSnippets#SetFrameSourceXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/FrameSnippets/CS/MainWindow.xaml#setframesourcexaml1)]  
[!code-xaml[FrameSnippets#SetFrameSourceXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/FrameSnippets/CS/MainWindow.xaml#setframesourcexaml2)]  
[!code-xaml[FrameSnippets#SetFrameSourceXAML3](~/samples/snippets/csharp/VS_Snippets_Wpf/FrameSnippets/CS/MainWindow.xaml#setframesourcexaml3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Frame ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Frame();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Controls.Frame" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigator.AddBackEntry(System.Windows.Navigation.CustomContentState)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">Oggetto <see cref="T:System.Windows.Navigation.CustomContentState" /> che rappresenta lo stato definito da una applicazione associato a una parte specifica di contenuto.</param>
        <summary>Aggiunge una voce alla cronologia di navigazione indietro che contiene un oggetto <see cref="T:System.Windows.Navigation.CustomContentState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="state" /> è <see langword="null" /> e un oggetto <see cref="T:System.Windows.Navigation.CustomContentState" /> non è restituito da <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" />.</exception>
        <altmember cref="M:System.Windows.Controls.Frame.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="AddChild">
      <MemberSignature Language="C#" Value="protected override void AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AddChild (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AddChild(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto figlio da aggiungere.</param>
        <summary>Aggiunge un oggetto figlio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene eseguito l'override perché <xref:System.Windows.Controls.Frame> non consentono elementi figlio. Utilizzare invece la <xref:System.Windows.Controls.ContentControl.Content%2A> proprietà per impostare il contenuto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddText">
      <MemberSignature Language="C#" Value="protected override void AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AddText (text As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AddText(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Testo da aggiungere all'oggetto.</param>
        <summary>Aggiunge il contenuto di testo di un nodo all'oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene sottoposto a override per impedire <xref:System.Windows.Controls.Frame> dall'aggiunta di testo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackStack">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable BackStack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable BackStack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.BackStack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BackStack As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerable ^ BackStack { System::Collections::IEnumerable ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:MS.Internal.AppModel.INavigator.BackStack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un <see cref="T:System.Collections.IEnumerable" /> che si utilizza per enumerare le voci nella cronologia di navigazione indietro per un <see cref="T:System.Windows.Controls.Frame" />.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerable" /> se almeno una voce è stata aggiunta alla cronologia di navigazione indietro. Se non sono presenti voci, o <see cref="T:System.Windows.Controls.Frame" /> non possiede una propria cronologia di navigazione, <see cref="P:System.Windows.Controls.Frame.BackStack" /> è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le voci restituite da <xref:System.Windows.Controls.Frame.BackStack%2A> incluso tutto il contenuto, navigazioni e stato personalizzato.  
  
<a name="dependencyPropertyInfo_FrameBackStack"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Frame.BackStackProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.Frame.FragmentNavigation" />
        <altmember cref="T:System.Windows.Navigation.CustomContentState" />
      </Docs>
    </Member>
    <Member MemberName="BackStackProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackStackProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackStackProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Frame.BackStackProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackStackProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackStackProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Frame.BackStack" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Frame.BackStack%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseUri">
      <MemberSignature Language="C#" Value="protected virtual Uri BaseUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.BaseUri" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property BaseUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Uri ^ BaseUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IUriContext.BaseUri</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l’[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] di base per un <see cref="T:System.Windows.Controls.Frame" />.</summary>
        <value>[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] di base del controllo <see cref="T:System.Windows.Controls.Frame" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Frame.BaseUri%2A> può essere impostato su facilitare la risoluzione del relativo [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] per un'ulteriore navigazione.  
  
 Per ottenere o impostare il [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] del <xref:System.Windows.Controls.Frame> controllo, utilizzare il <xref:System.Windows.Controls.Frame.Source%2A> proprietà.  
  
 Questa è una proprietà virtuale protetta e non può essere utilizzata direttamente, anche se può essere utilizzato nelle classi derivate.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Markup.IUriContext.BaseUri" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:MS.Internal.AppModel.INavigator.CanGoBack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è presente almeno una voce nella cronologia di navigazione indietro.</summary>
        <value>
          <see langword="true" /> se è presente almeno una voce nella cronologia di navigazione indietro. <see langword="false" /> se non sono presenti voci nella cronologia di navigazione indietro o se <see cref="T:System.Windows.Controls.Frame" /> non dispone di una propria cronologia di navigazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_FrameCanGoBack"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Frame.CanGoBackProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Frame.GoBack" />
        <altmember cref="P:System.Windows.Controls.Frame.CanGoForward" />
        <altmember cref="M:System.Windows.Controls.Frame.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBackProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CanGoBackProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CanGoBackProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Frame.CanGoBackProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CanGoBackProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CanGoBackProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Frame.CanGoBack" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Frame.CanGoBack%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:MS.Internal.AppModel.INavigator.CanGoForward</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è presente almeno una voce nella cronologia di navigazione avanti.</summary>
        <value>
          <see langword="true" /> se è presente almeno una voce nella cronologia di navigazione avanti; <see langword="false" /> se non sono presenti voci nella cronologia di navigazione avanti o se <see cref="T:System.Windows.Controls.Frame" /> non possiede cronologia di navigazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Controls.Frame.CanGoForward%2A>.  
  
<a name="dependencyPropertyInfo_FrameCanGoForward"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Frame.CanGoForwardProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Frame.GoForward" />
        <altmember cref="M:System.Windows.Controls.Frame.GoBack" />
        <altmember cref="P:System.Windows.Controls.Frame.CanGoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForwardProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CanGoForwardProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CanGoForwardProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Frame.CanGoForwardProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CanGoForwardProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CanGoForwardProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Frame.CanGoForward" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Frame.CanGoForward%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Frame.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:MS.Internal.AppModel.IDownloader.ContentRendered</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica dopo che è stato eseguito il rendering del contenuto di <see cref="T:System.Windows.Controls.Frame" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Controls.Frame> non ha contenuto, non viene generato questo evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:MS.Internal.AppModel.INavigatorBase.CurrentSource</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] dell’ultimo contenuto sul quale ci si è spostati.</summary>
        <value>Un <see cref="T:System.Uri" /> per il contenuto che è stato ultima aperto, se ci si è a usando un URI; in caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForwardStack">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ForwardStack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable ForwardStack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.ForwardStack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ForwardStack As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerable ^ ForwardStack { System::Collections::IEnumerable ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:MS.Internal.AppModel.INavigator.ForwardStack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un <see cref="T:System.Collections.IEnumerable" /> che si utilizza per enumerare le voci nella cronologia di navigazione avanti per un <see cref="T:System.Windows.Controls.Frame" />.</summary>
        <value>Oggetto <see cref="T:System.Collections.IEnumerable" /> se è stata aggiunta almeno una voce nella cronologia di navigazione avanti oppure <see langword="null" /> se non sono presenti voci o se <see cref="T:System.Windows.Controls.Frame" /> non possiede cronologia di navigazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le voci restituite da <xref:System.Windows.Controls.Frame.ForwardStack%2A> incluso tutto il contenuto, navigazioni e stato personalizzato.  
  
<a name="dependencyPropertyInfo_FrameForwardStack"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Frame.ForwardStackProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForwardStackProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForwardStackProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForwardStackProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Frame.ForwardStackProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForwardStackProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForwardStackProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Frame.ForwardStack" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Frame.ForwardStack%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Frame.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:MS.Internal.AppModel.INavigatorBase.FragmentNavigation</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando ha inizio la navigazione verso un frammento di contenuto, vale a dire immediatamente se il frammento desiderato si trova nel contenuto corrente, oppure dopo il caricamento del contenuto [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] di origine se il frammento desiderato si trova in un contenuto diverso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.Frame.Navigating" />
        <altmember cref="E:System.Windows.Controls.Frame.Navigated" />
        <altmember cref="E:System.Windows.Controls.Frame.LoadCompleted" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationProgress" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationStopped" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GoBack();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigator.GoBack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si sposta al più recente elemento nella cronologia di navigazione indietro se un <see cref="T:System.Windows.Controls.Frame" /> gestisce la cronologia di navigazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la cronologia di navigazione per un frame viene gestita tramite uno strumento di navigazione padre (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), il `GoBack` metodo su tale strumento di navigazione o associati <xref:System.Windows.Navigation.NavigationService> deve essere chiamato l'oggetto:  
  
-   <xref:System.Windows.Controls.Frame.GoBack%2A?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationWindow.GoBack%2A?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Controls.Frame.GoBack" /> viene chiamato quando non sono presenti voci nella cronologia di navigazione indietro.</exception>
        <altmember cref="P:System.Windows.Controls.Frame.CanGoBack" />
        <altmember cref="P:System.Windows.Controls.Frame.CanGoForward" />
        <altmember cref="M:System.Windows.Controls.Frame.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GoForward();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigator.GoForward</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Si sposta al più recente elemento nella cronologia di navigazione avanti se un <see cref="T:System.Windows.Controls.Frame" /> gestisce la cronologia di navigazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la cronologia di navigazione per un frame viene gestita tramite uno strumento di navigazione padre (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), il `GoForward` metodo su tale strumento di navigazione o associati <xref:System.Windows.Navigation.NavigationService> deve essere chiamato l'oggetto:  
  
-   <xref:System.Windows.Controls.Frame.GoForward%2A?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationWindow.GoForward%2A?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.GoForward%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Controls.Frame.GoForward" /> viene chiamato quando non sono presenti voci nella cronologia di navigazione indietro.</exception>
        <altmember cref="P:System.Windows.Controls.Frame.CanGoBack" />
        <altmember cref="M:System.Windows.Controls.Frame.GoBack" />
        <altmember cref="P:System.Windows.Controls.Frame.CanGoForward" />
      </Docs>
    </Member>
    <Member MemberName="JournalOwnership">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalOwnership JournalOwnership { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Navigation.JournalOwnership JournalOwnership" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.JournalOwnership" />
      <MemberSignature Language="VB.NET" Value="Public Property JournalOwnership As JournalOwnership" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::JournalOwnership JournalOwnership { System::Windows::Navigation::JournalOwnership get(); void set(System::Windows::Navigation::JournalOwnership value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalOwnership</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta se un <see cref="T:System.Windows.Controls.Frame" /> è responsabile della gestione della cronologia di navigazione o se affida la gestione della cronologia di navigazione a uno strumento di navigazione padre (<see cref="T:System.Windows.Navigation.NavigationWindow" />, <see cref="T:System.Windows.Controls.Frame" />).</summary>
        <value>Il valore <see cref="T:System.Windows.Navigation.JournalOwnership" /> che specifica se <see cref="T:System.Windows.Controls.Frame" /> gestisce il journal. Il valore predefinito è <see cref="F:System.Windows.Navigation.JournalOwnership.Automatic" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, <xref:System.Windows.Controls.Frame> userà la propria cronologia di navigazione solo se un host di navigazione padre (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) con il proprio journal non è possibile trovare (ad esempio, se un <xref:System.Windows.Controls.Frame> è ospitato in un contenuto ospitato da un <xref:System.Windows.Window>). Per forzare <xref:System.Windows.Controls.Frame> per gestire la propria cronologia di navigazione, impostare <xref:System.Windows.Controls.Frame.JournalOwnership%2A> a <xref:System.Windows.Navigation.JournalOwnership.OwnsJournal>.  
  
<a name="dependencyPropertyInfo_FrameJournalOwnership"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Frame.JournalOwnershipProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un <xref:System.Windows.Controls.Frame> che è configurato per utilizzare la cronologia di navigazione.  
  
 [!code-xaml[FrameJournalOwnershipSnippetSample#SetJournalOwnershipProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FrameJournalOwnershipSnippetSample/CS/HomePage.xaml#setjournalownershipproperty)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JournalOwnershipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty JournalOwnershipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty JournalOwnershipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Frame.JournalOwnershipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly JournalOwnershipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ JournalOwnershipProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Frame.JournalOwnership" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Frame.JournalOwnership%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Frame.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:MS.Internal.AppModel.INavigatorBase.LoadCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il contenuto sul quale ci si è spostati è stato caricato, analizzato e ne è iniziata l'esecuzione del rendering.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.Frame.Navigating" />
        <altmember cref="E:System.Windows.Controls.Frame.Navigated" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationProgress" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationStopped" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationFailed" />
        <altmember cref="E:System.Windows.Controls.Frame.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Si sposta in modo asincrono al contenuto di origine specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Navigate(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (content As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Navigate(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigatorBase.Navigate(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Un <see cref="T:System.Object" /> che include il contenuto su cui spostarsi.</param>
        <summary>Esegue la navigazione asincrona sul contenuto incluso in un oggetto.</summary>
        <returns>
          <see langword="true" /> se la navigazione non è annullata, altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come passare per il contenuto da un oggetto.  
  
 [!code-csharp[HOWTONavigationSnippets#NavigateToPageObjCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/MainWindow.xaml.cs#navigatetopageobjcode)]
 [!code-vb[HOWTONavigationSnippets#NavigateToPageObjCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTONavigationSnippets/visualbasic/mainwindow.xaml.vb#navigatetopageobjcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Navigate(Uri ^ source);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigatorBase.Navigate(System.Uri)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Uri" /> inizializzato con l'URI del contenuto desiderato.</param>
        <summary>Esegue lo spostamento asincrono sul contenuto specificato da un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</summary>
        <returns>
          <see langword="true" /> se la navigazione non è annullata, altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[TLA#tla_uri#initcap#plural](~/includes/tlasharptla-urisharpinitcapsharpplural-md.md)] può essere relativo o assoluto. Per altre informazioni, vedere [URI di tipo pack in WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Windows.Controls.Frame.Navigate%2A> metodo per passare a un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].  
  
 [!code-csharp[HOWTONavigationSnippets#NavigateToPageNavCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/MainWindow.xaml.cs#navigatetopagenavcode)]
 [!code-vb[HOWTONavigationSnippets#NavigateToPageNavCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTONavigationSnippets/visualbasic/mainwindow.xaml.vb#navigatetopagenavcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object content, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Navigate(object content, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (content As Object, extraData As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Navigate(System::Object ^ content, System::Object ^ extraData);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigatorBase.Navigate(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Un <see cref="T:System.Object" /> che include il contenuto su cui spostarsi.</param>
        <param name="extraData">Un <see cref="T:System.Object" /> che contiene dati da utilizzare per l'elaborazione durante la navigazione.</param>
        <summary>Esegue la navigazione asincrona sul contenuto incluso in un oggetto e passa un oggetto che contiene dati da utilizzare per l'elaborazione durante la navigazione.</summary>
        <returns>
          <see langword="true" /> se la navigazione non è annullata, altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Navigate(class System.Uri source, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, extraData As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Navigate(Uri ^ source, System::Object ^ extraData);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigatorBase.Navigate(System.Uri,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Uri" /> inizializzato con l'URI del contenuto desiderato.</param>
        <param name="extraData">Un <see cref="T:System.Object" /> che contiene dati da utilizzare per l'elaborazione durante la navigazione.</param>
        <summary>Si sposta in modo asincrono al contenuto di origine disponibile a un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]e passa un oggetto che contiene dati da utilizzare per l'elaborazione durante la navigazione.</summary>
        <returns>
          <see langword="true" /> se la navigazione non è annullata, altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Frame.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:MS.Internal.AppModel.INavigatorBase.Navigated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il contenuto sul quale si sta navigando viene trovato ed è disponibile tramite la proprietà <see cref="P:System.Windows.Controls.ContentControl.Content" />, anche se il relativo caricamento potrebbe non essere stato completato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.Navigated?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.Frame.Navigating" />
        <altmember cref="E:System.Windows.Controls.Frame.LoadCompleted" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationProgress" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationStopped" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationFailed" />
        <altmember cref="E:System.Windows.Controls.Frame.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Frame.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:MS.Internal.AppModel.INavigatorBase.Navigating</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene richiesta una nuova navigazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.Frame.Navigated" />
        <altmember cref="E:System.Windows.Controls.Frame.LoadCompleted" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationProgress" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationStopped" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationFailed" />
        <altmember cref="E:System.Windows.Controls.Frame.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Frame.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:MS.Internal.AppModel.INavigatorBase.NavigationFailed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene generato un errore durante la navigazione nel contenuto richiesto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.Frame.Navigating" />
        <altmember cref="E:System.Windows.Controls.Frame.Navigated" />
        <altmember cref="E:System.Windows.Controls.Frame.LoadCompleted" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationProgress" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationStopped" />
        <altmember cref="E:System.Windows.Controls.Frame.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Frame.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:MS.Internal.AppModel.INavigatorBase.NavigationProgress</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica periodicamente durante un download per fornire informazioni sullo stato dello spostamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.Frame.Navigating" />
        <altmember cref="E:System.Windows.Controls.Frame.Navigated" />
        <altmember cref="E:System.Windows.Controls.Frame.LoadCompleted" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationStopped" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationFailed" />
        <altmember cref="E:System.Windows.Controls.Frame.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.NavigationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NavigationService As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationService ^ NavigationService { System::Windows::Navigation::NavigationService ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:MS.Internal.AppModel.IJournalNavigationScopeHost.NavigationService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il <see cref="T:System.Windows.Navigation.NavigationService" /> utilizzato da <see cref="T:System.Windows.Controls.Frame" /> per fornire servizi di navigazione.</summary>
        <value>Oggetto <see cref="T:System.Windows.Controls.Frame" /> che rappresenta il <see cref="T:System.Windows.Navigation.NavigationService" /> utilizzato da <see cref="T:System.Windows.Controls.Frame" />, se disponibile. In caso contrario, viene restituito <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Frame> Usa <xref:System.Windows.Navigation.NavigationService> per supportare la navigazione per il contenuto ospitato. <xref:System.Windows.Controls.Frame.NavigationService%2A> è utile per il codice che ospita un <xref:System.Windows.Controls.Frame> per ottenere un riferimento di <xref:System.Windows.Navigation.NavigationService>. Contenuto ospitato da un <xref:System.Windows.Controls.Frame>, ad esempio <xref:System.Windows.Controls.Page>, deve utilizzare <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> o <xref:System.Windows.Controls.Page.NavigationService%2A> per ottenere un riferimento di <xref:System.Windows.Navigation.NavigationService>.  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Frame.NavigationService%2A> non restituisce un riferimento allo stesso <xref:System.Windows.Controls.Frame.NavigationService%2A> a chiamare <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> e passando <xref:System.Windows.Controls.Frame> does. Il primo restituisce il <xref:System.Windows.Controls.Frame.NavigationService%2A> di proprietà di <xref:System.Windows.Controls.Frame> mentre il secondo restituisce il <xref:System.Windows.Controls.Frame.NavigationService%2A> per l'host di navigazione che si è spostato il contenuto in cui il <xref:System.Windows.Controls.Frame> è ospitato. Il codice seguente illustra le differenze.  
  
 [!code-csharp[NSGNSvsFNSSnippets#NSFrameDiffCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGNSvsFNSSnippets/CSharp/Window1.xaml.cs#nsframediffcode1)]
 [!code-vb[NSGNSvsFNSSnippets#NSFrameDiffCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGNSvsFNSSnippets/visualbasic/window1.xaml.vb#nsframediffcode1)]  
[!code-csharp[NSGNSvsFNSSnippets#NSFrameDiffCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGNSvsFNSSnippets/CSharp/Window1.xaml.cs#nsframediffcode2)]
[!code-vb[NSGNSvsFNSSnippets#NSFrameDiffCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGNSvsFNSSnippets/visualbasic/window1.xaml.vb#nsframediffcode2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Frame.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:MS.Internal.AppModel.INavigatorBase.NavigationStopped</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene chiamato il metodo <see cref="M:System.Windows.Controls.Frame.StopLoading" />, o quando viene richiesta una nuova navigazione mentre è già in corso una navigazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.Frame.Navigating" />
        <altmember cref="E:System.Windows.Controls.Frame.Navigated" />
        <altmember cref="E:System.Windows.Controls.Frame.LoadCompleted" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationProgress" />
        <altmember cref="E:System.Windows.Controls.Frame.NavigationFailed" />
        <altmember cref="E:System.Windows.Controls.Frame.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationUIVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationUIVisibility NavigationUIVisibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Navigation.NavigationUIVisibility NavigationUIVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.NavigationUIVisibility" />
      <MemberSignature Language="VB.NET" Value="Public Property NavigationUIVisibility As NavigationUIVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationUIVisibility NavigationUIVisibility { System::Windows::Navigation::NavigationUIVisibility get(); void set(System::Windows::Navigation::NavigationUIVisibility value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationUIVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta quando <see cref="T:System.Windows.Controls.Frame" /> può visualizzare la propria interfaccia utente di navigazione.</summary>
        <value>Un <see cref="T:System.Windows.Navigation.NavigationUIVisibility" /> valore che specifica quando il <see cref="T:System.Windows.Controls.Frame" /> consente di visualizzare la propria interfaccia utente di spostamento. Il valore predefinito è <see cref="F:System.Windows.Navigation.NavigationUIVisibility.Automatic" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un <xref:System.Windows.Controls.Frame> Mostra automaticamente la propria interfaccia utente di spostamento quando la prima voce viene aggiunto alla cronologia di navigazione. Lo spostamento dell'interfaccia utente rimane successivamente visibile, con i pulsanti di navigazione in avanti opportunamente abilitato o disabilitato per riflettere il numero di voci presenti in avanti e Indietro back.  
  
 È possibile assicurarsi che navigazione dell'interfaccia utente è sempre visibile impostando:  
  
1.  <xref:System.Windows.Navigation.NavigationUIVisibility> in <xref:System.Windows.Navigation.NavigationUIVisibility.Visible>  
  
2.  <xref:System.Windows.Controls.Frame.JournalOwnership%2A> in <xref:System.Windows.Navigation.JournalOwnership.OwnsJournal>  
  
 È impostato <xref:System.Windows.Navigation.NavigationUIVisibility> a <xref:System.Windows.Navigation.NavigationUIVisibility.Hidden> se si desidera nascondere l'interfaccia utente di spostamento. Questo potrebbe essere il caso quando navigazione dell'interfaccia utente non ha senso con il contenuto che si sta visualizzando da un <xref:System.Windows.Controls.Frame>, oppure perché si fornisce la propria interfaccia utente di spostamento.  
  
<a name="dependencyPropertyInfo_FrameJournalNavigationUIVisibility"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Frame.NavigationUIVisibilityProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come assicurarsi che il riquadro di spostamento di un <xref:System.Windows.Controls.Frame> è sempre visibile impostando <xref:System.Windows.Controls.Frame.NavigationUIVisibility%2A> a <xref:System.Windows.Navigation.NavigationUIVisibility.Visible>.  
  
 [!code-csharp[FrameNavigationUIVisibilitySnippets#SetNavigationUIVisibility](~/samples/snippets/csharp/VS_Snippets_Wpf/FrameNavigationUIVisibilitySnippets/CSharp/Window1.xaml.cs#setnavigationuivisibility)]
 [!code-vb[FrameNavigationUIVisibilitySnippets#SetNavigationUIVisibility](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FrameNavigationUIVisibilitySnippets/visualbasic/window1.xaml.vb#setnavigationuivisibility)]
 [!code-xaml[FrameNavigationUIVisibilitySnippets#SetNavigationUIVisibility](~/samples/snippets/xaml/VS_Snippets_Wpf/FrameNavigationUIVisibilitySnippets/XAML/Window1.xaml#setnavigationuivisibility)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationUIVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NavigationUIVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NavigationUIVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Frame.NavigationUIVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NavigationUIVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NavigationUIVisibilityProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Frame.NavigationUIVisibility" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Frame.NavigationUIVisibility%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiamato quando viene creata la generazione del modello per la struttura ad albero visuale.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Controls.Frame.ContentRendered" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Frame.OnContentRendered%2A> genera l'evento <xref:System.Windows.Controls.Frame.ContentRendered>.  
  
 Un tipo che deriva da <xref:System.Windows.Controls.Frame> può eseguire l'override <xref:System.Windows.Controls.Frame.OnContentRendered%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Controls.Frame.OnContentRendered%2A> sulla classe di base se <xref:System.Windows.Controls.Frame.ContentRendered> deve essere generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea e restituisce un oggetto <see cref="T:System.Windows.Automation.Peers.NavigationWindowAutomationPeer" /> per questo <see cref="T:System.Windows.Controls.Frame" />.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Automation.Peers.NavigationWindowAutomationPeer" /> per questa classe <see cref="T:System.Windows.Controls.Frame" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override del metodo <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigatorBase.Refresh</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ricarica il contenuto corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.Refresh%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigator.RemoveBackEntry</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove la voce più recente del journal dalla cronologia indietro.</summary>
        <returns>
          <see cref="T:System.Windows.Navigation.JournalEntry" /> più recente nella eventuale cronologia di navigazione indietro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Frame.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="SandboxExternalContent">
      <MemberSignature Language="C#" Value="public bool SandboxExternalContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxExternalContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.SandboxExternalContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxExternalContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxExternalContent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta se un <see cref="T:System.Windows.Controls.Frame" /> isola il contenuto esterno [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] in una sandbox di sicurezza di attendibilità parziale (con il set di autorizzazioni predefinito <see langword="Internet" />).</summary>
        <value>
          <see langword="true" /> se il contenuto è isolato all'interno di una sandbox di sicurezza parzialmente attendibile; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il contenuto esterno è [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] contenuto che non è incluso in un'applicazione come un file di risorse o un file di contenuto (vedere [risorse dell'applicazione WPF, contenuto e i file di dati](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
 Quando <xref:System.Windows.Controls.Frame.SandboxExternalContent%2A> è `true`e l'origine per il contenuto del <xref:System.Windows.Controls.Frame> è esterno [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] file, il contenuto viene caricato in un sandbox di sicurezza parzialmente attendibile che è limitato per il valore predefinito `Internet` set di autorizzazioni. Il contenuto esterno viene successivamente caricato in un processo separato. Di conseguenza, il contenuto esterno viene isolato e non dispone dell'accesso alle risorse dell'ambito dell'applicazione, ad esempio dizionari delle risorse (vedere <xref:System.Windows.ResourceDictionary>).  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Frame> conterrà solo il contenuto esterno quando il <xref:System.Windows.Controls.Frame.Source%2A> è impostata sul [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] per esterno [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] file. <xref:System.Windows.Controls.Frame> contenuto che è fornito mediante la <xref:System.Windows.Controls.ContentControl.Content%2A> proprietà è considerata contenuto interno e, successivamente, non è isolata.  
  
<a name="dependencyPropertyInfo_FrameSandboxExternalContent"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Frame.SandboxExternalContent%2A>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="P:System.Windows.Controls.Frame.SandboxExternalContent" /> è impostato quando un'applicazione è in esecuzione in situazione di attendibilità parziale.</exception>
      </Docs>
    </Member>
    <Member MemberName="SandboxExternalContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SandboxExternalContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SandboxExternalContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Frame.SandboxExternalContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SandboxExternalContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SandboxExternalContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Frame.SandboxExternalContent" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Frame.SandboxExternalContent%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeContent">
      <MemberSignature Language="C#" Value="public override bool ShouldSerializeContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ShouldSerializeContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.ShouldSerializeContent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ShouldSerializeContent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ShouldSerializeContent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente alle classi derivate di determinare il comportamento del serializzazione della proprietà <see cref="P:System.Windows.Controls.ContentControl.Content" />.</summary>
        <returns>
          <see langword="true" /> se il contenuto deve essere serializzato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:MS.Internal.AppModel.INavigatorBase.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] del contenuto corrente, o l'URI del nuovo contenuto nuovo sul quale ci si sta spostando.</summary>
        <value>Oggetto <see cref="T:System.Uri" /> che contiene l'URI per il contenuto corrente o il contenuto che ci si sta spostando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.Source%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[TLA#tla_uri#initcap#plural](~/includes/tlasharptla-urisharpinitcapsharpplural-md.md)] può essere relativo o assoluto. Per altre informazioni, vedere [URI di tipo pack in WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md).  
  
<a name="dependencyPropertyInfo_FrameSource"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Frame.SourceProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come passare a un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] impostando il <xref:System.Windows.Controls.Frame.Source%2A> proprietà.  
  
 [!code-csharp[HOWTONavigationSnippets#NavigateToPageSrcCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/MainWindow.xaml.cs#navigatetopagesrccode)]
 [!code-vb[HOWTONavigationSnippets#NavigateToPageSrcCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTONavigationSnippets/visualbasic/mainwindow.xaml.vb#navigatetopagesrccode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SourceProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SourceProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Frame.SourceProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SourceProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SourceProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Frame.Source" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Frame.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void StopLoading();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.AppModel.INavigatorBase.StopLoading</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompe il download di contenuto per la richiesta di navigazione corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Navigation.NavigationService.StopLoading%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Controls.Frame.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IUriContext.BaseUri">
      <MemberSignature Language="C#" Value="Uri System.Windows.Markup.IUriContext.BaseUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri System.Windows.Markup.IUriContext.BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Frame.System#Windows#Markup#IUriContext#BaseUri" />
      <MemberSignature Language="VB.NET" Value=" Property BaseUri As Uri Implements IUriContext.BaseUri" />
      <MemberSignature Language="C++ CLI" Value="property Uri ^ System.Windows.Markup.IUriContext.BaseUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IUriContext.BaseUri</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Windows.Markup.IUriContext.BaseUri" />.</summary>
        <value>URI di base del contesto corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Windows.Controls.Frame> a un'interfaccia <xref:System.Windows.Markup.IUriContext>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Frame.BaseUri" />
      </Docs>
    </Member>
  </Members>
</Type>