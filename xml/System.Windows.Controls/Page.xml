<Type Name="Page" FullName="System.Windows.Controls.Page">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d2b2f547328a5918908d2949cdc123c74c5786fc" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694919" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Incapsula una pagina di contenuto alla quale si può accedere e che può essere contenuta in Windows Internet Explorer, <see cref="T:System.Windows.Navigation.NavigationWindow" /> e <see cref="T:System.Windows.Controls.Frame" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page> Incapsula una pagina di contenuto che è possibile spostarsi e include i membri chiavi seguenti:  
  
-   **Gestione della durata**: <xref:System.Windows.Controls.Page.KeepAlive%2A>.  
  
-   **Navigazione**: <xref:System.Windows.Controls.Page.NavigationService%2A>.  
  
-   **Aspetto**: <xref:System.Windows.Controls.Page.Background%2A>, <xref:System.Windows.Controls.Page.Content%2A>, <xref:System.Windows.Controls.Page.FontFamily%2A>, <xref:System.Windows.Controls.Page.FontSize%2A>, <xref:System.Windows.Controls.Page.Foreground%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>, <xref:System.Windows.Controls.Page.Template%2A>, <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   **Aspetto della finestra host**: <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowTitle%2A>.  
  
 Una pagina può essere definita tramite markup, markup e code-behind o codice. Una pagina è il modo preferito per il contenuto del pacchetto per la navigazione, per i motivi seguenti:  
  
-   È facile definire, riutilizzare e gestire.  
  
-   È possibile accedere e utilizzare il <xref:System.Windows.Navigation.NavigationService> che si sposta su tale.  
  
-   È possibile modificare il titolo, la larghezza, altezza e navigazione [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] della finestra host (<xref:System.Windows.Controls.Page.WindowTitle%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>).  
  
-   Dispone del supporto della finestra di progettazione in [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)].  
  
 Una pagina può essere ospitata da <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, o da un browser. Per essere ospitata una pagina può essere:  
  
-   Il figlio diretto di un <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, o <xref:System.Windows.Controls.Frame> elemento [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
-   Creare un'istanza e impostare come valore della `Content` proprietà di <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, e <xref:System.Windows.Controls.Frame>.  
  
-   Impostare come il [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] origine il `Source` proprietà di <xref:System.Windows.Navigation.NavigationWindow> o <xref:System.Windows.Controls.Frame>.  
  
-   Impostare come il <xref:System.Windows.Application.StartupUri%2A> in un'applicazione autonoma.  
  
-   Impostare come il <xref:System.Windows.Application.StartupUri%2A> in un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
 Un'applicazione è in genere due o più pagine, è possibile spostarsi tra i meccanismi seguenti:  
  
-   In modo dichiarativo utilizzando <xref:System.Windows.Documents.Hyperlink>.  
  
-   A livello di programmazione utilizzando <xref:System.Windows.Navigation.NavigationService>.  
  
-   Visivamente utilizzando la navigazione [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] dell'host, tra cui [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], <xref:System.Windows.Navigation.NavigationWindow>, e <xref:System.Windows.Controls.Frame>.  
  
 Per lo spostamento strutturato utilizzando funzioni di pagina (<xref:System.Windows.Navigation.PageFunction%601>), vedere [Structured Navigation Overview](~/docs/framework/wpf/app-development/structured-navigation-overview.md) e [Cenni preliminari sulle topologie di navigazione](~/docs/framework/wpf/app-development/navigation-topologies-overview.md).  
  
 Proprietà di dipendenza per questo controllo potrebbe essere impostata dallo stile predefinito del controllo.  Se una proprietà viene impostata da uno stile predefinito, la proprietà può variare rispetto al valore predefinito quando il controllo viene visualizzato nell'applicazione. Lo stile predefinito è determinato dal tema del desktop viene utilizzato quando l'applicazione è in esecuzione.  Per ulteriori informazioni, vedere [temi WPF predefiniti](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come una pagina standard viene definito utilizzando solo il markup:  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 Nell'esempio seguente viene illustrato come viene definita una pagina standard utilizzando solo codice:  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 Nell'esempio seguente viene illustrato come una pagina standard viene definito mediante una combinazione di markup e code-behind.  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Navigation.PageFunction`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un <xref:System.Windows.Controls.Page> non viene mantenuto attivo (vedere <xref:System.Windows.Controls.Page.KeepAlive%2A>), è necessario implementare un costruttore predefinito in modo [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] per creare una nuova istanza quando vi si accede al backup o indietro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">La dimensione da utilizzare per disporre degli elementi figlio.</param>
        <summary>Dispone il contenuto (elementi figlio) della classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Size" /> che rappresenta la dimensione disposta della pagina.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene e imposta lo sfondo per la classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Brush" /> che <see cref="T:System.Windows.Controls.Page" /> utilizza per disegnare lo sfondo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Page.Background" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il contenuto di una classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Oggetto che contiene il contenuto di una classe <see cref="T:System.Windows.Controls.Page" />. Il valore predefinito è <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Controls.Page> può avere solo un singolo elemento figlio. Tutti gli altri elementi in un <xref:System.Windows.Controls.Page> devono essere discendenti di tale elemento. In genere, il contenuto di un <xref:System.Windows.Controls.Page> ospita un elemento di layout, ad esempio <xref:System.Windows.Controls.Grid>, <xref:System.Windows.Controls.StackPanel>, e <xref:System.Windows.Controls.DockPanel>, che ospita il contenuto del <xref:System.Windows.Controls.Page>.  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Page.ContentProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Page.Content" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome della famiglia di caratteri specificata.</summary>
        <value>Una <see cref="T:System.Windows.Media.FontFamily" /> che è la famiglia di caratteri per il contenuto di una classe <see cref="T:System.Windows.Controls.Page" />. Il valore predefinito è <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Page.FontFamily" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Page.FontFamily%2A>.  
  
   
  
## Examples  
 [Panoramica sulle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta la dimensione di carattere.</summary>
        <value>La dimensione del carattere per il contenuto di una classe <see cref="T:System.Windows.Controls.Page" />. Il valore predefinito è <see cref="P:System.Windows.SystemFonts.MessageFontSize" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dimensioni del carattere devono essere un numero positivo compreso nell'intervallo di <xref:System.Windows.SystemFonts.MessageFontSize%2A>.  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Page.FontSize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Page.FontSize%2A>.  
  
   
  
## Examples  
 [Panoramica sulle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene e imposta il primo piano di una classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Brush" /> che <see cref="T:System.Windows.Controls.Page" /> utilizza per disegnare il primo piano. Il valore predefinito è <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Page.Foreground" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Page.Foreground%2A>.  
  
   
  
## Examples  
 [Panoramica sulle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'istanza della classe <see cref="T:System.Windows.Controls.Page" /> viene conservata nella cronologia di navigazione.</summary>
        <value>
          <see langword="true" /> se l'istanza di <see cref="T:System.Windows.Controls.Page" /> viene conservata nella cronologia di navigazione; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una pagina prima ci si sposta in una nuova istanza di <xref:System.Windows.Controls.Page> classe viene creata. Quando una pagina ci si sposta (in avanti o indietro), una voce per la pagina viene aggiunto alla cronologia di navigazione. Per impostazione predefinita, la voce non fa riferimento l'oggetto della pagina. Al contrario, la voce contiene un Service pack uniform resource identifier (URI) per la pagina. Quando si accede alla voce per la pagina utilizzando la cronologia di navigazione, l'URI di tipo pack consente di creare una nuova istanza della pagina. Questo comportamento è l'impostazione predefinita, per evitare l'utilizzo eccessivo della memoria: mantenere le istanze della pagina può consumare memoria rapidamente, in particolare quelli con una quantità di contenuto complessa. Questo problema è aumentato dal fatto che non esiste alcun limite per il numero di voci che possono essere archiviati nel back e forward stack della cronologia di navigazione. Al contrario, l'URI di tipo pack per le pagine di archiviazione virtualmente non incide sul consumo di memoria.  
  
 L'effetto sul lato principale della creazione di nuove istanze di una pagina è che lo stato della pagina non viene memorizzato da un'istanza di una pagina a un altro. In questi casi, Windows Presentation Foundation offre diverse tecniche per la memorizzazione dello stato.  
  
 Per mantenere attiva una pagina, impostare il <xref:System.Windows.Controls.Page.KeepAlive%2A> proprietà `true` (il valore predefinito è `false`).  
  
> [!NOTE]
>  Pagine Creazione di un'istanza che si accede utilizzando solo il codice (ad esempio, la chiamata <xref:System.Windows.Navigation.NavigationService.Navigate%2A>), vengono mantenute attive automaticamente.  
  
 È consigliabile evitare di impostare <xref:System.Windows.Controls.Page.KeepAlive%2A> per `true` a meno che non è necessario:  
  
-   Quando una pagina contiene una grande quantità di contenuto, potrebbe richiedere molto tempo per creare un'istanza. Se la pagina non vengono mantenuta attiva e la pagina viene esplorata spesso, il costo della creazione di un'istanza della pagina può avere un impatto negativo sull'esperienza dell'utente. Dal punto di vista delle prestazioni, è necessario basarsi sulle impostazioni predefinite e profilare le prestazioni dell'applicazione; Se il test identifica pagine con tempi di caricamento che cadono di sotto dell'intervallo richiesto per l'applicazione, la configurazione delle pagine essere conservate potrebbe essere un modo per risolvere il problema.  
  
> [!NOTE]
>  Le voci per le pagine che vengono mantenute attive non vengono mantenute nella cronologia di navigazione di un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] se un utente si sposta da e al [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]. Solo le voci di registrazione per le pagine che non vengono mantenute attive vengono mantenute nella cronologia di navigazione.  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
> [!NOTE]
>  Il tipo di metadati per questa proprietà di dipendenza è <xref:System.Windows.PropertyMetadata>, non <xref:System.Windows.FrameworkPropertyMetadata>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] per mantenere un'istanza di <xref:System.Windows.Controls.Page> classe esplorazioni più.  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.JournalEntry.KeepAlive" />
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeepAliveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ KeepAliveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Page.KeepAlive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Page.KeepAlive%2A>.  
  
   
  
## Examples  
 [Panoramica sulle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un enumeratore per gli elementi figlio logici di una classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" /> per gli elementi figlio logici di una classe <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">L'area disponibile che la finestra può assegnare ai figli.</param>
        <summary>Misura gli elementi figlio della classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>Un oggetto <see cref="T:System.Windows.Size" /> che è la dimensione effettiva della finestra. Il metodo può restituire un valore maggiore, in tal caso il padre può richiedere l'aggiunta di barre di scorrimento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NavigationService As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationService ^ NavigationService { System::Windows::Navigation::NavigationService ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il servizio di navigazione che l'host della pagina sta utilizzando per gestire la navigazione.</summary>
        <value>L'oggetto <see cref="T:System.Windows.Navigation.NavigationService" /> che l'host della pagina sta utilizzando per gestire la navigazione o <see langword="null" /> se l'host non supporta la navigazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le pagine possono essere ospitate da più tipi di host, inclusi <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>e un browser.  
  
 Pagine è spesso necessario per l'integrazione con lo spostamento dell'host per supportare la navigazione all'interno della pagina. Tuttavia, poiché una pagina potrà non conosce l'host in fase di esecuzione, non può integrarsi direttamente con i membri di navigazione dell'host a tale scopo.  
  
 In alternativa, può tentare di utilizzare un servizio di spostamento è un servizio che supporta la navigazione di tipo browser e viene incapsulata dalle classi di <xref:System.Windows.Navigation.NavigationService> classe. Non è possibile creare <xref:System.Windows.Navigation.NavigationService> tuttavia istanza. Tipi di host, ad esempio <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, o un browser crearne di propri <xref:System.Windows.Navigation.NavigationService> istanza che è possibile accedere dal <xref:System.Windows.Controls.Page.NavigationService%2A> proprietà.  
  
 Il servizio di navigazione che viene restituito dal <xref:System.Windows.Controls.Page.NavigationService%2A> proprietà è l'istanza del <xref:System.Windows.Navigation.NavigationService> classe gestita dal Navigatore prima la struttura ad albero visuale. Se non viene trovata, `null` viene restituito, che indica l'host della pagina non supporta la navigazione.  
  
> [!NOTE]
>  La <xref:System.Windows.Window> classe non supporta la navigazione e non fornisce un servizio di spostamento.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come una pagina può controllare se è disponibile un servizio di spostamento e, in caso affermativo, utilizzarlo per tornare alla pagina precedente.  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">Modello precedente.</param>
        <param name="newTemplate">Nuovo modello.</param>
        <summary>Chiamato quando il modello per la classe <see cref="T:System.Windows.Controls.Page" /> viene modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Page.Template" />
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Elemento padre precedente. Impostare su <see langword="null" /> se <see cref="T:System.Windows.DependencyObject" /> non aveva un padre precedente.</param>
        <summary>Chiamato quando il padre della classe <see cref="T:System.Windows.Controls.Page" /> viene modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il padre nuovo non è un <see cref="T:System.Windows.Window" /> né <see cref="T:System.Windows.Controls.Frame" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeShowsNavigationUI () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeShowsNavigationUI();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente alle classi derivate di determinare il comportamento del serializzazione della proprietà <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" />.</summary>
        <returns>
          <see langword="true" /> se il contenuto deve essere serializzato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTitle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente alle classi derivate di determinare il comportamento del serializzazione della proprietà <see cref="P:System.Windows.Controls.Page.Title" />.</summary>
        <returns>
          <see langword="true" /> se il contenuto deve essere serializzato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowHeight () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowHeight();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente alle classi derivate di determinare il comportamento del serializzazione della proprietà <see cref="P:System.Windows.Controls.Page.WindowHeight" />.</summary>
        <returns>
          <see langword="true" /> se il contenuto deve essere serializzato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowTitle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente alle classi derivate di determinare il comportamento del serializzazione della proprietà <see cref="P:System.Windows.Controls.Page.WindowTitle" />.</summary>
        <returns>
          <see langword="true" /> se il contenuto deve essere serializzato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowWidth () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowWidth();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente alle classi derivate di determinare il comportamento del serializzazione della proprietà <see cref="P:System.Windows.Controls.Page.WindowWidth" />.</summary>
        <returns>
          <see langword="true" /> se il contenuto deve essere serializzato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowsNavigationUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowsNavigationUI { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] di navigazione di <see cref="T:System.Windows.Navigation.NavigationWindow" /> su [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)] è visibile.</summary>
        <value>
          <see langword="true" /> se la [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] di navigazione di <see cref="T:System.Windows.Navigation.NavigationWindow" /> dell'host è visibile; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow> Visualizza lo spostamento [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] per impostazione predefinita per consentire di tipo browser avanti e indietro navigazione. Se una pagina viene impostata come il <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application> verrà aperta automaticamente una <xref:System.Windows.Navigation.NavigationWindow> per ospitare la pagina. Se la pagina non desidera utilizzare il valore predefinito <xref:System.Windows.Navigation.NavigationWindow> navigazione [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], è possibile impostare <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> a `false`.  
  
> [!NOTE]
>  Poiché [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] non si integra con la navigazione [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] per [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)], fornisce il proprio navigazione [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], che possono essere visualizzati o nascosti impostando <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>. [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] integrazione con il [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] navigazione [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], impostando così <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> nelle pagine [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] non ha alcun effetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] per nascondere la navigazione [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] di un <xref:System.Windows.Navigation.NavigationWindow>.  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> è controllata su un'istanza della classe <see cref="T:System.Windows.Controls.Page" /> che non è ospitata da <see cref="T:System.Windows.Window" />, <see cref="T:System.Windows.Navigation.NavigationWindow" /> o da un browser.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (obj As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ obj) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto figlio da aggiungere.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Windows.Controls.Page> a un'interfaccia <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (str As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ str) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Testo da aggiungere all'oggetto.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Windows.Controls.Page> a un'interfaccia <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il modello di controllo per una classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Windows.Controls.ControlTemplate" /> per un oggetto <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *resourceExtension*  
 Un'estensione di markup che identifica come fare riferimento alla risorsa di modello, ovvero `StaticResource` o `DynamicResource`. Vedere [risorse XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 La chiave che identifica il selettore di modello richiesto. La chiave fa riferimento a una risorsa esistente in un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  La sintassi degli elementi è tecnicamente possibile, ma non è consigliata. Per ulteriori informazioni, vedere [stili Inline e modelli](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Page.Template" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il titolo della classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Titolo della classe <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore della <xref:System.Windows.Controls.Page.Title%2A> proprietà non viene visualizzata per <xref:System.Windows.Controls.Page>, né viene visualizzato dalla barra del titolo della finestra che ospita un <xref:System.Windows.Controls.Page>. È invece impostare <xref:System.Windows.Controls.Page.WindowTitle%2A> per modificare il titolo di una finestra host.  
  
 <xref:System.Windows.Controls.Page.Title%2A> può anche essere utilizzato per generare il nome della voce di cronologia di spostamento di una parte del contenuto. Le seguenti porzioni di dati utilizzate per costruire automaticamente un nome della voce della cronologia di navigazione, in ordine di precedenza:  
  
-   L'allegato <xref:System.Windows.Navigation.JournalEntry.Name%2A> attributo.  
  
-   La proprietà <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   Il <xref:System.Windows.Controls.Page.WindowTitle%2A> proprietà e [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] per la pagina corrente  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] per la pagina corrente.  
  
 Se è stato associato un <xref:System.Windows.Navigation.CustomContentState> oggetto con una parte del contenuto nella cronologia di navigazione, è possibile specificare il nome visualizzato nella voce di cronologia di navigazione eseguendo l'override <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.Page.TitleProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.Page.Title" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificatore della proprietà di dipendenza <xref:System.Windows.Controls.Page.Title%2A>.  
  
   
  
## Examples  
 [Panoramica sulle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'altezza della <see cref="T:System.Windows.Window" /> o <see cref="T:System.Windows.Navigation.NavigationWindow" /> dell'host di una classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>L'altezza di una finestra che ospita direttamente una classe <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A> viene applicato solo quando un <xref:System.Windows.Controls.Page> è ospitato direttamente da una finestra che include:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Se un <xref:System.Windows.Controls.Page> è ospitato da un <xref:System.Windows.Controls.Frame>, l'impostazione <xref:System.Windows.Controls.Page.WindowHeight%2A> non ha alcun effetto, ma è comunque possibile ottenere il valore di <xref:System.Windows.Controls.Page.WindowHeight%2A>.  
  
 A <xref:System.Windows.Controls.Page> in un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] possibile utilizzare solo <xref:System.Windows.Controls.Page.WindowHeight%2A> per modificare l'altezza di [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; non può essere modificata impostando l'altezza <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.MinHeight%2A>, o <xref:System.Windows.FrameworkElement.MaxHeight%2A>.  
  
 L'altezza minima del [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] finestra è 150 pixel. Per le pagine ospitate da browser, ciò significa che il valore di <xref:System.Windows.Controls.Page.WindowHeight%2A> non possono essere applicate se quest ' operazione causerebbe l'altezza totale del [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] finestra inferiore a 150 pixel.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare l'altezza di una finestra da una pagina.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WindowTitle { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il titolo della <see cref="T:System.Windows.Window" /> o <see cref="T:System.Windows.Navigation.NavigationWindow" /> dell'host di una classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Il titolo di una finestra che ospita direttamente la classe <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il titolo di una finestra che ospita una pagina, tra cui <xref:System.Windows.Navigation.NavigationWindow> e [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], è il nome del file che è attualmente ospitato (con estensione XAML, se la pagina è separato [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], o un'estensione. xbap se la pagina fa parte di un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).  
  
 Una pagina è possibile modificare l'impostazione predefinita impostando il relativo <xref:System.Windows.Controls.Page.WindowTitle%2A> proprietà.  
  
 Una volta che una pagina imposta il titolo di una finestra in questo modo, il titolo della finestra cambia fintanto che non imposta un'altra pagina <xref:System.Windows.Controls.Page.WindowTitle%2A> con un valore diverso.  
  
> [!NOTE]
>  Il <xref:System.Windows.Controls.Page> deve essere la parte superiore del contenuto in una finestra per <xref:System.Windows.Controls.Page.WindowTitle%2A> abbia effetto; se un <xref:System.Windows.Controls.Page> è ospitato all'interno di un <xref:System.Windows.Controls.Frame>, ad esempio, l'impostazione <xref:System.Windows.Controls.Page.WindowTitle%2A> non modificare il titolo della finestra host.  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A> può anche essere utilizzato per generare il nome della voce di cronologia di spostamento di una parte del contenuto. Le seguenti porzioni di dati utilizzate per costruire automaticamente un nome della voce della cronologia di navigazione, in ordine di precedenza:  
  
-   L'allegato <xref:System.Windows.Navigation.JournalEntry.Name%2A> attributo.  
  
-   La proprietà <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   Il <xref:System.Windows.Controls.Page.WindowTitle%2A> proprietà e [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] per la pagina corrente  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] per la pagina corrente.  
  
 Se è stato associato un <xref:System.Windows.Navigation.CustomContentState> oggetto con una parte del contenuto nella cronologia di navigazione, è possibile specificare il valore del nome di un elemento della cronologia di navigazione eseguendo l'override <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il titolo di una finestra da una pagina.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowWidth { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la larghezza <see cref="T:System.Windows.Window" /> o <see cref="T:System.Windows.Navigation.NavigationWindow" /> dell'host di una classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>La larghezza di una finestra che ospita direttamente una classe <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A> viene applicato solo quando un <xref:System.Windows.Controls.Page> è ospitato direttamente da una finestra che include:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Se un <xref:System.Windows.Controls.Page> è ospitato da un <xref:System.Windows.Controls.Frame>, l'impostazione <xref:System.Windows.Controls.Page.WindowWidth%2A> non ha alcun effetto, ma è comunque possibile ottenere il valore di <xref:System.Windows.Controls.Page.WindowWidth%2A>.  
  
 Oggetto <xref:System.Windows.Controls.Page> in un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] possibile utilizzare solo <xref:System.Windows.Controls.Page.WindowWidth%2A> per modificare la larghezza di [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; la larghezza non può essere modificata impostando <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, o <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  
  
 La larghezza minima del [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] finestra è 250 pixel. Per le pagine ospitate da browser, ciò significa che il valore di <xref:System.Windows.Controls.Page.WindowWidth%2A> non possono essere applicate se quest ' operazione causerebbe la larghezza totale del [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] finestra meno di 250 pixel.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare la larghezza di una finestra da una pagina.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>