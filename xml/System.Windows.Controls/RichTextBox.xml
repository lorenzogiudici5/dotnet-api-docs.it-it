<Type Name="RichTextBox" FullName="System.Windows.Controls.RichTextBox">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8b07f5a6f84f8eb40c402bc37671fa961eb75220" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51910353" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Controls.Primitives.TextBoxBase, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi RichTextBox extends System.Windows.Controls.Primitives.TextBoxBase implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Controls::Primitives::TextBoxBase, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Inherit)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ContentProperty("Document")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un controllo rich edit che opera su oggetti <see cref="T:System.Windows.Documents.FlowDocument" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.FlowDocument> è l'unico elemento figlio supportato per un <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Controls.RichTextBox> supporta la gestione incorporata di bubbling <xref:System.Windows.UIElement.MouseUp> e <xref:System.Windows.UIElement.MouseDown> eventi.  Di conseguenza, i gestori eventi personalizzati che sono in attesa per `MouseUp` oppure `MouseDown` gli eventi da un <xref:System.Windows.Controls.RichTextBox> non verrà mai chiamato.  Se è necessario rispondere a tali eventi, in attesa per il tunneling <xref:System.Windows.UIElement.PreviewMouseUp> e <xref:System.Windows.UIElement.PreviewMouseDown> eventi invece o registrare i gestori con la <xref:System.Windows.EventSetter.HandledEventsToo%2A> argomento (questa seconda opzione è disponibile solo tramite il codice). Non contrassegnare l'evento come gestito, a meno che si desidera disabilitare intenzionalmente <xref:System.Windows.Controls.RichTextBox> nativa è possibile gestire questi eventi e tenere presente che ciò abbia effetti significativi sull'oggetto del controllo [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  
  
 Mentre <xref:System.Windows.Controls.RichTextBox> supporta la copia e Incolla di immagini, alcuni scenari non sono attualmente supportati e potrebbero non funzionare correttamente.  La tabella seguente riepiloga questi scenari e i risultati previsti.  
  
|Origine della copia immagine|Risultato Incolla immagine|  
|-----------------------|------------------------|  
|Origine dell'immagine è un metafile grafico|Nessuna immagine viene incollata|  
|Origine dell'immagine Usa percorso relativo o un collegamento|Immagine alterata o vuota viene incollata|  
|Collegamento all'origine immagine non termina con un formato di immagine prevista (. PNG. JPG. GIF)|Immagine alterata o vuota viene incollata|  
|Origine dell'immagine copiata dal corretto testo RTF (RTF)|Collegamento all'origine dell'immagine viene incollato, invece di immagine,|  
  
 Incollare il contenuto HTML in un <xref:System.Windows.Controls.RichTextBox> potrebbe produrre risultati imprevisti perché <xref:System.Windows.Controls.RichTextBox> utilizza il formato RTF anziché direttamente utilizzando il formato HTML.  
  
 Testo esegue sempre il wrapping in un <xref:System.Windows.Controls.RichTextBox>. Se non si desidera testo a capo, impostare il <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> nella <xref:System.Windows.Documents.FlowDocument> sia maggiore della larghezza del <xref:System.Windows.Controls.RichTextBox>. Tuttavia, quando viene raggiunta la larghezza della pagina di testo ancora esegue il wrapping.  
  
 L'allineamento orizzontale e verticale del contenuto all'interno di un <xref:System.Windows.Controls.RichTextBox> viene eseguita con il <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> e <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A> proprietà. Allineare le <xref:System.Windows.Controls.RichTextBox> all'interno del layout della pagina viene eseguita con il <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> e <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> proprietà.  
  
 Le barre di scorrimento non sono visibili in un <xref:System.Windows.Controls.RichTextBox> per impostazione predefinita. Per rendere visibile una barra di scorrimento, impostare il <xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility%2A> proprietà <xref:System.Windows.Controls.ScrollBarVisibility.Visible> o <xref:System.Windows.Controls.ScrollBarVisibility.Auto>.  
  
 In genere, il <xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged> evento deve essere usato per rilevare quando il testo in un <xref:System.Windows.Controls.TextBox> oppure <xref:System.Windows.Controls.RichTextBox> viene modificato, anziché <xref:System.Windows.UIElement.KeyDown> come è prevedibile. Per un esempio, vedere [procedura: rilevare quando il testo in una casella di testo è stato modificato](~/docs/framework/wpf/controls/how-to-detect-when-text-in-a-textbox-has-changed.md).  
  
 <xref:System.Windows.Controls.RichTextBox> supporta un'ampia gamma di comandi da tastiera. Per un elenco di comandi da tastiera, vedere <xref:System.Windows.Documents.EditingCommands>.  
  
 Le proprietà di dipendenza di questo controllo potrebbero essere impostate dallo stile predefinito del controllo.  Se una proprietà viene impostata da uno stile predefinito, la proprietà può variare rispetto al valore predefinito quando il controllo viene visualizzato nell'applicazione. Lo stile predefinito è determinato dal tema del desktop viene usato quando viene eseguita l'applicazione.  Per altre informazioni, vedere [temi WPF predefiniti](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 Nell'esempio seguente viene dichiarata una <xref:System.Windows.Controls.RichTextBox> che contiene una semplice <xref:System.Windows.Documents.FlowDocument>.  
  
 [!code-xaml[RichTextBoxSnippets#_RTB_XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml#_rtb_xaml)]  
  
 [!code-csharp[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/CSharp/RichTextBoxExample.cs#richtextboxcodeonlyexample)]
 [!code-vb[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/visualbasic/richtextboxexample.vb#richtextboxcodeonlyexample)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza predefinita della classe <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un oggetto vuoto <xref:System.Windows.Documents.FlowDocument> associato con la proprietà del documento.  In particolare, il controllo <xref:System.Windows.Documents.FlowDocument> vuoto contiene un solo <xref:System.Windows.Documents.Paragraph> che contiene un solo <xref:System.Windows.Documents.Run> che non contiene testo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox (System.Windows.Documents.FlowDocument document);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.FlowDocument document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor(System.Windows.Documents.FlowDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (document As FlowDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox(System::Windows::Documents::FlowDocument ^ document);" />
      <MemberSignature Language="F#" Value="new System.Windows.Controls.RichTextBox : System.Windows.Documents.FlowDocument -&gt; System.Windows.Controls.RichTextBox" Usage="new System.Windows.Controls.RichTextBox document" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="document" Type="System.Windows.Documents.FlowDocument" />
      </Parameters>
      <Docs>
        <param name="document">Un <see cref="T:System.Windows.Documents.FlowDocument" /> da aggiungere come contenuto iniziale del nuovo controllo <see cref="T:System.Windows.Controls.RichTextBox" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Controls.RichTextBox" /> aggiungendo un elemento <see cref="T:System.Windows.Documents.FlowDocument" /> specificato come contenuto iniziale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente illustra l'uso di questo costruttore.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_constructor)]
 [!code-vb[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_constructor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaretPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer CaretPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer CaretPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property CaretPosition As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ CaretPosition { System::Windows::Documents::TextPointer ^ get(); void set(System::Windows::Documents::TextPointer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CaretPosition : System.Windows.Documents.TextPointer with get, set" Usage="System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la posizione del cursore.</summary>
        <value>Un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che specifica la posizione del cursore.  
  
Per impostazione predefinita, il cursore è nella prima posizione di inserimento all'inizio del contenuto ospitato dal controllo <see cref="T:System.Windows.Controls.RichTextBox" />. Per ulteriori informazioni sulla terminologia della posizione di testo come ad esempio "posizione di inserimento", vedere <see cref="T:System.Windows.Documents.TextPointer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questa proprietà.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_caretposition)]
 [!code-vb[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_caretposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">È stato effettuato un tentativo di impostare la proprietà su <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Si è tentato di impostare questa proprietà su un <see cref="T:System.Windows.Documents.TextPointer" /> che fa riferimento a una posizione esterna del documento corrente.</exception>
        <altmember cref="T:System.Windows.Documents.TextPointer" />
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.FlowDocument Document { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.FlowDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Document" />
      <MemberSignature Language="VB.NET" Value="Public Property Document As FlowDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::FlowDocument ^ Document { System::Windows::Documents::FlowDocument ^ get(); void set(System::Windows::Documents::FlowDocument ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Documents.FlowDocument with get, set" Usage="System.Windows.Controls.RichTextBox.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.FlowDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Documents.FlowDocument" /> che rappresenta il contenuto del controllo <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Documents.FlowDocument" /> che rappresenta il contenuto del controllo <see cref="T:System.Windows.Controls.RichTextBox" />.  
  
Per impostazione predefinita, questa proprietà è impostata su un oggetto <see cref="T:System.Windows.Documents.FlowDocument" /> vuoto.  In particolare, il controllo <see cref="T:System.Windows.Documents.FlowDocument" /> vuoto contiene un solo <see cref="T:System.Windows.Documents.Paragraph" /> che contiene un solo <see cref="T:System.Windows.Documents.Run" /> che non contiene testo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un oggetto FlowDocument può essere ospitato da un singolo <xref:System.Windows.Controls.RichTextBox>.  Specifica di un oggetto FlowDocument singolo come il contenuto di più <xref:System.Windows.Controls.RichTextBox> controlli non è supportato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questa proprietà.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_document)]
 [!code-vb[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_document)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">È stato effettuato un tentativo di impostare la proprietà su <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Si è tentato di impostare questa proprietà su un oggetto <see cref="T:System.Windows.Documents.FlowDocument" /> che rappresenta il contenuto di un altro controllo <see cref="T:System.Windows.Controls.RichTextBox" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questa proprietà viene impostata quando un blocco di modifiche è stato attivato.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNextSpellingErrorPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextSpellingErrorPosition (System.Windows.Documents.TextPointer position, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextSpellingErrorPosition(class System.Windows.Documents.TextPointer position, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextSpellingErrorPosition (position As TextPointer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextSpellingErrorPosition(System::Windows::Documents::TextPointer ^ position, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextSpellingErrorPosition : System.Windows.Documents.TextPointer * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetNextSpellingErrorPosition (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="position">Un <see cref="T:System.Windows.Documents.TextPointer" /> che indica una posizione a partire dalla quale cercare il successivo errore di ortografia.</param>
        <param name="direction">Oggetto <see cref="T:System.Windows.Documents.LogicalDirection" /> nel quale cercare il successivo errore di ortografia, a partire dall'elemento <c>position</c> specificato.</param>
        <summary>Restituisce un <see cref="T:System.Windows.Documents.TextPointer" /> che punta al successivo errore di ortografia nel contenuto del controllo <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Un <see cref="T:System.Windows.Documents.TextPointer" /> che punta al successivo errore di ortografia nel contenuto del <see cref="T:System.Windows.Controls.RichTextBox" />, o <see langword="null" /> se non esiste alcun errore di ortografia.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetPositionFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberSignature Language="F#" Value="member this.GetPositionFromPoint : System.Windows.Point * bool -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetPositionFromPoint (point, snapToText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Un oggetto <see cref="T:System.Windows.Point" /> che specifica la posizione per la quale recuperare un <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <param name="snapToText">Se <see langword="true" />, questo metodo restituisce sempre un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che specifica la posizione di inserimento più vicina per l'oggetto <see cref="T:System.Windows.Point" /> specificato, indipendentemente dal fatto che all'interno del riquadro delimitatore del testo di un carattere sia presente o meno l'oggetto <see cref="T:System.Windows.Point" /> fornito.  
  
Se <see langword="false" />, questo metodo restituisce <see langword="null" /> se l'oggetto <see cref="T:System.Windows.Point" /> specificato non è compreso all'interno del riquadro delimitatore del testo.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che punta al punto di inserimento più vicino alla posizione specificata.</summary>
        <returns>Un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che specifica la posizione di inserimento più vicina per il punto fornito, o <see langword="null" /> se <paramref name="snapToText" /> è <see langword="false" /> e l'oggetto fornito <see cref="T:System.Windows.Point" /> non si trova all'interno del riquadro delimitatore del testo. Si noti che l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> restituito rappresenta in genere la posizione tra due caratteri. Utilizzare la proprietà <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> dell'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> restituito per determinare a quale dei due caratteri corrisponde l'oggetto <see cref="T:System.Windows.Documents.TextPointer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox> utilizza un sistema di coordinate standard con l'origine che si trova nell'angolo superiore sinistro del <xref:System.Windows.Controls.RichTextBox>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Viene generato se le informazioni sul layout per il controllo <see cref="T:System.Windows.Controls.RichTextBox" /> non sono correnti.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSpellingError">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.SpellingError GetSpellingError (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Controls.SpellingError GetSpellingError(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingError (position As TextPointer) As SpellingError" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Controls::SpellingError ^ GetSpellingError(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingError : System.Windows.Documents.TextPointer -&gt; System.Windows.Controls.SpellingError" Usage="richTextBox.GetSpellingError position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.SpellingError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">
          <see cref="T:System.Windows.Documents.TextPointer" /> che specifica una posizione e una direzione logica che risolve un carattere da esaminare per verificare la presenza di un errore di ortografia. Usare la proprietà <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> di <see cref="T:System.Windows.Documents.TextPointer" /> per specificare la direzione del carattere da esaminare.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Controls.SpellingError" /> associato a un errore di ortografia in una posizione specificata nei contenuti di <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Controls.SpellingError" /> che contiene i dettagli dell'errore di ortografia trovato in corrispondenza del carattere indicato da <paramref name="position" /> oppure <see langword="null" /> se non ci sono errori di ortografia in corrispondenza del carattere specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Documents.TextPointer> , ad esempio `position` in genere specifica una posizione tra due caratteri. Usare la <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> proprietà di `position` per specificare il carattere da esaminare.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetSpellingErrorRange">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextRange GetSpellingErrorRange (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextRange GetSpellingErrorRange(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingErrorRange (position As TextPointer) As TextRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextRange ^ GetSpellingErrorRange(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingErrorRange : System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.TextRange" Usage="richTextBox.GetSpellingErrorRange position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">
          <see cref="T:System.Windows.Documents.TextPointer" /> che specifica una posizione e una direzione logica che risolve un carattere da esaminare per verificare la presenza di un errore di ortografia. Usare la proprietà <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> di <see cref="T:System.Windows.Documents.TextPointer" /> per specificare la direzione del carattere da esaminare.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextRange" /> che analizza eventuali parole digitate in modo non corretto in una posizione specificata nel contenuto del <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Un oggetto <see cref="T:System.Windows.Documents.TextRange" /> che analizza eventuali parole digitate in modo non corretto compreso il carattere specificato dalla <paramref name="position" /> oppure <see langword="null" /> se non esiste alcun errore di ortografia nel carattere specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Documents.TextPointer> , ad esempio `position` in genere specifica una posizione tra due caratteri. Usare la <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> proprietà di `position` per specificare il carattere da esaminare.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabled">
      <MemberSignature Language="C#" Value="public bool IsDocumentEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDocumentEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsDocumentEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDocumentEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsDocumentEnabled : bool with get, set" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l’utente può interagire con gli oggetti <see cref="T:System.Windows.UIElement" /> e <see cref="T:System.Windows.ContentElement" /> contenuti in un oggetto <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value>
          <see langword="true" /> se l’utente può interagire con gli oggetti <see cref="T:System.Windows.UIElement" /> e <see cref="T:System.Windows.ContentElement" /> contenuti in <see cref="T:System.Windows.Controls.RichTextBox" />; altrimenti, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A> è stato introdotto in .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene creato <xref:System.Windows.Controls.CheckBox> e una <xref:System.Windows.Controls.RichTextBox> che contiene un <xref:System.Windows.Documents.Hyperlink> e un <xref:System.Windows.Controls.Button>.  Il <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A> proprietà del <xref:System.Windows.Controls.RichTextBox> è associato ai <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> proprietà del <xref:System.Windows.Controls.CheckBox>.  Quando l'utente seleziona il <xref:System.Windows.Controls.CheckBox>, l'utente può interagire con il <xref:System.Windows.Controls.Button> e <xref:System.Windows.Documents.Hyperlink>. Quando l'utente cancella il <xref:System.Windows.Controls.CheckBox>, il <xref:System.Windows.Controls.Button> e <xref:System.Windows.Documents.Hyperlink> sono disabilitati.  
  
 [!code-xaml[RTBIsDocumentEnabled#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RTBIsDocumentEnabled/VB/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsDocumentEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsDocumentEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsDocumentEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsDocumentEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsDocumentEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un enumeratore in grado di scorrere gli oggetti figlio logici di <see langword="RichTextBox" />.</summary>
        <value>Enumeratore per i figli logici.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="richTextBox.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Una struttura <see cref="T:System.Windows.Size" /> che specifica i vincoli sulla dimensione del controllo <see cref="T:System.Windows.Controls.RichTextBox" />.</param>
        <summary>Chiamato per misurare nuovamente <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Una struttura <see cref="T:System.Windows.Size" /> che indica la nuova dimensione di <see cref="T:System.Windows.Controls.RichTextBox" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.Windows.Controls.Control.MeasureOverride%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="richTextBox.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea e restituisce un oggetto <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> per questo <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> per questo <see cref="T:System.Windows.Controls.RichTextBox" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override di <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpiScaleInfo, System.Windows.DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpiScaleInfo, valuetype System.Windows.DpiScale newDpiScaleInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpiScaleInfo As DpiScale, newDpiScaleInfo As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpiScaleInfo, System::Windows::DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="richTextBox.OnDpiChanged (oldDpiScaleInfo, newDpiScaleInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpiScaleInfo" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpiScaleInfo" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpiScaleInfo">Impostazione precedente della scala DPI.</param>
        <param name="newDpiScaleInfo">Nuova impostazione della scala DPI.</param>
        <summary>Chiamato in caso di variazione del valore DPI usato per il rendering della casella di testo con formattazione.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Selection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextSelection Selection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextSelection Selection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Selection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Selection As TextSelection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextSelection ^ Selection { System::Windows::Documents::TextSelection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Selection : System.Windows.Documents.TextSelection" Usage="System.Windows.Controls.RichTextBox.Selection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextSelection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Windows.Documents.TextSelection" /> che contiene la selezione corrente nel controllo <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Documents.TextSelection" /> che contiene la selezione corrente nel controllo <see cref="T:System.Windows.Controls.RichTextBox" />.  
  
L'oggetto predefinito restituito <see cref="T:System.Windows.Documents.TextSelection" /> ha un valore della proprietà <see cref="P:System.Windows.Documents.TextRange.IsEmpty" /> uguale a <see langword="True" />. Nell'area di testo senza selezione, un <see cref="T:System.Windows.Documents.TextSelection" /> vuoto viene rappresentato come un cursore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Windows.Documents.TextRange.Select%2A> metodo a livello di codice selezionare il contenuto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questa proprietà.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_selection)]
 [!code-vb[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_selection)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeDocument">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeDocument() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.ShouldSerializeDocument" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeDocument () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeDocument();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeDocument : unit -&gt; bool" Usage="richTextBox.ShouldSerializeDocument " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un valore che indica se il valore effettivo della proprietà <see cref="P:System.Windows.Controls.RichTextBox.Document" /> deve essere serializzato o meno durante la serializzazione di un oggetto <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>
          <see langword="true" /> se la proprietà <see cref="P:System.Windows.Controls.RichTextBox.Document" /> deve essere serializzata; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da aggiungere come elemento figlio.</param>
        <summary>Questo tipo o membro supporta l'infrastruttura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e non deve essere usato direttamente dal codice.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Stringa da aggiungere all'oggetto.</param>
        <summary>Questo tipo o membro supporta l'infrastruttura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e non deve essere usato direttamente dal codice.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>