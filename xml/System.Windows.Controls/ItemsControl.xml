<Type Name="ItemsControl" FullName="System.Windows.Controls.ItemsControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2b61f4268f7a9ad6b9d230eaeb5912890d4a2fff" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36566285" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ItemsControl : System.Windows.Controls.Control, System.Windows.Controls.Primitives.IContainItemStorage, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ItemsControl extends System.Windows.Controls.Control implements class System.Windows.Controls.Primitives.IContainItemStorage, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ItemsControl" />
  <TypeSignature Language="VB.NET" Value="Public Class ItemsControl&#xA;Inherits Control&#xA;Implements IAddChild, IContainItemStorage" />
  <TypeSignature Language="C++ CLI" Value="public ref class ItemsControl : System::Windows::Controls::Control, System::Windows::Controls::Primitives::IContainItemStorage, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type ItemsControl = class&#xA;    inherit Control&#xA;    interface IAddChild&#xA;    interface IContainItemStorage" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Controls.Primitives.IContainItemStorage</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("OnItemsChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Items")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Items")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="ItemContainerStyle", StyleTargetType=typeof(System.Windows.FrameworkElement))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a control that can be used to present a collection of items.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un' <xref:System.Windows.Controls.ItemsControl> è un tipo di <xref:System.Windows.Controls.Control> che può contenere più elementi, ad esempio stringhe, oggetti o altri elementi. La figura seguente mostra un <xref:System.Windows.Controls.ListBox> controllo che contiene i tipi diversi di elementi seguenti:  
  
-   Una stringa.  
  
-   Oggetto <xref:System.DateTime>.  
  
-   Oggetto <xref:System.Windows.UIElement>.  
  
-   Un <xref:System.Windows.Controls.Panel> controllo contenente un' <xref:System.Windows.Shapes.Ellipse> e un <xref:System.Windows.Controls.TextBlock>.  
  
 ![ListBox con quattro tipi di contenuto](~/add/media/controlcontentmodellistbox2.PNG "ListBox con quattro tipi di contenuto")  
ListBox con più tipi di oggetti  
  
 Utilizzare la <xref:System.Windows.Controls.ItemsControl.Items%2A> o il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> proprietà per specificare la raccolta da utilizzare per generare il contenuto del <xref:System.Windows.Controls.ItemsControl>. È possibile impostare il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> proprietà di qualsiasi tipo che implementa <xref:System.Collections.IEnumerable>. <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> è in genere utilizzata per visualizzare una raccolta di dati o per associare un <xref:System.Windows.Controls.ItemsControl> a un oggetto raccolta.  
  
 Se non si desidera utilizzare un oggetto che implementa <xref:System.Collections.IEnumerable> per popolare il <xref:System.Windows.Controls.ItemsControl>, è possibile aggiungere elementi utilizzando il <xref:System.Windows.Controls.ItemsControl.Items%2A> proprietà. Gli elementi in un <xref:System.Windows.Controls.ItemsControl> può contenere tipi differenti. Ad esempio, un <xref:System.Windows.Controls.ListBox> può contenere un unico elemento che è una stringa e un altro elemento che è un <xref:System.Windows.Controls.Image>.  
  
 Quando il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> è impostata, il <xref:System.Windows.Controls.ItemsControl.Items%2A> set di raccolta di sola lettura e di dimensioni fisse. Ciò significa che non è possibile aggiungere elementi alla raccolta direttamente. Quando si <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> è in uso, impostare la proprietà `null` rimuove la raccolta e di ripristinare l'utilizzo di <xref:System.Windows.Controls.ItemsControl.Items%2A>, che sarà vuota <xref:System.Windows.Controls.ItemCollection>.  
  
 Ogni <xref:System.Windows.Controls.ItemsControl> tipo ha un tipo di elemento contenitore corrispondente. Contenitore di elementi corrispondenti per ciascuno <xref:System.Windows.Controls.ItemsControl> Accoda `Item` al relativo nome. Ad esempio, per <xref:System.Windows.Controls.ListBox>, i contenitori vengono <xref:System.Windows.Controls.ListBoxItem> controlli; per <xref:System.Windows.Controls.ComboBox>, sono <xref:System.Windows.Controls.ComboBoxItem> controlli. È possibile creare in modo esplicito un tipo di contenitore per ogni elemento nella <xref:System.Windows.Controls.ItemsControl>, ma non è necessario. Quando non si crea in modo esplicito il tipo di contenitore, uno viene generato che contiene un elemento di dati nella raccolta di elementi. Ad esempio, se si associa una raccolta di oggetti stringa per il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> proprietà di un <xref:System.Windows.Controls.ListBox>, non si crea in modo esplicito <xref:System.Windows.Controls.ListBoxItem> oggetti, ma la <xref:System.Windows.Controls.ListBox> genererà uno per ogni stringa. È possibile accedere a un contenitore di elementi generati tramite il <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> proprietà.  
  
> [!NOTE]
>  Alcune funzionalità di automazione interfaccia utente non funzionano correttamente quando un <xref:System.Windows.Controls.ItemsControl> contiene oggetti duplicati.   Se un oggetto viene visualizzato più volte, solo la prima istanza verrà visualizzato nell'albero di automazione.   (Due oggetti **x** e **y** sono considerati duplicati se `Object.Equals(x, y)` restituisce `true`.)  
>   
>  Mentre un oggetto **x** è in uso da un <xref:System.Windows.Controls.ItemsControl> il valore restituito da **x.**`GetHashCode()` non deve essere modificato.  Le modifiche a questo valore sono non supportato e causare un comportamento imprevedibile.  
  
 Proprietà di dipendenza per questo controllo potrebbe essere impostata dallo stile predefinito del controllo. Se una proprietà viene impostata da uno stile predefinito, la proprietà può variare rispetto al valore predefinito quando il controllo viene visualizzato nell'applicazione. Lo stile predefinito è determinato dal tema del desktop viene utilizzato quando l'applicazione è in esecuzione. Per altre informazioni, vedere [temi WPF predefiniti](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 Gli esempi seguenti illustrano il data binding a un <xref:System.Windows.Controls.ItemsControl>. Nel primo esempio viene creata una classe denominata `MyData` vale a dire una semplice raccolta di stringhe.  
  
 [!code-csharp[ControlContentOverviewSnippets#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#8)]
 [!code-vb[ControlContentOverviewSnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#8)]  
  
 Nell'esempio seguente viene associato il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> oggetto di un <xref:System.Windows.Controls.ItemsControl> a `MyData`.  
  
 [!code-xaml[ControlContentOverviewSnippets#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#7)]  
[!code-xaml[ControlContentOverviewSnippets#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#6)]  
  
 [!code-csharp[ControlContentOverviewSnippets#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#9)]
 [!code-vb[ControlContentOverviewSnippets#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#9)]  
  
 La figura seguente mostra il <xref:System.Windows.Controls.ListBox> controllo creato nell'esempio precedente.  
  
 ![ListBox](~/add/media/controlcontentmodellistbox1.PNG "ListBox")  
  
 Nell'esempio seguente viene illustrato come compilare un <xref:System.Windows.Controls.ItemsControl> utilizzando il <xref:System.Windows.Controls.ItemsControl.Items%2A> proprietà. L'esempio aggiunge i seguenti tipi diversi di elementi per il <xref:System.Windows.Controls.ListBox>:  
  
-   Una stringa.  
  
-   Oggetto <xref:System.DateTime>.  
  
-   Oggetto <xref:System.Windows.UIElement>.  
  
-   Un <xref:System.Windows.Controls.Panel> controllo che contiene altri <xref:System.Windows.UIElement> oggetti.  
  
 [!code-xaml[ControlContentOverviewSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#3)]  
  
 [!code-csharp[ControlContentOverviewSnippets#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#4)]
 [!code-vb[ControlContentOverviewSnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#4)]  
  
 La figura seguente mostra il <xref:System.Windows.Controls.ListBox> creato nell'esempio precedente.  
  
 ![ListBox con quattro tipi di contenuto](~/add/media/controlcontentmodellistbox2.PNG "ListBox con quattro tipi di contenuto")  
  
 Nell'esempio seguente viene illustrato come utilizzare i diversi stili e le proprietà correlate ai modelli forniti dal <xref:System.Windows.Controls.ItemsControl>. Il <xref:System.Windows.Controls.ItemsControl> in questo esempio viene associato a una raccolta di `Task` oggetti. A scopo dimostrativo, gli stili e i modelli in questo esempio sono tutti dichiarati incorporati.  
  
 [!code-xaml[DataTemplatingIntro_snip#ItemsControlProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#itemscontrolproperties)]  
  
 Nella figura seguente viene riportata una schermata dell'esempio, quando ne viene eseguito il rendering.  
  
 ![Schermata di esempio ItemsControl](~/add/media/databinding-itemscontrolproperties.png "schermata di esempio ItemsControl")  
  
 Due altre proprietà correlate allo stile del <xref:System.Windows.Controls.ItemsControl> che non vengono visualizzate di seguito sono riportate <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> e <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.ItemCollection" />
    <altmember cref="T:System.Windows.Controls.ItemContainerGenerator" />
    <altmember cref="T:System.Windows.Controls.ItemsPresenter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ItemsControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ItemsControl();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Controls.ItemsControl" /> class.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="AddChild">
      <MemberSignature Language="C#" Value="protected virtual void AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddChild (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddChild(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member AddChild : obj -&gt; unit&#xA;override this.AddChild : obj -&gt; unit" Usage="itemsControl.AddChild value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to add as a child.</param>
        <summary>Adds the specified object as the child of the <see cref="T:System.Windows.Controls.ItemsControl" /> object.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddText">
      <MemberSignature Language="C#" Value="protected virtual void AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddText (text As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddText(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member AddText : string -&gt; unit&#xA;override this.AddText : string -&gt; unit" Usage="itemsControl.AddText text" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">The string to add.</param>
        <summary>Adds the specified text string to the <see cref="T:System.Windows.Controls.ItemsControl" /> object.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationCount">
      <MemberSignature Language="C#" Value="public int AlternationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AlternationCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.AlternationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property AlternationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AlternationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AlternationCount : int with get, set" Usage="System.Windows.Controls.ItemsControl.AlternationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of alternating item containers in the <see cref="T:System.Windows.Controls.ItemsControl" />, which enables alternating containers to have a unique appearance.</summary>
        <value>Numero di contenitori di elementi alternativi in <see cref="T:System.Windows.Controls.ItemsControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> e <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> proprietà consentono di specificare l'aspetto per due o più contenitori di elementi alternativi. Ad esempio, è possibile specificare i colori di sfondo alternativi per ogni elemento nella terza un <xref:System.Windows.Controls.ItemsControl>.  Il <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> viene assegnato a ogni contenitore di elementi nel <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> inizia da 0, con incrementi fino a quando non è <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> meno 1 e quindi viene riavviato da 0. Ad esempio, se <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> è 3 e sono disponibili sette elementi nel <xref:System.Windows.Controls.ItemsControl>, la tabella seguente elenca i <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> per ogni elemento.  
  
|Posizione dell'elemento di <xref:System.Windows.Controls.ItemsControl>|<xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|1|0|  
|2|1|  
|3|2|  
|4|0|  
|5|1|  
|6|2|  
|7|0|  
  
 Esistono diversi metodi che è possibile utilizzare per specificare aspetti diversi per i contenitori di elementi alternativi. Un metodo consiste nell'associare le proprietà del contenitore di elementi per il <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>. È quindi possibile utilizzare un <xref:System.Windows.Controls.AlternationConverter> per specificare quale valore deve essere applicato al contenitore di elementi che dispone di un determinato <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> valore. È anche possibile utilizzare i trigger per modificare il valore della proprietà di un contenitore di elementi in base al valore relativo <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente specifica che il <xref:System.Windows.Controls.ListBox> (che eredita dalla classe <xref:System.Windows.Controls.ItemsControl>) dispone di contenitori di elementi alternativi (che sono di tipo <xref:System.Windows.Controls.ListBoxItem>) e specifica un piano per ciascuna di esse e sfondo diversi.  Nell'esempio viene associato il <xref:System.Windows.Controls.Control.Background%2A> e <xref:System.Windows.Controls.Control.Foreground%2A> delle proprietà per il <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> e fornisce un <xref:System.Windows.Controls.AlternationConverter> per ogni proprietà.  
  
 [!code-xaml[AlternationIndexSnippets#2](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#2)]  
  
 L'esempio seguente è uguale all'esempio precedente utilizzando <xref:System.Windows.Trigger> oggetti.  
  
 [!code-xaml[AlternationIndexSnippets#1](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationCountProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AlternationCountProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AlternationCountProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.AlternationCountProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AlternationCountProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AlternationCountProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AlternationCountProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.AlternationCountProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationIndex">
      <MemberSignature Language="C#" Value="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberSignature Language="ILAsm" Value="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.AlternationIndex" />
      <MemberSignature Language="VB.NET" Value="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberSignature Language="F#" Value="see GetAlternationIndex, and SetAlternationIndex" Usage="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AlternationIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AlternationIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.AlternationIndexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AlternationIndexProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AlternationIndexProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AlternationIndexProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.AlternationIndexProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public override void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void BeginInit();" />
      <MemberSignature Language="F#" Value="override this.BeginInit : unit -&gt; unit" Usage="itemsControl.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the initialization of the <see cref="T:System.Windows.Controls.ItemsControl" /> object is about to start.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="ClearContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual void ClearContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ClearContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member ClearContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit&#xA;override this.ClearContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="itemsControl.ClearContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">The container element.</param>
        <param name="item">The item.</param>
        <summary>When overridden in a derived class, undoes the effects of the <see cref="M:System.Windows.Controls.ItemsControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" /> method.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione di base non esegue alcuna operazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ContainerFromElement">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the container that belongs to the current <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given container element.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContainerFromElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject ContainerFromElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject ContainerFromElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ContainerFromElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainerFromElement (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ ContainerFromElement(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="member this.ContainerFromElement : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="itemsControl.ContainerFromElement element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The element to return the container for.</param>
        <summary>Returns the container that belongs to the current <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given element.</summary>
        <returns>The container that belongs to the current <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given element or <see langword="null" /> if no such container exists.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="ContainerFromElement">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject ContainerFromElement (System.Windows.Controls.ItemsControl itemsControl, System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject ContainerFromElement(class System.Windows.Controls.ItemsControl itemsControl, class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ContainerFromElement(System.Windows.Controls.ItemsControl,System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ ContainerFromElement(System::Windows::Controls::ItemsControl ^ itemsControl, System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member ContainerFromElement : System.Windows.Controls.ItemsControl * System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Controls.ItemsControl.ContainerFromElement (itemsControl, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemsControl" Type="System.Windows.Controls.ItemsControl" />
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="itemsControl">The <see cref="T:System.Windows.Controls.ItemsControl" /> to return the container for.</param>
        <param name="element">The element to return the container for.</param>
        <summary>Returns the container that belongs to the specified <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given container element.</summary>
        <returns>The container that belongs to the specified <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given element, if <paramref name="itemsControl" /> is not <see langword="null" />. If <paramref name="itemsControl" /> is <see langword="null" />, returns the closest container that belongs to any <see cref="T:System.Windows.Controls.ItemsControl" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMemberPath">
      <MemberSignature Language="C#" Value="public string DisplayMemberPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayMemberPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayMemberPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayMemberPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMemberPath : string with get, set" Usage="System.Windows.Controls.ItemsControl.DisplayMemberPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a path to a value on the source object to serve as the visual representation of the object.</summary>
        <value>Percorso di un valore nell'oggetto di origine. Può trattarsi di qualsiasi percorso o una query XPath, ad esempio "@Name". Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è un modo semplice per definire un modello predefinito che viene descritto come visualizzare gli oggetti dati.  
  
<a name="dependencyPropertyInfo_DisplayMemberPath"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.DisplayMemberPathProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente, la risorsa statica denominata `places` è definito come una raccolta di `Place` oggetti, in cui ogni `Place` oggetto dispone di una `CityName` proprietà e un `State` proprietà. Il prefisso `src` viene eseguito il mapping allo spazio dei nomi in cui l'origine dati `Places` è definito. I prefissi `scm` e `dat` viene eseguito il mapping per il <xref:System.ComponentModel> e <xref:System.Windows.Data> gli spazi dei nomi, rispettivamente.  
  
 Nell'esempio seguente crea una visualizzazione della raccolta di dati ordinati in base al nome della città e raggruppata per stato.  
  
 [!code-xaml[CollectionViewSource#1](~/samples/snippets/csharp/VS_Snippets_Wpf/CollectionViewSource/CS/window1.xaml#1)]  
  
 La vista può essere un'origine di associazione, come nell'esempio seguente. A causa di specificato <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A>, ognuna`Place` oggetto viene visualizzato con il relativo `CityName` valore. Se <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A> non è specificato ed è presente alcun <xref:System.Windows.DataTemplate>, quindi il <xref:System.Windows.Controls.ListBox> Visualizza una rappresentazione di stringa di ogni oggetto nella raccolta sottostante (in questo caso, "SDKSample").  
  
 [!code-xaml[CollectionViewSource#2](~/samples/snippets/csharp/VS_Snippets_Wpf/CollectionViewSource/CS/window1.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMemberPathProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DisplayMemberPathProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DisplayMemberPathProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.DisplayMemberPathProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DisplayMemberPathProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DisplayMemberPathProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DisplayMemberPathProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.DisplayMemberPathProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public override void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndInit();" />
      <MemberSignature Language="F#" Value="override this.EndInit : unit -&gt; unit" Usage="itemsControl.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the initialization of the <see cref="T:System.Windows.Controls.ItemsControl" /> object is complete.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAlternationIndex">
      <MemberSignature Language="C#" Value="public static int GetAlternationIndex (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetAlternationIndex(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetAlternationIndex(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAlternationIndex (element As DependencyObject) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetAlternationIndex(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetAlternationIndex : System.Windows.DependencyObject -&gt; int" Usage="System.Windows.Controls.ItemsControl.GetAlternationIndex element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The object from which to get the <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" />.</param>
        <summary>Gets the <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" /> for the specified object.</summary>
        <returns>The value of the <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.DependencyObject GetContainerForItemOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.DependencyObject GetContainerForItemOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetContainerForItemOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContainerForItemOverride () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::DependencyObject ^ GetContainerForItemOverride();" />
      <MemberSignature Language="F#" Value="abstract member GetContainerForItemOverride : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetContainerForItemOverride : unit -&gt; System.Windows.DependencyObject" Usage="itemsControl.GetContainerForItemOverride " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates or identifies the element that is used to display the given item.</summary>
        <returns>The element that is used to display the given item.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="GetItemsOwner">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ItemsControl GetItemsOwner (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Controls.ItemsControl GetItemsOwner(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetItemsOwner(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetItemsOwner (element As DependencyObject) As ItemsControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ItemsControl ^ GetItemsOwner(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetItemsOwner : System.Windows.DependencyObject -&gt; System.Windows.Controls.ItemsControl" Usage="System.Windows.Controls.ItemsControl.GetItemsOwner element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsControl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The host element.</param>
        <summary>Returns the <see cref="T:System.Windows.Controls.ItemsControl" /> that the specified element hosts items for.</summary>
        <returns>The <see cref="T:System.Windows.Controls.ItemsControl" /> that the specified element hosts items for, or <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Windows.Controls.Panel.IsItemsHost%2A> è impostata su `true` sul `element` in uno stile o se `element` è un pannello creato dal <xref:System.Windows.Controls.ItemsPresenter> per un <xref:System.Windows.Controls.ItemsControl>, il <xref:System.Windows.Controls.ItemsControl> sia restituito; in caso contrario, `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupStyle">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt; GroupStyle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;class System.Windows.Controls.GroupStyle&gt; GroupStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.GroupStyle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GroupStyle As ObservableCollection(Of GroupStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ObservableCollection&lt;System::Windows::Controls::GroupStyle ^&gt; ^ GroupStyle { System::Collections::ObjectModel::ObservableCollection&lt;System::Windows::Controls::GroupStyle ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupStyle : System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt;" Usage="System.Windows.Controls.ItemsControl.GroupStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of <see cref="T:System.Windows.Controls.GroupStyle" /> objects that define the appearance of each level of groups.</summary>
        <value>Una raccolta di <see cref="T:System.Windows.Controls.GroupStyle" /> gli oggetti che definiscono l'aspetto di ogni livello di gruppi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La voce in corrispondenza dell'indice 0 descrive i gruppi di livello superiore, la voce in corrispondenza dell'indice 1 descrive successivo livello, e così via. Se sono presenti più livelli di raggruppamento rispetto alle voci nella raccolta, l'ultima voce viene utilizzato per i livelli aggiuntivi.  
  
<a name="xamlPropertyElementUsage_GroupStyle"></a>   
## <a name="xaml-property-element-usage"></a>Utilizzo della sintassi XAML per elementi proprietà  
  
```  
<object>  
  <object.GroupStyle>  
    OneOrMoreGroupStyleObjects  
  </object.GroupStyle>  
</object>  
  
```  
  
<a name="xamlValues_GroupStyle"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *OneOrMoreGroupStyleObjects*  
 Uno o più <xref:System.Windows.Controls.GroupStyle> oggetti.  
  
   
  
## Examples  
 Gli esempi seguenti illustrano un <xref:System.Windows.Controls.ItemsControl> associato a un <xref:System.Windows.Data.XmlDataProvider> e il contenuto di code-behind che contiene la logica per aggiungere e rimuovere il raggruppamento. Quando la casella di controllo è selezionata, il contenuto del <xref:System.Windows.Controls.ItemsControl> viene raggruppato il `Type` attributo.  
  
 Ogni gruppo è di tipo <xref:System.Windows.Data.CollectionViewGroup>. Il <xref:System.Windows.Controls.GroupStyle> <xref:System.Windows.Controls.GroupStyle.HeaderTemplate%2A> è specificato in modo che venga visualizzato come un <xref:System.Windows.Controls.TextBlock> che consente di visualizzare il <xref:System.Windows.Data.CollectionViewGroup.Name%2A> di ogni gruppo. In questo caso, il <xref:System.Windows.Data.CollectionViewGroup.Name%2A> può essere `Work` o `Home`.  
  
 [!code-xaml[GroupingSample#XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml#xaml)]  
  
 [!code-csharp[GroupingSample#Code](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#code)]
 [!code-vb[GroupingSample#Code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#code)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      </Docs>
    </Member>
    <Member MemberName="GroupStyleSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.GroupStyleSelector GroupStyleSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.GroupStyleSelector GroupStyleSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property GroupStyleSelector As GroupStyleSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::GroupStyleSelector ^ GroupStyleSelector { System::Windows::Controls::GroupStyleSelector ^ get(); void set(System::Windows::Controls::GroupStyleSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.GroupStyleSelector : System.Windows.Controls.GroupStyleSelector with get, set" Usage="System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.GroupStyleSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a method that enables you to provide custom selection logic for a <see cref="T:System.Windows.Controls.GroupStyle" /> to apply to each group in a collection.</summary>
        <value>Un metodo che consente di specificare la logica di selezione personalizzata per un <see cref="T:System.Windows.Controls.GroupStyle" /> da applicare a ogni gruppo in una raccolta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_GroupStyleSelector"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.PropertyGroupDescription" />
      </Docs>
    </Member>
    <Member MemberName="GroupStyleSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty GroupStyleSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty GroupStyleSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GroupStyleSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ GroupStyleSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable GroupStyleSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasItems">
      <MemberSignature Language="C#" Value="public bool HasItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.HasItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasItems As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasItems { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasItems : bool" Usage="System.Windows.Controls.ItemsControl.HasItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Windows.Controls.ItemsControl" /> contains items.</summary>
        <value>
          <see langword="true" /> se il conteggio degli elementi è maggiore di 0; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_HasItems"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.HasItemsProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasItemsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HasItemsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HasItemsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.HasItemsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HasItemsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HasItemsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HasItemsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.HasItemsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.HasItems" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGrouping">
      <MemberSignature Language="C#" Value="public bool IsGrouping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGrouping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsGrouping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGrouping As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGrouping { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGrouping : bool" Usage="System.Windows.Controls.ItemsControl.IsGrouping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the control is using grouping.</summary>
        <value>
          <see langword="true" /> Se un controllo Usa il raggruppamento. in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsGrouping"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.IsGroupingProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGroupingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsGroupingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsGroupingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsGroupingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsGroupingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsGroupingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsGroupingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsGroupingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.IsGrouping" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsItemItsOwnContainer">
      <MemberSignature Language="C#" Value="public bool IsItemItsOwnContainer (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsItemItsOwnContainer(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.IsItemItsOwnContainer(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsItemItsOwnContainer (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsItemItsOwnContainer(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="member this.IsItemItsOwnContainer : obj -&gt; bool" Usage="itemsControl.IsItemItsOwnContainer item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.Controls.IGeneratorHost.IsItemItsOwnContainer(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The item to check.</param>
        <summary>Determines if the specified item is (or is eligible to be) its own container.</summary>
        <returns>
          <see langword="true" /> if the item is (or is eligible to be) its own container; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il metodo <xref:System.Windows.Controls.ItemsControl.IsItemItsOwnContainerOverride%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsItemItsOwnContainerOverride">
      <MemberSignature Language="C#" Value="protected virtual bool IsItemItsOwnContainerOverride (object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsItemItsOwnContainerOverride(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.IsItemItsOwnContainerOverride(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsItemItsOwnContainerOverride (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsItemItsOwnContainerOverride(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member IsItemItsOwnContainerOverride : obj -&gt; bool&#xA;override this.IsItemItsOwnContainerOverride : obj -&gt; bool" Usage="itemsControl.IsItemItsOwnContainerOverride item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The item to check.</param>
        <summary>Determines if the specified item is (or is eligible to be) its own container.</summary>
        <returns>
          <see langword="true" /> if the item is (or is eligible to be) its own container; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchCaseSensitive">
      <MemberSignature Language="C#" Value="public bool IsTextSearchCaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTextSearchCaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTextSearchCaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTextSearchCaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTextSearchCaseSensitive : bool with get, set" Usage="System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether case is a condition when searching for items.</summary>
        <value>
          <see langword="true" /> Se nelle ricerche di testo viene distinzione maiuscole/minuscole; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Windows.Controls.ItemsControl.IsTextSearchEnabled%2A> è impostata su `true`, la <xref:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive%2A> proprietà specifica se il case determina se un elemento è selezionato un <xref:System.Windows.Controls.ItemsControl>. Ad esempio, se un <xref:System.Windows.Controls.ItemsControl> contiene due stringhe che differiscono solo nel caso in cui, ad esempio "ITEM" e "item", la prima stringa verrà sempre selezionata, indipendentemente dalla situazione dell'input.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Windows.Controls.ComboBox> che contiene le stringhe, "DOG", "CAT", "dog" e "cat". Nell'esempio viene associato il <xref:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive%2A> proprietà per il <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> proprietà di un <xref:System.Windows.Controls.CheckBox>. Se la casella di controllo è selezionata e l'utente digita "dog", il terzo elemento nel <xref:System.Windows.Controls.ItemsControl> sia selezionata. Se l'utente, viene deselezionata la casella di controllo e i tipi "dog", viene selezionato il primo elemento perché il caso non è una condizione della ricerca.  
  
 [!code-xaml[ComboBoxProps_snip#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxProps_snip/CS/pane1.xaml#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchCaseSensitiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTextSearchCaseSensitiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTextSearchCaseSensitiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTextSearchCaseSensitiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTextSearchCaseSensitiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsTextSearchCaseSensitiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchEnabled">
      <MemberSignature Language="C#" Value="public bool IsTextSearchEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTextSearchEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsTextSearchEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTextSearchEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTextSearchEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTextSearchEnabled : bool with get, set" Usage="System.Windows.Controls.ItemsControl.IsTextSearchEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether <see cref="T:System.Windows.Controls.TextSearch" /> is enabled on the <see cref="T:System.Windows.Controls.ItemsControl" /> instance.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Windows.Controls.TextSearch" /> è abilitato; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsTextSearchEnabled"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTextSearchEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTextSearchEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTextSearchEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTextSearchEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsTextSearchEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.IsTextSearchEnabled" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemBindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup ItemBindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup ItemBindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemBindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ ItemBindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemBindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.Controls.ItemsControl.ItemBindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is copied to each item in the <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Il <see cref="T:System.Windows.Data.BindingGroup" /> che viene copiato in ogni elemento di <see cref="T:System.Windows.Controls.ItemsControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si imposta la <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> ottiene ogni contenitore di elementi di proprietà, un <xref:System.Windows.Data.BindingGroup> che ha lo stesso <xref:System.Windows.Controls.ValidationRule> oggetti come le <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A>, ma le proprietà che descrivono i dati nelle associazioni, ad esempio <xref:System.Windows.Data.BindingGroup.Items%2A> e <xref:System.Windows.Data.BindingGroup.BindingExpressions%2A>, sono specifiche dei dati per ogni elemento di <xref:System.Windows.Controls.ItemsControl>.  È necessario accedere al contenitore elemento <xref:System.Windows.FrameworkContentElement.BindingGroup%2A> per eseguire operazioni come la convalida dei dati e la presenza di errori su un elemento.  
  
   
  
## Examples  
 Nell'esempio seguente fa parte di un'applicazione che richiede all'utente di immettere più clienti e assegnare un rappresentante di vendita per ogni cliente e quindi verifica che il rappresentante di vendita e il cliente appartenga alla stessa area. Nell'esempio viene impostata la <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> del <xref:System.Windows.Controls.ItemsControl> pertanto la <xref:System.Windows.Controls.ValidationRule>, `AreasMatch`, convaliderà ogni elemento. Nell'esempio viene creata anche una <xref:System.Windows.Controls.Label> che consente di visualizzare gli errori di convalida. Si noti che il <xref:System.Windows.Controls.ContentControl.Content%2A> del <xref:System.Windows.Controls.Label> è associato a un <xref:System.Windows.Controls.ValidationError> ottenute dal <xref:System.Windows.Controls.Validation.ValidationAdornerSiteForProperty?displayProperty=nameWithType> proprietà. Il valore di <xref:System.Windows.Controls.Validation.ValidationAdornerSiteForProperty?displayProperty=nameWithType> è il contenitore di elementi con l'errore.  
  
 [!code-xaml[BindingGroupSnippets#ItemBindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml#itembindinggroup)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSiteFor](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml#validationadornersitefor)]  
  
 Nell'esempio seguente ottiene il contenitore di elementi e chiama <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> del contenitore <xref:System.Windows.Data.BindingGroup> per convalidare i dati. È necessario convalidare i dati chiamando un metodo del contenitore dell'elemento <xref:System.Windows.FrameworkContentElement.BindingGroup%2A>non via il <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> del <xref:System.Windows.Controls.ItemsControl>.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSources](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#updatesources)]
 [!code-vb[BindingGroupSnippets#UpdateSources](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#updatesources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemBindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemBindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemBindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemBindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemBindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemBindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemBindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemBindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerGenerator">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemContainerGenerator ItemContainerGenerator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemContainerGenerator ItemContainerGenerator" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemContainerGenerator As ItemContainerGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemContainerGenerator ^ ItemContainerGenerator { System::Windows::Controls::ItemContainerGenerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerGenerator : System.Windows.Controls.ItemContainerGenerator" Usage="System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemContainerGenerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.Controls.ItemContainerGenerator" /> that is associated with the control.</summary>
        <value>Il <see cref="T:System.Windows.Controls.ItemContainerGenerator" /> che viene associato al controllo. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un' <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> è responsabile della generazione di [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] per l'host, ad esempio un <xref:System.Windows.Controls.ItemsControl>. Gestisce l'associazione tra gli elementi nella vista dati del controllo e i corrispondenti <xref:System.Windows.UIElement> oggetti. Ogni <xref:System.Windows.Controls.ItemsControl> dispone di un contenitore di elementi associati che contiene un elemento di dati nella raccolta di elementi. È possibile usare il <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> proprietà per accedere al contenitore di elementi che è associato il <xref:System.Windows.Controls.ItemsControl>. Ad esempio, se si dispone di un'associazione a dati <xref:System.Windows.Controls.TreeView> controllo e si desidera ottenere un <xref:System.Windows.Controls.TreeViewItem> in base al relativo indice o l'elemento di dati associati, è possibile utilizzare il <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromIndex%2A?displayProperty=nameWithType> o <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromItem%2A?displayProperty=nameWithType> metodo. In alternativa, è possibile utilizzare il <xref:System.Windows.Controls.ItemContainerGenerator.IndexFromContainer%2A?displayProperty=nameWithType> o <xref:System.Windows.Controls.ItemContainerGenerator.ItemFromContainer%2A?displayProperty=nameWithType> metodo per ottenere l'indice o un elemento dati associato a un elemento contenitore generato specificato.  
  
 Il <xref:System.Windows.Controls.Primitives.IItemContainerGenerator> interfaccia viene anche utilizzata in scenari avanzati. In genere, le applicazioni avanzate con la propria implementazione di un pannello virtualizzazione chiamano i membri dell'interfaccia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style ItemContainerStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style ItemContainerStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemContainerStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ ItemContainerStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerStyle : System.Windows.Style with get, set" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Content")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Style" /> that is applied to the container element generated for each item.</summary>
        <value>Il <see cref="T:System.Windows.Style" /> che viene applicato all'elemento contenitore generato per ogni elemento. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà o il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> proprietà per impostare uno stile influiscono sull'aspetto degli elementi che contengono gli elementi di dati. Ad esempio, per <xref:System.Windows.Controls.ListBox>, i contenitori generati sono <xref:System.Windows.Controls.ListBoxItem> controlli; per <xref:System.Windows.Controls.ComboBox>, sono <xref:System.Windows.Controls.ComboBoxItem> controlli.  
  
 Il <xref:System.Windows.Controls.ItemsControl> offre una notevole flessibilità per la personalizzazione visiva e fornisce molte proprietà di stili e modelli. Per influenzare il layout degli elementi, utilizzare il <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> proprietà. Se si utilizza il raggruppamento sul controllo, è possibile utilizzare il <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> o <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> proprietà. Per specificare la visualizzazione di oggetti dati, usare il <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> o <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> proprietà. Per ulteriori informazioni sulle situazioni in cui specificare un' <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>, vedere [panoramica dei modelli di dati](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemContainerStyle"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object ItemContainerStyle="ResourceExtension StyleResourceKey"/>  
```  
  
<a name="xamlValues_ItemContainerStyle"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *ResourceExtension*  
 Uno dei seguenti: `StaticResource`, o `DynamicResource`. A meno che gli stili stessi contengano riferimenti a riferimenti in fase di esecuzione potenziali, ad esempio le risorse di sistema o le preferenze dell'utente, `StaticResource` riferimento a uno stile in genere è consigliabile per le prestazioni.  
  
 *StyleResourceKey*  
 `x:Key` valore stringa che fa riferimento allo stile richiesto come una risorsa.  
  
<a name="dependencyPropertyInfo_ItemContainerStyle"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.ItemContainerStyleProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare questa proprietà. Tenere presente quanto segue associati a dati <xref:System.Windows.Controls.ListBox>:  
  
 [!code-xaml[StylingIntroSnippet#UIListBox](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#uilistbox)]   
  
 Per creare uno stile per gli elementi che contengono gli elementi di dati, creare un <xref:System.Windows.Controls.ListBoxItem> stile, come illustrato nell'esempio seguente. Lo stile viene applicato a tutti i <xref:System.Windows.Controls.ListBoxItem> elementi all'interno dell'ambito è definito lo stile.  
  
 [!code-xaml[StylingIntroSnippet#ListBoxItemStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#listboxitemstyle)]   
  
 Il <xref:System.Windows.Controls.ListBoxItem> corrisponde all'elemento contenitore per il <xref:System.Windows.Controls.ListBox> controllo. Pertanto, un'alternativa al precedente consiste nell'impostare il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> proprietà del <xref:System.Windows.Controls.ListBox> sullo stile definito. A tale scopo, assegnare il <xref:System.Windows.Controls.ListBoxItem> stile un `x:Key` pertanto è disponibile come risorsa:  
  
 [!code-xaml[StylingIntroSample_snippet#ContainerStyle1](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#containerstyle1)]   
  
 Successivamente, impostare il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> proprietà della risorsa, come nell'esempio seguente:  
  
 [!code-xaml[StylingIntroSample_snippet#ListBox](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#listbox)]   
  
 Entrambi gli scenari precedenti producono lo stesso risultato. Tuttavia, uno dei vantaggi di rendere disponibile come risorsa per lo stile è che è possibile riutilizzare lo stile. Impostazione di <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> proprietà, in modo esplicito, può anche offrire maggiore leggibilità.  
  
 Per un esempio completo, vedere [Introduzione agli stili e modelli](http://go.microsoft.com/fwlink/?LinkID=160010).  
  
 L'esempio seguente è progettato per illustrare la funzione dei diversi stili e modelli correlati le proprietà forniti dal <xref:System.Windows.Controls.ItemsControl>. Il <xref:System.Windows.Controls.ItemsControl> in questo esempio viene associato a una raccolta di `Task` oggetti. A scopo dimostrativo, gli stili e i modelli in questo esempio sono tutti dichiarati incorporati.  
  
 [!code-xaml[DataTemplatingIntro_snip#ItemsControlProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#itemscontrolproperties)]  
  
 Lo screenshot seguente mostra l'esempio dopo il rendering:  
  
 ![Schermata di esempio ItemsControl](~/add/media/databinding-itemscontrolproperties.png "schermata di esempio ItemsControl")  
  
 Due altre proprietà correlate allo stile del <xref:System.Windows.Controls.ItemsControl> che non vengono visualizzate di seguito sono riportate <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> e <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemContainerStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemContainerStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemContainerStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemContainerStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemContainerStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemContainerStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.StyleSelector ItemContainerStyleSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.StyleSelector ItemContainerStyleSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemContainerStyleSelector As StyleSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::StyleSelector ^ ItemContainerStyleSelector { System::Windows::Controls::StyleSelector ^ get(); void set(System::Windows::Controls::StyleSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerStyleSelector : System.Windows.Controls.StyleSelector with get, set" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Content")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.StyleSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets custom style-selection logic for a style that can be applied to each generated container element.</summary>
        <value>Un <see cref="T:System.Windows.Controls.StyleSelector" /> oggetto che contiene la logica che sceglie lo stile da usare come il <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> proprietà per impostare uno stile influiscono sull'aspetto degli elementi che contengono gli elementi di dati. Ad esempio, per <xref:System.Windows.Controls.ListBox>, i contenitori generati sono <xref:System.Windows.Controls.ListBoxItem> controlli; per <xref:System.Windows.Controls.ComboBox>, sono <xref:System.Windows.Controls.ComboBoxItem> controlli. Se si hanno più di uno stile definito ed è necessario fornire la logica per scegliere quella da applicare, quindi si utilizza il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> proprietà anziché il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> proprietà. Si noti che questa proprietà viene ignorata se il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> è impostata.  
  
 Il <xref:System.Windows.Controls.ItemsControl> offre una notevole flessibilità per la personalizzazione visiva e fornisce molte proprietà di stili e modelli. Per influenzare il layout degli elementi, utilizzare il <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> proprietà. Se si utilizza il raggruppamento sul controllo, è possibile utilizzare il <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> o <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> proprietà. Per specificare la visualizzazione di oggetti dati, usare il <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> o <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> proprietà. Per ulteriori informazioni sulle situazioni in cui specificare un' <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>, vedere [panoramica dei modelli di dati](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="dependencyPropertyInfo_ItemContainerStyleSelector"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemContainerStyleSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemContainerStyleSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemContainerStyleSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemContainerStyleSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemContainerStyleSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemCollection Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemCollection Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ItemCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemCollection ^ Items { System::Windows::Controls::ItemCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Windows.Controls.ItemCollection" Usage="System.Windows.Controls.ItemsControl.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection used to generate the content of the <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>La raccolta che viene utilizzata per generare il contenuto del <see cref="T:System.Windows.Controls.ItemsControl" />. Il valore predefinito è una raccolta vuota.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà può essere utilizzata per aggiungere elementi a un <xref:System.Windows.Controls.ItemsControl>. Aggiunta di un elemento figlio di un <xref:System.Windows.Controls.ItemsControl> oggetto aggiunge in modo implicito per il <xref:System.Windows.Controls.ItemCollection> per il <xref:System.Windows.Controls.ItemsControl> oggetto.  
  
> [!NOTE]
>  Questa proprietà può essere impostata solo [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] tramite la sintassi di raccolta illustrata, oppure accedendo all'oggetto collection e utilizzando i vari metodi, ad esempio `Add`. La proprietà per accedere all'oggetto raccolta stesso è di sola lettura e la raccolta è in lettura-scrittura.  
  
 Si noti che è utilizzare la <xref:System.Windows.Controls.ItemsControl.Items%2A> o il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> proprietà per specificare la raccolta che deve essere utilizzata per generare il contenuto del <xref:System.Windows.Controls.ItemsControl>. Quando il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> è impostata, il <xref:System.Windows.Controls.ItemsControl.Items%2A> insieme viene reso di sola lettura e di dimensioni fisse.  
  
 Quando si <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> è in uso, l'impostazione di <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> proprietà da `null` rimuove la raccolta e di ripristinare l'utilizzo di <xref:System.Windows.Controls.ItemsControl.Items%2A>, che sarà vuota <xref:System.Windows.Controls.ItemCollection>.  
  
<a name="xamlPropertyElementUsage_Items"></a>   
## <a name="xaml-property-element-usage"></a>Utilizzo della sintassi XAML per elementi proprietà  
  
```  
<object>  
  OneOrMoreElements  
</object>  
```  
  
<a name="xamlValues_Items"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *OneOrMoreElements*  
 Uno o più <xref:System.Windows.UIElement> oggetti.  
  
   
  
## Examples  
 Gli esempi seguenti illustrano il data binding a un <xref:System.Windows.Controls.ItemsControl>. Nel primo esempio viene creata una classe denominata `MyData` vale a dire una semplice raccolta di stringhe.  
  
 [!code-csharp[ControlContentOverviewSnippets#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#8)]
 [!code-vb[ControlContentOverviewSnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#8)]  
  
 Nell'esempio seguente viene associato il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> oggetto di un <xref:System.Windows.Controls.ItemsControl> a `MyData`.  
  
 [!code-xaml[ControlContentOverviewSnippets#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#7)]  
[!code-xaml[ControlContentOverviewSnippets#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#6)]  
  
 [!code-csharp[ControlContentOverviewSnippets#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#9)]
 [!code-vb[ControlContentOverviewSnippets#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#9)]  
  
 La figura seguente mostra il <xref:System.Windows.Controls.ListBox> controllo creato nell'esempio precedente.  
  
 ![ListBox](~/add/media/controlcontentmodellistbox1.PNG "ListBox")  
  
 Nell'esempio seguente viene illustrato come compilare un <xref:System.Windows.Controls.ItemsControl> utilizzando il <xref:System.Windows.Controls.ItemsControl.Items%2A> proprietà. L'esempio aggiunge i seguenti tipi diversi di elementi per il <xref:System.Windows.Controls.ListBox>:  
  
-   Una stringa.  
  
-   Oggetto <xref:System.DateTime>.  
  
-   Oggetto <xref:System.Windows.UIElement>.  
  
-   Un <xref:System.Windows.Controls.Panel> controllo che contiene altri <xref:System.Windows.UIElement> oggetti.  
  
 [!code-xaml[ControlContentOverviewSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#3)]  
  
 [!code-csharp[ControlContentOverviewSnippets#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#4)]
 [!code-vb[ControlContentOverviewSnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#4)]  
  
 La figura seguente mostra il <xref:System.Windows.Controls.ListBox> creato nell'esempio precedente.  
  
 ![ListBox con quattro tipi di contenuto](~/add/media/controlcontentmodellistbox2.PNG "ListBox con quattro tipi di contenuto")  
  
 Si noti che il <xref:System.Windows.Controls.ItemCollection> è una vista, pertanto è possibile utilizzare le funzionalità correlate alla vista, ad esempio l'ordinamento, filtro e raggruppamento.  
  
 Ad esempio, se si dispone di un'istanza di un <xref:System.Windows.Controls.ListBox>, `myListBox`, è possibile eseguire il comando seguente per ordinare il contenuto del <xref:System.Windows.Controls.ListBox>. In questo esempio, `Content` è il nome della proprietà da ordinare.  
  
 [!code-csharp[ListBoxSort_snip#Sort](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxSort_snip/CSharp/Window1.xaml.cs#sort)]
 [!code-vb[ListBoxSort_snip#Sort](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxSort_snip/visualbasic/window1.xaml.vb#sort)]  
  
 Si noti che, quando si esegue questa operazione, se il controllo viene associato direttamente a una raccolta, viene utilizzata la visualizzazione di raccolta predefinita e i criteri di ordinamento vengono applicati a tutti gli altri controlli associati direttamente alla stessa raccolta. La vista non sarà la visualizzazione predefinita se il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> proprietà è associata a un <xref:System.Windows.Data.CollectionViewSource>.  
  
 Se il <xref:System.Windows.Controls.ItemsControl> è associato direttamente a una raccolta, è possibile eseguire il comando seguente per ottenere la visualizzazione predefinita:  
  
 [!code-csharp[GroupingSample#MyView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#myview)]
 [!code-vb[GroupingSample#MyView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#myview)]  
[!code-csharp[GroupingSample#GetView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#getview)]
[!code-vb[GroupingSample#GetView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#getview)]  
  
 In alternativa, è possibile specificare il filtro, ordinamento e raggruppamento criteri [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] o il codice utilizzando un <xref:System.Windows.Data.CollectionViewSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsControlFromItemContainer">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ItemsControl ItemsControlFromItemContainer (System.Windows.DependencyObject container);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Controls.ItemsControl ItemsControlFromItemContainer(class System.Windows.DependencyObject container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ItemsControlFromItemContainer(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ItemsControlFromItemContainer (container As DependencyObject) As ItemsControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ItemsControl ^ ItemsControlFromItemContainer(System::Windows::DependencyObject ^ container);" />
      <MemberSignature Language="F#" Value="static member ItemsControlFromItemContainer : System.Windows.DependencyObject -&gt; System.Windows.Controls.ItemsControl" Usage="System.Windows.Controls.ItemsControl.ItemsControlFromItemContainer container" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsControl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="container">The container element to return the <see cref="T:System.Windows.Controls.ItemsControl" /> for.</param>
        <summary>Returns the <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the specified container element.</summary>
        <returns>The <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the specified container element.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="ItemsPanel">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemsPanelTemplate ItemsPanel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemsPanelTemplate ItemsPanel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemsPanel" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemsPanel As ItemsPanelTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemsPanelTemplate ^ ItemsPanel { System::Windows::Controls::ItemsPanelTemplate ^ get(); void set(System::Windows::Controls::ItemsPanelTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemsPanel : System.Windows.Controls.ItemsPanelTemplate with get, set" Usage="System.Windows.Controls.ItemsControl.ItemsPanel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsPanelTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the template that defines the panel that controls the layout of items.</summary>
        <value>Un <see cref="T:System.Windows.Controls.ItemsPanelTemplate" /> che definisce il pannello da usare per il layout degli elementi. Il valore predefinito per il <see cref="T:System.Windows.Controls.ItemsControl" /> è un <see cref="T:System.Windows.Controls.ItemsPanelTemplate" /> che specifica un <see cref="T:System.Windows.Controls.StackPanel" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per il <xref:System.Windows.Controls.ListBox>, il valore predefinito <xref:System.Windows.Controls.ItemsPanelTemplate> specifica il <xref:System.Windows.Controls.VirtualizingStackPanel>. Per <xref:System.Windows.Controls.MenuItem>, viene utilizzato il valore predefinito <xref:System.Windows.Controls.WrapPanel>. Per <xref:System.Windows.Controls.Primitives.StatusBar>, viene utilizzato il valore predefinito <xref:System.Windows.Controls.DockPanel>.  
  
 Per influenzare il layout degli elementi in un <xref:System.Windows.Controls.ItemsControl>, questa proprietà consente di specificare un <xref:System.Windows.Controls.ItemsPanelTemplate>.  
  
 Il <xref:System.Windows.Controls.ItemsControl> offre una notevole flessibilità per la personalizzazione visiva e fornisce molte proprietà di stili e modelli. Utilizzare la <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> proprietà o il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> proprietà per impostare uno stile influiscono sull'aspetto degli elementi che contengono gli elementi di dati. Ad esempio, per <xref:System.Windows.Controls.ListBox>, i contenitori generati sono <xref:System.Windows.Controls.ListBoxItem> controlli; per <xref:System.Windows.Controls.ComboBox>, sono <xref:System.Windows.Controls.ComboBoxItem> controlli. Se si utilizza il raggruppamento sul controllo, è possibile utilizzare il <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> o <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> proprietà. Per specificare la visualizzazione degli oggetti dati, usare il <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> o <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> proprietà. Per altre informazioni, vedere [Panoramica dei modelli di dati](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="dependencyPropertyInfo_ItemsPanel"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.ItemsPanelProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
   
  
## Examples  
 Per creare un oggetto orizzontale <xref:System.Windows.Controls.ListBox>, è possibile creare un modello che specifica un oggetto orizzontale <xref:System.Windows.Controls.StackPanel> e impostarlo come il <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> proprietà. L'esempio seguente illustra una <xref:System.Windows.Controls.ListBox> <xref:System.Windows.Style> che crea un oggetto orizzontale <xref:System.Windows.Controls.ListBox>.  
  
 [!code-xaml[StylingIntroSample_snippet#ItemsPanel](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#itemspanel)] 
  
 L'esempio seguente usa un' <xref:System.Windows.Controls.ControlTemplate> per creare un oggetto orizzontale <xref:System.Windows.Controls.ListBox> che ha gli angoli arrotondati. In questo esempio, anziché impostare il <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> proprietà come illustrato nell'esempio precedente, orizzontale <xref:System.Windows.Controls.StackPanel> viene specificato all'interno di <xref:System.Windows.Controls.ControlTemplate>. Il <xref:System.Windows.Controls.Panel.IsItemsHost%2A> è impostata su `true` sul <xref:System.Windows.Controls.StackPanel>, che indica che gli elementi generati devono andare nel pannello. Quando si specifica in questo modo, il <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> non può essere sostituito dall'utente del controllo senza usare un <xref:System.Windows.Controls.ControlTemplate>. Pertanto, eseguire questa operazione solo se si conosce che il pannello deve essere sostituita senza l'utilizzo di un modello non è consigliabile.  
  
 [!code-xaml[StylingIntroSnippet#ListBoxCT](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#listboxct)]   
  
 In alternativa, è possibile eseguire il comando seguente per ottenere gli stessi risultati. In questo caso, il <xref:System.Windows.Controls.ItemsPresenter> crea il pannello per il layout degli elementi in base a quanto specificato dal <xref:System.Windows.Controls.ItemsPanelTemplate>.  
  
 [!code-xaml[StyleOvw01#ItemsPanelTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#itemspaneltemplate)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsPanelProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemsPanelProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemsPanelProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemsPanelProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemsPanelProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemsPanelProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemsPanelProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemsPanelProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsSource">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ItemsSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable ItemsSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemsSource" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemsSource As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerable ^ ItemsSource { System::Collections::IEnumerable ^ get(); void set(System::Collections::IEnumerable ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemsSource : System.Collections.IEnumerable with get, set" Usage="System.Windows.Controls.ItemsControl.ItemsSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a collection used to generate the content of the <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Una raccolta che viene utilizzata per generare il contenuto del <see cref="T:System.Windows.Controls.ItemsControl" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Modello di contenuto:** questa proprietà può essere utilizzata per aggiungere elementi a un <xref:System.Windows.Controls.ItemsControl>.  
  
 Uno scenario comune consiste nell'utilizzare un <xref:System.Windows.Controls.ItemsControl> , ad esempio un <xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ListView>, oppure <xref:System.Windows.Controls.TreeView> per visualizzare una raccolta di dati o per associare un <xref:System.Windows.Controls.ItemsControl> a un oggetto raccolta. Per associare un' <xref:System.Windows.Controls.ItemsControl> a un oggetto di raccolta, usare il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> proprietà. Si noti che il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> supporta proprietà <xref:System.Windows.Data.BindingMode.OneWay> binding per impostazione predefinita.  
  
 Quando il <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> è impostata, il <xref:System.Windows.Controls.ItemsControl.Items%2A> insieme viene reso di sola lettura e di dimensioni fisse.  
  
 Quando si <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> è in uso, impostare la proprietà `null` rimuove la raccolta e di ripristinare l'utilizzo di <xref:System.Windows.Controls.ItemsControl.Items%2A>, che sarà vuota <xref:System.Windows.Controls.ItemCollection>. Quando si <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> è non in uso, il valore di questa proprietà è `null`e se è impostato su `null` non ha alcun effetto.  
  
> [!NOTE]
>  Nella maggior parte dei casi non è necessario implementare le proprie raccolte. Al contrario, provare a usare <xref:System.Collections.ObjectModel.ObservableCollection%601> o di altre raccolte esistenti. Per altre informazioni, vedere la "raccolta di oggetti utilizzata come origine dell'associazione" nella [Cenni preliminari sulle origini di associazione](~/docs/framework/wpf/data/binding-sources-overview.md).  
  
<a name="xamlAttributeUsage_ItemsSource"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object ItemsSource="bindingDeclaration"/>  
```  
  
<a name="xamlValues_ItemsSource"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *bindingDeclaration*  
 Oggetto <xref:System.Windows.Data.Binding> dichiarazione. Vedere [estensione di Markup di associazione](~/docs/framework/wpf/advanced/binding-markup-extension.md) per altre informazioni.  
  
<a name="dependencyPropertyInfo_ItemsSource"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.ItemsSourceProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsSourceProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemsSourceProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemsSourceProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemsSourceProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemsSourceProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemsSourceProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemsSourceProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemsSourceProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemStringFormat">
      <MemberSignature Language="C#" Value="public string ItemStringFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ItemStringFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemStringFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemStringFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ItemStringFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemStringFormat : string with get, set" Usage="System.Windows.Controls.ItemsControl.ItemStringFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a composite string that specifies how to format the items in the <see cref="T:System.Windows.Controls.ItemsControl" /> if they are displayed as strings.</summary>
        <value>Una stringa composita che specifica come formattare gli elementi di <see cref="T:System.Windows.Controls.ItemsControl" /> se vengono visualizzati come stringhe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> può essere un formato di stringa predefinito, composito o personalizzato. Per ulteriori informazioni sui formati di stringa, vedere [formattazione dei tipi](~/docs/standard/base-types/formatting-types.md). Se si imposta la <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> oppure <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> di un <xref:System.Windows.Controls.ItemsControl>, il <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> proprietà viene ignorata.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> per specificare il formato di un elenco di <xref:System.DateTime> oggetti.  
  
 [!code-xaml[ContentStringSnippets#ItemsControl](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentStringSnippets/CSharp/Window1.xaml#itemscontrol)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemStringFormatProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemStringFormatProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemStringFormatProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemStringFormatProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemStringFormatProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemStringFormatProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemStringFormatProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemStringFormatProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplate">
      <MemberSignature Language="C#" Value="public System.Windows.DataTemplate ItemTemplate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DataTemplate ItemTemplate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemTemplate As DataTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DataTemplate ^ ItemTemplate { System::Windows::DataTemplate ^ get(); void set(System::Windows::DataTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemTemplate : System.Windows.DataTemplate with get, set" Usage="System.Windows.Controls.ItemsControl.ItemTemplate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DataTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.DataTemplate" /> used to display each item.</summary>
        <value>Oggetto <see cref="T:System.Windows.DataTemplate" /> che specifica la visualizzazione degli oggetti dati. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> per specificare la visualizzazione degli oggetti dati. Se il <xref:System.Windows.Controls.ItemsControl> è associata a una raccolta di oggetti e si non forniscono le istruzioni di visualizzazione specifico utilizzando un <xref:System.Windows.DataTemplate>, il valore risultante [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] di ciascun elemento è una rappresentazione di stringa di ciascun oggetto nella raccolta sottostante.  
  
 Quando si imposta un' <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> in un <xref:System.Windows.Controls.ItemsControl>, la [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] viene generato come segue (utilizzando il <xref:System.Windows.Controls.ListBox> come esempio):  
  
1.  Durante la generazione del contenuto, il <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> avvia una richiesta per il <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> per creare un contenitore per ogni elemento di dati. Per <xref:System.Windows.Controls.ListBox>, il contenitore è un <xref:System.Windows.Controls.ListBoxItem>. Il generatore richiama il <xref:System.Windows.Controls.ItemsControl> per preparare il contenitore.  
  
2.  Parte della preparazione comporta la copia del <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> del <xref:System.Windows.Controls.ListBox> sia il <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> del <xref:System.Windows.Controls.ListBoxItem>.  
  
3.  Simile a tutti <xref:System.Windows.Controls.ContentControl> i tipi, il <xref:System.Windows.Controls.ControlTemplate> di un <xref:System.Windows.Controls.ListBoxItem> contiene un <xref:System.Windows.Controls.ContentPresenter>. Quando viene applicato il modello, viene creato un <xref:System.Windows.Controls.ContentPresenter> cui <xref:System.Windows.Controls.ContentPresenter.ContentTemplate%2A> è associato al <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> del <xref:System.Windows.Controls.ListBoxItem>.  
  
4.  Infine, il <xref:System.Windows.Controls.ContentPresenter> applica l'oggetto <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> a se stessa, e che crea il [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  
  
 Se si dispone di una o più <xref:System.Windows.DataTemplate> definite e si desidera fornire la logica per scegliere e si applicano a livello di codice un <xref:System.Windows.DataTemplate>, utilizzare il <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> proprietà.  
  
 Il <xref:System.Windows.Controls.ItemsControl> offre una notevole flessibilità per la personalizzazione visiva e fornisce molte proprietà di stili e modelli. Usare la <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> proprietà o il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> proprietà per impostare uno stile influiscono sull'aspetto degli elementi che contengono gli elementi di dati. Ad esempio, per <xref:System.Windows.Controls.ListBox>, i contenitori generati sono <xref:System.Windows.Controls.ListBoxItem> controlli; per <xref:System.Windows.Controls.ComboBox>, sono <xref:System.Windows.Controls.ComboBoxItem> controlli. Per influenzare il layout degli elementi, utilizzare il <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> proprietà. Se si utilizza il raggruppamento sul controllo, è possibile utilizzare il <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> o <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> proprietà.  
  
 Per altre informazioni, vedere [Panoramica dei modelli di dati](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object ItemTemplate=" ResourceExtension TemplateResourceKey"/>  
```  
  
<a name="xamlValues_ItemTemplate"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *ResourceExtension*  
 Uno dei seguenti: [estensione di Markup StaticResource](~/docs/framework/wpf/advanced/staticresource-markup-extension.md), o [estensione di Markup DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). A meno che gli stili stessi contengano riferimenti a riferimenti in fase di esecuzione potenziali, ad esempio le preferenze dell'utente, o le risorse di sistema [estensione di Markup StaticResource](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) riferimento a uno stile in genere è consigliabile per le prestazioni.  
  
 *TemplateResourceKey*  
 [Direttiva X:Key](~/docs/framework/xaml-services/x-key-directive.md) valore stringa che fa riferimento al modello di richiesta come una risorsa.  
  
<a name="dependencyPropertyInfo_ItemTemplate"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.ItemTemplateProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un <xref:System.Windows.DataTemplate> inline. Il <xref:System.Windows.DataTemplate> specifica che ogni elemento di dati viene visualizzato come tre <xref:System.Windows.Controls.TextBlock> elementi all'interno di un <xref:System.Windows.Controls.StackPanel>. In questo esempio, l'oggetto dati è una classe denominata `Task`. Si noti che ogni <xref:System.Windows.Controls.TextBlock> elemento in questo modello è associato a una proprietà del `Task` classe.  
  
 [!code-xaml[DataTemplatingIntro_snip#Inline](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#inline)]  
  
 È più comune per definire un <xref:System.Windows.DataTemplate> nella sezione delle risorse in modo può essere un oggetto riutilizzabile, come nell'esempio seguente:  
  
 [!code-xaml[DataTemplatingIntro_snip#R1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r1)]  
[!code-xaml[DataTemplatingIntro_snip#AsResource](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#asresource)]  
[!code-xaml[DataTemplatingIntro_snip#R2](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r2)]  
  
 È possibile a questo punto usare `myTaskTemplate` come risorsa, come illustrato nell'esempio seguente:  
  
 [!code-xaml[DataTemplatingIntro_snip#MyTaskTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#mytasktemplate)]  
  
 Per l'esempio completo, vedere [Introduction to Data Templating Sample](http://go.microsoft.com/fwlink/?LinkID=160009) (Introduzione a un esempio di applicazione di modello).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemTemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemTemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemTemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemTemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemTemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemTemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemTemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.DataTemplateSelector ItemTemplateSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.DataTemplateSelector ItemTemplateSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemTemplateSelector As DataTemplateSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::DataTemplateSelector ^ ItemTemplateSelector { System::Windows::Controls::DataTemplateSelector ^ get(); void set(System::Windows::Controls::DataTemplateSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemTemplateSelector : System.Windows.Controls.DataTemplateSelector with get, set" Usage="System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.DataTemplateSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the custom logic for choosing a template used to display each item.</summary>
        <value>Un oggetto personalizzato <see cref="T:System.Windows.Controls.DataTemplateSelector" /> oggetto che fornisce la logica e restituisce un <see cref="T:System.Windows.DataTemplate" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> per specificare la visualizzazione degli oggetti dati. Se si dispone più di un modello definito e si desidera fornire la logica per restituire un modello da usare, quindi utilizzare questa proprietà. Si noti che questa proprietà viene ignorata se <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> è impostata.  
  
 Il <xref:System.Windows.Controls.ItemsControl> offre una notevole flessibilità per la personalizzazione visiva e fornisce molte proprietà di stili e modelli. Usare la <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> proprietà o il <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> proprietà per impostare uno stile influiscono sull'aspetto degli elementi che contengono gli elementi di dati. Ad esempio, per <xref:System.Windows.Controls.ListBox>, i contenitori generati sono <xref:System.Windows.Controls.ListBoxItem> controlli; per <xref:System.Windows.Controls.ComboBox>, sono <xref:System.Windows.Controls.ComboBoxItem> controlli. Per influenzare il layout degli elementi, utilizzare il <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> proprietà. Se si utilizza il raggruppamento sul controllo, è possibile utilizzare il <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> o <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> proprietà.  
  
 Per altre informazioni, vedere [Panoramica dei modelli di dati](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemTemplateSelector"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object ItemTemplateSelector="ResourceExtension SelectorResourceKey"/>  
```  
  
<a name="xamlValues_ItemTemplateSelector"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *ResourceExtension*  
 Uno dei seguenti: `StaticResource`, o `DynamicResource`. A meno che gli stili stessi contengano riferimenti a riferimenti in fase di esecuzione potenziali, ad esempio le risorse di sistema o le preferenze dell'utente, `StaticResource` riferimento a uno stile in genere è consigliabile per le prestazioni.  
  
 *SelectorResourceKey*  
 `x:Key` valore stringa che fa riferimento al selettore richiesto come una risorsa.  
  
<a name="dependencyPropertyInfo_ItemTemplateSelector"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente, il `auctionItemDataTemplateSelector` nome della risorsa (corrispondente a un `AuctionItemDataTemplateSelector` classe) viene assegnato al <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> proprietà del <xref:System.Windows.Controls.ItemsControl>.  
  
 [!code-xaml[DataTemplateSelector#ItemTemplateSelector](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplateSelector/CSharp/Window1.xaml#itemtemplateselector)]  
  
 Nell'esempio seguente viene illustrata l'implementazione del `AuctionItemDataTemplateSelector` classe con un override del <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> metodo:  
  
 [!code-csharp[DataTemplateSelector#DataTemplateSelector](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplateSelector/CSharp/AuctionItemDataTemplateSelector.cs#datatemplateselector)]
 [!code-vb[DataTemplateSelector#DataTemplateSelector](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DataTemplateSelector/visualbasic/auctionitemdatatemplateselector.vb#datatemplateselector)]  
  
 In questo caso, all'interno del <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> metodo della classe, è disponibile una logica per restituire il modello appropriato in base al valore del `SpecialFeatures` proprietà del `item` oggetto passato. Il modello da restituire viene trovato nelle risorse di busta <xref:System.Windows.Window> elemento.  
  
 Quando si imposta la <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> proprietà, il <xref:System.Windows.Controls.ItemsControl> viene indirizzato a richiamare automaticamente il <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> metodo di `AuctionItemDataTemplateSelector` per ciascuno degli elementi nella raccolta a cui il <xref:System.Windows.Controls.ItemsControl> è associato. La chiamata passa l'elemento di dati come oggetto. Il <xref:System.Windows.DataTemplate> che viene restituito per il metodo viene quindi utilizzato per visualizzare l'elemento di dati.  
  
 Per un altro esempio, vedere [panoramica dei modelli di dati](~/docs/framework/wpf/data/data-templating-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemTemplateSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemTemplateSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemTemplateSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemTemplateSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemTemplateSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.ItemsControl.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an enumerator for the logical child objects of the <see cref="T:System.Windows.Controls.ItemsControl" /> object.</summary>
        <value>Un enumeratore per gli oggetti figlio logici del <see cref="T:System.Windows.Controls.ItemsControl" /> oggetto. Il valore predefinito è <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAlternationCountChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAlternationCountChanged (int oldAlternationCount, int newAlternationCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAlternationCountChanged(int32 oldAlternationCount, int32 newAlternationCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnAlternationCountChanged(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAlternationCountChanged (oldAlternationCount As Integer, newAlternationCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAlternationCountChanged(int oldAlternationCount, int newAlternationCount);" />
      <MemberSignature Language="F#" Value="abstract member OnAlternationCountChanged : int * int -&gt; unit&#xA;override this.OnAlternationCountChanged : int * int -&gt; unit" Usage="itemsControl.OnAlternationCountChanged (oldAlternationCount, newAlternationCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldAlternationCount" Type="System.Int32" />
        <Parameter Name="newAlternationCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldAlternationCount">The old value of <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</param>
        <param name="newAlternationCount">The new value of <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayMemberPathChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayMemberPathChanged (string oldDisplayMemberPath, string newDisplayMemberPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayMemberPathChanged(string oldDisplayMemberPath, string newDisplayMemberPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnDisplayMemberPathChanged(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayMemberPathChanged (oldDisplayMemberPath As String, newDisplayMemberPath As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayMemberPathChanged(System::String ^ oldDisplayMemberPath, System::String ^ newDisplayMemberPath);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayMemberPathChanged : string * string -&gt; unit&#xA;override this.OnDisplayMemberPathChanged : string * string -&gt; unit" Usage="itemsControl.OnDisplayMemberPathChanged (oldDisplayMemberPath, newDisplayMemberPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDisplayMemberPath" Type="System.String" />
        <Parameter Name="newDisplayMemberPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldDisplayMemberPath">The old value of the <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> property.</param>
        <param name="newDisplayMemberPath">New value of the <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGroupStyleSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnGroupStyleSelectorChanged (System.Windows.Controls.GroupStyleSelector oldGroupStyleSelector, System.Windows.Controls.GroupStyleSelector newGroupStyleSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGroupStyleSelectorChanged(class System.Windows.Controls.GroupStyleSelector oldGroupStyleSelector, class System.Windows.Controls.GroupStyleSelector newGroupStyleSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnGroupStyleSelectorChanged(System.Windows.Controls.GroupStyleSelector,System.Windows.Controls.GroupStyleSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGroupStyleSelectorChanged (oldGroupStyleSelector As GroupStyleSelector, newGroupStyleSelector As GroupStyleSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGroupStyleSelectorChanged(System::Windows::Controls::GroupStyleSelector ^ oldGroupStyleSelector, System::Windows::Controls::GroupStyleSelector ^ newGroupStyleSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnGroupStyleSelectorChanged : System.Windows.Controls.GroupStyleSelector * System.Windows.Controls.GroupStyleSelector -&gt; unit&#xA;override this.OnGroupStyleSelectorChanged : System.Windows.Controls.GroupStyleSelector * System.Windows.Controls.GroupStyleSelector -&gt; unit" Usage="itemsControl.OnGroupStyleSelectorChanged (oldGroupStyleSelector, newGroupStyleSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldGroupStyleSelector" Type="System.Windows.Controls.GroupStyleSelector" />
        <Parameter Name="newGroupStyleSelector" Type="System.Windows.Controls.GroupStyleSelector" />
      </Parameters>
      <Docs>
        <param name="oldGroupStyleSelector">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> property.</param>
        <param name="newGroupStyleSelector">New value of the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemBindingGroupChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemBindingGroupChanged (System.Windows.Data.BindingGroup oldItemBindingGroup, System.Windows.Data.BindingGroup newItemBindingGroup);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemBindingGroupChanged(class System.Windows.Data.BindingGroup oldItemBindingGroup, class System.Windows.Data.BindingGroup newItemBindingGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemBindingGroupChanged(System.Windows.Data.BindingGroup,System.Windows.Data.BindingGroup)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemBindingGroupChanged (oldItemBindingGroup As BindingGroup, newItemBindingGroup As BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemBindingGroupChanged(System::Windows::Data::BindingGroup ^ oldItemBindingGroup, System::Windows::Data::BindingGroup ^ newItemBindingGroup);" />
      <MemberSignature Language="F#" Value="abstract member OnItemBindingGroupChanged : System.Windows.Data.BindingGroup * System.Windows.Data.BindingGroup -&gt; unit&#xA;override this.OnItemBindingGroupChanged : System.Windows.Data.BindingGroup * System.Windows.Data.BindingGroup -&gt; unit" Usage="itemsControl.OnItemBindingGroupChanged (oldItemBindingGroup, newItemBindingGroup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemBindingGroup" Type="System.Windows.Data.BindingGroup" />
        <Parameter Name="newItemBindingGroup" Type="System.Windows.Data.BindingGroup" />
      </Parameters>
      <Docs>
        <param name="oldItemBindingGroup">The old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</param>
        <param name="newItemBindingGroup">The new value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemContainerStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemContainerStyleChanged (System.Windows.Style oldItemContainerStyle, System.Windows.Style newItemContainerStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemContainerStyleChanged(class System.Windows.Style oldItemContainerStyle, class System.Windows.Style newItemContainerStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemContainerStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemContainerStyleChanged (oldItemContainerStyle As Style, newItemContainerStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemContainerStyleChanged(System::Windows::Style ^ oldItemContainerStyle, System::Windows::Style ^ newItemContainerStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnItemContainerStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnItemContainerStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="itemsControl.OnItemContainerStyleChanged (oldItemContainerStyle, newItemContainerStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemContainerStyle" Type="System.Windows.Style" />
        <Parameter Name="newItemContainerStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldItemContainerStyle">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> property.</param>
        <param name="newItemContainerStyle">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemContainerStyleSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemContainerStyleSelectorChanged (System.Windows.Controls.StyleSelector oldItemContainerStyleSelector, System.Windows.Controls.StyleSelector newItemContainerStyleSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemContainerStyleSelectorChanged(class System.Windows.Controls.StyleSelector oldItemContainerStyleSelector, class System.Windows.Controls.StyleSelector newItemContainerStyleSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemContainerStyleSelectorChanged(System.Windows.Controls.StyleSelector,System.Windows.Controls.StyleSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector As StyleSelector, newItemContainerStyleSelector As StyleSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemContainerStyleSelectorChanged(System::Windows::Controls::StyleSelector ^ oldItemContainerStyleSelector, System::Windows::Controls::StyleSelector ^ newItemContainerStyleSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnItemContainerStyleSelectorChanged : System.Windows.Controls.StyleSelector * System.Windows.Controls.StyleSelector -&gt; unit&#xA;override this.OnItemContainerStyleSelectorChanged : System.Windows.Controls.StyleSelector * System.Windows.Controls.StyleSelector -&gt; unit" Usage="itemsControl.OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector, newItemContainerStyleSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemContainerStyleSelector" Type="System.Windows.Controls.StyleSelector" />
        <Parameter Name="newItemContainerStyleSelector" Type="System.Windows.Controls.StyleSelector" />
      </Parameters>
      <Docs>
        <param name="oldItemContainerStyleSelector">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> property.</param>
        <param name="newItemContainerStyleSelector">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsChanged (e As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="itemsControl.OnItemsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Information about the change.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.Items" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsPanelChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsPanelChanged (System.Windows.Controls.ItemsPanelTemplate oldItemsPanel, System.Windows.Controls.ItemsPanelTemplate newItemsPanel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsPanelChanged(class System.Windows.Controls.ItemsPanelTemplate oldItemsPanel, class System.Windows.Controls.ItemsPanelTemplate newItemsPanel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsPanelChanged(System.Windows.Controls.ItemsPanelTemplate,System.Windows.Controls.ItemsPanelTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsPanelChanged (oldItemsPanel As ItemsPanelTemplate, newItemsPanel As ItemsPanelTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsPanelChanged(System::Windows::Controls::ItemsPanelTemplate ^ oldItemsPanel, System::Windows::Controls::ItemsPanelTemplate ^ newItemsPanel);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsPanelChanged : System.Windows.Controls.ItemsPanelTemplate * System.Windows.Controls.ItemsPanelTemplate -&gt; unit&#xA;override this.OnItemsPanelChanged : System.Windows.Controls.ItemsPanelTemplate * System.Windows.Controls.ItemsPanelTemplate -&gt; unit" Usage="itemsControl.OnItemsPanelChanged (oldItemsPanel, newItemsPanel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemsPanel" Type="System.Windows.Controls.ItemsPanelTemplate" />
        <Parameter Name="newItemsPanel" Type="System.Windows.Controls.ItemsPanelTemplate" />
      </Parameters>
      <Docs>
        <param name="oldItemsPanel">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> property.</param>
        <param name="newItemsPanel">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsSourceChanged (System.Collections.IEnumerable oldValue, System.Collections.IEnumerable newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsSourceChanged(class System.Collections.IEnumerable oldValue, class System.Collections.IEnumerable newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsSourceChanged(System.Collections.IEnumerable,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsSourceChanged (oldValue As IEnumerable, newValue As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsSourceChanged(System::Collections::IEnumerable ^ oldValue, System::Collections::IEnumerable ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsSourceChanged : System.Collections.IEnumerable * System.Collections.IEnumerable -&gt; unit&#xA;override this.OnItemsSourceChanged : System.Collections.IEnumerable * System.Collections.IEnumerable -&gt; unit" Usage="itemsControl.OnItemsSourceChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Collections.IEnumerable" />
        <Parameter Name="newValue" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="oldValue">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> property.</param>
        <param name="newValue">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> property.</param>
        <summary>Called when the <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemStringFormatChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemStringFormatChanged (string oldItemStringFormat, string newItemStringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemStringFormatChanged(string oldItemStringFormat, string newItemStringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemStringFormatChanged(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemStringFormatChanged (oldItemStringFormat As String, newItemStringFormat As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemStringFormatChanged(System::String ^ oldItemStringFormat, System::String ^ newItemStringFormat);" />
      <MemberSignature Language="F#" Value="abstract member OnItemStringFormatChanged : string * string -&gt; unit&#xA;override this.OnItemStringFormatChanged : string * string -&gt; unit" Usage="itemsControl.OnItemStringFormatChanged (oldItemStringFormat, newItemStringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemStringFormat" Type="System.String" />
        <Parameter Name="newItemStringFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldItemStringFormat">The old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> property.</param>
        <param name="newItemStringFormat">The new value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemTemplateChanged (System.Windows.DataTemplate oldItemTemplate, System.Windows.DataTemplate newItemTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemTemplateChanged(class System.Windows.DataTemplate oldItemTemplate, class System.Windows.DataTemplate newItemTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemTemplateChanged(System.Windows.DataTemplate,System.Windows.DataTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemTemplateChanged (oldItemTemplate As DataTemplate, newItemTemplate As DataTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemTemplateChanged(System::Windows::DataTemplate ^ oldItemTemplate, System::Windows::DataTemplate ^ newItemTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnItemTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit&#xA;override this.OnItemTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit" Usage="itemsControl.OnItemTemplateChanged (oldItemTemplate, newItemTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemTemplate" Type="System.Windows.DataTemplate" />
        <Parameter Name="newItemTemplate" Type="System.Windows.DataTemplate" />
      </Parameters>
      <Docs>
        <param name="oldItemTemplate">The old <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> property value.</param>
        <param name="newItemTemplate">The new <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> property value.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemTemplateSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemTemplateSelectorChanged (System.Windows.Controls.DataTemplateSelector oldItemTemplateSelector, System.Windows.Controls.DataTemplateSelector newItemTemplateSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemTemplateSelectorChanged(class System.Windows.Controls.DataTemplateSelector oldItemTemplateSelector, class System.Windows.Controls.DataTemplateSelector newItemTemplateSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemTemplateSelectorChanged(System.Windows.Controls.DataTemplateSelector,System.Windows.Controls.DataTemplateSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemTemplateSelectorChanged (oldItemTemplateSelector As DataTemplateSelector, newItemTemplateSelector As DataTemplateSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemTemplateSelectorChanged(System::Windows::Controls::DataTemplateSelector ^ oldItemTemplateSelector, System::Windows::Controls::DataTemplateSelector ^ newItemTemplateSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnItemTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit&#xA;override this.OnItemTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit" Usage="itemsControl.OnItemTemplateSelectorChanged (oldItemTemplateSelector, newItemTemplateSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
        <Parameter Name="newItemTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
      </Parameters>
      <Docs>
        <param name="oldItemTemplateSelector">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> property.</param>
        <param name="newItemTemplateSelector">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="itemsControl.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Information about the event.</param>
        <summary>Invoked when the <see cref="E:System.Windows.UIElement.KeyDown" /> event is received.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected override void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="itemsControl.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Information about the event.</param>
        <summary>Invoked when the <see cref="E:System.Windows.UIElement.TextInput" /> event is received.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual void PrepareContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void PrepareContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub PrepareContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void PrepareContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit&#xA;override this.PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="itemsControl.PrepareContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Element used to display the specified item.</param>
        <param name="item">Specified item.</param>
        <summary>Prepares the specified element to display the specified item.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La preparazione dell'elemento potrebbe richiedere l'applicazione di stili, impostazione delle associazioni e così via.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldApplyItemContainerStyle">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldApplyItemContainerStyle (System.Windows.DependencyObject container, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldApplyItemContainerStyle(class System.Windows.DependencyObject container, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldApplyItemContainerStyle(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldApplyItemContainerStyle (container As DependencyObject, item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldApplyItemContainerStyle(System::Windows::DependencyObject ^ container, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member ShouldApplyItemContainerStyle : System.Windows.DependencyObject * obj -&gt; bool&#xA;override this.ShouldApplyItemContainerStyle : System.Windows.DependencyObject * obj -&gt; bool" Usage="itemsControl.ShouldApplyItemContainerStyle (container, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="container">The container element.</param>
        <param name="item">The item of interest.</param>
        <summary>Returns a value that indicates whether to apply the style from the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> or <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> property to the container element of the specified item.</summary>
        <returns>Always <see langword="true" /> for the base implementation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeGroupStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeGroupStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeGroupStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldSerializeGroupStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeGroupStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeGroupStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeGroupStyle : unit -&gt; bool" Usage="itemsControl.ShouldSerializeGroupStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether serialization processes should serialize the effective value of the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyle" /> property.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyle" /> property value should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeItems">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeItems ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldSerializeItems" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeItems () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeItems();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeItems : unit -&gt; bool" Usage="itemsControl.ShouldSerializeItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether serialization processes should serialize the effective value of the <see cref="P:System.Windows.Controls.ItemsControl.Items" /> property.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.Controls.ItemsControl.Items" /> property value should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.Clear">
      <MemberSignature Language="C#" Value="void IContainItemStorage.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IContainItemStorage.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.Clear() = System::Windows::Controls::Primitives::IContainItemStorage::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all property associations.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.ClearItemValue (object item, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(object item, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ClearItemValue(System.Object,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub ClearItemValue (item As Object, dp As DependencyProperty) Implements IContainItemStorage.ClearItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ClearItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(System.Object,System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="item">The associated item.</param>
        <param name="dp">The associated property.</param>
        <summary>Removes the association between the specified item and property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ClearValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub ClearValue (dp As DependencyProperty) Implements IContainItemStorage.ClearValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ClearValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The property to remove.</param>
        <summary>Removes the specified property from all property lists.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue">
      <MemberSignature Language="C#" Value="object IContainItemStorage.ReadItemValue (object item, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(object item, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ReadItemValue(System.Object,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Function ReadItemValue (item As Object, dp As DependencyProperty) As Object Implements IContainItemStorage.ReadItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ReadItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(System.Object,System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="item">The item that has the specified property associated with it.</param>
        <param name="dp">The property whose value to return.</param>
        <summary>Returns the value of the specified property that is associated with the specified item.</summary>
        <returns>The value of the specified property that is associated with the specified item.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.StoreItemValue (object item, System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(object item, class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#StoreItemValue(System.Object,System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub StoreItemValue (item As Object, dp As DependencyProperty, value As Object) Implements IContainItemStorage.StoreItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp, System::Object ^ value) = System::Windows::Controls::Primitives::IContainItemStorage::StoreItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(System.Object,System.Windows.DependencyProperty,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The item to associate the value and property with.</param>
        <param name="dp">The property that is associated with the specified item.</param>
        <param name="value">The value of the associated property.</param>
        <summary>Stores the specified property and value and associates them with the specified item.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to add as a child.</param>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">The text to add.</param>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="itemsControl.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provides a string representation of the <see cref="T:System.Windows.Controls.ItemsControl" /> object.</summary>
        <returns>The string representation of the object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>