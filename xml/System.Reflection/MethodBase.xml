<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cc835ba89554a81318a5948b06c2447df89fe759" />
    <Meta Name="ms.sourcegitcommit" Value="254e16ae65e82f4aa59360cd8572b36b6b5b2f80" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/05/2018" />
    <Meta Name="ms.locfileid" Value="30826215" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce informazioni su metodi e costruttori.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `MethodBase` è la classe di base di <xref:System.Reflection.MethodInfo> e <xref:System.Reflection.ConstructorInfo>.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per l'attendibilità totale per gli eredi. Questa classe non può essere ereditata da codice parzialmente attendibile.</permission>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Quando si eredita da <see langword="MethodBase" />, è necessario eseguire l'override dei seguenti membri: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> , <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, e <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.MethodBase" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene gli attributi associati a questo metodo.</summary>
        <value>Uno dei valori di <see cref="T:System.Reflection.MethodAttributes" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti i membri dispongono di un set di attributi, che sono definiti in relazione al tipo specifico di membro.  
  
 Per ottenere il <xref:System.Reflection.MethodAttributes>, ottenere innanzitutto il tipo. Dal tipo, il metodo get. Dal metodo, ottenere il <xref:System.Reflection.MethodAttributes>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare gli attributi del metodo Mymethod definito dall'utente.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 L'output del codice è il seguente:  
  
 Esempio Reflection.MethodBase.Attributes  
  
 Mymethodbase = Mymethod Void (Int32, System. String ByRef, System. String ByRef)  
  
 PrivateScope  
  
 FamANDAssem  
  
 Famiglia  
  
 Public  
  
 HideBySig  
  
 ReuseSlot  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Utilizzare il <see cref="P:System.Reflection.MethodBase.Attributes" /> proprietà per determinare se un metodo è <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />e così via.</para>
        </block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica le convenzioni di chiamata per questo metodo.</summary>
        <value>Oggetto <see cref="T:System.Reflection.CallingConventions" /> per questo metodo.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo generico contiene parametri di tipo generico non assegnati.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Reflection.MethodBase" /> corrente rappresenta un metodo generico contenente parametri di tipo generico non assegnati; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un metodo generico può essere richiamato solo se non sono disponibili definizioni di tipo generico o i tipi costruiti aperti negli argomenti di tipo del metodo stesso o in dei tipi. Poiché i tipi possono essere arbitrariamente complessi, ottenere questa conferma ricorsiva è difficile. Per motivi di praticità e per ridurre le probabilità di errore, il <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> proprietà fornisce un modo per distinguere tra metodi costruiti chiusi, che possono essere richiamati, standard e metodi, che non può essere costruito aperto. Se il <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> restituisce proprietà `true`, il metodo non può essere richiamato.  
  
 Il <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> proprietà di ricerca in modo ricorsivo per i parametri di tipo. Ad esempio, viene restituito `true` per ogni metodo in un tipo aperto `A<T>` (`A(Of T)` in Visual Basic), anche se il metodo non è generico. Ciò si differenzia dal comportamento del <xref:System.Reflection.MethodBase.IsGenericMethod%2A> proprietà, che restituisce `false` per tale metodo.  
  
 Analogamente, il <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> parametro property restituisce `true` per qualsiasi altro costruttore in un tipo aperto, anche se costruttori non possono avere parametri di tipo i propri.  
  
 Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <xref:System.Reflection.MethodBase.IsGenericMethod%2A> proprietà. Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con questa istanza o <see langword="null" />.</param>
        <summary>Restituisce un valore che indica se questa istanza è uguale a un oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> è uguale al tipo e al valore di questa istanza; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see langword="MethodBase" /> che rappresenta il metodo attualmente in esecuzione.</summary>
        <returns>
          <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> è un metodo statico che viene chiamato dall'interno di un metodo in esecuzione e che restituisce informazioni su tale metodo.  
  
 Oggetto <see langword="MethodBase" /> che rappresenta il metodo attualmente in esecuzione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è definito il metodo attualmente in esecuzione su un tipo generico, la <xref:System.Reflection.MethodInfo> restituito da <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> viene ottenuto dalla definizione di tipo generico (vale a dire <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> restituisce `true`). Pertanto, non riflette gli argomenti di tipo che sono stati utilizzati durante la chiamata del metodo. Ad esempio, se un metodo `M()` è definito su un tipo generico `C<T>` (`C(Of T)` in Visual Basic), e <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> viene chiamato da `C<string>.M()`, quindi <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> restituisce `C<T>.M()` (`C(Of T).M()` in Visual Basic).  
  
 Se il metodo attualmente in esecuzione è un metodo generico, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> restituisce la definizione di metodo generico. Se il metodo generico è definito su un tipo generico, la <xref:System.Reflection.MethodInfo> viene ottenuto dalla definizione di tipo generico.  
  
   
  
## Examples  
 L'esempio seguente definisce due tipi. La prima è una classe non generica, `TestClass`, include un costruttore, un metodo denominato `GetValue`e una proprietà di lettura / scrittura denominata `GetValue`. La seconda è una classe generica denominata `TestClass<T>` che include un costruttore, un `GetValue` (metodo) e un metodo generico, `ConvertValue<Y>`. Ogni costruttore, il metodo e funzione di accesso proprietà include una chiamata al <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> metodo.  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di oggetti <see cref="T:System.Type" /> che rappresentano gli argomenti di tipo di un metodo generico o i parametri di tipo della definizione di un metodo generico.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Type" /> che rappresentano gli argomenti di tipo di un metodo generico o i parametri di tipo della definizione di un metodo generica. Restituisce una matrice vuota se il metodo corrente non è un metodo generico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi della matrice restituita sono nell'ordine in cui compaiono nell'elenco dei parametri di tipo per il metodo generico.  
  
-   Se il metodo corrente è un metodo costruito chiuso (vale a dire il <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> restituisce proprietà `false`), la matrice restituita dal <xref:System.Reflection.MethodBase.GetGenericArguments%2A> metodo contiene i tipi che sono stati assegnati ai parametri di tipo generico del metodo generico definizione.  
  
-   Se il metodo corrente è una definizione di metodo generico, la matrice contiene i parametri di tipo.  
  
-   Se il metodo corrente è un metodo costruito aperto (ovvero, il <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> restituisce proprietà `true`) in tipi specifici assegnati ad alcuni parametri di tipo e il tipo di parametri di tipi generici di inclusione sono stati assegnati a altro tipo i parametri, la matrice contiene i tipi e tipo di parametri. Utilizzare il <xref:System.Type.IsGenericParameter%2A> proprietà per distinguerli. Per una dimostrazione di questo scenario, vedere l'esempio di codice fornito per il <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> proprietà.  
  
 I costruttori generici non sono supportati in .NET Framework versione 2.0. Questa proprietà genera <xref:System.NotSupportedException> pertanto, se non sottoposto a override in una classe derivata, viene generata un'eccezione se l'istanza corrente è di tipo <xref:System.Reflection.ConstructorInfo>.  
  
 Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <xref:System.Reflection.MethodBase.IsGenericMethod%2A> proprietà. Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'oggetto corrente è un <see cref="T:System.Reflection.ConstructorInfo" />. I costruttori generici non sono supportati in .NET Framework versione 2.0. Questa eccezione rappresenta il comportamento predefinito se non viene eseguito l'override del metodo in una classe derivata.</exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se viene eseguito l'override in una classe derivata, ottiene un oggetto <see cref="T:System.Reflection.MethodBody" /> che consente di accedere al flusso MSIL, alle variabili locali e alle eccezioni per il metodo corrente.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.MethodBody" /> che consente di accedere al flusso MSIL, alle variabili locali e alle eccezioni per il metodo corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è necessario eseguire l'override di <xref:System.Reflection.MethodBase.GetMethodBody%2A> per utilizzarlo. È possibile chiamare il <xref:System.Reflection.MethodBase.GetMethodBody%2A> metodo <xref:System.Reflection.MethodInfo> e <xref:System.Reflection.ConstructorInfo> oggetti, poiché il metodo viene sottoposto a override nelle versioni di queste classi di runtime. Ad esempio, la versione di runtime del <xref:System.Reflection.MethodInfo> deriva dalla classe di <xref:System.Reflection.MethodInfo> (classe), che a sua volta deriva dal <xref:System.Reflection.MethodBase> classe.  
  
   
  
## Examples  
 Esempio di codice seguente definisce un metodo di test denominato `MethodBodyExample` e vengono visualizzate le informazioni sulle variabili locali e clausole di gestione delle eccezioni. Il <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> metodo viene utilizzato per ottenere un <xref:System.Reflection.MethodBody> oggetto per il metodo di test.  
  
 Il <xref:System.Reflection.MethodBody.LocalVariables%2A> proprietà viene utilizzata per ottenere un elenco di <xref:System.Reflection.LocalVariableInfo> oggetti e visualizzare i relativi tipi e l'ordine dell'indice. Il <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> proprietà viene utilizzata per ottenere un elenco di clausole di gestione delle eccezioni.  
  
> [!NOTE]
>  Non tutti i linguaggi di programmazione è possibile generare <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clausole. Nell'esempio di Visual Basic viene illustrata una clausola di filtro, utilizzando un Visual Basic `When` espressione, che viene omesso dagli esempi per le altre lingue.  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questo metodo non è valido a meno che non venga sottoposto a override in una classe derivata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso ai metadati per i membri. Valore di autorizzazione: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene informazioni sul metodo utilizzando l'handle specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Handle del metodo.</param>
        <summary>Ottiene le informazioni sul metodo utilizzando la rappresentazione interna dei metadati (handle) del metodo.</summary>
        <returns>
          <see langword="MethodBase" /> contenente informazioni sul metodo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Handle sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Handle per la rappresentazione dei metadati interni di un costruttore o di un metodo.</param>
        <param name="declaringType">Handle al tipo generico che definisce il costruttore o il metodo.</param>
        <summary>Ottiene un oggetto <see cref="T:System.Reflection.MethodBase" /> per il costruttore o il metodo rappresentati dall'handle specificato, per il tipo generico specificato.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.MethodBase" /> che rappresenta il metodo o il costruttore specificati da <paramref name="handle" />, nel tipo generico specificato da <paramref name="declaringType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Handle sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.  
  
 Oggetto <xref:System.RuntimeMethodHandle> struttura per un costruttore o un metodo di un tipo generico può rappresentare diverse <xref:System.Reflection.MethodBase> oggetti, a seconda dei tipi per i parametri di tipo del tipo generico specificati. Ad esempio, se `class G<T>` (`class G(Of T)` in Visual Basic `generic <T> ref class G` in C++) dispone di un metodo che restituisce il tipo `T`, <xref:System.Reflection.MethodBase> oggetto per il metodo in una classe costruita come `G<int>` è diverso dal <xref:System.Reflection.MethodBase>oggetto relativo al metodo nella definizione di tipo generico.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando è sottoposto a override in una classe derivata, restituisce i flag <see cref="T:System.Reflection.MethodImplAttributes" />.</summary>
        <returns>Flag <see langword="MethodImplAttributes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente definisce un costruttore in un assembly dinamico e quindi utilizza il <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> metodo per visualizzare i flag di implementazione che per impostazione predefinita.  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene sottoposto a override in una classe derivata, ottiene i parametri del metodo o del costruttore specificato.</summary>
        <returns>Matrice di tipo <see langword="ParameterInfo" /> contenente le informazioni corrispondenti alla firma del metodo (o del costruttore) ottenuto mediante reflection da questa istanza di <see langword="MethodBase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa il <xref:System.Reflection.MethodBase.GetParameters%2A> metodo per recuperare i parametri del `Invoke` metodo di un delegato.  
  
 L'esempio definisce un delegato denominato `MyDelegate` e un evento denominato `ev` di tipo `MyDelegate`. Il codice nel `Main` metodo individua la firma dell'evento ottenendo il tipo delegato dell'evento, il recupero di `Invoke` metodo del tipo delegato, quindi il recupero e visualizzazione dei parametri di.  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Richiama il metodo o il costruttore ottenuto mediante reflection da questa istanza di <see langword="MethodInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto su cui richiamare il metodo o il costruttore. Se un metodo è statico, questo argomento viene ignorato. Se un costruttore è statico, questo argomento deve essere <see langword="null" /> oppure un'istanza della classe che definisce il costruttore.</param>
        <param name="parameters">Elenco di argomenti per il metodo o il costruttore richiamato. È costituito da una matrice di oggetti con lo stesso numero, ordine e tipo dei parametri del metodo o del costruttore da richiamare. In assenza di parametri, <c>parameters<see langword="null" /> deve essere </c>.  
  
 Se il metodo o il costruttore rappresentato da questa istanza accetta un parametro <see langword="ref" /> (<see langword="ByRef" /> in Visual Basic), non sono richiesti speciali attributi del parametro per poter richiamare il metodo o il costruttore tramite questa funzione. Qualsiasi oggetto in questa matrice non inizializzato in modo esplicito con un valore conterrà il valore predefinito per quel tipo di oggetto. Per gli elementi di tipo riferimento, questo valore è <see langword="null" />. Per gli elementi di tipo valore, questo valore è 0, 0.0 o <see langword="false" />, a seconda del tipo di elemento specifico.</param>
        <summary>Richiama il metodo o il costruttore rappresentato dall'istanza corrente usando i parametri specificati.</summary>
        <returns>Oggetto che contiene il valore restituito del metodo richiamato o <see langword="null" /> nel caso di un costruttore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che chiama il <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> overload del metodo, passando <xref:System.Reflection.BindingFlags.Default> per `invokeAttr` e `null` per `binder` e `culture`.  
  
 Se il metodo richiamato genera un'eccezione, il <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> metodo restituisce l'eccezione.  
  
 Per richiamare un metodo statico tramite il relativo <xref:System.Reflection.MethodInfo> dell'oggetto, passare `null` per `obj`.  
  
> [!NOTE]
>  Se questo overload viene utilizzato per richiamare un costruttore di istanza, l'oggetto fornito per `obj` viene reinizializzata; ovvero, in cui vengono eseguiti tutti gli inizializzatori di istanza. Il valore restituito è `null`. Se viene richiamato un costruttore di classe, la classe viene reinizializzata; ovvero, vengono eseguiti tutti gli inizializzatori di classi. Il valore restituito è `null`.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a membri pubblici, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dei membri non pubblici è limitato al chiamante o a un sottoinsieme Questi due elementi. (Vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 Se un parametro del metodo corrente è un tipo di valore e l'argomento corrispondente in `parameters` è `null`, il runtime passa un'istanza inizializzata su zero del tipo di valore.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come ricerca del metodo dinamico tramite reflection. Si noti che non è possibile utilizzare il <xref:System.Reflection.MethodInfo> oggetto della classe base per richiamare il metodo sottoposto a override nella classe derivata, perché l'associazione tardiva non è possibile risolvere gli override.  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>  
 In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione <see cref="T:System.Exception" />.  
  
</para>
          </block>  
  
 Il parametro <paramref name="obj" /> è <see langword="null" /> e il metodo non è statico.  
  
 oppure  
  
 Il metodo non è dichiarato né ereditato dalla classe di <paramref name="obj" />.  
  
 oppure  
  
 Viene richiamato un costruttore statico e <paramref name="obj" /> non è <see langword="null" /> né un'istanza della classe che ha dichiarato il costruttore.</exception>
        <exception cref="T:System.ArgumentException">Gli elementi della matrice di <paramref name="parameters" /> non corrispondono alla firma del metodo o del costruttore ottenuto mediante reflection da questa istanza.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il metodo o il costruttore richiamato genera un'eccezione.  
  
 oppure  
  
 L'istanza corrente è un oggetto <see cref="T:System.Reflection.Emit.DynamicMethod" /> contenente codice non verificabile. Vedere la sezione "Verifica" nelle note per <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">La matrice <paramref name="parameters" /> non contiene il numero corretto di argomenti.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.MemberAccessException" />.  
  
</para>
          </block>  
  
 Il chiamante non è autorizzato a eseguire il metodo o il costruttore rappresentato dall'istanza corrente.</exception>
        <exception cref="T:System.InvalidOperationException">Il tipo che dichiara il metodo è un tipo generico aperto, ovvero la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" /> per il tipo dichiarante.</exception>
        <exception cref="T:System.NotSupportedException">L'istanza corrente è <see cref="T:System.Reflection.Emit.MethodBuilder" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto su cui richiamare il metodo o il costruttore. Se un metodo è statico, questo argomento viene ignorato. Se un costruttore è statico, questo argomento deve essere <see langword="null" /> oppure un'istanza della classe che definisce il costruttore.</param>
        <param name="invokeAttr">Maschera di bit equivalente a una combinazione di 0 o più flag di bit da <see cref="T:System.Reflection.BindingFlags" />. Se <c>binder</c> è <see langword="null" />, al parametro viene assegnato il valore <see cref="F:System.Reflection.BindingFlags.Default" />; di conseguenza, verrà ignorato qualsiasi elemento passato.</param>
        <param name="binder">Oggetto che consente il binding, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see langword="MemberInfo" /> tramite reflection. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="parameters">Elenco di argomenti per il metodo o il costruttore richiamato. È costituito da una matrice di oggetti con lo stesso numero, ordine e tipo dei parametri del metodo o del costruttore da richiamare. In assenza di parametri, deve essere <see langword="null" />.  
  
 Se il metodo o il costruttore rappresentati da questa istanza accettano un parametro ByRef, non sono richiesti attributi speciali per tale parametro per poter richiamare il metodo o il costruttore che utilizza la funzione. Qualsiasi oggetto in questa matrice non inizializzato in modo esplicito con un valore conterrà il valore predefinito per quel tipo di oggetto. Per gli elementi di tipo riferimento, questo valore è <see langword="null" />. Per gli elementi di tipo valore, questo valore è 0, 0.0 o <see langword="false" />, a seconda del tipo di elemento specifico.</param>
        <param name="culture">Istanza di <see langword="CultureInfo" /> usata per regolare la coercizione dei tipi. Se è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see langword="CultureInfo" />. Si tratta di un parametro necessario per convertire un oggetto <see langword="String" /> che rappresenta, ad esempio, il numero 1000 in un valore <see langword="Double" />, dal momento che questo numero è rappresentato in modo diverso nelle varie impostazioni cultura.</param>
        <summary>Quando viene sottoposto a override in una classe derivata, richiama il metodo o il costruttore ottenuto mediante reflection con i parametri specificati.</summary>
        <returns>
          <see langword="Object" /> contenente il valore restituito del metodo richiamato, oppure <see langword="null" /> nel caso di un costruttore, oppure <see langword="null" /> se il tipo restituito dal metodo è <see langword="void" />. Prima di chiamare il metodo o il costruttore, <see langword="Invoke" /> verifica che l'utente disponga dell'autorizzazione per l'accesso e che i parametri siano validi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Richiama dinamicamente il metodo ottenuto mediante reflection da questa istanza `obj`e passa i parametri specificati. Se il metodo è statico, il `obj` parametro viene ignorato. Per i metodi non statici `obj` deve essere un'istanza di una classe che eredita o dichiara il metodo e deve essere dello stesso tipo di questa classe. Se il metodo non ha parametri, il valore di `parameters` deve essere `null`. In caso contrario, il numero, tipo e l'ordine degli elementi in `parameters` deve essere identico a numero, tipo e ordine dei parametri per il metodo ottenuto mediante reflection da questa istanza.  
  
 Non è possibile omettere i parametri facoltativi nelle chiamate a `Invoke`. Per richiamare un metodo omettendo i parametri facoltativi, è necessario chiamare `Type.InvokeMember` invece.  
  
> [!NOTE]
>  Se questo overload viene utilizzato per richiamare un costruttore di istanza, l'oggetto fornito per `obj` viene reinizializzata; ovvero, in cui vengono eseguiti tutti gli inizializzatori di istanza. Il valore restituito è `null`. Se viene richiamato un costruttore di classe, la classe viene reinizializzata; ovvero, vengono eseguiti tutti gli inizializzatori di classi. Il valore restituito è `null`.  
  
 Per i parametri primitivi pass-by-value, viene eseguito un ampliamento normale (Int16 -> Int32, ad esempio). Per i parametri di riferimento di pass-by-value, (classe di base e la classe base per il tipo di interfaccia, una classe derivata) è consentito un ampliamento normale del riferimento. Tuttavia, per i parametri primitivi passata per riferimento, i tipi devono corrispondere. Per i parametri di riferimento di passaggio per riferimento, l'ampliamento normale ancora valide.  
  
 Ad esempio, se il metodo ottenuto mediante reflection da questa istanza è dichiarata come `public boolean Compare(String a, String b)`, quindi `parameters` deve essere una matrice di `Objects` con lunghezza 2 tale `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.  
  
 Se un parametro del metodo corrente è un tipo di valore e l'argomento corrispondente in `parameters` è `null`, il runtime passa un'istanza inizializzata su zero del tipo di valore.  
  
 Reflection Usa ricerca del metodo dinamico durante la chiamata di metodi virtuali. Ad esempio, si supponga che la classe B eredita dalla classe e implementano un metodo virtuale denominato M. Ora si supponga di avere un `MethodInfo` oggetto che rappresenta M sulla classe A. Se si utilizza il `Invoke` metodo da richiamare M su un oggetto di tipo B, la reflection utilizzerà l'implementazione fornita dalla classe B. Anche se l'oggetto di tipo B viene eseguito il cast ad A, viene utilizzata l'implementazione fornita dalla classe B (vedere l'esempio di codice riportato di seguito).  
  
 D'altra parte, se il metodo non virtuale, quindi reflection utilizzerà l'implementazione fornita dal tipo dal quale il `MethodInfo` è stato ottenuto, indipendentemente dal tipo dell'oggetto passato come destinazione.  
  
 Le restrizioni di accesso vengono ignorate per il codice completamente attendibile. Vale a dire, proprietà, metodi, campi e costruttori privati accessibili e richiamate tramite reflection, ogni volta che il codice è completamente attendibile.  
  
 Se il metodo richiamato genera un'eccezione, `TargetInvocationException.GetException` restituisce l'eccezione. Questa implementazione genera un `NotSupportedException`.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a membri pubblici, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dei membri non pubblici è limitato al chiamante o a un sottoinsieme Questi due elementi. (Vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti i membri del <xref:System.Reflection.Binder?displayProperty=nameWithType> classe utilizzando un overload di <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>. Il metodo privato `CanConvertFrom` ricerca tipi compatibili per un determinato tipo. Per un altro esempio di richiamo dei membri in uno scenario di associazione personalizzata, vedere [in modo dinamico durante il caricamento e utilizzo dei tipi](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">Il parametro <paramref name="obj" /> è <see langword="null" /> e il metodo non è statico.  
  
 oppure  
  
 Il metodo non è dichiarato né ereditato dalla classe di <paramref name="obj" />.  
  
 oppure  
  
 Viene richiamato un costruttore statico e <paramref name="obj" /> non è <see langword="null" /> né un'istanza della classe che ha dichiarato il costruttore.</exception>
        <exception cref="T:System.ArgumentException">Il tipo del parametro <paramref name="parameters" /> non corrisponde alla firma del metodo o del costruttore ottenuto mediante reflection da questa istanza.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">La matrice <paramref name="parameters" /> non contiene il numero corretto di argomenti.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il metodo o il costruttore richiamato genera un'eccezione.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non è autorizzato a eseguire il metodo o il costruttore rappresentato dall'istanza corrente.</exception>
        <exception cref="T:System.InvalidOperationException">Il tipo che dichiara il metodo è un tipo generico aperto, ovvero la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" /> per il tipo dichiarante.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo è astratto.</summary>
        <value>
          <see langword="true" /> se il metodo è astratto; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un membro astratto viene dichiarato in una classe base e non ha fornito alcuna implementazione.  
  
 Per ottenere il <xref:System.Reflection.MethodBase>, ottenere innanzitutto il tipo. Dal tipo, il metodo get. Dal metodo, ottenere il `MethodBase`. Se il `MethodBase` o costruttore non è pubblico, è protetto e non è possibile accedervi. Per accedere a un metodo non pubblico, impostare il <xref:System.Reflection.BindingFlags> maschera per `NonPublic` in `GetMethod`.  
  
   
  
## Examples  
 Nell'esempio seguente determina se il metodo è astratto e vengono visualizzati i risultati specificati.  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la visibilità potenziale di questo metodo o costruttore è descritta da <see cref="F:System.Reflection.MethodAttributes.Assembly" />, ovvero se il metodo o costruttore è visibile al massimo ad altri tipi dello stesso assembly, ma non ai tipi derivati all'esterno dell'assembly.</summary>
        <value>
          <see langword="true" /> se la visibilità di questo metodo o costruttore è descritta esattamente da <see cref="F:System.Reflection.MethodAttributes.Assembly" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La visibilità di un metodo effettiva è limitata dalla visibilità del relativo tipo. Il <xref:System.Reflection.MethodBase.IsAssembly%2A> proprietà potrebbe essere `true` per un metodo, ma se è un metodo di un tipo annidato privato, quindi il metodo non è visibile all'esterno del tipo che lo contiene.  
  
 La visibilità di un metodo o costruttore è descritta esattamente da <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> se è l'unico modificatore di visibilità `internal` (`Friend` in Visual Basic). Questa proprietà è `false` per i metodi che vengono `protected internal` in c# (`Protected Friend` in Visual Basic `protected public` in C++); usare il <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> proprietà per identificare tali metodi.  
  
   
  
## Examples  
 Esempio di codice seguente definisce i metodi con livelli di visibilità e visualizza i valori di loro <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, e <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> proprietà.  
  
> [!NOTE]
>  I linguaggi Visual Basic e c# non possono definire metodi con <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilità; che il livello di accesso viene visualizzata solo nell'esempio C++.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo è un costruttore.</summary>
        <value>
          <see langword="true" /> se il metodo è un costruttore rappresentato da un oggetto <see cref="T:System.Reflection.ConstructorInfo" /> (vedere la nota sugli oggetti <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> nella sezione Osservazioni); in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il <xref:System.Reflection.MethodBase.IsConstructor%2A> restituisce proprietà `false` per un <xref:System.Reflection.Emit.ConstructorBuilder> dell'oggetto in un tipo dinamico, a meno che il <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag è stato incluso nel `attributes` parametro quando il costruttore è stato definito. L'omissione di <xref:System.Reflection.MethodAttributes.RTSpecialName> flag non influisce sulla correttezza del costruttore creato.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la visibilità di questo metodo o costruttore è descritta da <see cref="F:System.Reflection.MethodAttributes.Family" />, ovvero se il metodo o costruttore è visibile solo all'interno della relativa classe e delle classi derivate.</summary>
        <value>
          <see langword="true" /> se l'accesso al metodo o costruttore è descritto esattamente da <see cref="F:System.Reflection.MethodAttributes.Family" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La visibilità di un metodo o costruttore è descritta esattamente da <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> se è l'unico modificatore di visibilità `protected`. Questa proprietà è `false` per i metodi che vengono `protected internal` in c# (`Protected Friend` in Visual Basic `protected public` in C++); usare il <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> proprietà per identificare tali metodi.  
  
   
  
## Examples  
 Esempio di codice seguente definisce i metodi con livelli di visibilità e visualizza i valori di loro <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, e <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> proprietà.  
  
> [!NOTE]
>  I linguaggi Visual Basic e c# non possono definire metodi con <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilità; che il livello di accesso viene visualizzata solo nell'esempio C++.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la visibilità di questo metodo o costruttore è descritta da <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />, ovvero se è possibile chiamare il metodo o il costruttore da classi derivate, ma solo se appartenenti allo stesso assembly.</summary>
        <value>
          <see langword="true" /> se l'accesso al metodo o costruttore è descritto esattamente da <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La visibilità di un metodo o costruttore è descritta esattamente da <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> se il modificatore di visibilità `protected private` in C++. Non è possibile definire metodi con questa visibilità in Visual Basic o c#.  
  
   
  
## Examples  
 Esempio di codice seguente definisce i metodi con livelli di visibilità e visualizza i valori di loro <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, e <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> proprietà.  
  
> [!NOTE]
>  I linguaggi Visual Basic e c# non possono definire metodi con <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilità; che il livello di accesso viene visualizzata solo nell'esempio C++.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la visibilità potenziale di questo metodo o costruttore è descritta da <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />, ovvero se è possibile chiamare il metodo o il costruttore da classi derivate indipendentemente dalla posizione e da classi appartenenti allo stesso assembly.</summary>
        <value>
          <see langword="true" /> se l'accesso al metodo o costruttore è descritto esattamente da <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un membro di tipo è <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibilità può essere chiamato da qualsiasi membro in una classe derivata o qualsiasi membro nello stesso assembly, ma non da qualsiasi altro tipo.  
  
 La visibilità di un metodo effettiva è limitata dalla visibilità del relativo tipo. Il <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> proprietà potrebbe essere `true` per un metodo, ma se è un metodo di un tipo annidato privato, quindi il metodo non è visibile all'esterno del tipo che lo contiene.  
  
 La visibilità di un metodo o costruttore è descritta esattamente da <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> se il modificatore di visibilità `protected internal` in c# (`Protected Friend` in Visual Basic `protected public` in C++).  
  
   
  
## Examples  
 Esempio di codice seguente definisce i metodi con livelli di visibilità e visualizza i valori di loro <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, e <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> proprietà.  
  
> [!NOTE]
>  I linguaggi Visual Basic e c# non possono definire metodi con <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilità; che il livello di accesso viene visualizzata solo nell'esempio C++.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo è <see langword="final" />.</summary>
        <value>
          <see langword="true" /> se questo metodo è <see langword="final" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per determinare se un metodo sottoponibile a override, non è sufficiente verificare che <xref:System.Reflection.MethodBase.IsVirtual%2A> è `true`. Per un metodo essere sottoposto a override, `IsVirtual` deve essere `true` e `IsFinal` deve essere `false`. Ad esempio, un metodo potrebbe essere non virtuale, ma implementa un metodo di interfaccia. Common language runtime richiede che tutti i metodi che implementano membri di interfaccia devono essere contrassegnati come `virtual`; pertanto, il compilatore contrassegna il metodo `virtual final`. Pertanto vi sono casi in cui un metodo è contrassegnato come `virtual` ma è ancora non sottoponibile a override.  
  
 Per stabilire con certezza se un metodo sottoponibile a override, usare codice simile al seguente:  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 Se `IsVirtual` è `false` o `IsFinal` è `true`, il metodo non può essere sottoposto a override.  
  
   
  
## Examples  
 L'esempio seguente mostra `false` per `IsFinal`, che potrebbe far pensare che MyMethod è sottoponibile a override. Il codice visualizza `false` anche se non è contrassegnato come MyMethod `virtual` e pertanto non può essere sottoposto a override.  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo è generico.</summary>
        <value>
          <see langword="true" /> se la classe <see cref="T:System.Reflection.MethodBase" /> corrente rappresenta un metodo generico; in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Reflection.MethodBase.IsGenericMethod%2A> proprietà per determinare se l'oggetto corrente <xref:System.Reflection.MethodBase> oggetto rappresenta un metodo generico. Utilizzare il <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> proprietà per determinare se l'oggetto corrente <xref:System.Reflection.MethodBase> oggetto rappresenta un metodo costruito aperto o chiuso.  
  
> [!NOTE]
>  Generics non supportati per impostazione predefinita. Questa proprietà restituisce `false` se non viene sottoposto a override in una classe derivata. I costruttori generici non sono supportati in .NET Framework versione 2.0, questa proprietà restituisce `false` se l'istanza corrente è di tipo <xref:System.Reflection.ConstructorInfo>.  
  
Nella tabella seguente vengono riepilogate le condizioni invariante per condizioni specifiche per i metodi generici. Per altri termini utilizzati nella reflection generica, ad esempio *parametro di tipo generico* e *tipo generico*, vedere il <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> proprietà.   

|Termine|Condizione dell'invariabile| 
|---|---| 
|definizione di metodo generico| La proprietà <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> è `true`. <br />Definisce un metodo generico. Viene creato un metodo costruito chiamando il <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metodo su un <xref:System.Reflection.MethodInfo> dell'oggetto che rappresenta una definizione di metodo generico e specificando una matrice di argomenti di tipo. <br />Il <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> metodo può essere chiamato solo in definizioni di metodo generico. <br/>Qualsiasi definizione di metodo generico è un metodo generico, ma non è vero il contrario.|    
|metodo generico|La proprietà `IsGenericMethod` è `true`. <br/> Può essere una definizione di metodo generico, un metodo costruito aperto o chiuso.| 
|Open costruito (metodo)|La proprietà <xref:System.Reflection.MethodBase.ContainsGenericParameters> è `true`. <br/>Non è possibile richiamare un metodo costruito aperto.|  
|metodo costruito chiuso|La proprietà <xref:System.Reflection.MethodBase.ContainsGenericParameters> è `false`. <br/>Quando viene esaminato in modo ricorsivo, il metodo non dispone di alcun parametro generico non assegnati. Il tipo contenitore non dispone di alcun parametro di tipo generico e nessuno degli argomenti di tipo dispone di parametri di tipo generico. <br/>Il metodo può essere richiamato.|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo è una definizione di un metodo generico.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Reflection.MethodBase" /> corrente rappresenta la definizione di un metodo generico; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Reflection.MethodBase> rappresenta la definizione di un metodo generico:  
  
-   La proprietà <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> è `true`.  
  
-   Per ogni <xref:System.Type> oggetto nella matrice restituita dal <xref:System.Reflection.MethodBase.GetGenericArguments%2A> metodo:  
  
    -   La proprietà <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> è `true`.  
  
    -   Il <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> proprietà restituisce l'istanza corrente.  
  
    -   Il <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> proprietà corrisponde alla posizione del <xref:System.Type> oggetto nella matrice.  
  
> [!NOTE]
>  Generics non supportati per impostazione predefinita. Questa proprietà restituisce `false` se non viene sottoposto a override in una classe derivata. I costruttori generici non sono supportati in .NET Framework versione 2.0, questa proprietà restituisce `false` se l'istanza corrente è di tipo <xref:System.Reflection.ConstructorInfo>.  
  
 Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <xref:System.Reflection.MethodBase.IsGenericMethod%2A> proprietà. Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se nella classe derivata è nascosto un solo membro dello stesso tipo che riporta esattamente la stessa firma.</summary>
        <value>
          <see langword="true" /> se il membro è nascosto dalla firma; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un membro in una classe derivata viene dichiarato con c# `new` modificatore o Visual Basic `Shadows` modificatore, può nascondere un membro con lo stesso nome nella classe base. C# consente di nascondere i membri della classe base dalla firma. Se il membro della classe base dispone di più overload, l'unico nascosta è quello che ha una firma identica. Al contrario, Visual Basic nasconde tutti gli overload della classe di base. Di conseguenza, <xref:System.Reflection.MethodBase.IsHideBySig%2A> restituisce `false` in un membro dichiarato con Visual Basic `Shadows` modificatore, e `true` su un membro dichiarato con c# `new` modificatore.  
  
> [!WARNING]
>  Questa proprietà determina se un metodo dispone di <xref:System.Reflection.MethodAttributes.NewSlot> attributo. Un metodo che è dichiarato con la `new` o `Shadows` modificatore avrà il <xref:System.Reflection.MethodAttributes.NewSlot> attributo, ma solo i metodi dichiarati con `new` (vale a dire solo metodi c#) avrà il <xref:System.Reflection.MethodBase.IsHideBySig%2A> proprietà è impostata su `true`.  Per determinare se un metodo ha il <xref:System.Reflection.MethodAttributes.NewSlot> attributo, utilizzare codice simile al seguente: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in c# o `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic. Si noti, tuttavia, che anche se tutti i metodi dichiarati con `new` o `Shadows` hanno il <xref:System.Reflection.MethodAttributes.NewSlot> attributo, non tutti i metodi che presentano il <xref:System.Reflection.MethodAttributes.NewSlot> attributo vengono dichiarati con `new` o `Shadows`.  
  
   
  
## Examples  
 Esempio di codice seguente contiene una classe base con un metodo di overload e una classe derivata che consente di nascondere uno degli overload. La versione di Visual Basic dell'esempio di codice, il <xref:System.Reflection.MethodBase.IsHideBySig%2A> restituisce proprietà `false` per il membro nella classe derivata. Nella versione c# dell'esempio di codice, la proprietà restituisce `true` per il membro nella classe derivata.  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se questo membro è privato.</summary>
        <value>
          <see langword="true" /> se l'accesso al metodo è limitato agli altri membri della classe; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un membro di tipo è `Private` visibilità livello, può essere chiamato da qualsiasi membro nella stessa classe e non da altri.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se si tratta di un metodo pubblico.</summary>
        <value>
          <see langword="true" /> se il metodo è pubblico; in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere il <xref:System.Reflection.MethodBase>, ottenere innanzitutto il tipo. Dal tipo, il metodo get. Dal metodo, ottenere il `MethodBase`. Se il `MethodBase` o costruttore non è pubblico, è protetto e non è possibile accedervi. Per accedere a un metodo non pubblico, impostare il <xref:System.Reflection.BindingFlags> maschera per `NonPublic` in `GetMethod`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Reflection.MethodBase.IsPublic%2A> proprietà per visualizzare un messaggio che indica se il metodo specificato è pubblico.  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo o il costruttore corrente è critico per la sicurezza o security-safe-critical al livello di attendibilità corrente, e pertanto può eseguire operazioni critiche.</summary>
        <value>
          <see langword="true" /> se il metodo o costruttore corrente è critico per la sicurezza o security-safe-critical al livello di attendibilità corrente; <see langword="false" /> se è trasparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> riportano il livello di trasparenza del metodo o costruttore al livello di attendibilità corrente, come determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Utilizzo di queste proprietà è molto più semplice che esaminare le annotazioni di sicurezza di un assembly e i relativi tipi e membri, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
> [!IMPORTANT]
>  Per gli assembly parzialmente attendibile, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly. Se l'assembly viene caricato in un dominio di applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi vengono considerati come trasparente. Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando l'assembly viene caricato in un dominio applicazione completamente attendibile (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). Al contrario, un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il relativo livello di attendibilità corrente è sempre completamente attendibile. È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly utilizzando il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà.  
  
 Per ulteriori informazioni sulla reflection e trasparenza, vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Per informazioni su trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo o il costruttore corrente è security-safe-critical al livello di attendibilità corrente, vale a dire se può eseguire operazioni critiche ed essere richiamato da codice trasparente.</summary>
        <value>
          <see langword="true" /> se il metodo o costruttore corrente è security-safe-critical al livello di attendibilità corrente; <see langword="false" /> se è critico per la sicurezza o trasparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> riportano il livello di trasparenza del metodo o costruttore al livello di attendibilità corrente, come determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Utilizzo di queste proprietà è molto più semplice che esaminare le annotazioni di sicurezza di un assembly e i relativi tipi e membri, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
> [!IMPORTANT]
>  Per gli assembly parzialmente attendibile, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly. Se l'assembly viene caricato in un dominio di applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi vengono considerati come trasparente. Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando l'assembly viene caricato in un dominio applicazione completamente attendibile (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). Al contrario, un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il relativo livello di attendibilità corrente è sempre completamente attendibile. È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly utilizzando il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà.  
  
 Per ulteriori informazioni sulla reflection e trasparenza, vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Per informazioni su trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo o il costruttore corrente è trasparente al livello di attendibilità corrente, e pertanto non può eseguire operazioni critiche.</summary>
        <value>
          <see langword="true" /> se il metodo o costruttore corrente è SecurityTrasparent al livello di attendibilità corrente; in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questa proprietà restituisce `true`, <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> e <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> restituiscono `false`.  
  
 Il <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> riportano il livello di trasparenza del metodo o costruttore al livello di attendibilità corrente, come determinato da common language runtime (CLR). Utilizzo di queste proprietà è molto più semplice che esaminare le annotazioni di sicurezza di un assembly e i relativi tipi e membri, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
> [!IMPORTANT]
>  Per gli assembly parzialmente attendibile, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly. Se l'assembly viene caricato in un dominio di applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi vengono considerati come trasparente. Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando l'assembly viene caricato in un dominio applicazione completamente attendibile (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). Al contrario, un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il relativo livello di attendibilità corrente è sempre completamente attendibile. È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly utilizzando il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà.  
  
 Per ulteriori informazioni sulla reflection e trasparenza, vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Per informazioni su trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se questo metodo ha un nome speciale.</summary>
        <value>
          <see langword="true" /> se questo metodo ha un nome speciale; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.MethodAttributes.SpecialName> bit viene impostato su membri di flag che sono gestiti in modo speciale da alcuni compilatori (ad esempio funzioni di accesso a proprietà e metodi di overload di operatori).  
  
   
  
## Examples  
 In questo esempio viene illustrato un utilizzo di <xref:System.Reflection.MethodBase.IsSpecialName%2A> per filtrare interni o membri privati da un elenco.  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo è <see langword="static" />.</summary>
        <value>
          <see langword="true" /> se questo metodo è <see langword="static" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un membro statico in modo implicito non può fare riferimento a dati di istanza in una classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il metodo è <see langword="virtual" />.</summary>
        <value>
          <see langword="true" /> se questo metodo è <see langword="virtual" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un membro virtuale può fare riferimento a dati di istanza in una classe e deve fare riferimento tramite un'istanza della classe.  
  
 Per determinare se un metodo sottoponibile a override, non è sufficiente verificare che `IsVirtual` è `true`. Per un metodo essere sottoposto a override, `IsVirtual` deve essere `true` e <xref:System.Reflection.MethodBase.IsFinal%2A> deve essere `false`. Ad esempio, un metodo potrebbe essere non virtuale, ma implementa un metodo di interfaccia. Common language runtime richiede che tutti i metodi che implementano membri di interfaccia devono essere contrassegnati come `virtual`; pertanto, il compilatore contrassegna il metodo `virtual final`. Pertanto vi sono casi in cui un metodo è contrassegnato come `virtual` ma è ancora non sottoponibile a override.  
  
 Per stabilire con certezza se un metodo sottoponibile a override, usare codice simile al seguente:  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 Se `IsVirtual` è `false` o `IsFinal` è `true`, il metodo non può essere sottoposto a override.  
  
 È possibile determinare se il metodo corrente esegue l'override di un metodo in una classe base chiamando il <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> metodo. Nell'esempio seguente viene implementato un `IsOverride` metodo che esegue questa operazione.  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 L'esempio seguente mostra `false` per `IsFinal`, che potrebbe far pensare che `MyMethod` è sottoponibile a override. Il codice visualizza `false` anche se `MyMethod` non è contrassegnato come `virtual` e pertanto non può essere sottoposto a override.  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un handle alla rappresentazione interna dei metadati di un metodo.</summary>
        <value>Un oggetto <see cref="T:System.RuntimeMethodHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli handle sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i flag <see cref="T:System.Reflection.MethodImplAttributes" /> che specificano gli attributi di implementazione di un metodo.</summary>
        <value>Flag di implementazione dei metodi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni, vedere il metodo <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">Primo oggetto da confrontare.</param>
        <param name="right">Secondo oggetto da confrontare.</param>
        <summary>Indica se due oggetti <see cref="T:System.Reflection.MethodBase" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">Primo oggetto da confrontare.</param>
        <param name="right">Secondo oggetto da confrontare.</param>
        <summary>Indica se due oggetti <see cref="T:System.Reflection.MethodBase" /> non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> non è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="rgszNames">Matrice di nomi passata di cui eseguire il mapping.</param>
        <param name="cNames">Conteggio dei nomi di cui eseguire il mapping.</param>
        <param name="lcid">Contesto delle impostazioni locali in cui interpretare i nomi.</param>
        <param name="rgDispId">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</param>
        <summary>Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetIDsOfNames`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</summary>
        <returns>Per una descrizione di questo membro, vedere <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informazioni sul tipo da restituire.</param>
        <param name="lcid">Identificatore delle impostazioni locali per le informazioni sul tipo.</param>
        <param name="ppTInfo">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</param>
        <summary>Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfo`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</param>
        <summary>Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfoCount`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica il membro.</param>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="lcid">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</param>
        <param name="wFlags">Flag che descrivono il contesto della chiamata.</param>
        <param name="pDispParams">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</param>
        <param name="pVarResult">Puntatore alla posizione in cui deve essere archiviato il risultato.</param>
        <param name="pExcepInfo">Puntatore a una struttura contenente informazioni sull'eccezione.</param>
        <param name="puArgErr">Indice del primo argomento che contiene un errore.</param>
        <summary>Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::Invoke`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Reflection.MethodBase> a un'interfaccia <xref:System.Runtime.InteropServices._MethodBase>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>