<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodBase.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac55a27c711459e7ed675df80d23d28b658e1d7b113.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5a27c711459e7ed675df80d23d28b658e1d7b113</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Provides information about methods and constructors.</source>
          <target state="translated">Fornisce informazioni su metodi e costruttori.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source><ph id="ph1">`MethodBase`</ph> is the base class of <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`MethodBase`</ph> è la classe di base di <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>for full trust for inheritors.</source>
          <target state="translated">per l'attendibilità totale per gli eredi.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Questa classe non può essere ereditata da codice parzialmente attendibile.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This type is thread safe.</source>
          <target state="translated">Questo tipo è thread-safe.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>When you inherit from <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, you must override the following members: <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, and <ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">Quando si eredita da <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, è necessario eseguire l'override dei seguenti membri: <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> , <ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, e <ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Gets the attributes associated with this method.</source>
          <target state="translated">Ottiene gli attributi associati a questo metodo.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values.</source>
          <target state="translated">Uno dei valori di <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>All members have a set of attributes, which are defined in relation to the specific type of member.</source>
          <target state="translated">Tutti i membri dispongono di un set di attributi, che sono definiti in relazione al tipo specifico di membro.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, first get the type.</source>
          <target state="translated">Per ottenere il <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, ottenere innanzitutto il tipo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the type, get the method.</source>
          <target state="translated">Dal tipo, il metodo get.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the method, get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</source>
          <target state="translated">Dal metodo, ottenere il <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>The following code example displays the attributes of the user-defined method Mymethod.</source>
          <target state="translated">Esempio di codice seguente consente di visualizzare gli attributi del metodo Mymethod definito dall'utente.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>This code produces the following output:</source>
          <target state="translated">L'output del codice è il seguente:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Reflection.MethodBase.Attributes Sample</source>
          <target state="translated">Esempio Reflection.MethodBase.Attributes</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</source>
          <target state="translated">Mymethodbase = Mymethod Void (Int32, System. String ByRef, System. String ByRef)</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>PrivateScope</source>
          <target state="translated">PrivateScope</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>FamANDAssem</source>
          <target state="translated">FamANDAssem</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Family</source>
          <target state="translated">Famiglia</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Public</source>
          <target state="translated">Public</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>HideBySig</source>
          <target state="translated">HideBySig</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>ReuseSlot</source>
          <target state="translated">ReuseSlot</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph> property to determine whether a method is <ph id="ph2">&lt;see langword="public" /&gt;</ph>, <ph id="ph3">&lt;see langword="private" /&gt;</ph>, <ph id="ph4">&lt;see langword="final" /&gt;</ph>, <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>, and so on.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph> proprietà per determinare se un metodo è <ph id="ph2">&lt;see langword="public" /&gt;</ph>, <ph id="ph3">&lt;see langword="private" /&gt;</ph>, <ph id="ph4">&lt;see langword="final" /&gt;</ph>, <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>e così via.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>Gets a value indicating the calling conventions for this method.</source>
          <target state="translated">Ottiene un valore che indica le convenzioni di chiamata per questo metodo.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> for this method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> per questo metodo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Gets a value indicating whether the generic method contains unassigned generic type parameters.</source>
          <target state="translated">Ottiene un valore che indica se il metodo generico contiene parametri di tipo generico non assegnati.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents a generic method that contains unassigned generic type parameters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> corrente rappresenta un metodo generico contenente parametri di tipo generico non assegnati; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</source>
          <target state="translated">Un metodo generico può essere richiamato solo se non sono disponibili definizioni di tipo generico o i tipi costruiti aperti negli argomenti di tipo del metodo stesso o in dei tipi.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Because types can be arbitrarily complex, making this recursive determination is difficult.</source>
          <target state="translated">Poiché i tipi possono essere arbitrariamente complessi, ottenere questa conferma ricorsiva è difficile.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For convenience, and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</source>
          <target state="translated">Per motivi di praticità e per ridurre le probabilità di errore, il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> proprietà fornisce un modo per distinguere tra metodi costruiti chiusi, che possono essere richiamati, standard e metodi, che non può essere costruito aperto.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the method cannot be invoked.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> restituisce proprietà <ph id="ph2">`true`</ph>, il metodo non può essere richiamato.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> proprietà di ricerca in modo ricorsivo per i parametri di tipo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for any method in an open type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the method itself is not generic.</source>
          <target state="translated">Ad esempio, viene restituito <ph id="ph1">`true`</ph> per ogni metodo in un tipo aperto <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), anche se il metodo non è generico.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for such a method.</source>
          <target state="translated">Ciò si differenzia dal comportamento del <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> proprietà, che restituisce <ph id="ph2">`false`</ph> per tale metodo.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Similarly, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property parameter returns <ph id="ph2">`true`</ph> for any constructor in an open type, even though constructors cannot have type parameters of their own.</source>
          <target state="translated">Analogamente, il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> parametro property restituisce <ph id="ph2">`true`</ph> per qualsiasi altro costruttore in un tipo aperto, anche se costruttori non possono avere parametri di tipo i propri.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto da confrontare con questa istanza o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">Restituisce un valore che indica se questa istanza è uguale a un oggetto specificato.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> è uguale al tipo e al valore di questa istanza; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Returns a <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> che rappresenta il metodo attualmente in esecuzione.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> is a static method that is called from within an executing method and that returns information about that method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> è un metodo statico che viene chiamato dall'interno di un metodo in esecuzione e che restituisce informazioni su tale metodo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> che rappresenta il metodo attualmente in esecuzione.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that is returned by <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is obtained from the generic type definition (that is, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph4">`true`</ph>).</source>
          <target state="translated">Se è definito il metodo attualmente in esecuzione su un tipo generico, la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> restituito da <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> viene ottenuto dalla definizione di tipo generico (vale a dire <ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph> restituisce <ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Therefore, it does not reflect the type arguments that were used when the method was called.</source>
          <target state="translated">Pertanto, non riflette gli argomenti di tipo che sono stati utilizzati durante la chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>For example, if a method <ph id="ph1">`M()`</ph> is defined on a generic type <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> in Visual Basic), and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is called from <ph id="ph5">`C&lt;string&gt;.M()`</ph>, then <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> in Visual Basic).</source>
          <target state="translated">Ad esempio, se un metodo <ph id="ph1">`M()`</ph> è definito su un tipo generico <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> in Visual Basic), e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> viene chiamato da <ph id="ph5">`C&lt;string&gt;.M()`</ph>, quindi <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> restituisce <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is a generic method, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns the generic method definition.</source>
          <target state="translated">Se il metodo attualmente in esecuzione è un metodo generico, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> restituisce la definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the generic method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is obtained from the generic type definition.</source>
          <target state="translated">Se il metodo generico è definito su un tipo generico, la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> viene ottenuto dalla definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The following example defines two types.</source>
          <target state="translated">L'esempio seguente definisce due tipi.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The first is a non-generic class, <ph id="ph1">`TestClass`</ph>, includes a constructor, a method named <ph id="ph2">`GetValue`</ph>, and a read-write property named <ph id="ph3">`GetValue`</ph>.</source>
          <target state="translated">La prima è una classe non generica, <ph id="ph1">`TestClass`</ph>, include un costruttore, un metodo denominato <ph id="ph2">`GetValue`</ph>e una proprietà di lettura / scrittura denominata <ph id="ph3">`GetValue`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The second is a generic class named <ph id="ph1">`TestClass&lt;T&gt;`</ph> that includes a constructor, a <ph id="ph2">`GetValue`</ph> method, and a generic method, <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>.</source>
          <target state="translated">La seconda è una classe generica denominata <ph id="ph1">`TestClass&lt;T&gt;`</ph> che include un costruttore, un <ph id="ph2">`GetValue`</ph> (metodo) e un metodo generico, <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Each constructor, method, and property accessor includes a call to the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> method.</source>
          <target state="translated">Ogni costruttore, il metodo e funzione di accesso proprietà include una chiamata al <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">Questo membro è stato richiamato con un meccanismo di associazione tardiva.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresentano gli argomenti di tipo di un metodo generico o i parametri di tipo della definizione di un metodo generico.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresentano gli argomenti di tipo di un metodo generico o i parametri di tipo della definizione di un metodo generica.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an empty array if the current method is not a generic method.</source>
          <target state="translated">Restituisce una matrice vuota se il metodo corrente non è un metodo generico.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
          <target state="translated">Gli elementi della matrice restituita sono nell'ordine in cui compaiono nell'elenco dei parametri di tipo per il metodo generico.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
          <target state="translated">Se il metodo corrente è un metodo costruito chiuso (vale a dire il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> restituisce proprietà <ph id="ph2">`false`</ph>), la matrice restituita dal <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> metodo contiene i tipi che sono stati assegnati ai parametri di tipo generico del metodo generico definizione.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
          <target state="translated">Se il metodo corrente è una definizione di metodo generico, la matrice contiene i parametri di tipo.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
          <target state="translated">Se il metodo corrente è un metodo costruito aperto (ovvero, il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> restituisce proprietà <ph id="ph2">`true`</ph>) in tipi specifici assegnati ad alcuni parametri di tipo e il tipo di parametri di tipi generici di inclusione sono stati assegnati a altro tipo i parametri, la matrice contiene i tipi e tipo di parametri.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> proprietà per distinguerli.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Per una dimostrazione di questo scenario, vedere l'esempio di codice fornito per il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">I costruttori generici non sono supportati in .NET Framework versione 2.0.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This property throws <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> if not overridden in a derived class, so an exception is thrown if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">Questa proprietà genera <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> pertanto, se non sottoposto a override in una classe derivata, viene generata un'eccezione se l'istanza corrente è di tipo <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The current object is a <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</source>
          <target state="translated">L'oggetto corrente è un <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">I costruttori generici non sono supportati in .NET Framework versione 2.0.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This exception is the default behavior if this method is not overridden in a derived class.</source>
          <target state="translated">Questa eccezione rappresenta il comportamento predefinito se non viene eseguito l'override del metodo in una classe derivata.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Restituisce il codice hash per l'istanza.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Codice hash di un intero con segno a 32 bit.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>When overridden in a derived class, gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated">Se viene eseguito l'override in una classe derivata, ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> che consente di accedere al flusso MSIL, alle variabili locali e alle eccezioni per il metodo corrente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> che consente di accedere al flusso MSIL, alle variabili locali e alle eccezioni per il metodo corrente.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You do not have to override the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> in order to use it.</source>
          <target state="translated">Non è necessario eseguire l'override di <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> per utilizzarlo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You can call the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> method on <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects, because the method is overridden in the runtime versions of these classes.</source>
          <target state="translated">È possibile chiamare il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> metodo <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> oggetti, poiché il metodo viene sottoposto a override nelle versioni di queste classi di runtime.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>For example, the runtime version of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class derives from the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class, which in turn derives from the <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> class.</source>
          <target state="translated">Ad esempio, la versione di runtime del <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> deriva dalla classe di <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> (classe), che a sua volta deriva dal <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The following code example defines a test method named <ph id="ph1">`MethodBodyExample`</ph> and displays its local variable information and exception-handling clauses.</source>
          <target state="translated">Esempio di codice seguente definisce un metodo di test denominato <ph id="ph1">`MethodBodyExample`</ph> e vengono visualizzate le informazioni sulle variabili locali e clausole di gestione delle eccezioni.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph> method is used to obtain a <ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph> object for the test method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph> metodo viene utilizzato per ottenere un <ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph> oggetto per il metodo di test.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph> property is used to obtain a list of <ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph> objects and display their types and index order.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph> proprietà viene utilizzata per ottenere un elenco di <ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph> oggetti e visualizzare i relativi tipi e l'ordine dell'indice.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph> property is used to obtain a list of exception-handling clauses.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph> proprietà viene utilizzata per ottenere un elenco di clausole di gestione delle eccezioni.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Not all computer languages can generate <ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph> clauses.</source>
          <target state="translated">Non tutti i linguaggi di programmazione è possibile generare <ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph> clausole.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The Visual Basic example shows a filter clause, using a Visual Basic <ph id="ph1">`When`</ph> expression, which is omitted from the examples for other languages.</source>
          <target state="translated">Nell'esempio di Visual Basic viene illustrata una clausola di filtro, utilizzando un Visual Basic <ph id="ph1">`When`</ph> espressione, che viene omesso dagli esempi per le altre lingue.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>This method is invalid unless overridden in a derived class.</source>
          <target state="translated">Questo metodo non è valido a meno che non venga sottoposto a override in una classe derivata.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>for the access to metadata for members.</source>
          <target state="translated">per l'accesso ai metadati per i membri.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Permission value: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Valore di autorizzazione: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Gets method information using the specified handle.</source>
          <target state="translated">Ottiene informazioni sul metodo utilizzando l'handle specificato.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>The method's handle.</source>
          <target state="translated">Handle del metodo.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Gets method information by using the method's internal metadata representation (handle).</source>
          <target state="translated">Ottiene le informazioni sul metodo utilizzando la rappresentazione interna dei metadati (handle) del metodo.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> containing information about the method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> contenente informazioni sul metodo.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Handle sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the internal metadata representation of a constructor or method.</source>
          <target state="translated">Handle per la rappresentazione dei metadati interni di un costruttore o di un metodo.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the generic type that defines the constructor or method.</source>
          <target state="translated">Handle al tipo generico che definisce il costruttore o il metodo.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object for the constructor or method represented by the specified handle, for the specified generic type.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> per il costruttore o il metodo rappresentati dall'handle specificato, per il tipo generico specificato.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method or constructor specified by <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, in the generic type specified by <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> che rappresenta il metodo o il costruttore specificati da <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, nel tipo generico specificato da <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Handle sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> structure for a constructor or method of a generic type can represent different <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objects, depending on the types specified for the type parameters of the generic type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> struttura per un costruttore o un metodo di un tipo generico può rappresentare diverse <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> oggetti, a seconda dei tipi per i parametri di tipo del tipo generico specificati.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>For example, if <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> in C++) has a method that returns type <ph id="ph4">`T`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in a constructed class such as <ph id="ph6">`G&lt;int&gt;`</ph> is different from the <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in the generic type definition.</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> in Visual Basic <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> in C++) dispone di un metodo che restituisce il tipo <ph id="ph4">`T`</ph>, <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> oggetto per il metodo in una classe costruita come <ph id="ph6">`G&lt;int&gt;`</ph> è diverso dal <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph>oggetto relativo al metodo nella definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated">Quando è sottoposto a override in una classe derivata, restituisce i flag <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The <ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated">Flag <ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The following example defines a constructor in a dynamic assembly and then uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method to display the method implementation flags that are set by default.</source>
          <target state="translated">Nell'esempio seguente definisce un costruttore in un assembly dinamico e quindi utilizza il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> metodo per visualizzare i flag di implementazione che per impostazione predefinita.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>When overridden in a derived class, gets the parameters of the specified method or constructor.</source>
          <target state="translated">Quando viene sottoposto a override in una classe derivata, ottiene i parametri del metodo o del costruttore specificato.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> containing information that matches the signature of the method (or constructor) reflected by this <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph> instance.</source>
          <target state="translated">Matrice di tipo <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> contenente le informazioni corrispondenti alla firma del metodo (o del costruttore) ottenuto mediante reflection da questa istanza di <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method to retrieve the parameters of the <ph id="ph2">`Invoke`</ph> method of a delegate.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> metodo per recuperare i parametri del <ph id="ph2">`Invoke`</ph> metodo di un delegato.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The example defines a delegate named <ph id="ph1">`MyDelegate`</ph> and an event named <ph id="ph2">`ev`</ph> of type <ph id="ph3">`MyDelegate`</ph>.</source>
          <target state="translated">L'esempio definisce un delegato denominato <ph id="ph1">`MyDelegate`</ph> e un evento denominato <ph id="ph2">`ev`</ph> di tipo <ph id="ph3">`MyDelegate`</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The code in the <ph id="ph1">`Main`</ph> method discovers the event signature by getting the delegate type of the event, getting the <ph id="ph2">`Invoke`</ph> method of the delegate type, and then retrieving and displaying the parameters.</source>
          <target state="translated">Il codice nel <ph id="ph1">`Main`</ph> metodo individua la firma dell'evento ottenendo il tipo delegato dell'evento, il recupero di <ph id="ph2">`Invoke`</ph> metodo del tipo delegato, quindi il recupero e visualizzazione dei parametri di.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Invokes the method or constructor reflected by this <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> instance.</source>
          <target state="translated">Richiama il metodo o il costruttore ottenuto mediante reflection da questa istanza di <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">Oggetto su cui richiamare il metodo o il costruttore.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">Se un metodo è statico, questo argomento viene ignorato.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">Se un costruttore è statico, questo argomento deve essere <ph id="ph1">&lt;see langword="null" /&gt;</ph> oppure un'istanza della classe che definisce il costruttore.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">Elenco di argomenti per il metodo o il costruttore richiamato.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">È costituito da una matrice di oggetti con lo stesso numero, ordine e tipo dei parametri del metodo o del costruttore da richiamare.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If there are no parameters, <bpt id="p1">&lt;c&gt;</bpt>parameters<ept id="p1">&lt;/c&gt;</ept> should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">In assenza di parametri, <bpt id="p1">&lt;c&gt;</bpt>parameters<ph id="ph1">&lt;see langword="null" /&gt;</ph> deve essere <ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the method or constructor represented by this instance takes a <ph id="ph1">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">Se il metodo o il costruttore rappresentato da questa istanza accetta un parametro <ph id="ph1">&lt;see langword="ref" /&gt;</ph> (<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic), non sono richiesti speciali attributi del parametro per poter richiamare il metodo o il costruttore tramite questa funzione.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">Qualsiasi oggetto in questa matrice non inizializzato in modo esplicito con un valore conterrà il valore predefinito per quel tipo di oggetto.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Per gli elementi di tipo riferimento, questo valore è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">Per gli elementi di tipo valore, questo valore è 0, 0.0 o <ph id="ph1">&lt;see langword="false" /&gt;</ph>, a seconda del tipo di elemento specifico.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Invokes the method or constructor represented by the current instance, using the specified parameters.</source>
          <target state="translated">Richiama il metodo o il costruttore rappresentato dall'istanza corrente usando i parametri specificati.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An object containing the return value of the invoked method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> in the case of a constructor.</source>
          <target state="translated">Oggetto che contiene il valore restituito del metodo richiamato o <ph id="ph1">&lt;see langword="null" /&gt;</ph> nel caso di un costruttore.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is a convenience method that calls the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> method overload, passing <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> for <ph id="ph3">`invokeAttr`</ph> and <ph id="ph4">`null`</ph> for <ph id="ph5">`binder`</ph> and <ph id="ph6">`culture`</ph>.</source>
          <target state="translated">Si tratta di un metodo pratico che chiama il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> overload del metodo, passando <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> per <ph id="ph3">`invokeAttr`</ph> e <ph id="ph4">`null`</ph> per <ph id="ph5">`binder`</ph> e <ph id="ph6">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the invoked method throws an exception, the <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph> method returns the exception.</source>
          <target state="translated">Se il metodo richiamato genera un'eccezione, il <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph> metodo restituisce l'eccezione.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To invoke a static method using its <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object, pass <ph id="ph2">`null`</ph> for <ph id="ph3">`obj`</ph>.</source>
          <target state="translated">Per richiamare un metodo statico tramite il relativo <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> dell'oggetto, passare <ph id="ph2">`null`</ph> per <ph id="ph3">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">Se questo overload viene utilizzato per richiamare un costruttore di istanza, l'oggetto fornito per <ph id="ph1">`obj`</ph> viene reinizializzata; ovvero, in cui vengono eseguiti tutti gli inizializzatori di istanza.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Il valore restituito è <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">Se viene richiamato un costruttore di classe, la classe viene reinizializzata; ovvero, vengono eseguiti tutti gli inizializzatori di classi.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Il valore restituito è <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo metodo può essere utilizzato per accedere a membri pubblici, se il chiamante è stato concesso <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag e se il set di concessioni dei membri non pubblici è limitato al chiamante o a un sottoinsieme Questi due elementi.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>considerazioni sulla sicurezza per la Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">Se un parametro del metodo corrente è un tipo di valore e l'argomento corrispondente in <ph id="ph1">`parameters`</ph> è <ph id="ph2">`null`</ph>, il runtime passa un'istanza inizializzata su zero del tipo di valore.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The following code example demonstrates dynamic method lookup using reflection.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come ricerca del metodo dinamico tramite reflection.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Note that you cannot use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</source>
          <target state="translated">Si noti che non è possibile utilizzare il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto della classe base per richiamare il metodo sottoposto a override nella classe derivata, perché l'associazione tardiva non è possibile risolvere gli override.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instead.</source>
          <target state="translated">In <bpt id="p1">[</bpt>.NET per app di Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o nella <bpt id="p2">[</bpt>libreria di classi portabile<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> rilevare invece l'eccezione <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e il metodo non è statico.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">Il metodo non è dichiarato né ereditato dalla classe di <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">Viene richiamato un costruttore statico e <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> né un'istanza della classe che ha dichiarato il costruttore.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The elements of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array do not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated">Gli elementi della matrice di <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> non corrispondono alla firma del metodo o del costruttore ottenuto mediante reflection da questa istanza.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">Il metodo o il costruttore richiamato genera un'eccezione.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph> that contains unverifiable code.</source>
          <target state="translated">L'istanza corrente è un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph> contenente codice non verificabile.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</source>
          <target state="translated">Vedere la sezione "Verifica" nelle note per <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated">La matrice <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> non contiene il numero corretto di argomenti.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>, instead.</source>
          <target state="translated">In <bpt id="p1">[</bpt>.NET per app di Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o nella <bpt id="p2">[</bpt>libreria di classi portabile<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> rilevare invece l'eccezione della classe di base, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">Il chiamante non è autorizzato a eseguire il metodo o il costruttore rappresentato dall'istanza corrente.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">Il tipo che dichiara il metodo è un tipo generico aperto,</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">ovvero la proprietà <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="true" /&gt;</ph> per il tipo dichiarante.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">L'istanza corrente è <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">Oggetto su cui richiamare il metodo o il costruttore.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">Se un metodo è statico, questo argomento viene ignorato.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">Se un costruttore è statico, questo argomento deve essere <ph id="ph1">&lt;see langword="null" /&gt;</ph> oppure un'istanza della classe che definisce il costruttore.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask that is a combination of 0 or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Maschera di bit equivalente a una combinazione di 0 o più flag di bit da <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this parameter is assigned the value <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>; thus, whatever you pass in is ignored.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, al parametro viene assegnato il valore <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>; di conseguenza, verrà ignorato qualsiasi elemento passato.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Oggetto che consente il binding, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> tramite reflection.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">Elenco di argomenti per il metodo o il costruttore richiamato.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">È costituito da una matrice di oggetti con lo stesso numero, ordine e tipo dei parametri del metodo o del costruttore da richiamare.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters, this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">In assenza di parametri, deve essere <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">Se il metodo o il costruttore rappresentati da questa istanza accettano un parametro ByRef, non sono richiesti attributi speciali per tale parametro per poter richiamare il metodo o il costruttore che utilizza la funzione.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">Qualsiasi oggetto in questa matrice non inizializzato in modo esplicito con un valore conterrà il valore predefinito per quel tipo di oggetto.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Per gli elementi di tipo riferimento, questo valore è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">Per gli elementi di tipo valore, questo valore è 0, 0.0 o <ph id="ph1">&lt;see langword="false" /&gt;</ph>, a seconda del tipo di elemento specifico.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Istanza di <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> usata per regolare la coercizione dei tipi.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(This is necessary to convert a <ph id="ph1">&lt;see langword="String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see langword="Double" /&gt;</ph> value, for example, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">Si tratta di un parametro necessario per convertire un oggetto <ph id="ph1">&lt;see langword="String" /&gt;</ph> che rappresenta, ad esempio, il numero 1000 in un valore <ph id="ph2">&lt;see langword="Double" /&gt;</ph>, dal momento che questo numero è rappresentato in modo diverso nelle varie impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</source>
          <target state="translated">Quando viene sottoposto a override in una classe derivata, richiama il metodo o il costruttore ottenuto mediante reflection con i parametri specificati.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing the return value of the invoked method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> in the case of a constructor, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the method's return type is <ph id="ph4">&lt;see langword="void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Object" /&gt;</ph> contenente il valore restituito del metodo richiamato, oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> nel caso di un costruttore, oppure <ph id="ph3">&lt;see langword="null" /&gt;</ph> se il tipo restituito dal metodo è <ph id="ph4">&lt;see langword="void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Before calling the method or constructor, <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> checks to see if the user has access permission and verifies that the parameters are valid.</source>
          <target state="translated">Prima di chiamare il metodo o il costruttore, <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> verifica che l'utente disponga dell'autorizzazione per l'accesso e che i parametri siano validi.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the method reflected by this instance on <ph id="ph1">`obj`</ph>, and passes along the specified parameters.</source>
          <target state="translated">Richiama dinamicamente il metodo ottenuto mediante reflection da questa istanza <ph id="ph1">`obj`</ph>e passa i parametri specificati.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
          <target state="translated">Se il metodo è statico, il <ph id="ph1">`obj`</ph> parametro viene ignorato.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
          <target state="translated">Per i metodi non statici <ph id="ph1">`obj`</ph> deve essere un'istanza di una classe che eredita o dichiara il metodo e deve essere dello stesso tipo di questa classe.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Se il metodo non ha parametri, il valore di <ph id="ph1">`parameters`</ph> deve essere <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise, the number, type, and order of elements in <ph id="ph1">`parameters`</ph> should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
          <target state="translated">In caso contrario, il numero, tipo e l'ordine degli elementi in <ph id="ph1">`parameters`</ph> deve essere identico a numero, tipo e ordine dei parametri per il metodo ottenuto mediante reflection da questa istanza.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>You may not omit optional parameters in calls to <ph id="ph1">`Invoke`</ph>.</source>
          <target state="translated">Non è possibile omettere i parametri facoltativi nelle chiamate a <ph id="ph1">`Invoke`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To invoke a method omitting optional parameters, you should call <ph id="ph1">`Type.InvokeMember`</ph> instead.</source>
          <target state="translated">Per richiamare un metodo omettendo i parametri facoltativi, è necessario chiamare <ph id="ph1">`Type.InvokeMember`</ph> invece.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">Se questo overload viene utilizzato per richiamare un costruttore di istanza, l'oggetto fornito per <ph id="ph1">`obj`</ph> viene reinizializzata; ovvero, in cui vengono eseguiti tutti gli inizializzatori di istanza.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Il valore restituito è <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">Se viene richiamato un costruttore di classe, la classe viene reinizializzata; ovvero, vengono eseguiti tutti gli inizializzatori di classi.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Il valore restituito è <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value primitive parameters, normal widening is performed (Int16 -&gt; Int32, for example).</source>
          <target state="translated">Per i parametri primitivi pass-by-value, viene eseguito un ampliamento normale (Int16 -&gt; Int32, ad esempio).</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</source>
          <target state="translated">Per i parametri di riferimento di pass-by-value, (classe di base e la classe base per il tipo di interfaccia, una classe derivata) è consentito un ampliamento normale del riferimento.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>However, for pass-by-reference primitive parameters, the types must match exactly.</source>
          <target state="translated">Tuttavia, per i parametri primitivi passata per riferimento, i tipi devono corrispondere.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-reference reference parameters, the normal widening still applies.</source>
          <target state="translated">Per i parametri di riferimento di passaggio per riferimento, l'ampliamento normale ancora valide.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the method reflected by this instance is declared as <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, then <ph id="ph2">`parameters`</ph> should be an array of <ph id="ph3">`Objects`</ph> with length 2 such that <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</source>
          <target state="translated">Ad esempio, se il metodo ottenuto mediante reflection da questa istanza è dichiarata come <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, quindi <ph id="ph2">`parameters`</ph> deve essere una matrice di <ph id="ph3">`Objects`</ph> con lunghezza 2 tale <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">Se un parametro del metodo corrente è un tipo di valore e l'argomento corrispondente in <ph id="ph1">`parameters`</ph> è <ph id="ph2">`null`</ph>, il runtime passa un'istanza inizializzata su zero del tipo di valore.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Reflection uses dynamic method lookup when invoking virtual methods.</source>
          <target state="translated">Reflection Usa ricerca del metodo dinamico durante la chiamata di metodi virtuali.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a <ph id="ph1">`MethodInfo`</ph> object that represents M on class A. If you use the <ph id="ph2">`Invoke`</ph> method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</source>
          <target state="translated">Ad esempio, si supponga che la classe B eredita dalla classe e implementano un metodo virtuale denominato M. Ora si supponga di avere un <ph id="ph1">`MethodInfo`</ph> oggetto che rappresenta M sulla classe A. Se si utilizza il <ph id="ph2">`Invoke`</ph> metodo da richiamare M su un oggetto di tipo B, la reflection utilizzerà l'implementazione fornita dalla classe B. Anche se l'oggetto di tipo B viene eseguito il cast ad A, viene utilizzata l'implementazione fornita dalla classe B (vedere l'esempio di codice riportato di seguito).</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the <ph id="ph1">`MethodInfo`</ph> was obtained, regardless of the type of the object passed as the target.</source>
          <target state="translated">D'altra parte, se il metodo non virtuale, quindi reflection utilizzerà l'implementazione fornita dal tipo dal quale il <ph id="ph1">`MethodInfo`</ph> è stato ottenuto, indipendentemente dal tipo dell'oggetto passato come destinazione.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Le restrizioni di accesso vengono ignorate per il codice completamente attendibile.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</source>
          <target state="translated">Vale a dire, proprietà, metodi, campi e costruttori privati accessibili e richiamate tramite reflection, ogni volta che il codice è completamente attendibile.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the invoked method throws an exception, <ph id="ph1">`TargetInvocationException.GetException`</ph> returns the exception.</source>
          <target state="translated">Se il metodo richiamato genera un'eccezione, <ph id="ph1">`TargetInvocationException.GetException`</ph> restituisce l'eccezione.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This implementation throws a <ph id="ph1">`NotSupportedException`</ph>.</source>
          <target state="translated">Questa implementazione genera un <ph id="ph1">`NotSupportedException`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo metodo può essere utilizzato per accedere a membri pubblici, se il chiamante è stato concesso <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag e se il set di concessioni dei membri non pubblici è limitato al chiamante o a un sottoinsieme Questi due elementi.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>considerazioni sulla sicurezza per la Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The following example demonstrates all members of the <ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class using an overload of <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L'esempio seguente illustra tutti i membri del <ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> classe utilizzando un overload di <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The private method <ph id="ph1">`CanConvertFrom`</ph> finds compatible types for a given type.</source>
          <target state="translated">Il metodo privato <ph id="ph1">`CanConvertFrom`</ph> ricerca tipi compatibili per un determinato tipo.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For another example of invoking members in a custom binding scenario, see <bpt id="p1">[</bpt>Dynamically Loading and Using Types<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>.</source>
          <target state="translated">Per un altro esempio di richiamo dei membri in uno scenario di associazione personalizzata, vedere <bpt id="p1">[</bpt>in modo dinamico durante il caricamento e utilizzo dei tipi<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e il metodo non è statico.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">Il metodo non è dichiarato né ereditato dalla classe di <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">Viene richiamato un costruttore statico e <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> né un'istanza della classe che ha dichiarato il costruttore.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> parameter does not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated">Il tipo del parametro <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> non corrisponde alla firma del metodo o del costruttore ottenuto mediante reflection da questa istanza.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated">La matrice <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> non contiene il numero corretto di argomenti.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">Il metodo o il costruttore richiamato genera un'eccezione.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">Il chiamante non è autorizzato a eseguire il metodo o il costruttore rappresentato dall'istanza corrente.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">Il tipo che dichiara il metodo è un tipo generico aperto,</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">ovvero la proprietà <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="true" /&gt;</ph> per il tipo dichiarante.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>Gets a value indicating whether the method is abstract.</source>
          <target state="translated">Ottiene un valore che indica se il metodo è astratto.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method is abstract; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo è astratto; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>An abstract member is declared on a base class and has no implementation supplied.</source>
          <target state="translated">Un membro astratto viene dichiarato in una classe base e non ha fornito alcuna implementazione.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">Per ottenere il <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, ottenere innanzitutto il tipo.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the type, get the method.</source>
          <target state="translated">Dal tipo, il metodo get.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">Dal metodo, ottenere il <ph id="ph1">`MethodBase`</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">Se il <ph id="ph1">`MethodBase`</ph> o costruttore non è pubblico, è protetto e non è possibile accedervi.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">Per accedere a un metodo non pubblico, impostare il <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> maschera per <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>The following example determines whether specified the method is abstract and displays the result.</source>
          <target state="translated">Nell'esempio seguente determina se il metodo è astratto e vengono visualizzati i risultati specificati.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</source>
          <target state="translated">Ottiene un valore che indica se la visibilità potenziale di questo metodo o costruttore è descritta da <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>, ovvero se il metodo o costruttore è visibile al massimo ad altri tipi dello stesso assembly, ma non ai tipi derivati all'esterno dell'assembly.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the visibility of this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se la visibilità di questo metodo o costruttore è descritta esattamente da <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">La visibilità di un metodo effettiva è limitata dalla visibilità del relativo tipo.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> proprietà potrebbe essere <ph id="ph2">`true`</ph> per un metodo, ma se è un metodo di un tipo annidato privato, quindi il metodo non è visibile all'esterno del tipo che lo contiene.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">La visibilità di un metodo o costruttore è descritta esattamente da <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph> se è l'unico modificatore di visibilità <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">Questa proprietà è <ph id="ph1">`false`</ph> per i metodi che vengono <ph id="ph2">`protected internal`</ph> in c# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic <ph id="ph4">`protected public`</ph> in C++); usare il <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> proprietà per identificare tali metodi.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">Esempio di codice seguente definisce i metodi con livelli di visibilità e visualizza i valori di loro <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">I linguaggi Visual Basic e c# non possono definire metodi con <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilità; che il livello di accesso viene visualizzata solo nell'esempio C++.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Gets a value indicating whether the method is a constructor.</source>
          <target state="translated">Ottiene un valore che indica se il metodo è un costruttore.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is a constructor represented by a <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object (see note in Remarks about <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> objects); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo è un costruttore rappresentato da un oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> (vedere la nota sugli oggetti <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> nella sezione Osservazioni); in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for a <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object in a dynamic type, unless the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph> flag was included in the <ph id="ph5">`attributes`</ph> parameter when the constructor was defined.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> restituisce proprietà <ph id="ph2">`false`</ph> per un <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> dell'oggetto in un tipo dinamico, a meno che il <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph> flag è stato incluso nel <ph id="ph5">`attributes`</ph> parametro quando il costruttore è stato definito.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Omitting the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> flag does not affect the correctness of the emitted constructor.</source>
          <target state="translated">L'omissione di <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> flag non influisce sulla correttezza del costruttore creato.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; that is, the method or constructor is visible only within its class and derived classes.</source>
          <target state="translated">Ottiene un valore che indica se la visibilità di questo metodo o costruttore è descritta da <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>, ovvero se il metodo o costruttore è visibile solo all'interno della relativa classe e delle classi derivate.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'accesso al metodo o costruttore è descritto esattamente da <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">La visibilità di un metodo o costruttore è descritta esattamente da <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph> se è l'unico modificatore di visibilità <ph id="ph2">`protected`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">Questa proprietà è <ph id="ph1">`false`</ph> per i metodi che vengono <ph id="ph2">`protected internal`</ph> in c# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic <ph id="ph4">`protected public`</ph> in C++); usare il <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> proprietà per identificare tali metodi.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">Esempio di codice seguente definisce i metodi con livelli di visibilità e visualizza i valori di loro <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">I linguaggi Visual Basic e c# non possono definire metodi con <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilità; che il livello di accesso viene visualizzata solo nell'esempio C++.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</source>
          <target state="translated">Ottiene un valore che indica se la visibilità di questo metodo o costruttore è descritta da <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>, ovvero se è possibile chiamare il metodo o il costruttore da classi derivate, ma solo se appartenenti allo stesso assembly.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'accesso al metodo o costruttore è descritto esattamente da <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected private`</ph> in C++.</source>
          <target state="translated">La visibilità di un metodo o costruttore è descritta esattamente da <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> se il modificatore di visibilità <ph id="ph2">`protected private`</ph> in C++.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Methods with this visibility cannot be defined in Visual Basic or C#.</source>
          <target state="translated">Non è possibile definire metodi con questa visibilità in Visual Basic o c#.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">Esempio di codice seguente definisce i metodi con livelli di visibilità e visualizza i valori di loro <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">I linguaggi Visual Basic e c# non possono definire metodi con <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilità; che il livello di accesso viene visualizzata solo nell'esempio C++.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</source>
          <target state="translated">Ottiene un valore che indica se la visibilità potenziale di questo metodo o costruttore è descritta da <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>, ovvero se è possibile chiamare il metodo o il costruttore da classi derivate indipendentemente dalla posizione e da classi appartenenti allo stesso assembly.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'accesso al metodo o costruttore è descritto esattamente da <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>If a type member has <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</source>
          <target state="translated">Se un membro di tipo è <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> visibilità può essere chiamato da qualsiasi membro in una classe derivata o qualsiasi membro nello stesso assembly, ma non da qualsiasi altro tipo.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">La visibilità di un metodo effettiva è limitata dalla visibilità del relativo tipo.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> proprietà potrebbe essere <ph id="ph2">`true`</ph> per un metodo, ma se è un metodo di un tipo annidato privato, quindi il metodo non è visibile all'esterno del tipo che lo contiene.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++).</source>
          <target state="translated">La visibilità di un metodo o costruttore è descritta esattamente da <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> se il modificatore di visibilità <ph id="ph2">`protected internal`</ph> in c# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic <ph id="ph4">`protected public`</ph> in C++).</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">Esempio di codice seguente definisce i metodi con livelli di visibilità e visualizza i valori di loro <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">I linguaggi Visual Basic e c# non possono definire metodi con <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilità; che il livello di accesso viene visualizzata solo nell'esempio C++.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>Gets a value indicating whether this method is <ph id="ph1">&lt;see langword="final" /&gt;</ph>.</source>
          <target state="translated">Ottiene un valore che indica se il metodo è <ph id="ph1">&lt;see langword="final" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="final" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se questo metodo è <ph id="ph2">&lt;see langword="final" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Per determinare se un metodo sottoponibile a override, non è sufficiente verificare che <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> è <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">`IsFinal`</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Per un metodo essere sottoposto a override, <ph id="ph1">`IsVirtual`</ph> deve essere <ph id="ph2">`true`</ph> e <ph id="ph3">`IsFinal`</ph> deve essere <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">Ad esempio, un metodo potrebbe essere non virtuale, ma implementa un metodo di interfaccia.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">Common language runtime richiede che tutti i metodi che implementano membri di interfaccia devono essere contrassegnati come <ph id="ph1">`virtual`</ph>; pertanto, il compilatore contrassegna il metodo <ph id="ph2">`virtual final`</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">Pertanto vi sono casi in cui un metodo è contrassegnato come <ph id="ph1">`virtual`</ph> ma è ancora non sottoponibile a override.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">Per stabilire con certezza se un metodo sottoponibile a override, usare codice simile al seguente:</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">Se <ph id="ph1">`IsVirtual`</ph> è <ph id="ph2">`false`</ph> o <ph id="ph3">`IsFinal`</ph> è <ph id="ph4">`true`</ph>, il metodo non può essere sottoposto a override.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that MyMethod is overridable.</source>
          <target state="translated">L'esempio seguente mostra <ph id="ph1">`false`</ph> per <ph id="ph2">`IsFinal`</ph>, che potrebbe far pensare che MyMethod è sottoponibile a override.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The code prints <ph id="ph1">`false`</ph> even though MyMethod is not marked <ph id="ph2">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">Il codice visualizza <ph id="ph1">`false`</ph> anche se non è contrassegnato come MyMethod <ph id="ph2">`virtual`</ph> e pertanto non può essere sottoposto a override.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Gets a value indicating whether the method is generic.</source>
          <target state="translated">Ottiene un valore che indica se il metodo è generico.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> represents a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se la classe <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> corrente rappresenta un metodo generico; in caso contrario <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents a generic method.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> proprietà per determinare se l'oggetto corrente <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> oggetto rappresenta un metodo generico.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents an open constructed method or a closed constructed method.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> proprietà per determinare se l'oggetto corrente <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> oggetto rappresenta un metodo costruito aperto o chiuso.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">Generics non supportati per impostazione predefinita. Questa proprietà restituisce <ph id="ph1">`false`</ph> se non viene sottoposto a override in una classe derivata.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">I costruttori generici non sono supportati in .NET Framework versione 2.0, questa proprietà restituisce <ph id="ph1">`false`</ph> se l'istanza corrente è di tipo <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The following table summarizes the invariant conditions for terms specific to generic methods.</source>
          <target state="translated">Nella tabella seguente vengono riepilogate le condizioni invariante per condizioni specifiche per i metodi generici.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>For other terms used in generic reflection, such as <bpt id="p1">*</bpt>generic type parameter<ept id="p1">*</ept> and <bpt id="p2">*</bpt>generic type<ept id="p2">*</ept>, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per altri termini utilizzati nella reflection generica, ad esempio <bpt id="p1">*</bpt>parametro di tipo generico<ept id="p1">*</ept> e <bpt id="p2">*</bpt>tipo generico<ept id="p2">*</ept>, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Term</source>
          <target state="translated">Termine</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Invariant condition</source>
          <target state="translated">Condizione dell'invariabile</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method definition</source>
          <target state="translated">definizione di metodo generico</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> è <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Defines a generic method.</source>
          <target state="translated">Definisce un metodo generico.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>A constructed method is created by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition, and specifying an array of type arguments.</source>
          <target state="translated">Viene creato un metodo costruito chiamando il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> metodo su un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> dell'oggetto che rappresenta una definizione di metodo generico e specificando una matrice di argomenti di tipo.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be called only on generic method definitions.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> metodo può essere chiamato solo in definizioni di metodo generico.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Any generic method definition is a generic method, but the converse is not true.</source>
          <target state="translated">Qualsiasi definizione di metodo generico è un metodo generico, ma non è vero il contrario.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method</source>
          <target state="translated">metodo generico</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">`IsGenericMethod`</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">`IsGenericMethod`</ph> è <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Can be a generic method definition, an open constructed method, or a closed constructed method.</source>
          <target state="translated">Può essere una definizione di metodo generico, un metodo costruito aperto o chiuso.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>open constructed method</source>
          <target state="translated">Open costruito (metodo)</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> è <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>It is not possible to invoke an open constructed method.</source>
          <target state="translated">Non è possibile richiamare un metodo costruito aperto.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>closed constructed method</source>
          <target state="translated">metodo costruito chiuso</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> è <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>When examined recursively, the method has no unassigned generic parameters.</source>
          <target state="translated">Quando viene esaminato in modo ricorsivo, il metodo non dispone di alcun parametro generico non assegnati.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</source>
          <target state="translated">Il tipo contenitore non dispone di alcun parametro di tipo generico e nessuno degli argomenti di tipo dispone di parametri di tipo generico.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The method can be invoked.</source>
          <target state="translated">Il metodo può essere richiamato.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Gets a value indicating whether the method is a generic method definition.</source>
          <target state="translated">Ottiene un valore che indica se il metodo è una definizione di un metodo generico.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> corrente rappresenta la definizione di un metodo generico; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> represents a generic method definition, then:</source>
          <target state="translated">Se l'oggetto corrente <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> rappresenta la definizione di un metodo generico:</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> è <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For each <ph id="ph1">&lt;xref:System.Type&gt;</ph> object in the array returned by the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method:</source>
          <target state="translated">Per ogni <ph id="ph1">&lt;xref:System.Type&gt;</ph> oggetto nella matrice restituita dal <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> metodo:</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> è <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph> property returns the current instance.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph> proprietà restituisce l'istanza corrente.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph> property is the same as the position of the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object in the array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph> proprietà corrisponde alla posizione del <ph id="ph2">&lt;xref:System.Type&gt;</ph> oggetto nella matrice.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">Generics non supportati per impostazione predefinita. Questa proprietà restituisce <ph id="ph1">`false`</ph> se non viene sottoposto a override in una classe derivata.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">I costruttori generici non sono supportati in .NET Framework versione 2.0, questa proprietà restituisce <ph id="ph1">`false`</ph> se l'istanza corrente è di tipo <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</source>
          <target state="translated">Ottiene un valore che indica se nella classe derivata è nascosto un solo membro dello stesso tipo che riporta esattamente la stessa firma.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member is hidden by signature; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il membro è nascosto dalla firma; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>When a member in a derived class is declared with the C# <ph id="ph1">`new`</ph> modifier or the Visual Basic <ph id="ph2">`Shadows`</ph> modifier, it can hide a member of the same name in the base class.</source>
          <target state="translated">Quando un membro in una classe derivata viene dichiarato con c# <ph id="ph1">`new`</ph> modificatore o Visual Basic <ph id="ph2">`Shadows`</ph> modificatore, può nascondere un membro con lo stesso nome nella classe base.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>C# hides base class members by signature.</source>
          <target state="translated">C# consente di nascondere i membri della classe base dalla firma.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</source>
          <target state="translated">Se il membro della classe base dispone di più overload, l'unico nascosta è quello che ha una firma identica.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>By contrast, Visual Basic hides all the base class overloads.</source>
          <target state="translated">Al contrario, Visual Basic nasconde tutti gli overload della classe di base.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Thus, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> returns <ph id="ph2">`false`</ph> on a member declared with the Visual Basic <ph id="ph3">`Shadows`</ph> modifier, and <ph id="ph4">`true`</ph> on a member declared with the C# <ph id="ph5">`new`</ph> modifier.</source>
          <target state="translated">Di conseguenza, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> restituisce <ph id="ph2">`false`</ph> in un membro dichiarato con Visual Basic <ph id="ph3">`Shadows`</ph> modificatore, e <ph id="ph4">`true`</ph> su un membro dichiarato con c# <ph id="ph5">`new`</ph> modificatore.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>This property does not determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute.</source>
          <target state="translated">Questa proprietà determina se un metodo dispone di <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>A method that is declared with either the <ph id="ph1">`new`</ph> or the <ph id="ph2">`Shadows`</ph> modifier will have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, but only methods declared with <ph id="ph4">`new`</ph> (that is, only C# methods) will have the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property set to <ph id="ph6">`true`</ph>.</source>
          <target state="translated">Un metodo che è dichiarato con la <ph id="ph1">`new`</ph> o <ph id="ph2">`Shadows`</ph> modificatore avrà il <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attributo, ma solo i metodi dichiarati con <ph id="ph4">`new`</ph> (vale a dire solo metodi c#) avrà il <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> proprietà è impostata su <ph id="ph6">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>To determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, use code similar to the following: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> in C# or <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> in Visual Basic.</source>
          <target state="translated">Per determinare se un metodo ha il <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attributo, utilizzare codice simile al seguente: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> in c# o <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> in Visual Basic.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Note, however, that although all methods declared with <ph id="ph1">`new`</ph> or <ph id="ph2">`Shadows`</ph> have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, not all methods that have the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute are declared with <ph id="ph5">`new`</ph> or <ph id="ph6">`Shadows`</ph>.</source>
          <target state="translated">Si noti, tuttavia, che anche se tutti i metodi dichiarati con <ph id="ph1">`new`</ph> o <ph id="ph2">`Shadows`</ph> hanno il <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attributo, non tutti i metodi che presentano il <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attributo vengono dichiarati con <ph id="ph5">`new`</ph> o <ph id="ph6">`Shadows`</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</source>
          <target state="translated">Esempio di codice seguente contiene una classe base con un metodo di overload e una classe derivata che consente di nascondere uno degli overload.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the Visual Basic version of the code example, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the member in the derived class.</source>
          <target state="translated">La versione di Visual Basic dell'esempio di codice, il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> restituisce proprietà <ph id="ph2">`false`</ph> per il membro nella classe derivata.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the C# version of the code sample, the property returns <ph id="ph1">`true`</ph> for the member in the derived class.</source>
          <target state="translated">Nella versione c# dell'esempio di codice, la proprietà restituisce <ph id="ph1">`true`</ph> per il membro nella classe derivata.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>Gets a value indicating whether this member is private.</source>
          <target state="translated">Ottiene un valore che indica se questo membro è privato.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method is restricted to other members of the class itself; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'accesso al metodo è limitato agli altri membri della classe; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>If a type member has <ph id="ph1">`Private`</ph> level visibility, it can be called from any member in the same class and no others.</source>
          <target state="translated">Se un membro di tipo è <ph id="ph1">`Private`</ph> visibilità livello, può essere chiamato da qualsiasi membro nella stessa classe e non da altri.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>Gets a value indicating whether this is a public method.</source>
          <target state="translated">Ottiene un valore che indica se si tratta di un metodo pubblico.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo è pubblico; in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">Per ottenere il <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, ottenere innanzitutto il tipo.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the type, get the method.</source>
          <target state="translated">Dal tipo, il metodo get.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">Dal metodo, ottenere il <ph id="ph1">`MethodBase`</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">Se il <ph id="ph1">`MethodBase`</ph> o costruttore non è pubblico, è protetto e non è possibile accedervi.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">Per accedere a un metodo non pubblico, impostare il <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> maschera per <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> property to display a message that indicates whether the specified method is public.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> proprietà per visualizzare un messaggio che indica se il metodo specificato è pubblico.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">Ottiene un valore che indica se il metodo o il costruttore corrente è critico per la sicurezza o security-safe-critical al livello di attendibilità corrente, e pertanto può eseguire operazioni critiche.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo o costruttore corrente è critico per la sicurezza o security-safe-critical al livello di attendibilità corrente; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se è trasparente.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> riportano il livello di trasparenza del metodo o costruttore al livello di attendibilità corrente, come determinato da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Livello di sicurezza</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Utilizzo di queste proprietà è molto più semplice che esaminare le annotazioni di sicurezza di un assembly e i relativi tipi e membri, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Per gli assembly parzialmente attendibile, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Se l'assembly viene caricato in un dominio di applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">L'assembly e tutti i relativi tipi vengono considerati come trasparente.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando l'assembly viene caricato in un dominio applicazione completamente attendibile (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop).</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Al contrario, un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il relativo livello di attendibilità corrente è sempre completamente attendibile.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla reflection e trasparenza, vedere <bpt id="p1">[</bpt>considerazioni sulla sicurezza per la Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Per informazioni su trasparenza, vedere <bpt id="p1">[</bpt>modifiche della sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Ottiene un valore che indica se il metodo o il costruttore corrente è security-safe-critical al livello di attendibilità corrente, vale a dire se può eseguire operazioni critiche ed essere richiamato da codice trasparente.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo o costruttore corrente è security-safe-critical al livello di attendibilità corrente; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se è critico per la sicurezza o trasparente.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> riportano il livello di trasparenza del metodo o costruttore al livello di attendibilità corrente, come determinato da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Livello di sicurezza</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Utilizzo di queste proprietà è molto più semplice che esaminare le annotazioni di sicurezza di un assembly e i relativi tipi e membri, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Per gli assembly parzialmente attendibile, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Se l'assembly viene caricato in un dominio di applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">L'assembly e tutti i relativi tipi vengono considerati come trasparente.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando l'assembly viene caricato in un dominio applicazione completamente attendibile (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop).</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Al contrario, un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il relativo livello di attendibilità corrente è sempre completamente attendibile.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla reflection e trasparenza, vedere <bpt id="p1">[</bpt>considerazioni sulla sicurezza per la Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Per informazioni su trasparenza, vedere <bpt id="p1">[</bpt>modifiche della sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">Ottiene un valore che indica se il metodo o il costruttore corrente è trasparente al livello di attendibilità corrente, e pertanto non può eseguire operazioni critiche.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo o costruttore corrente è SecurityTrasparent al livello di attendibilità corrente; in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se questa proprietà restituisce <ph id="ph1">`true`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> restituiscono <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> riportano il livello di trasparenza del metodo o costruttore al livello di attendibilità corrente, come determinato da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Utilizzo di queste proprietà è molto più semplice che esaminare le annotazioni di sicurezza di un assembly e i relativi tipi e membri, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Per gli assembly parzialmente attendibile, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Se l'assembly viene caricato in un dominio di applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">L'assembly e tutti i relativi tipi vengono considerati come trasparente.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando l'assembly viene caricato in un dominio applicazione completamente attendibile (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop).</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Al contrario, un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il relativo livello di attendibilità corrente è sempre completamente attendibile.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla reflection e trasparenza, vedere <bpt id="p1">[</bpt>considerazioni sulla sicurezza per la Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Per informazioni su trasparenza, vedere <bpt id="p1">[</bpt>modifiche della sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>Gets a value indicating whether this method has a special name.</source>
          <target state="translated">Ottiene un valore che indica se questo metodo ha un nome speciale.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method has a special name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se questo metodo ha un nome speciale; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> bit viene impostato su membri di flag che sono gestiti in modo speciale da alcuni compilatori (ad esempio funzioni di accesso a proprietà e metodi di overload di operatori).</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>This example shows a use of <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph> to filter internal or private members out of a list.</source>
          <target state="translated">In questo esempio viene illustrato un utilizzo di <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph> per filtrare interni o membri privati da un elenco.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="static" /&gt;</ph>.</source>
          <target state="translated">Ottiene un valore che indica se il metodo è <ph id="ph1">&lt;see langword="static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="static" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se questo metodo è <ph id="ph2">&lt;see langword="static" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>A static member cannot implicitly reference instance data in a class.</source>
          <target state="translated">Un membro statico in modo implicito non può fare riferimento a dati di istanza in una classe.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>.</source>
          <target state="translated">Ottiene un valore che indica se il metodo è <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se questo metodo è <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>A virtual member may reference instance data in a class and must be referenced through an instance of the class.</source>
          <target state="translated">Un membro virtuale può fare riferimento a dati di istanza in una classe e deve fare riferimento tramite un'istanza della classe.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Per determinare se un metodo sottoponibile a override, non è sufficiente verificare che <ph id="ph1">`IsVirtual`</ph> è <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Per un metodo essere sottoposto a override, <ph id="ph1">`IsVirtual`</ph> deve essere <ph id="ph2">`true`</ph> e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> deve essere <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">Ad esempio, un metodo potrebbe essere non virtuale, ma implementa un metodo di interfaccia.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">Common language runtime richiede che tutti i metodi che implementano membri di interfaccia devono essere contrassegnati come <ph id="ph1">`virtual`</ph>; pertanto, il compilatore contrassegna il metodo <ph id="ph2">`virtual final`</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">Pertanto vi sono casi in cui un metodo è contrassegnato come <ph id="ph1">`virtual`</ph> ma è ancora non sottoponibile a override.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">Per stabilire con certezza se un metodo sottoponibile a override, usare codice simile al seguente:</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">Se <ph id="ph1">`IsVirtual`</ph> è <ph id="ph2">`false`</ph> o <ph id="ph3">`IsFinal`</ph> è <ph id="ph4">`true`</ph>, il metodo non può essere sottoposto a override.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">È possibile determinare se il metodo corrente esegue l'override di un metodo in una classe base chiamando il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
          <target state="translated">Nell'esempio seguente viene implementato un <ph id="ph1">`IsOverride`</ph> metodo che esegue questa operazione.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that <ph id="ph3">`MyMethod`</ph> is overridable.</source>
          <target state="translated">L'esempio seguente mostra <ph id="ph1">`false`</ph> per <ph id="ph2">`IsFinal`</ph>, che potrebbe far pensare che <ph id="ph3">`MyMethod`</ph> è sottoponibile a override.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The code prints <ph id="ph1">`false`</ph> even though <ph id="ph2">`MyMethod`</ph> is not marked <ph id="ph3">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">Il codice visualizza <ph id="ph1">`false`</ph> anche se <ph id="ph2">`MyMethod`</ph> non è contrassegnato come <ph id="ph3">`virtual`</ph> e pertanto non può essere sottoposto a override.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>Gets a handle to the internal metadata representation of a method.</source>
          <target state="translated">Ottiene un handle alla rappresentazione interna dei metadati di un metodo.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph> object.</source>
          <target state="translated">Un oggetto <ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Gli handle sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags that specify the attributes of a method implementation.</source>
          <target state="translated">Ottiene i flag <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> che specificano gli attributi di implementazione di un metodo.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>The method implementation flags.</source>
          <target state="translated">Flag di implementazione dei metodi.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method for more information.</source>
          <target state="translated">Per altre informazioni, vedere il metodo <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">Primo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">Secondo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica se due oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> sono uguali.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> è uguale a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">Primo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">Secondo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica se due oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> non sono uguali.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> non è uguale a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matrice di nomi passata di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Conteggio dei nomi di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contesto delle impostazioni locali in cui interpretare i nomi.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Informazioni sul tipo da restituire.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificatore delle impostazioni locali per le informazioni sul tipo.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica il membro.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flag che descrivono il contesto della chiamata.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntatore alla posizione in cui deve essere archiviato il risultato.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntatore a una struttura contenente informazioni sull'eccezione.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Indice del primo argomento che contiene un errore.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::Invoke`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">Per una descrizione di questo membro, vedere <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>