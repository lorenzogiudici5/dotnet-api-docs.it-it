<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3d5877ccfca1ad46bc974cf9102a85adaba2a32" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30481495" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un assembly, ovvero un blocco predefinito di un'applicazione Common Language Runtime riutilizzabile, autodescrittivo e di cui è possibile eseguire il controllo delle versioni.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.Reflection.Assembly> classe per caricare gli assembly, per esplorare i metadati e le parti costitutive dell'assembly, per individuare i tipi contenuti nell'assembly e per creare istanze di tali tipi.  
  
 Per ottenere una matrice di <xref:System.Reflection.Assembly> gli oggetti che rappresentano gli assembly attualmente caricati in un dominio di applicazione (ad esempio, il dominio applicazione predefinito di un progetto semplice), utilizzare il <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> metodo.  
  
 Per caricare gli assembly in modo dinamico, il <xref:System.Reflection.Assembly> classe fornisce i seguenti metodi statici (`Shared` metodi in Visual Basic). Gli assembly vengono caricati nel dominio applicazione in cui si verifica l'operazione di caricamento.  
  
-   Il modo consigliato per il caricamento degli assembly consiste nell'utilizzare il <xref:System.AppDomain.Load%2A> metodo, che identifica l'assembly da caricare in base al nome visualizzato (ad esempio, "Forms, Version = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089"). La ricerca per l'assembly segue le regole descritte in [come il Runtime individua gli assembly](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).  
  
-   Il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi consentono di caricare un assembly per la reflection, ma non per l'esecuzione. Ad esempio, un assembly destinato a una piattaforma a 64 bit può essere esaminato dal codice che è in esecuzione su una piattaforma a 32 bit.  
  
-   Il <xref:System.Reflection.Assembly.LoadFile%2A> e <xref:System.Reflection.Assembly.LoadFrom%2A> metodi vengono forniti per i rari scenari in cui un assembly deve essere identificato dal percorso.  
  
 Per ottenere un <xref:System.Reflection.Assembly> oggetto per l'assembly attualmente in esecuzione, utilizzare il <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> metodo.  
  
 Numero di membri della <xref:System.Reflection.Assembly> classe fornisce informazioni relative a un assembly. Ad esempio:  
  
-   Il <xref:System.Reflection.Assembly.GetName%2A> metodo restituisce un <xref:System.Reflection.AssemblyName> oggetto che fornisce accesso alle parti del nome visualizzato dell'assembly.  
  
-   Il <xref:System.Reflection.Assembly.GetCustomAttributes%2A> metodo elenca gli attributi applicati all'assembly.  
  
-   Il <xref:System.Reflection.Assembly.GetFiles%2A> metodo fornisce l'accesso ai file nel manifesto dell'assembly.  
  
-   Il <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> metodo fornisce i nomi delle risorse nel manifesto dell'assembly.  
  
 Il <xref:System.Reflection.Assembly.GetTypes%2A> metodo elenca tutti i tipi nell'assembly. Il <xref:System.Reflection.Assembly.GetExportedTypes%2A> metodo sono elencati i tipi che sono visibili ai chiamanti all'esterno dell'assembly. Il <xref:System.Reflection.Assembly.GetType%2A> metodo può essere utilizzato per cercare un particolare tipo nell'assembly. Il <xref:System.Reflection.Assembly.CreateInstance%2A> metodo può essere utilizzato per la ricerca e creare istanze dei tipi nell'assembly.  
  
 Per ulteriori informazioni sugli assembly, vedere la sezione "Assembly e domini di applicazione" di [domini applicazione](~/docs/framework/app-domains/application-domains.md) argomento.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere l'assembly attualmente in esecuzione, creare un'istanza di un tipo di contenuti in tale assembly e richiamare uno dei metodi del tipo con associazione tardiva. A tale scopo, l'esempio di codice definisce una classe denominata `Example`, con un metodo denominato `SampleMethod`. Il costruttore della classe accetta un numero intero, viene utilizzato per calcolare il valore restituito del metodo.  
  
 L'esempio di codice viene inoltre illustrato l'utilizzo del <xref:System.Reflection.Assembly.GetName%2A> per ottenere un <xref:System.Reflection.AssemblyName> oggetto che può essere utilizzato per analizzare il nome completo dell'assembly. L'esempio visualizza il numero di versione dell'assembly, il <xref:System.Reflection.Assembly.CodeBase%2A> , proprietà e <xref:System.Reflection.Assembly.EntryPoint%2A> proprietà.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per l'attendibilità totale per gli eredi. Questa classe non può essere ereditata da codice parzialmente attendibile.</permission>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Assembly" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene richiamato dalle classi derivate durante la costruzione di <xref:System.Reflection.Assembly> oggetti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso dell'assembly come originariamente specificato, ad esempio in un oggetto <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <value>Percorso dell'assembly come originariamente specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere il percorso assoluto del file caricato che contiene manifesto, utilizzare il <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> proprietà invece.  
  
 Se l'assembly è stato caricato come una matrice di byte, utilizzando un overload di <xref:System.Reflection.Assembly.Load%2A> metodo che accetta una matrice di byte, questa proprietà restituisce la posizione del chiamante del metodo, non il percorso dell'assembly caricato.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Reflection.Assembly.CodeBase%2A> proprietà.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere al percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Individua un tipo in questo assembly e ne crea un'istanza usando l'attivatore di sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> del tipo da individuare.</param>
        <summary>Individua il tipo specificato in questo assembly e ne crea un'istanza usando l'attivatore di sistema e consentendo la ricerca con distinzione tra maiuscole e minuscole.</summary>
        <returns>Istanza del tipo specificato creata con il costruttore predefinito oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Il tipo viene risolto usando il binder predefinito, senza specificare attributi delle impostazioni cultura o dell'attivazione e con <see cref="T:System.Reflection.BindingFlags" /> impostato su <see langword="Public" /> o <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il runtime è riuscito a trovare `typeName` nel <xref:System.Reflection.Assembly> istanza, viene restituito `null` anziché generare un'eccezione. Questa situazione può verificarsi perché:  
  
-   Non sono stati specificati il nome completo del tipo.  
  
-   È stato specificato il nome completo del tipo, ma il relativo case non corrisponde nel caso del tipo <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà. Per un confronto senza distinzione di `typeName` con il nome del tipo completo, chiamare il <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload e specificare `true` per il `ignoreCase` argomento.  
  
-   Il tipo non esiste nell'oggetto <xref:System.Reflection.Assembly> istanza.  
  
   
  
## Examples  
 L'esempio seguente definisce un `Person` classe e viene chiamato il <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> metodo un'istanza.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> è una stringa vuota ("") o una stringa che inizia con un carattere Null.  
  
 oppure  
  
 L'assembly corrente è stato caricato nel contesto di sola reflection.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
 oppure  
  
 L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="typeName" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
 oppure  
  
 <paramref name="typeName" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> del tipo da individuare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole nel nome del tipo; in caso contrario, <see langword="false" />.</param>
        <summary>Individua il tipo specificato in questo assembly e ne crea un'istanza usando l'attivatore di sistema e consentendo la ricerca con distinzione facoltativa tra maiuscole e minuscole.</summary>
        <returns>Istanza del tipo specificato creata con il costruttore predefinito oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Il tipo viene risolto usando il binder predefinito, senza specificare attributi delle impostazioni cultura o dell'attivazione e con <see cref="T:System.Reflection.BindingFlags" /> impostato su <see langword="Public" /> o <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il runtime è riuscito a trovare `typeName` nel <xref:System.Reflection.Assembly> istanza, viene restituito `null` anziché generare un'eccezione. Questa situazione può verificarsi perché:  
  
-   Non sono stati specificati il nome completo del tipo.  
  
-   Il tipo non esiste nell'oggetto <xref:System.Reflection.Assembly> istanza.  
  
   
  
## Examples  
 L'esempio seguente definisce un `Person` classe. Chiama quindi il <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> metodo per creare un'istanza, tuttavia, poiché le maiuscole e minuscole del `typeName` argomento non corrisponde a quello del tipo <xref:System.Type.FullName%2A> proprietà, il metodo restituisce `null`. Quando l'esempio passa la stessa stringa per il <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload e specifica che il confronto deve essere tra maiuscole e minuscole, il `Person` classe viene trovata e un `Person` oggetto viene creata un'istanza.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> è una stringa vuota ("") o una stringa che inizia con un carattere Null.  
  
 oppure  
  
 L'assembly corrente è stato caricato nel contesto di sola reflection.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
 oppure  
  
 L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="typeName" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
 oppure  
  
 <paramref name="typeName" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> del tipo da individuare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole nel nome del tipo; in caso contrario, <see langword="false" />.</param>
        <param name="bindingAttr">Maschera di bit che influenza le modalità di esecuzione della ricerca. Il valore è una combinazione di flag di bit dell'oggetto <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Oggetto che consente il binding, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see langword="MemberInfo" /> tramite reflection. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice contenente gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o <see langword="null" />.</param>
        <param name="culture">Istanza di <see langword="CultureInfo" /> usata per regolare la coercizione dei tipi. Se è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see langword="CultureInfo" />. Si tratta di un parametro necessario per convertire un oggetto <see langword="String" /> che rappresenta, ad esempio, il numero 1000 in un valore <see langword="Double" />, dal momento che questo numero è rappresentato in modo diverso nelle varie impostazioni cultura.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Individua il tipo specificato in questo assembly e ne crea un'istanza usando l'attivatore di sistema, consentendo la ricerca con distinzione facoltativa tra maiuscole e minuscole e usando le impostazioni cultura, gli argomenti e gli attributi di attivazione e di binding specificati.</summary>
        <returns>Istanza del tipo specificato o <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Gli argomenti forniti vengono usati per risolvere il tipo e per associare il costruttore usato per creare l'istanza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> è una stringa vuota ("") o una stringa che inizia con un carattere Null.  
  
 oppure  
  
 L'assembly corrente è stato caricato nel contesto di sola reflection.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Una matrice di attributi di attivazione non vuota viene passata a un tipo che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
 oppure  
  
 L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="typeName" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
 oppure  
  
 <paramref name="typeName" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per creare un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato di un assembly.</param>
        <param name="typeName">Nome completo di un tipo.</param>
        <summary>Crea il nome di un tipo qualificato dal nome visualizzato del relativo assembly.</summary>
        <returns>Nome completo del tipo qualificato dal nome visualizzato dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il formato della stringa restituita è:  
  
 \<FullTypeName>, \<AssemblyDisplayName>  
  
 Vedere <xref:System.Reflection.AssemblyName> per una descrizione del formato del nome visualizzato di un assembly.  
  
 Per le modifiche nelle versioni di common language runtime, utilizzare questo metodo anziché costruire il nome completo manualmente.  Per informazioni sui nomi di assembly completo, vedere <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta che contiene gli attributi personalizzati di questo assembly.</summary>
        <value>Raccolta che contiene gli attributi personalizzati di questo assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta dei tipi definiti in questo assembly.</summary>
        <value>Raccolta dei tipi definiti in questo assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Assembly.DefinedTypes%2A> proprietà è confrontabile con il <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> (metodo), con la differenza che il <xref:System.Reflection.Assembly.DefinedTypes%2A> proprietà restituisce una raccolta di <xref:System.Reflection.TypeInfo> oggetti e il <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metodo restituisce una matrice di <xref:System.Type> oggetti.  
  
 La matrice restituita include i tipi annidati.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il punto di ingresso di questo assembly.</summary>
        <value>Oggetto che rappresenta il punto di ingresso di questo assembly. Se non viene trovato alcun punto di ingresso, ad esempio se l'assembly è un file DLL, viene restituito <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Oggetto da confrontare con questa istanza.</param>
        <summary>Determina se questo assembly e l'oggetto specificato sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="o" /> è uguale all'istanza. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Assembly.Equals%2A> metodo esegue un test di uguaglianza di riferimenti determinare se l'istanza corrente e `o` sono uguali.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'URI, inclusi i caratteri di escape, che rappresenta la codebase.</summary>
        <value>URI con caratteri di escape.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere al percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'evidenza per questo assembly.</summary>
        <value>Evidenza per questo assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'evidenza è l'insieme di informazioni su cui vengono basate le decisioni inerenti i criteri di sicurezza, ad esempio le autorizzazioni che è possibile assegnare al codice.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta dei tipi pubblici definiti in questo assembly visibili all'esterno dell'assembly.</summary>
        <value>Raccolta dei tipi pubblici definiti in questo assembly visibili all'esterno dell'assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome visualizzato dell'assembly.</summary>
        <value>Nome visualizzato dell'assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Reflection.AssemblyName> per una descrizione del formato del nome visualizzato di un assembly.  
  
> [!NOTE]
>  Non è consigliabile scrivere il proprio codice per analizzare i nomi visualizzati. Al contrario, passare il nome visualizzato per il <xref:System.Reflection.AssemblyName.%23ctor%2A> costruttore, che analizza e compila i campi appropriati del nuovo <xref:System.Reflection.AssemblyName>.  
  
 In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly. Tuttavia, non è incluso nella stringa restituita dal <xref:System.Reflection.Assembly.FullName%2A> proprietà, per motivi di compatibilità. Vedere <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'esempio seguente recupera il nome visualizzato dell'assembly attualmente in esecuzione e il nome visualizzato dell'assembly che contiene il <xref:System.Int32> tipo (`int` in c#, `Integer` in Visual Basic).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Oggetto che rappresenta un tipo nell'assembly che verrà restituito.</param>
        <summary>Ottiene l'assembly attualmente caricato in cui è definito il tipo specificato.</summary>
        <returns>Assembly in cui è definito il tipo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo equivale a recuperare il valore della <xref:System.Type.Assembly?displayProperty=nameWithType> proprietà. Tuttavia, il <xref:System.Type.Assembly?displayProperty=nameWithType> proprietà offre in genere prestazioni migliori.  
  
 Per chiamare questo metodo, è necessario un <xref:System.Type> oggetto, che indica che l'assembly in cui è definita la classe deve essere già caricato.  
  
   
  
## Examples  
 L'esempio seguente recupera l'assembly che contiene il <xref:System.Int32> digitare e visualizza il nome e il percorso file.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Reflection.Assembly" /> del metodo che ha richiamato il metodo attualmente in esecuzione.</summary>
        <returns>Oggetto <see langword="Assembly" /> del metodo che ha richiamato il metodo attualmente in esecuzione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il metodo che chiama il <xref:System.Reflection.Assembly.GetCallingAssembly%2A> metodo espansione inline dal compilatore just-in-time (JIT), o se il chiamante è espanso inline, l'assembly restituito da <xref:System.Reflection.Assembly.GetCallingAssembly%2A> possono variare in modo imprevisto. Si consideri, ad esempio, i metodi e gli assembly seguenti:  
  
-   Metodo `M1` nell'assembly `A1` chiamate <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
-   Metodo `M2` nell'assembly `A2` chiamate `M1`.  
  
-   Metodo `M3` nell'assembly `A3` chiamate `M2`.  
  
 Quando `M1` non inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> restituisce `A2`. Quando `M1` inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> restituisce `A3`. Analogamente, quando `M2` non inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> restituisce `A2`. Quando `M2` inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> restituisce `A3`.  
  
 Questo effetto si verifica anche quando `M1` viene eseguito come una chiamata tail da `M2`, o quando `M2` viene eseguito come una chiamata tail da `M3`. È possibile impedire al compilatore JIT inline che chiama il metodo di <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, applicando il <xref:System.Runtime.CompilerServices.MethodImplAttribute> attributo con il <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flag, ma non è disponibile alcun meccanismo simile per impedire le chiamate tail.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene l'assembly chiamante del metodo corrente.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene gli attributi personalizzati per questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Questo argomento viene ignorato per gli oggetti di tipo <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Ottiene tutti gli attributi personalizzati per questo assembly.</summary>
        <returns>Matrice contenente gli attributi personalizzati per questo assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa corrispondente <xref:System.Reflection.ICustomAttributeProvider> metodo di interfaccia. Pertanto, il `inherit` parametro deve essere specificato anche se viene ignorata.  
  
 Un pseudo-attributo indica i bit di metadati di base che deve essere impostata quando l'attributo è presenta. A differenza di un attributo personalizzato che estende i metadati per un tipo e viene salvato insieme al tipo, uno pseudo-attributo modifica i metadati per il tipo e quindi viene eliminato. Alcuni dei bit risultante non sono accessibili tramite l'API di reflection esistenti.  
  
 Nella tabella seguente sono riepilogati i diversi pseudo- attributi e le funzioni di accesso per i bit sono disponibili nella reflection.  
  
|Pseudo-Attribute|Bit di metadati|Funzione di accesso di Reflection|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Nome della DLL|Nessuna funzione di accesso per PInvokeMap per gli attributi del metodo normale metodo globale.<br /><br /> Nessuna funzione di accesso per il nome DLL.|  
|GuidAttribute|Archiviato come un attributo personalizzato reale.|Accedere come un attributo personalizzato reale.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Vari bit.|Nessuna funzione di accesso.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Compressione di classe.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Nessuna funzione di accesso.|  
|FieldOffsetAttribute|Offset di campo.|Nessuna funzione di accesso.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Nessuna funzione di accesso o enumeratore.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo per cui restituire gli attributi personalizzati.</param>
        <param name="inherit">Questo argomento viene ignorato per gli oggetti di tipo <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Ottiene gli attributi personalizzati per questo assembly, come specificato dal tipo.</summary>
        <returns>Matrice contenente gli attributi personalizzati per questo assembly, come specificato da <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa corrispondente <xref:System.Reflection.ICustomAttributeProvider> metodo di interfaccia. Pertanto, il `inherit` parametro deve essere specificato anche se viene ignorata.  
  
 Un pseudo-attributo indica i bit di metadati di base che deve essere impostata quando l'attributo è presenta. A differenza di un attributo personalizzato che estende i metadati per un tipo e viene salvato insieme al tipo, uno pseudo-attributo modifica i metadati per il tipo e quindi viene eliminato. Alcuni dei bit risultante non sono accessibili tramite l'API di reflection esistenti.  
  
 Nella tabella seguente sono riepilogati i diversi pseudo- attributi e le funzioni di accesso per i bit sono disponibili nella reflection.  
  
|Pseudo-Attribute|Bit di metadati|Funzione di accesso di Reflection|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Nome della DLL|Nessuna funzione di accesso per PInvokeMap per gli attributi del metodo normale metodo globale.<br /><br /> Nessuna funzione di accesso per il nome DLL.|  
|GuidAttribute|Archiviato come un attributo personalizzato reale.|Accedere come un attributo personalizzato reale.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Vari bit.|Nessuna funzione di accesso.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Compressione di classe.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Nessuna funzione di accesso.|  
|FieldOffsetAttribute|Offset di campo.|Nessuna funzione di accesso.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Nessuna funzione di accesso o enumeratore.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> non è un tipo da runtime.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce informazioni sugli attributi applicati all'oggetto <see cref="T:System.Reflection.Assembly" /> corrente, espresse sotto forma di oggetti <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
        <returns>Elenco generico di oggetti <see cref="T:System.Reflection.CustomAttributeData" /> che rappresentano i dati relativi agli attributi applicati all'assembly corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per esaminare gli attributi personalizzati del codice nel contesto ReflectionOnly, in casi in cui gli attributi personalizzati sono definiti nel codice caricato nel contesto reflection-only. Metodi come <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> e <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> non può essere utilizzato in questi casi, perché creano istanze degli attributi. Impossibile eseguire il codice nel contesto reflection-only. Per ulteriori informazioni e ad esempio di codice, vedere la <xref:System.Reflection.CustomAttributeData> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'eseguibile del processo nel dominio applicazione predefinito. In altri domini applicazione, si tratta del primo eseguibile eseguito da <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</summary>
        <returns>Assembly che rappresenta l'eseguibile del processo nel dominio applicazione predefinito oppure il primo eseguibile eseguito da <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />. Può restituire <see langword="null" /> se chiamato da codice non gestito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Assembly.GetEntryAssembly%2A> metodo può restituire `null` quando un assembly gestito è stato caricato da un'applicazione non gestita. Ad esempio, se un'applicazione non gestita crea un'istanza di un componente COM, scritto in c#, una chiamata al <xref:System.Reflection.Assembly.GetEntryAssembly%2A> metodo dal componente c# restituisce null, perché il punto di ingresso per il processo è il codice non gestito, piuttosto che un assembly gestito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'assembly che contiene il codice attualmente in esecuzione.</summary>
        <returns>Assembly che contiene il codice attualmente in esecuzione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per motivi di prestazioni, è necessario chiamare questo metodo solo quando non si conosce in fase di progettazione quali assembly attualmente in esecuzione. Il metodo consigliato per recuperare un <xref:System.Reflection.Assembly> oggetto che rappresenta l'assembly corrente consiste nell'utilizzare il <xref:System.Type.Assembly%2A?displayProperty=nameWithType> trovare la proprietà di un tipo nell'assembly, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 Per ottenere l'assembly che contiene il metodo che ha chiamato il codice attualmente in esecuzione, utilizzare <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Type.Assembly%2A?displayProperty=nameWithType> basata su proprietà per ottenere l'assembly attualmente in esecuzione su un tipo di contenuti in tale assembly. Chiama anche il <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> metodo per mostrare che restituisce un <xref:System.Reflection.Assembly> oggetto che rappresenta lo stesso assembly.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene i tipi pubblici definiti nell'assembly visibili all'esterno dell'assembly.</summary>
        <returns>Matrice che rappresenta i tipi definiti nell'assembly visibili all'esterno dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli unici tipi visibili all'esterno di un assembly sono tipi pubblici e i tipi pubblici annidati all'interno di altri tipi pubblici.  
  
   
  
## Examples  
 Esempio di codice seguente definisce una serie di classi con vari livelli di accesso e chiamate <xref:System.Reflection.Assembly.GetExportedTypes%2A> per visualizzare quelli visibili all'esterno dell'assembly.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'assembly è un assembly dinamico.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è possibile caricare un assembly dipendente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome del file specificato. Non includere il percorso del file.</param>
        <summary>Ottiene un oggetto <see cref="T:System.IO.FileStream" /> per il file specificato nella tabella file del manifesto dell'assembly.</summary>
        <returns>Flusso che contiene il file specificato o <see langword="null" /> se il file non viene trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in entrambi i file di risorse pubbliche e private.  
  
 Il `name` non deve includere il percorso del file.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="name" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> non è un assembly valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere al percorso e la lettura del file specificato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene i file della tabella file di un manifesto dell'assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene i file della tabella file di un manifesto dell'assembly.</summary>
        <returns>Matrice di flussi che contengono i file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in file di risorse pubbliche e private.  
  
 Questo overload equivale alla chiamata di <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> overload e specificare `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File non trovato.</exception>
        <exception cref="T:System.BadImageFormatException">Un file non è un assembly valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> per includere i moduli delle risorse; in caso contrario, <see langword="false" />.</param>
        <summary>Ottiene i file della tabella file di un manifesto dell'assembly, specificando se includere i moduli delle risorse.</summary>
        <returns>Matrice di flussi che contengono i file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in file di risorse pubbliche e private.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File non trovato.</exception>
        <exception cref="T:System.BadImageFormatException">Un file non è un assembly valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene tutti i moduli caricati che fanno parte di questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene tutti i moduli caricati che fanno parte di questo assembly.</summary>
        <returns>Matrice di moduli.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> per includere i moduli delle risorse; in caso contrario, <see langword="false" />.</param>
        <summary>Ottiene tutti i moduli caricati che fanno parte di questo assembly, specificando se includere i moduli delle risorse.</summary>
        <returns>Matrice di moduli.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">Nome della risorsa con distinzione tra maiuscole e minuscole.</param>
        <summary>Restituisce informazioni sul modo in cui la risorsa specificata è stata resa persistente.</summary>
        <returns>Oggetto popolato con informazioni relative alla topologia della risorsa oppure <see langword="null" /> se la risorsa non viene trovata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="resourceName" /> è una stringa vuota ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce i nomi di tutte le risorse di questo assembly.</summary>
        <returns>Matrice che contiene i nomi di tutte le risorse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare ogni nome di risorsa nella matrice restituita da questo metodo, come indicato di seguito:  
  
-   È possibile passare il nome della risorsa per il <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> metodo per ottenere ulteriori informazioni sulla risorsa.  
  
-   Se il nome identifica un file con estensione resources binari, è possibile rimuovere l'estensione del file. Resources e passarlo al <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> costruttore per creare un'istanza di gestione risorse.  
  
-   È possibile passare il nome della risorsa per il <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> metodo per recuperare un <xref:System.IO.Stream> oggetto che è quindi possibile passare il <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> costruttore.  
  
-   È possibile passare il nome della risorsa per il <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> metodo per recuperare un <xref:System.IO.Stream> oggetto che è quindi possibile passare il <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> costruttore.  
  
 Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica la risorsa del manifesto specificata da questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome della risorsa del manifesto richiesta con distinzione tra maiuscole e minuscole.</param>
        <summary>Carica la risorsa del manifesto specificata da questo assembly.</summary>
        <returns>Risorsa di manifesto oppure <see langword="null" /> se non vengono specificate risorse durante la compilazione o se la risorsa non è visibile al chiamante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una risorsa di manifesto è una risorsa incorporata nell'assembly in fase di compilazione (ad esempio un file di immagine). Per ulteriori informazioni sulle risorse di manifesto, vedere [concetti fondamentali sulle risorse di Microsoft .NET Framework](http://go.microsoft.com/fwlink/?LinkId=204554) in MSDN Library.  
  
 Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Questo metodo restituisce `null` se si accede a una risorsa privata in un altro assembly e il chiamante non dispone <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.  
  
 Se il manifesto dell'assembly include un file di risorse, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> restituisce un <xref:System.IO.Stream> anche se il file di risorse non è disponibile su disco al momento dell'oggetto. Se non viene trovato il file di risorse, passando il valore risultante <xref:System.IO.Stream> dell'oggetto per il <xref:System.Resources.ResourceReader> cause costruttore un <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="name" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> non è un assembly valido.</exception>
        <exception cref="T:System.NotImplementedException">La lunghezza della risorsa è maggiore di <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo il cui spazio dei nomi viene usato per definire l'ambito del nome della risorsa del manifesto.</param>
        <param name="name">Nome della risorsa del manifesto richiesta con distinzione tra maiuscole e minuscole.</param>
        <summary>Carica la risorsa del manifesto specificata, definita per l'ambito dallo spazio dei nomi del tipo specificato, da questo assembly.</summary>
        <returns>Risorsa di manifesto oppure <see langword="null" /> se non vengono specificate risorse durante la compilazione o se la risorsa non è visibile al chiamante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, se il nome completo specificato per `type` è "MyNameSpace. MyClasses" e `name` è "Net", questo metodo di overload Cerca una risorsa denominata "MyNameSpace.Net".  
  
 Una risorsa di manifesto è una risorsa incorporata nell'assembly in fase di compilazione (ad esempio un file di immagine). Per ulteriori informazioni sulle risorse di manifesto, vedere [concetti fondamentali sulle risorse di Microsoft .NET Framework](http://go.microsoft.com/fwlink/?LinkId=204554) in MSDN Library.  
  
 Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Questo metodo restituisce `null` se si accede a una risorsa privata in un altro assembly e il chiamante non dispone <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.  
  
 Se il manifesto dell'assembly include un file di risorse, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> restituisce un <xref:System.IO.Stream> anche se il file di risorse non è disponibile su disco al momento dell'oggetto. Se non viene trovato il file di risorse, passando il valore risultante <xref:System.IO.Stream> dell'oggetto per il <xref:System.Resources.ResourceReader> cause costruttore un <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="name" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> non è un assembly valido.</exception>
        <exception cref="T:System.NotImplementedException">La lunghezza della risorsa è maggiore di <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome del modulo richiesto.</param>
        <summary>Ottiene il modulo specificato in questo assembly.</summary>
        <returns>Modulo richiesto o <see langword="null" /> se il modulo non viene trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona sui nomi di file.  
  
 Classi di `Reflection.Emit` dello spazio dei nomi creano il nome dell'ambito per un modulo dinamico. Il nome ambito può essere determinato mediante la <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> proprietà. Passare il tipo di modulo che si desidera `Assembly.GetModule`. Ad esempio, se si desidera il modulo che contiene il manifesto dell'assembly, passare il nome dell'ambito del modulo da `GetModule`. In caso contrario, passare il nome del file del modulo. Gli assembly caricati da una del `Load` metodi che hanno un parametro byte [] contengono un solo modulo, ovvero il modulo del manifesto. Ricercare sempre questi moduli utilizzando il nome dell'ambito.  
  
 Un tipo può essere recuperato da un modulo specifico tramite <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. La chiamata `Module.GetType` sul modulo che contiene il manifesto non verrà avviata una ricerca dell'intero assembly. Per recuperare un tipo da un assembly, indipendentemente dalla quale è in, è necessario chiamare <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="name" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> non è un assembly valido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene tutti i moduli che fanno parte di questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene tutti i moduli che fanno parte di questo assembly.</summary>
        <returns>Matrice di moduli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in file di risorse pubbliche e private.  
  
> [!NOTE]
>  I moduli devono essere generati con estensioni di file.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome del modulo nella matrice restituita che contiene il manifesto dell'assembly.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Il modulo da caricare non specifica un'estensione di file.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> per includere i moduli delle risorse; in caso contrario, <see langword="false" />.</param>
        <summary>Ottiene tutti i moduli che fanno parte di questo assembly, specificando se includere i moduli delle risorse.</summary>
        <returns>Matrice di moduli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in file di risorse pubbliche e private.  
  
> [!NOTE]
>  I moduli devono essere generati con estensioni di file.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Reflection.AssemblyName" /> per questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Reflection.AssemblyName" /> per questo assembly.</summary>
        <returns>Oggetto che contiene il nome visualizzato completamente analizzato per questo assembly.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere al percorso dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          <see langword="true" /> per impostare la proprietà <see cref="P:System.Reflection.Assembly.CodeBase" /> sul percorso dell'assembly dopo l'esecuzione della copia shadow; <see langword="false" /> per impostare <see cref="P:System.Reflection.Assembly.CodeBase" /> sul percorso originale.</param>
        <summary>Ottiene un oggetto <see cref="T:System.Reflection.AssemblyName" /> per questo assembly, impostando la codebase come specificato da <paramref name="copiedName" />.</summary>
        <returns>Oggetto che contiene il nome visualizzato completamente analizzato per questo assembly.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere al percorso dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto da popolare con le informazioni sulla serializzazione.</param>
        <param name="context">Contesto di destinazione della serializzazione.</param>
        <summary>Ottiene le informazioni sulla serializzazione con tutti i dati necessari per creare una nuova istanza di questo assembly.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene gli oggetti <see cref="T:System.Reflection.AssemblyName" /> per tutti gli assembly a cui fa riferimento questo assembly.</summary>
        <returns>Matrice contenente i nomi visualizzati completamente analizzati di tutti gli assembly a cui fa riferimento questo assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> proprietà di un <xref:System.Reflection.AssemblyName> oggetto restituito da questo metodo è <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> se è presente alcun algoritmo hash per l'assembly di riferimento, o se l'algoritmo hash dell'assembly di riferimento non è identificato dal <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumerazione. Nelle versioni precedenti di .NET Framework, il <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> proprietà restituita <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in questa situazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata la chiamata di <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Reflection.Assembly> classe.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene l'assembly satellite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Impostazioni cultura specificate.</param>
        <summary>Ottiene l'assembly satellite per le impostazioni cultura specificate.</summary>
        <returns>Assembly satellite specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli assembly satellite contengono risorse localizzate, distinte dall'assembly principale dell'applicazione, che contengono codice eseguibile non localizzabile nonché risorse per singole impostazioni cultura utilizzate come impostazioni cultura neutre o predefinito.  
  
 Chiamare questo metodo per utilizzare la versione dell'assembly corrente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">È stato trovato l'assembly satellite con un nome file corrispondente, ma <see langword="CultureInfo" /> non corrisponde a quello specificato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly satellite non è un assembly valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">Impostazioni cultura specificate.</param>
        <param name="version">Versione dell'assembly satellite.</param>
        <summary>Ottiene la versione specificata dell'assembly satellite per le impostazioni cultura specificate.</summary>
        <returns>Assembly satellite specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli assembly satellite contengono risorse localizzate, distinte dall'assembly principale dell'applicazione, che contengono codice eseguibile non localizzabile nonché risorse per singole impostazioni cultura utilizzate come impostazioni cultura neutre o predefinito.  
  
 Chiamare il <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload da utilizzare la versione dell'assembly corrente.  
  
 Se `version` è `null`, la versione dell'assembly corrente viene utilizzata se la risorsa e l'assembly principale sono firmati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">È stato trovato l'assembly satellite con un nome file corrispondente, ma <see langword="CultureInfo" /> o la versione non corrisponde a quanto specificato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly satellite non è un assembly valido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> che rappresenta il tipo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome completo del tipo.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato nell'istanza dell'assembly.</summary>
        <returns>Oggetto che rappresenta la classe specificata o <see langword="null" /> se la classe non viene trovata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca solo l'istanza dell'assembly corrente. Il `name` parametro include lo spazio dei nomi ma non l'assembly. Per cercare altri assembly per un tipo, usare il <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> overload del metodo, che può includere un nome visualizzato dell'assembly come parte del nome del tipo.  
  
> [!NOTE]
>  Se il tipo è stato inoltrato a un altro assembly, viene comunque restituito da questo metodo. Per informazioni sull'inoltro dei tipi, vedere [inoltro dei tipi in Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
   
  
## Examples  
 L'esempio seguente definisce una classe astratta `MeansOfTransportation` classe il `Transportation` dello spazio dei nomi. Chiama il <xref:System.Reflection.Assembly.GetType%28System.String%29> metodo per recuperare il relativo <xref:System.Type> oggetto, chiama il <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> metodo per ottenere una matrice di <xref:System.Reflection.PropertyInfo> gli oggetti che rappresentano le proprietà del tipo e quindi Visualizza le informazioni del tipo astraggono proprietà. Si noti che la chiamata al <xref:System.Reflection.Assembly.GetType%28System.String%29> metodo utilizza il nome completo del tipo (ovvero, lo spazio dei nomi con il nome del tipo).  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> non è valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>
          <paramref name="name" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
 oppure  
  
 L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="name" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
 oppure  
  
 <paramref name="name" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome completo del tipo.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se il tipo non viene trovato; <see langword="false" /> per restituire <see langword="null" />.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato nell'istanza dell'assembly e facoltativamente genera un'eccezione se il tipo non viene trovato.</summary>
        <returns>Oggetto che rappresenta la classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca solo l'istanza dell'assembly corrente. Il `name` parametro include lo spazio dei nomi ma non l'assembly. Per cercare altri assembly per un tipo, usare il <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> overload del metodo, che può includere un nome visualizzato dell'assembly come parte del nome del tipo.  
  
> [!NOTE]
>  Se il tipo è stato inoltrato a un altro assembly, viene comunque restituito da questo metodo. Per informazioni sull'inoltro dei tipi, vedere [inoltro dei tipi in Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Il `throwOnError` parametro ha effetto solo quando il tipo non è stato trovato. Non si applica le eccezioni eventualmente generate. In particolare, se il tipo è stato trovato ma non può essere caricato, <xref:System.TypeLoadException> possono essere generate anche se `throwOnError` è `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> non è valido.  
  
 oppure  
  
 La lunghezza <paramref name="name" /> supera i 1024 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
 oppure  
  
 L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="name" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
 oppure  
  
 <paramref name="name" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome completo del tipo.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se il tipo non viene trovato; <see langword="false" /> per restituire <see langword="null" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole nel nome del tipo; in caso contrario, <see langword="false" />.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato nell'istanza dell'assembly, con la possibilità di ignorare la distinzione tra maiuscole e minuscole e di generare un'eccezione se il tipo non viene trovato.</summary>
        <returns>Oggetto che rappresenta la classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca solo l'istanza dell'assembly corrente. Il `name` parametro include lo spazio dei nomi ma non l'assembly. Per cercare altri assembly per un tipo, usare il <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> overload del metodo, che può includere un nome visualizzato dell'assembly come parte del nome del tipo.  
  
> [!NOTE]
>  Se il tipo è stato inoltrato a un altro assembly, viene comunque restituito da questo metodo. Per informazioni sull'inoltro dei tipi, vedere [inoltro dei tipi in Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Il `throwOnError` parametro ha effetto solo quando il tipo non è stato trovato. Non si applica le eccezioni eventualmente generate. In particolare, se il tipo è stato trovato ma non può essere caricato, <xref:System.TypeLoadException> possono essere generate anche se `throwOnError` è `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> non è valido.  
  
 oppure  
  
 La lunghezza <paramref name="name" /> supera i 1024 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
 oppure  
  
 L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="name" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
 oppure  
  
 <paramref name="name" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene i tipi definiti in questo assembly.</summary>
        <returns>Matrice che contiene tutti i tipi definiti in questo assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matrice restituita include i tipi annidati.  
  
 Se il <xref:System.Reflection.Assembly.GetTypes%2A> metodo viene chiamato su un assembly e un tipo di tale assembly è dipendente da un tipo in un assembly che non è stato caricato (ad esempio, se deriva da un tipo nel secondo assembly), un <xref:System.Reflection.ReflectionTypeLoadException> viene generata un'eccezione. Ad esempio, questa situazione può verificarsi se il primo assembly è stato caricato con le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> o <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi e il secondo assembly non è stato caricato. Questo può verificarsi anche con gli assembly caricati utilizzando il <xref:System.Reflection.Assembly.Load%2A> e <xref:System.Reflection.Assembly.LoadFile%2A> metodi se il secondo assembly non viene trovato quando la <xref:System.Reflection.Assembly.GetTypes%2A> metodo viene chiamato.  
  
> [!NOTE]
>  Se un tipo è stato inoltrato a un altro assembly, non è incluso nella matrice restituita. Per informazioni sull'inoltro dei tipi, vedere [inoltro dei tipi in Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Per recuperare una raccolta di <xref:System.Reflection.TypeInfo> oggetti anziché una matrice di <xref:System.Type> oggetti, utilizzare il <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> proprietà.  
  
   
  
## Examples  
 L'esempio seguente mostra i parametri di un metodo su un tipo nell'assembly specificato.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">L'assembly contiene uno o più tipi che non possono essere caricati. La matrice restituita dalla proprietà <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> di questa eccezione contiene un oggetto <see cref="T:System.Type" /> per ogni tipo caricato e <see langword="null" /> per ogni tipo non caricato, mentre la proprietà <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> contiene un'eccezione per ogni tipo non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'assembly è stato caricato dalla Global Assembly Cache.</summary>
        <value>
          <see langword="true" /> se l'assembly è stato caricato dalla Global Assembly Cache; in caso contrario <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il contesto host con cui l'assembly è stato caricato.</summary>
        <value>Valore <see cref="T:System.Int64" /> che indica il contesto host con cui l'assembly è stato caricato, se presente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una stringa che rappresenta la versione di CLR (Common Language Runtime) salvata nel file che contiene il manifesto.</summary>
        <value>Nome della cartella della versione CLR. Non si tratta di un percorso completo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, il valore per la versione 1.1 di .NET Framework sarebbe v 1.1.4322. I file binari per tale versione potrebbe trovarsi nel windir%\Microsoft.NET\Framework\v1.1.4322% percorso.  
  
 Per impostazione predefinita, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> è impostata sulla versione di CLR utilizzata per compilare l'assembly. Tuttavia, si potrebbe essere impostato su un altro valore in fase di compilazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo dell'attributo da controllare per l'assembly.</param>
        <param name="inherit">Questo argomento viene ignorato per gli oggetti di questo tipo.</param>
        <summary>Indica se è stato applicato un attributo specificato all'assembly.</summary>
        <returns>
          <see langword="true" /> se l'attributo è stato applicato all'assembly; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio di codice seguente applica il <xref:System.Reflection.AssemblyTitleAttribute> attributo per un assembly e quindi Usa <xref:System.Reflection.Assembly.IsDefined%2A> per indicare se è stato applicato. Verifica inoltre un attributo che non è stato applicato.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />utilizza un tipo non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'assembly corrente è stato generato dinamicamente nel processo corrente tramite reflection emit.</summary>
        <value>
          <see langword="true" /> se l'assembly corrente è stato generato in modo dinamico nel processo corrente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli assembly dinamici sono rappresentati dalla classe derivata <xref:System.Reflection.Emit.AssemblyBuilder>.  
  
 Quando un assembly dinamico viene salvato su disco, l'assembly salvato non è dinamico. Se l'assembly salvato viene caricato in un altro dominio applicazione o processo, il <xref:System.Reflection.Assembly.IsDynamic%2A> restituisce proprietà `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'assembly corrente viene caricato con attendibilità totale.</summary>
        <value>
          <see langword="true" /> se l'assembly corrente è caricato con attendibilità totale; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica un assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <summary>Carica l'assembly con un'immagine in formato COFF (Common Object File Format) contenente un assembly generato. L'assembly viene caricato nel dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità dell'assembly chiamante. Per caricare un assembly da una matrice di byte con il livello di attendibilità del dominio dell'applicazione, utilizzare il <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> overload del metodo. Per ulteriori informazioni sull'utilizzo dell'evidenza con overload di <xref:System.Reflection.Assembly.Load%2A> metodo che accetta le matrici di byte, vedere il <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> overload del metodo.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere il `.reloc` indirizzo per il file eseguibile C++, specificare `/fixed:no` quando ci si sta collegando.  
  
 Si noti che questo overload del metodo crea sempre un nuovo <xref:System.Reflection.Assembly> oggetto con il proprio mapping.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Oggetto che descrive l'assembly da caricare.</param>
        <summary>Carica un assembly dato il relativo oggetto <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> viene generata se `assemblyRef` specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice con una versione diversa, le impostazioni cultura o token di chiave pubblica. Il caricatore non continuare la ricerca degli altri assembly che corrispondono al nome semplice.  
  
> [!NOTE]
>  Non utilizzare un <xref:System.Reflection.AssemblyName> solo con il <xref:System.Reflection.AssemblyName.CodeBase%2A> set di proprietà. Il <xref:System.Reflection.AssemblyName.CodeBase%2A> proprietà non fornisca tutti gli elementi dell'identità dell'assembly (ad esempio nome o la versione), quindi il caricamento non si verifica in base alle regole di caricamento all'identità, come ci si aspetta dal <xref:System.Reflection.Assembly.Load%2A> metodo. Al contrario, l'assembly viene caricato utilizzando le regole di caricamento. Per informazioni sugli svantaggi derivanti dall'utilizzo il contesto di caricamento, vedere il <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> overload del metodo o [le procedure consigliate per il caricamento di Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo senza <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine common object file formato COFF (), la prova viene ereditata dall'assembly chiamante. Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante e `Hash` e `StrongName` provengono dall'assembly COFF.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita. L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere il `.reloc` indirizzo per il file eseguibile C++, specificare `/fixed:no` quando ci si sta collegando.  
  
> [!NOTE]
>  Se entrambi i <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> proprietà e <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> proprietà sono impostate, il primo tentativo di caricare l'assembly viene utilizzato il nome visualizzato (compreso versione, impostazioni cultura e così via, restituito dal <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> proprietà). Se il file non viene trovato, <xref:System.Reflection.AssemblyName.CodeBase%2A> viene utilizzato per cercare l'assembly. Se l'assembly viene trovato tramite <xref:System.Reflection.AssemblyName.CodeBase%2A>, il nome visualizzato viene confrontato con l'assembly. Se la corrispondenza ha esito negativo, un <xref:System.IO.FileLoadException> viene generata un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un <xref:System.Reflection.AssemblyName> dell'oggetto che viene utilizzato per caricare il `sysglobal.dll` assembly. Nell'esempio viene quindi visualizzato il nome completo di tipi pubblici dell'assembly.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> non trovata.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> non è un assembly valido. oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyRef" /> è stato compilato con una versione successiva.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Forma estesa del nome dell'assembly.</param>
        <summary>Carica un assembly in base alla forma estesa del nome.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forma estesa del nome dell'assembly è costituito il relativo nome semplice (ad esempio "System" per l'assembly System. dll) con la versione, impostazioni cultura, token di chiave pubblica e, facoltativamente, l'architettura del processore. Corrisponde all'assembly <xref:System.Reflection.Assembly.FullName%2A> proprietà. Nell'esempio seguente viene illustrato l'utilizzo di un nome lungo per caricare l'assembly System.dll per .NET Framework 4.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> viene generata se `assemblyString` specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice con una versione diversa, le impostazioni cultura o token di chiave pubblica. Il caricatore non continuare la ricerca degli altri assembly che corrispondono al nome semplice.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo senza <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine common object file formato COFF (), la prova viene ereditata dall'assembly chiamante. Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante e `Hash` e `StrongName` provengono dall'assembly COFF.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita. L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere il `.reloc` indirizzo per il file eseguibile C++, specificare `/fixed:no` quando ci si sta collegando.  
  
 In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly. Ad esempio, "ProcessorArchitecture = msil". Tuttavia, il metodo consigliato per specificare un nome di assembly consiste nel creare un <xref:System.Reflection.AssemblyName> e passarlo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> metodo. Vedere <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente carica un assembly dato il relativo nome completo e vengono elencati tutti i tipi contenuti nell'assembly specificato. Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> è una stringa di lunghezza zero.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <summary>Carica l'assembly con un'immagine in formato COFF (Common Object File Format) che contiene un assembly generato e include facoltativamente i simboli per l'assembly. L'assembly viene caricato nel dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità dell'assembly chiamante. Per caricare un assembly da una matrice di byte con il livello di attendibilità del dominio dell'applicazione, utilizzare il <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> overload del metodo. Per ulteriori informazioni sull'utilizzo dell'evidenza con overload di <xref:System.Reflection.Assembly.Load%2A> metodo che accetta le matrici di byte, vedere il <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> overload del metodo.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere il `.reloc` indirizzo per il file eseguibile C++, specificare `/fixed:no` quando ci si sta collegando.  
  
 Si noti che questo overload del metodo crea sempre un nuovo <xref:System.Reflection.Assembly> oggetto con il proprio mapping.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Oggetto che descrive l'assembly da caricare.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly dato il relativo oggetto <see cref="T:System.Reflection.AssemblyName" />. L'assembly viene caricato nel dominio del chiamante usando l'evidenza fornita.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> viene generata se `assemblyRef` specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice con una versione diversa, le impostazioni cultura o token di chiave pubblica. Il caricatore non continuare la ricerca degli altri assembly che corrispondono al nome semplice.  
  
> [!NOTE]
>  Non utilizzare un <xref:System.Reflection.AssemblyName> solo con il <xref:System.Reflection.AssemblyName.CodeBase%2A> set di proprietà. Il <xref:System.Reflection.AssemblyName.CodeBase%2A> proprietà non fornisca tutti gli elementi dell'identità dell'assembly (ad esempio nome o la versione), quindi il caricamento non si verifica in base alle regole di caricamento all'identità, come ci si aspetta dal <xref:System.Reflection.Assembly.Load%2A> metodo. Al contrario, l'assembly viene caricato utilizzando le regole di caricamento. Per informazioni sugli svantaggi derivanti dall'utilizzo il contesto di caricamento, vedere il <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> overload del metodo o [le procedure consigliate per il caricamento di Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo senza <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine common object file formato COFF (), la prova viene ereditata dall'assembly chiamante. Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante e `Hash` e `StrongName` provengono dall'assembly COFF.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita. L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere il `.reloc` indirizzo per il file eseguibile C++, specificare `/fixed:no` quando ci si sta collegando.  
  
> [!NOTE]
>  Se entrambi i <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> proprietà e <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> proprietà sono impostate, il primo tentativo di caricare l'assembly viene utilizzato il nome visualizzato (compreso versione, impostazioni cultura e così via, restituito dal <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> proprietà). Se il file non viene trovato, <xref:System.Reflection.AssemblyName.CodeBase%2A> viene utilizzato per cercare l'assembly. Se l'assembly viene trovato tramite <xref:System.Reflection.AssemblyName.CodeBase%2A>, il nome visualizzato viene confrontato con l'assembly. Se la corrispondenza ha esito negativo, un <xref:System.IO.FileLoadException> viene generata un'eccezione.  
  
 Se si chiama il <xref:System.Reflection.Assembly.Load%2A> metodo più di una volta nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché non può essere l'uguaglianza e l'integrità delle diverse specifiche di prova determinato. L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyRef" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nome visualizzato dell'assembly.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly in base al nome visualizzato nel dominio del chiamante, usando l'evidenza fornita.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> viene generata se `assemblyString` specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice con una versione diversa, le impostazioni cultura o token di chiave pubblica. Il caricatore non continuare la ricerca degli altri assembly che corrispondono al nome semplice.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo senza <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine common object file formato COFF (), la prova viene ereditata dall'assembly chiamante. Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante e `Hash` e `StrongName` provengono dall'assembly COFF.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita. L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere il `.reloc` indirizzo per il file eseguibile C++, specificare `/fixed:no` quando ci si sta collegando.  
  
 Se si chiama questo metodo più volte nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché non è possibile determinare l'uguaglianza e l'integrità delle diverse specifiche di prova. L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.  
  
 In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly. Ad esempio, "ProcessorArchitecture = msil". Tuttavia, il metodo consigliato per specificare un nome di assembly consiste nel creare un <xref:System.Reflection.AssemblyName> e passarlo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> metodo. Vedere <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.  
  
 oppure  
  
 Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica l'assembly con un'immagine in formato COFF (Common Object File Format) che contiene un assembly generato e include facoltativamente i simboli e l'evidenza per l'assembly. L'assembly viene caricato nel dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly viene caricato nel dominio del chiamante usando l'evidenza fornita. Vengono caricati anche i byte non elaborati che rappresentano i simboli per l'assembly.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo senza <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine COFF, l'evidenza viene ereditata dall'assembly chiamante. Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametro per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante e `Hash` e `StrongName` provengono dall'assembly COFF.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita. L'evidenza dell'assembly chiamante e quella dell'immagine COFF vengono ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere il `.reloc` indirizzo per il file eseguibile C++, specificare `/fixed:no` quando ci si sta collegando.  
  
 Se si chiama il [\], Byte\<xref:System.Reflection.Assembly.Load%2A > metodo più di una volta nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché il Impossibile determinare l'uguaglianza e l'integrità delle diverse specifiche di prova. L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.  
  
 Si noti che questo overload del metodo crea sempre un nuovo <xref:System.Reflection.Assembly> oggetto con il proprio mapping.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> non è <see langword="null" />.  Per impostazione predefinita, i criteri di sicurezza dall'accesso di codice legacy non sono abilitati in [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; quando non sono abilitati, <paramref name="securityEvidence" /> deve essere <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <param name="securityContextSource">Origine del contesto di sicurezza.</param>
        <summary>Carica l'assembly con un'immagine in formato COFF (Common Object File Format) che contiene un assembly generato, include facoltativamente i simboli e specifica l'origine per il contesto di sicurezza. L'assembly viene caricato nel dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly viene caricato nel dominio applicazione del chiamante usando l'origine specificata per il contesto di sicurezza. Se `rawSymbolStore` è stato specificato, vengono caricati anche i byte non elaborati che rappresentano i simboli per l'assembly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="rawAssembly" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="securityContextSource" /> non è uno dei valori di enumerazione.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica il contenuto di un file di assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo del file da caricare.</param>
        <summary>Carica il contenuto di un file di assembly nel percorso specificato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Reflection.Assembly.LoadFile%2A> metodo per caricare ed esaminare gli assembly che hanno la stessa identità, ma si trovano in percorsi diversi.<xref:System.Reflection.Assembly.LoadFile%2A> Carica i file nel contesto di caricamento e non viene risolto le dipendenze tramite il percorso di caricamento, come il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo. <xref:System.Reflection.Assembly.LoadFile%2A> è utile in questo scenario limitato perché <xref:System.Reflection.Assembly.LoadFrom%2A> non può essere utilizzato per caricare gli assembly che ha le stesse identità ma percorsi diversi; verrà caricato solo il primo assembly di questo tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="path" /> non è un percorso assoluto.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="path" /> è una stringa vuota ("") o non esiste.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="path" /> è stato compilato con una versione successiva.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo del file di assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly in base al percorso nel dominio del chiamante, usando l'evidenza fornita.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Reflection.Assembly.LoadFile%2A> metodo per caricare ed esaminare gli assembly che hanno la stessa identità, ma si trovano in percorsi diversi. <xref:System.Reflection.Assembly.LoadFile%2A> Carica i file nel <xref:System.Reflection.Assembly.LoadFrom%2A> contesto e non consente di risolvere le dipendenze tramite il percorso di caricamento, come il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo. <xref:System.Reflection.Assembly.LoadFile%2A> è utile in questo scenario limitato perché <xref:System.Reflection.Assembly.LoadFrom%2A> non può essere utilizzato per caricare gli assembly che ha le stesse identità ma percorsi diversi; verrà caricato solo il primo assembly di questo tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="path" /> non è un percorso assoluto.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="path" /> è una stringa vuota ("") o non esiste.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="path" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> non è <see langword="null" />. Per impostazione predefinita, i criteri di sicurezza dall'accesso di codice legacy non sono abilitati in [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; quando non sono abilitati, <paramref name="securityEvidence" /> deve essere <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica un assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <summary>Carica un assembly in base al nome file o al percorso.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
> [!NOTE]
>  Protocollo file transfer protocol (FTP) non è supportata. Se l'URI fornito per `assemblyFile` è un indirizzo FTP, l'assembly non viene caricato. Non viene generata alcuna eccezione.  
  
 `assemblyFile` può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.  
  
 Assembly può essere caricato in uno dei tre contesti, o può essere caricato senza contesto:  
  
-   Il contesto di caricamento contiene assembly trovati tramite sondaggio: nella GAC, archiviate in un assembly host se è ospitato il runtime o nel <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio dell'applicazione. La maggior parte degli overload del metodo <xref:System.Reflection.Assembly.Load%2A> carica gli assembly in questo contesto.  
  
-   Il contesto di caricamento contiene assembly per cui l'utente ha fornito un percorso non incluso nella directory di ricerca mediante la ricerca. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> sono esempi di metodi che vengono caricati in base al percorso.  
  
-   Contesto reflection-only contiene gli assembly caricati con il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi; codice in tali contesti non possono essere eseguiti.  
  
-   Se l'utente generato o l'assembly è stato trovato, non è in qualsiasi contesto. Questo vale per gli assembly caricati tramite gli overload di <xref:System.Reflection.Assembly.Load%2A> metodo che specificano una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite la reflection emit e non salvate su disco.  
  
 Il contesto di caricamento consente a un assembly devono essere caricati da un percorso non incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare perché le informazioni sul percorso vengono mantenute dal contesto.  
  
 Il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo presenta gli svantaggi seguenti. In alternativa, considerare l'utilizzo di <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Se è già caricato un assembly con la stessa identità <xref:System.Reflection.Assembly.LoadFrom%2A> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>e successivamente un assembly nel contesto di caricamento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo. Ciò può verificarsi quando un assembly viene deserializzato.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>, e il percorso di sondaggio include un assembly con un percorso diverso, ma con la stessa identità un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, oppure possono avvenire in altri comportamenti imprevisti.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> richiede <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> o <xref:System.Net.WebPermission> per il percorso specificato.  
  
-   Se esiste un'immagine nativa per `assemblyFile`, non viene utilizzato. L'assembly non può essere caricato come indipendente dal dominio.  
  
-   In .NET Framework versioni 1.0 e 1.1, i criteri non vengono applicati.  
  
   
  
## Examples  
 Nell'esempio seguente carica un assembly in base al nome del file o al percorso.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit. Per altre informazioni, vedere l'argomento relativo alle eccezioni.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly in base al nome file o al percorso e fornendo l'evidenza di sicurezza.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
> [!NOTE]
>  Protocollo file transfer protocol (FTP) non è supportata. Se l'URI fornito per `assemblyFile` è un indirizzo FTP, l'assembly non viene caricato. Non viene generata alcuna eccezione.  
  
 `assemblyFile` può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.  
  
 Assembly può essere caricato in uno dei tre contesti, o può essere caricato senza contesto:  
  
-   Il contesto di caricamento contiene assembly trovati tramite sondaggio: nella GAC, archiviate in un assembly host se è ospitato il runtime o nel <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio dell'applicazione. La maggior parte degli overload del metodo <xref:System.Reflection.Assembly.Load%2A> carica gli assembly in questo contesto.  
  
-   Il contesto di caricamento contiene assembly per cui l'utente ha fornito un percorso non incluso nella directory di ricerca mediante la ricerca. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> sono esempi di metodi che vengono caricati in base al percorso.  
  
-   Contesto reflection-only contiene gli assembly caricati con il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi; codice in tali contesti non possono essere eseguiti.  
  
-   Se l'utente generato o l'assembly è stato trovato, non è in qualsiasi contesto. Questo vale per gli assembly caricati tramite gli overload di <xref:System.Reflection.Assembly.Load%2A> metodo che specificano una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite la reflection emit e non salvate su disco.  
  
 Il contesto di caricamento consente a un assembly devono essere caricati da un percorso non incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare perché le informazioni sul percorso vengono mantenute dal contesto.  
  
 Il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo presenta gli svantaggi seguenti. In alternativa, considerare l'utilizzo di <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Se è già caricato un assembly con la stessa identità <xref:System.Reflection.Assembly.LoadFrom%2A> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>e successivamente un assembly nel contesto di caricamento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo. Questa situazione può verificarsi quando un assembly è deserializzato.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>, e il percorso di sondaggio include un assembly con un percorso diverso, ma con la stessa identità un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, oppure possono avvenire in altri comportamenti imprevisti.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> richiede <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> o <xref:System.Net.WebPermission> per il percorso specificato.  
  
-   Se esiste un'immagine nativa per `assemblyFile`, non viene utilizzato. L'assembly non può essere caricato come indipendente dal dominio.  
  
-   In .NET Framework versioni 1.0 e 1.1, i criteri non vengono applicati.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.LoadFrom%2A> metodo senza <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
-   Se si chiama questo metodo più volte nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché non è possibile determinare l'uguaglianza e l'integrità delle diverse specifiche di prova. L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un `Byte[]` parametro per caricare un'immagine common object file formato COFF (), la prova viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante e `Hash` e `StrongName` provengono dall'assembly COFF.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita. L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.  
  
 oppure  
  
 <paramref name="securityEvidence" /> non è ambiguo ed è risultato non valido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit. Per altre informazioni, vedere l'argomento relativo alle eccezioni.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <param name="hashValue">Valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Algoritmo hash usato per generare un hash per i file e generare il nome sicuro.</param>
        <summary>Carica un assembly in base al nome file o al percorso, al valore hash e all'algoritmo hash.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
> [!NOTE]
>  Protocollo file transfer protocol (FTP) non è supportata. Se l'URI fornito per `assemblyFile` è un indirizzo FTP, l'assembly non viene caricato. Non viene generata alcuna eccezione.  
  
 `assemblyFile` può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.  
  
 Assembly può essere caricato in uno dei tre contesti, o può essere caricato senza contesto:  
  
-   Il contesto di caricamento contiene assembly trovati tramite sondaggio: nella global assembly cache, archiviate in un assembly host se è ospitato il runtime o nel <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio dell'applicazione. La maggior parte degli overload del metodo <xref:System.Reflection.Assembly.Load%2A> carica gli assembly in questo contesto.  
  
-   Il contesto di caricamento contiene assembly per cui l'utente ha fornito un percorso che non è incluso nella ricerca. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> sono esempi di metodi che vengono caricati in base al percorso.  
  
-   Contesto reflection-only contiene gli assembly caricati con il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi; codice in tali contesti non possono essere eseguiti.  
  
-   Se l'utente generato o l'assembly è stato trovato, non è in qualsiasi contesto. Questo vale per gli assembly caricati tramite gli overload di <xref:System.Reflection.Assembly.Load%2A> metodo che specificano una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite la reflection emit e non salvate su disco.  
  
 Il contesto di caricamento consente a un assembly devono essere caricati da un percorso che non è incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare perché le informazioni sul percorso vengono mantenute dal contesto.  
  
 Il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo presenta gli svantaggi seguenti. In alternativa, considerare l'utilizzo di <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Se è già caricato un assembly con la stessa identità <xref:System.Reflection.Assembly.LoadFrom%2A> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>e successivamente un assembly nel contesto di caricamento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo. Questa situazione può verificarsi quando un assembly è deserializzato.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>, e il percorso di sondaggio include un assembly con un percorso diverso, ma con la stessa identità un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, oppure possono avvenire in altri comportamenti imprevisti.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> richiede <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> o <xref:System.Net.WebPermission> per il percorso specificato.  
  
-   Se esiste un'immagine nativa per `assemblyFile`, non viene utilizzato. L'assembly non può essere caricato come modulo indipendente dal dominio.  
  
 L'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non è stato trovato oppure il modulo che si sta provando a caricare non specifica un'estensione di file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit. Per altre informazioni, vedere l'argomento relativo alle eccezioni.  
  
 oppure  
  
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <param name="hashValue">Valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Algoritmo hash usato per generare un hash per i file e generare il nome sicuro.</param>
        <summary>Carica un assembly in base al nome file o al percorso, all'evidenza di sicurezza, al valore hash e all'algoritmo hash.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
> [!NOTE]
>  Protocollo file transfer protocol (FTP) non è supportata. Se l'URI fornito per `assemblyFile` è un indirizzo FTP, l'assembly non viene caricato. Non viene generata alcuna eccezione.  
  
 `assemblyFile` può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.  
  
 Assembly può essere caricato in uno dei tre contesti, o può essere caricato senza contesto:  
  
-   Il contesto di caricamento contiene assembly trovati tramite sondaggio: nella GAC, archiviate in un assembly host se è ospitato il runtime o nel <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio dell'applicazione. La maggior parte degli overload del metodo <xref:System.Reflection.Assembly.Load%2A> carica gli assembly in questo contesto.  
  
-   Il contesto di caricamento contiene assembly per cui l'utente ha fornito un percorso non incluso nella directory di ricerca mediante la ricerca. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> sono esempi di metodi che vengono caricati in base al percorso.  
  
-   Contesto reflection-only contiene gli assembly caricati con il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi; codice in tali contesti non possono essere eseguiti.  
  
-   Se l'utente generato o l'assembly è stato trovato, non è in qualsiasi contesto. Questo vale per gli assembly caricati tramite gli overload di <xref:System.Reflection.Assembly.Load%2A> metodo che specificano una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite la reflection emit e non salvate su disco.  
  
 Il contesto di caricamento consente a un assembly devono essere caricati da un percorso non incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare perché le informazioni sul percorso vengono mantenute dal contesto.  
  
 Il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo presenta gli svantaggi seguenti. In alternativa, considerare l'utilizzo di <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Se è già caricato un assembly con la stessa identità <xref:System.Reflection.Assembly.LoadFrom%2A> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>e successivamente un assembly nel contesto di caricamento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo. Questa situazione può verificarsi quando un assembly è deserializzato.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>, e il percorso di sondaggio include un assembly con un percorso diverso, ma con la stessa identità un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, oppure possono avvenire in altri comportamenti imprevisti.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> richiede <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> o <xref:System.Net.WebPermission> per il percorso specificato.  
  
-   Se esiste un'immagine nativa per `assemblyFile`, non viene utilizzato. L'assembly non può essere caricato come indipendente dal dominio.  
  
-   In .NET Framework versioni 1.0 e 1.1, i criteri non vengono applicati.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.LoadFrom%2A> metodo senza <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
-   Se si chiama questo metodo più volte nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché non è possibile determinare l'uguaglianza e l'integrità delle diverse specifiche di prova. L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un `Byte[]` parametro per caricare un'immagine common object file formato COFF (), la prova viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante e `Hash` e `StrongName` provengono dall'assembly COFF.  
  
-   Quando si utilizza un <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita. L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.  
  
 oppure  
  
 <paramref name="securityEvidence" /> non è ambiguo ed è risultato non valido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit. Per altre informazioni, vedere l'argomento relativo alle eccezioni.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica il modulo interno a questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nome del modulo. Questa stringa deve corrispondere a un nome file nel manifesto dell'assembly.</param>
        <param name="rawModule">Matrice di byte costituita da un'immagine in formato COFF che contiene un modulo generato o una risorsa.</param>
        <summary>Carica il modulo, interno all'assembly, con un'immagine in formato COFF (Common Object File Format) contenente un modulo generato o un file di risorse.</summary>
        <returns>Modulo caricato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> o <paramref name="rawModule" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> non corrisponde a una voce di file nel manifesto dell'assembly.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> non è un modulo valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nome del modulo. Questa stringa deve corrispondere a un nome file nel manifesto dell'assembly.</param>
        <param name="rawModule">Matrice di byte costituita da un'immagine in formato COFF che contiene un modulo generato o una risorsa.</param>
        <param name="rawSymbolStore">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per il modulo. Deve essere <see langword="null" /> se si tratta di un file di risorse.</param>
        <summary>Carica il modulo, interno all'assembly, con un'immagine in formato COFF (Common Object File Format) contenente un modulo generato o un file di risorse. Vengono caricati anche i byte non elaborati che rappresentano i simboli per il modulo.</summary>
        <returns>Modulo caricato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> o <paramref name="rawModule" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> non corrisponde a una voce di file nel manifesto dell'assembly.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> non è un modulo valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica un assembly dalla directory dell'applicazione o dalla Global Assembly Cache con un nome parziale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Gli overload di <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> metodo sono obsoleto e sono state mantenute per la compatibilità con le versioni precedenti. L'alternativa non obsoleta è <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">Nome visualizzato dell'assembly.</param>
        <summary>Carica un assembly dalla directory dell'applicazione o dalla Global Assembly Cache con un nome parziale.</summary>
        <returns>Assembly caricato. Se <paramref name="partialName" /> non viene trovato, il metodo restituisce <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> metodo è obsoleto ed è stato mantenuto per compatibilità con le versioni precedenti. L'alternativa non obsoleta è <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Applicazioni che caricano gli assembly con questo metodo saranno interessate dagli aggiornamenti di tali assembly. Pertanto, non utilizzare questo metodo. riprogettare l'applicazione utilizzi la <xref:System.Reflection.Assembly.Load%28System.String%29> overload del metodo o <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> overload del metodo.  
  
 Questo metodo chiama innanzitutto <xref:System.Reflection.Assembly.Load%2A>. Se l'assembly non viene trovato, questo metodo restituisce l'assembly dalla global assembly cache con lo stesso nome semplice e il numero di versione più alto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="partialName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="partialName" /> è stato compilato con una versione successiva.</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">Nome visualizzato dell'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly dalla directory dell'applicazione o dalla Global Assembly Cache con un nome parziale. L'assembly viene caricato nel dominio del chiamante usando l'evidenza fornita.</summary>
        <returns>Assembly caricato. Se <paramref name="partialName" /> non viene trovato, il metodo restituisce <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> metodo è obsoleto ed è stato mantenuto per compatibilità con le versioni precedenti. L'alternativa non obsoleta è <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Un'evidenza è l'insieme di informazioni su cui vengono basate le decisioni inerenti i criteri di sicurezza, ad esempio le autorizzazioni che è possibile assegnare al codice.  
  
 Applicazioni che caricano gli assembly con questo metodo saranno interessate dagli aggiornamenti di tali assembly. Pertanto, non utilizzare questo metodo. riprogettare l'applicazione utilizzi la <xref:System.Reflection.Assembly.Load%2A> metodo o <xref:System.Reflection.Assembly.LoadFrom%2A> (metodo).  
  
 Questo metodo chiama innanzitutto <xref:System.Reflection.Assembly.Load%2A>. Se l'assembly non viene trovato, questo metodo restituisce l'assembly dalla global assembly cache con lo stesso nome semplice e il numero di versione più alto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due set di evidenze diversi.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="partialName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="partialName" /> è stato compilato con una versione successiva.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito e per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso completo o il percorso UNC del file caricato che contiene il manifesto.</summary>
        <value>Percorso del file caricato che contiene il manifesto. Se è stata eseguita una copia shadow del file caricato, il percorso è quello del file dopo l'esecuzione della copia shadow. Se l'assembly viene caricato da una matrice di byte, come quando si usa l'overload del metodo <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />, il valore restituito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere il percorso prima che il file è stato replicato, utilizzare il <xref:System.Reflection.Assembly.CodeBase%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il percorso del file caricato che contiene il manifesto.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'assembly corrente è un assembly dinamico, rappresentato da un oggetto <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere al percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il modulo contenente il manifesto per l'assembly corrente.</summary>
        <value>Modulo contenente il manifesto per l'assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il caricatore della classe Common Language Runtime non è in grado di risolvere un riferimento a un modulo interno di un assembly in modo normale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento offre l'opportunità di trovare e caricare il modulo e restituirlo il callback.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta contenente i moduli dell'assembly.</summary>
        <value>Raccolta contenente i moduli dell'assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Assembly da confrontare con <c>right</c>.</param>
        <param name="right">Assembly da confrontare con <c>left</c>.</param>
        <summary>Indica se due oggetti <see cref="T:System.Reflection.Assembly" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Assembly da confrontare con <c>right</c>.</param>
        <param name="right">Assembly da confrontare con <c>left</c>.</param>
        <summary>Indica se due oggetti <see cref="T:System.Reflection.Assembly" /> non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> non è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il set di concessioni dell'assembly corrente.</summary>
        <value>Set di concessioni dell'assembly corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> gli oggetti possono contenere informazioni riservate, ad esempio i percorsi. Pertanto, l'attendibilità totale deve accedere a questi oggetti.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se l'assembly è stato caricato nel contesto ReflectionOnly.</summary>
        <value>
          <see langword="true" /> se l'assembly è stato caricato nel contesto solo reflection anziché nel contesto di esecuzione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un assembly è stato caricato nel contesto reflection-only, utilizzando il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> (metodo), non è possibile eseguire codice nell'assembly. Per eseguire il codice, l'assembly deve essere caricato nel contesto di esecuzione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica un assembly nel contesto di sola reflection, in cui l'assembly può essere esaminato ma non eseguito.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <summary>Carica l'assembly da un'immagine in formato COFF (Common Object File Format) contenente un assembly generato. L'assembly viene caricato nel contesto di sola reflection del dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile eseguire codice da un assembly caricato nel contesto reflection-only. Per eseguire il codice, l'assembly deve essere caricato nel contesto di esecuzione, nonché tramite il <xref:System.Reflection.Assembly.Load%2A> metodo.  
  
 Contesto reflection-only non è diverso da altri contesti. Gli assembly caricati nel contesto possono essere scaricati solo scaricando il dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" /> non può essere caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nome visualizzato dell'assembly, come restituito dalla proprietà <see cref="P:System.Reflection.AssemblyName.FullName" />.</param>
        <summary>Carica un assembly nel contesto di sola reflection in base al nome visualizzato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dipendenze non vengono caricate automaticamente nel contesto reflection-only.  
  
 È possibile eseguire codice da un assembly caricato nel contesto reflection-only. Per eseguire il codice, l'assembly deve essere caricato nel contesto di esecuzione, nonché tramite il <xref:System.Reflection.Assembly.Load%2A> metodo.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:  
  
> [!NOTE]
>  La reflection sui file eseguibili compilati in C++ può generare un <xref:System.IO.FileLoadException>. Ciò è probabilmente causato dal compilatore C++ rimozione indirizzi di rilocazione oppure della sezione. reloc dal file eseguibile. Per mantenere l'indirizzo, specificare `/fixed:no` quando ci si sta collegando.  
  
 Contesto reflection-only non è diverso da altri contesti. Gli assembly caricati nel contesto possono essere scaricati solo scaricando il dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" /> è stato trovato ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Percorso del file che contiene il manifesto dell'assembly.</param>
        <summary>Carica un assembly nel contesto di sola reflection in base al percorso.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dipendenze non vengono caricate automaticamente nel contesto reflection-only. Per caricare automaticamente le dipendenze, gestire il <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> evento e caricare la dipendenza nel gestore eventi.  
  
 È possibile eseguire codice da un assembly che è stato caricato nel contesto reflection-only. Per eseguire il codice, caricare l'assembly con il <xref:System.Reflection.Assembly.LoadFile%2A> metodo.  
  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
 Il percorso specificato per `assemblyFile` è relativo alla directory corrente. L'assembly viene caricato nel dominio del chiamante.  
  
 Contesto reflection-only non è diverso da altri contesti. Gli assembly caricati nel contesto possono essere scaricati solo scaricando il dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non è stato trovato oppure il modulo che si sta provando a caricare non specifica un'estensione di file.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" /> è stato trovato ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica il set di regole di sicurezza applicato da Common Language Runtime (CLR) per questo assembly.</summary>
        <value>Set di regole di sicurezza applicato da CLR per questo assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, gli assembly che si compila con il [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] dispongono di trasparenza, anche se è possibile renderle esplicitamente invece. Gli assembly che sono stati compilati con le versioni precedenti di .NET Framework dispongono di trasparenza di livello 1.  
  
 Vedere [Modifiche di sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il tipo dell'istanza corrente.</summary>
        <returns>Oggetto che rappresenta il tipo di <see cref="T:System.Reflection.Assembly" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il nome completo dell'assembly, noto anche come nome visualizzato.</summary>
        <returns>Nome completo dell'assembly o nome della classe se non è possibile determinare il nome completo dell'assembly.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <summary>Carica un assembly nel contesto di origine del caricamento, ignorando alcuni controlli di sicurezza.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per caricare un assembly locale che il sistema operativo è contrassegnato come se fosse stato caricato dal Web (ad esempio, un file temporaneo è stato scaricato da Internet o intranet). Prima di [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tali assembly sono stati caricati automaticamente in un dominio applicazione sandboxed. A partire dal [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], vengono caricati con attendibilità totale.  
  
 Come alternativa all'utilizzo di questo metodo, è possibile applicare il [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) nel file di configurazione dell'applicazione. In questo modo common language runtime per i criteri di sicurezza di ripristinare il [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
> [!CAUTION]
>  Se si utilizza una di queste soluzioni, è necessario assicurarsi che sia possibile caricare `assemblyFile` con attendibilità totale.  
  
 Per una descrizione dei contesti di caricamento, incluso il contesto di caricamento, vedere il <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è possibile caricare un file che non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>