<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="61e41f0ea0e2ba2b5b68e7d5dde114072003f536" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39726330" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un assembly, ovvero un blocco predefinito di un'applicazione Common Language Runtime riutilizzabile, autodescrittivo e di cui è possibile eseguire il controllo delle versioni.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Reflection.Assembly> classe per caricare gli assembly, per esplorare i metadati e le parti costitutive dell'assembly, per individuare i tipi contenuti nell'assembly e creare istanze di tali tipi.  
  
 Per ottenere una matrice di <xref:System.Reflection.Assembly> gli oggetti che rappresentano gli assembly attualmente caricato in un dominio di applicazione (ad esempio, il dominio applicazione predefinito di un progetto semplice), usare il <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> (metodo).  
  
 Per caricare gli assembly in modo dinamico, il <xref:System.Reflection.Assembly> classe fornisce i metodi statici seguenti (`Shared` metodi in Visual Basic). Gli assembly vengono caricati nel dominio dell'applicazione in cui si verifica l'operazione di caricamento.  
  
-   È il modo consigliato per caricare gli assembly da utilizzare il <xref:System.AppDomain.Load%2A> metodo, che identifica l'assembly da caricare in base al nome visualizzato (ad esempio, "Forms, versione = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089"). La ricerca per l'assembly segue le regole descritte [modo in cui il Runtime individua gli assembly](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).  
  
-   Il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi consentono di caricare un assembly per la reflection, ma non per l'esecuzione. Ad esempio, un assembly che ha come destinazione una piattaforma a 64 bit può essere esaminato dal codice che è in esecuzione su una piattaforma a 32 bit.  
  
-   Il <xref:System.Reflection.Assembly.LoadFile%2A> e <xref:System.Reflection.Assembly.LoadFrom%2A> vengono forniti metodi per i rari scenari in cui un assembly deve essere identificato dal percorso.  
  
 Per ottenere un <xref:System.Reflection.Assembly> oggetto per l'assembly attualmente in esecuzione, usare il <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> (metodo).  
  
 Numero di membri del <xref:System.Reflection.Assembly> classe fornisce informazioni relative a un assembly. Ad esempio:  
  
-   Il <xref:System.Reflection.Assembly.GetName%2A> metodo restituisce un <xref:System.Reflection.AssemblyName> oggetto che fornisce accesso alle parti del nome visualizzato dell'assembly.  
  
-   Il <xref:System.Reflection.Assembly.GetCustomAttributes%2A> metodo elenca gli attributi applicati all'assembly.  
  
-   Il <xref:System.Reflection.Assembly.GetFiles%2A> metodo offre l'accesso ai file nel manifesto dell'assembly.  
  
-   Il <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> metodo fornisce i nomi delle risorse nel manifesto dell'assembly.  
  
 Il <xref:System.Reflection.Assembly.GetTypes%2A> metodo elenca tutti i tipi nell'assembly. Il <xref:System.Reflection.Assembly.GetExportedTypes%2A> metodo sono elencati i tipi che sono visibili ai chiamanti all'esterno dell'assembly. Il <xref:System.Reflection.Assembly.GetType%2A> metodo può essere utilizzato per cercare un particolare tipo nell'assembly. Il <xref:System.Reflection.Assembly.CreateInstance%2A> metodo può essere usato per cercare e creare istanze di tipi nell'assembly.  
  
 Per altre informazioni sugli assembly, vedere la sezione "Assembly e domini di applicazione" nel [domini applicazione](~/docs/framework/app-domains/application-domains.md) argomento.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere l'assembly attualmente in esecuzione, creare un'istanza di un tipo di contenuto in tale assembly e richiamare uno dei metodi del tipo con associazione tardiva. A tale scopo, nell'esempio di codice definisce una classe denominata `Example`, con un metodo denominato `SampleMethod`. Il costruttore della classe accetta un numero intero, viene usato per calcolare il valore restituito del metodo.  
  
 L'esempio di codice viene inoltre illustrato l'utilizzo dei <xref:System.Reflection.Assembly.GetName%2A> metodo per ottenere un <xref:System.Reflection.AssemblyName> oggetto che può essere utilizzato per analizzare il nome completo dell'assembly. L'esempio visualizza il numero di versione dell'assembly, il <xref:System.Reflection.Assembly.CodeBase%2A> proprietà e il <xref:System.Reflection.Assembly.EntryPoint%2A> proprietà.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per un'attendibilità totale per gli eredi. Questa classe non può essere ereditata da codice parzialmente attendibile.</permission>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Assembly" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene richiamato da classi derivate durante la costruzione di <xref:System.Reflection.Assembly> oggetti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso dell'assembly come originariamente specificato, ad esempio in un oggetto <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <value>Percorso dell'assembly come originariamente specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere il percorso assoluto del file caricato che contiene manifesto, usare il <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> proprietà invece.  
  
 Se l'assembly è stato caricato come una matrice di byte, usando un overload del <xref:System.Reflection.Assembly.Load%2A> metodo che accetta una matrice di byte, questa proprietà restituisce la posizione del chiamante del metodo, non il percorso dell'assembly caricato.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Reflection.Assembly.CodeBase%2A> proprietà.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso al percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Individua un tipo in questo assembly e ne crea un'istanza usando l'attivatore di sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> del tipo da individuare.</param>
        <summary>Individua il tipo specificato in questo assembly e ne crea un'istanza usando l'attivatore di sistema e consentendo la ricerca con distinzione tra maiuscole e minuscole.</summary>
        <returns>Istanza del tipo specificato creata con il costruttore predefinito oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Il tipo viene risolto usando il binder predefinito, senza specificare attributi delle impostazioni cultura o dell'attivazione e con <see cref="T:System.Reflection.BindingFlags" /> impostato su <see langword="Public" /> o <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il runtime non riesce a trovare `typeName` nella <xref:System.Reflection.Assembly> dell'istanza, viene restituito `null` anziché generare un'eccezione. Ciò può verificarsi perché:  
  
-   Non è stato specificato il nome completo del tipo.  
  
-   È stato specificato il nome completo del tipo, ma il non corrispondono a quelli nel caso del tipo <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà. Per un confronto tra maiuscole e minuscole `typeName` con il nome del tipo completo, chiamare il <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload e specificare `true` per il `ignoreCase` argomento.  
  
-   Il tipo non esiste nell'attuale <xref:System.Reflection.Assembly> istanza.  
  
   
  
## Examples  
 L'esempio seguente definisce una `Person` classi e le chiamate di <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> metodo crearne un'istanza.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> è una stringa vuota ("") o una stringa che inizia con un carattere Null.  
  
oppure 
L'assembly corrente è stato caricato nel contesto di sola reflection.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
oppure 
L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="typeName" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
oppure 
 <paramref name="typeName" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> del tipo da individuare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole nel nome del tipo; in caso contrario, <see langword="false" />.</param>
        <summary>Individua il tipo specificato in questo assembly e ne crea un'istanza usando l'attivatore di sistema e consentendo la ricerca con distinzione facoltativa tra maiuscole e minuscole.</summary>
        <returns>Istanza del tipo specificato creata con il costruttore predefinito oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Il tipo viene risolto usando il binder predefinito, senza specificare attributi delle impostazioni cultura o dell'attivazione e con <see cref="T:System.Reflection.BindingFlags" /> impostato su <see langword="Public" /> o <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il runtime non riesce a trovare `typeName` nella <xref:System.Reflection.Assembly> dell'istanza, viene restituito `null` anziché generare un'eccezione. Ciò può verificarsi perché:  
  
-   Non è stato specificato il nome completo del tipo.  
  
-   Il tipo non esiste nell'attuale <xref:System.Reflection.Assembly> istanza.  
  
   
  
## Examples  
 L'esempio seguente definisce un `Person` classe. Chiama quindi il <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> metodo per creare un'istanza, ma perché le maiuscole e minuscole del `typeName` l'argomento non corrisponde a quello del tipo <xref:System.Type.FullName%2A> proprietà, il metodo restituisce `null`. Quando nell'esempio vengono passate la stessa stringa per il <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload e specifica che il confronto deve essere tra maiuscole e minuscole, il `Person` classe viene trovata e un `Person` oggetto correttamente viene creata un'istanza.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> è una stringa vuota ("") o una stringa che inizia con un carattere Null.  
  
oppure 
L'assembly corrente è stato caricato nel contesto di sola reflection.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
oppure 
L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="typeName" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
oppure 
 <paramref name="typeName" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> del tipo da individuare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole nel nome del tipo; in caso contrario, <see langword="false" />.</param>
        <param name="bindingAttr">Maschera di bit che influenza le modalità di esecuzione della ricerca. Il valore è una combinazione di flag di bit dell'oggetto <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Oggetto che consente il binding, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see langword="MemberInfo" /> tramite reflection. Se <c>binder</c> è <see langword="null" />, verrà usato il binder predefinito.</param>
        <param name="args">Matrice contenente gli argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o <see langword="null" />.</param>
        <param name="culture">Istanza di <see langword="CultureInfo" /> usata per regolare la coercizione dei tipi. Se è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see langword="CultureInfo" />. Si tratta di un parametro necessario per convertire un oggetto <see langword="String" /> che rappresenta, ad esempio, il numero 1000 in un valore <see langword="Double" />, dal momento che questo numero è rappresentato in modo diverso nelle varie impostazioni cultura.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Individua il tipo specificato in questo assembly e ne crea un'istanza usando l'attivatore di sistema, consentendo la ricerca con distinzione facoltativa tra maiuscole e minuscole e usando le impostazioni cultura, gli argomenti e gli attributi di attivazione e di binding specificati.</summary>
        <returns>Istanza del tipo specificato o <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Gli argomenti forniti vengono usati per risolvere il tipo e per associare il costruttore usato per creare l'istanza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> è una stringa vuota ("") o una stringa che inizia con un carattere Null.  
  
oppure 
L'assembly corrente è stato caricato nel contesto di sola reflection.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Una matrice di attributi di attivazione non vuota viene passata a un tipo che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
oppure 
L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="typeName" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
oppure 
 <paramref name="typeName" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per creare un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato di un assembly.</param>
        <param name="typeName">Nome completo di un tipo.</param>
        <summary>Crea il nome di un tipo qualificato dal nome visualizzato del relativo assembly.</summary>
        <returns>Nome completo del tipo qualificato dal nome visualizzato dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il formato della stringa restituita è:  
  
 \<FullTypeName>, \<AssemblyDisplayName>  
  
 Vedere <xref:System.Reflection.AssemblyName> per una descrizione del formato del nome visualizzato di un assembly.  
  
 Per supportare le modifiche nelle versioni di common language runtime, usare questo metodo anziché costruire autonomamente il nome completo.  Per informazioni sui nomi di assembly completi, vedere <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta che contiene gli attributi personalizzati di questo assembly.</summary>
        <value>Raccolta che contiene gli attributi personalizzati di questo assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta dei tipi definiti in questo assembly.</summary>
        <value>Raccolta dei tipi definiti in questo assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Assembly.DefinedTypes%2A> proprietà può essere paragonata al <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metodo, con la differenza che la <xref:System.Reflection.Assembly.DefinedTypes%2A> proprietà restituisce una raccolta di <xref:System.Reflection.TypeInfo> oggetti e il <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metodo restituisce una matrice di <xref:System.Type> oggetti.  
  
 La matrice restituita include i tipi annidati.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il punto di ingresso di questo assembly.</summary>
        <value>Oggetto che rappresenta il punto di ingresso di questo assembly. Se non viene trovato alcun punto di ingresso, ad esempio se l'assembly è un file DLL, viene restituito <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Oggetto da confrontare con questa istanza.</param>
        <summary>Determina se questo assembly e l'oggetto specificato sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="o" /> è uguale all'istanza. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Assembly.Equals%2A> metodo esegue un test di uguaglianza di riferimento determinare se l'istanza corrente e `o` sono uguali.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'URI, inclusi i caratteri di escape, che rappresenta la codebase.</summary>
        <value>URI con caratteri di escape.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso al percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'evidenza per questo assembly.</summary>
        <value>Evidenza per questo assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'evidenza è l'insieme di informazioni su cui vengono basate le decisioni inerenti i criteri di sicurezza, ad esempio le autorizzazioni che è possibile assegnare al codice.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta dei tipi pubblici definiti in questo assembly visibili all'esterno dell'assembly.</summary>
        <value>Raccolta dei tipi pubblici definiti in questo assembly visibili all'esterno dell'assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome visualizzato dell'assembly.</summary>
        <value>Nome visualizzato dell'assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Reflection.AssemblyName> per una descrizione del formato del nome visualizzato di un assembly.  
  
> [!NOTE]
>  Non è consigliabile scrivere il proprio codice per analizzare i nomi visualizzati. In alternativa, passare il nome visualizzato per il <xref:System.Reflection.AssemblyName.%23ctor%2A> costruttore, che analizza e compila i campi appropriati del nuovo <xref:System.Reflection.AssemblyName>.  
  
 In .NET Framework versione 2.0, architettura del processore viene aggiunta all'identità di assembly e può essere specificato come parte di stringhe di nomi di assembly. Tuttavia, non è incluso nella stringa restituita dal <xref:System.Reflection.Assembly.FullName%2A> proprietà, per motivi di compatibilità. Vedere <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente recupera il nome visualizzato dell'assembly attualmente in esecuzione e il nome visualizzato dell'assembly che contiene il <xref:System.Int32> tipo (`int` in c#, `Integer` in Visual Basic).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Oggetto che rappresenta un tipo nell'assembly che verrà restituito.</param>
        <summary>Ottiene l'assembly attualmente caricato in cui è definito il tipo specificato.</summary>
        <returns>Assembly in cui è definito il tipo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo è equivalente a recuperare il valore della <xref:System.Type.Assembly?displayProperty=nameWithType> proprietà. Tuttavia, il <xref:System.Type.Assembly?displayProperty=nameWithType> proprietà offre in genere prestazioni migliori.  
  
 Per chiamare questo metodo, è necessario che un <xref:System.Type> oggetto, il che significa che l'assembly in cui è definita la classe deve essere già caricato.  
  
   
  
## Examples  
 Nell'esempio seguente recupera l'assembly che contiene il <xref:System.Int32> digitare e visualizza il nome e il percorso file.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Reflection.Assembly" /> del metodo che ha richiamato il metodo attualmente in esecuzione.</summary>
        <returns>Oggetto <see langword="Assembly" /> del metodo che ha richiamato il metodo attualmente in esecuzione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il metodo che chiama il <xref:System.Reflection.Assembly.GetCallingAssembly%2A> metodo verrà espansa inline dal compilatore just-in-time (JIT) o se il chiamante è espansa inline, l'assembly che viene restituito da <xref:System.Reflection.Assembly.GetCallingAssembly%2A> possono variare in modo imprevisto. Si consideri, ad esempio, i metodi e gli assembly seguenti:  
  
-   Metodo `M1` nell'assembly `A1` chiamate <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
-   Metodo `M2` nell'assembly `A2` chiamate `M1`.  
  
-   Metodo `M3` nell'assembly `A3` chiamate `M2`.  
  
 Quando `M1` non è impostato come inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> restituisce `A2`. Quando `M1` inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> restituisce `A3`. Analogamente, quando `M2` non è impostato come inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> restituisce `A2`. Quando `M2` inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> restituisce `A3`.  
  
 Questo effetto si verifica anche quando `M1` viene eseguita come una chiamata tail dal `M2`, o quando `M2` viene eseguita come una chiamata tail da `M3`. È possibile impedire al compilatore JIT inline il metodo che chiama <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, applicando le <xref:System.Runtime.CompilerServices.MethodImplAttribute> dell'attributo con il <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flag, ma non esiste un meccanismo simile per impedire che chiamate tail.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene l'assembly chiamante del metodo corrente.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene gli attributi personalizzati per questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Questo argomento viene ignorato per gli oggetti di tipo <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Ottiene tutti gli attributi personalizzati per questo assembly.</summary>
        <returns>Matrice contenente gli attributi personalizzati per questo assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il corrispondente <xref:System.Reflection.ICustomAttributeProvider> metodo di interfaccia. Pertanto, il `inherit` parametro deve essere specificato anche se viene ignorato.  
  
 Un pseudo-attributo di indica bit di metadati di base che deve essere impostata quando è presente l'attributo. A differenza di un attributo personalizzato che estende i metadati per un tipo e verrà salvato insieme al tipo, un pseudo-attributo di modifica i metadati per il tipo e quindi viene ignorato. Alcuni dei bit risultanti non sono accessibili tramite le API di reflection esistente.  
  
 Nella tabella seguente riepiloga i diversi pseudo- attributi e funzioni di accesso per i bit sono disponibili nella reflection.  
  
|Pseudo-attributi|Bit di metadati|Funzione di accesso di Reflection|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Nome della DLL|Nessuna funzione di accesso per PInvokeMap per gli attributi di metodo metodo ordinario/globali.<br /><br /> Nessuna funzione di accesso per il nome DLL.|  
|GuidAttribute|Archiviato come un vero attributo personalizzato.|Accedere come un vero attributo personalizzato.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Diversi bit.|Nessuna funzione di accesso.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Compressione delle classi.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Nessuna funzione di accesso.|  
|FieldOffsetAttribute|Offset di campo.|Nessuna funzione di accesso.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Nessun enumeratore o funzione di accesso.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo per cui restituire gli attributi personalizzati.</param>
        <param name="inherit">Questo argomento viene ignorato per gli oggetti di tipo <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Ottiene gli attributi personalizzati per questo assembly, come specificato dal tipo.</summary>
        <returns>Matrice contenente gli attributi personalizzati per questo assembly, come specificato da <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il corrispondente <xref:System.Reflection.ICustomAttributeProvider> metodo di interfaccia. Pertanto, il `inherit` parametro deve essere specificato anche se viene ignorato.  
  
 Un pseudo-attributo di indica bit di metadati di base che deve essere impostata quando è presente l'attributo. A differenza di un attributo personalizzato che estende i metadati per un tipo e verrà salvato insieme al tipo, un pseudo-attributo di modifica i metadati per il tipo e quindi viene ignorato. Alcuni dei bit risultanti non sono accessibili tramite le API di reflection esistente.  
  
 Nella tabella seguente riepiloga i diversi pseudo- attributi e funzioni di accesso per i bit sono disponibili nella reflection.  
  
|Pseudo-attributi|Bit di metadati|Funzione di accesso di Reflection|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Nome della DLL|Nessuna funzione di accesso per PInvokeMap per gli attributi di metodo metodo ordinario/globali.<br /><br /> Nessuna funzione di accesso per il nome DLL.|  
|GuidAttribute|Archiviato come un vero attributo personalizzato.|Accedere come un vero attributo personalizzato.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Diversi bit.|Nessuna funzione di accesso.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Compressione delle classi.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Nessuna funzione di accesso.|  
|FieldOffsetAttribute|Offset di campo.|Nessuna funzione di accesso.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Nessun enumeratore o funzione di accesso.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> non è un tipo da runtime.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce informazioni sugli attributi applicati all'oggetto <see cref="T:System.Reflection.Assembly" /> corrente, espresse sotto forma di oggetti <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
        <returns>Elenco generico di oggetti <see cref="T:System.Reflection.CustomAttributeData" /> che rappresentano i dati relativi agli attributi applicati all'assembly corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per esaminare gli attributi personalizzati del codice nel contesto reflection-only, nei casi in cui gli attributi personalizzati sono definiti nel codice che viene caricato nel contesto reflection-only. Metodi come <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> e <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> non può essere utilizzato in questi casi, poiché creano istanze degli attributi. Impossibile eseguire codice nel contesto reflection-only. Per altre informazioni e, ad esempio di codice, vedere il <xref:System.Reflection.CustomAttributeData> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'eseguibile del processo nel dominio applicazione predefinito. In altri domini applicazione, si tratta del primo eseguibile eseguito da <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</summary>
        <returns>Assembly che rappresenta l'eseguibile del processo nel dominio applicazione predefinito oppure il primo eseguibile eseguito da <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />. Può restituire <see langword="null" /> se chiamato da codice non gestito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Assembly.GetEntryAssembly%2A> metodo può restituire `null` quando un assembly gestito è stato caricato da un'applicazione non gestita. Ad esempio, se un'applicazione non gestita viene creata un'istanza di un componente COM, scritto in c#, una chiamata al <xref:System.Reflection.Assembly.GetEntryAssembly%2A> metodo dal componente di c# restituisce null, perché il punto di ingresso per il processo è il codice non gestito anziché un assembly gestito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'assembly che contiene il codice attualmente in esecuzione.</summary>
        <returns>Assembly che contiene il codice attualmente in esecuzione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per motivi di prestazioni, è necessario chiamare questo metodo solo quando non si conosce in fase di progettazione quali assembly attualmente in esecuzione. Il metodo consigliato per recuperare un <xref:System.Reflection.Assembly> oggetto che rappresenta l'assembly corrente consiste nell'usare il <xref:System.Type.Assembly%2A?displayProperty=nameWithType> trovare la proprietà di un tipo nell'assembly, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 Per ottenere l'assembly che contiene il metodo che ha chiamato il codice attualmente in esecuzione, usare <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Type.Assembly%2A?displayProperty=nameWithType> basata su proprietà per ottenere l'assembly attualmente in esecuzione su un tipo di contenuti in tale assembly. Chiama anche il <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> metodo per la visualizzazione viene restituito un <xref:System.Reflection.Assembly> oggetto che rappresenta lo stesso assembly.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene i tipi pubblici definiti nell'assembly visibili all'esterno dell'assembly.</summary>
        <returns>Matrice che rappresenta i tipi definiti nell'assembly visibili all'esterno dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli unici tipi visibili all'esterno di un assembly sono i tipi pubblici e i tipi pubblici annidati all'interno di altri tipi pubblici.  
  
   
  
## Examples  
 Esempio di codice seguente definisce una serie di classi con vari livelli di accesso e chiama <xref:System.Reflection.Assembly.GetExportedTypes%2A> da visualizzare quelli visibili all'esterno dell'assembly.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'assembly è un assembly dinamico.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è possibile caricare un assembly dipendente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome del file specificato. Non includere il percorso del file.</param>
        <summary>Ottiene un oggetto <see cref="T:System.IO.FileStream" /> per il file specificato nella tabella file del manifesto dell'assembly.</summary>
        <returns>Flusso che contiene il file specificato o <see langword="null" /> se il file non viene trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in entrambi i file di risorse pubbliche e private.  
  
 Il `name` non deve includere il percorso del file.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="name" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> non è un assembly valido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso al percorso e per la lettura del file specificato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene i file della tabella file di un manifesto dell'assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene i file della tabella file di un manifesto dell'assembly.</summary>
        <returns>Matrice di flussi che contengono i file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in file di risorse pubbliche e private.  
  
 Questo overload equivale a chiamare le <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> overload e specificando `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File non trovato.</exception>
        <exception cref="T:System.BadImageFormatException">Un file non è un assembly valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> per includere i moduli delle risorse; in caso contrario, <see langword="false" />.</param>
        <summary>Ottiene i file della tabella file di un manifesto dell'assembly, specificando se includere i moduli delle risorse.</summary>
        <returns>Matrice di flussi che contengono i file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in file di risorse pubbliche e private.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File non trovato.</exception>
        <exception cref="T:System.BadImageFormatException">Un file non è un assembly valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene tutti i moduli caricati che fanno parte di questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene tutti i moduli caricati che fanno parte di questo assembly.</summary>
        <returns>Matrice di moduli.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> per includere i moduli delle risorse; in caso contrario, <see langword="false" />.</param>
        <summary>Ottiene tutti i moduli caricati che fanno parte di questo assembly, specificando se includere i moduli delle risorse.</summary>
        <returns>Matrice di moduli.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">Nome della risorsa con distinzione tra maiuscole e minuscole.</param>
        <summary>Restituisce informazioni sul modo in cui la risorsa specificata è stata resa persistente.</summary>
        <returns>Oggetto popolato con informazioni relative alla topologia della risorsa oppure <see langword="null" /> se la risorsa non viene trovata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="resourceName" /> è una stringa vuota ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce i nomi di tutte le risorse di questo assembly.</summary>
        <returns>Matrice che contiene i nomi di tutte le risorse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare ogni nome di risorsa nella matrice restituita da questo metodo come indicato di seguito:  
  
-   È possibile passare il nome della risorsa per il <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> metodo per ottenere altre informazioni sulla risorsa.  
  
-   Se il nome identifica un file. Resources binario, è possibile rimuovere l'estensione del file con estensione resources e passarlo al <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> costruttore per creare un'istanza di resource manager.  
  
-   È possibile passare il nome della risorsa per il <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> metodo per recuperare un <xref:System.IO.Stream> oggetto che è quindi possibile passare il <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> costruttore.  
  
-   È possibile passare il nome della risorsa per il <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> metodo per recuperare un <xref:System.IO.Stream> oggetto che è quindi possibile passare il <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> costruttore.  
  
 Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica la risorsa del manifesto specificata da questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome della risorsa del manifesto richiesta con distinzione tra maiuscole e minuscole.</param>
        <summary>Carica la risorsa del manifesto specificata da questo assembly.</summary>
        <returns>Risorsa di manifesto oppure <see langword="null" /> se non vengono specificate risorse durante la compilazione o se la risorsa non è visibile al chiamante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una risorsa di manifesto è una risorsa incorporata nell'assembly in fase di compilazione (ad esempio un file di immagine). Per altre informazioni sulle risorse di manifesto, vedere [nozioni di base di Microsoft .NET Framework Resource](http://go.microsoft.com/fwlink/?LinkId=204554) in MSDN Library.  
  
 Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Questo metodo restituisce `null` se si accede a una risorsa privata in un altro assembly e il chiamante non dispone <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.  
  
 Se il manifesto dell'assembly sono elencati i file di risorse <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> restituisce un <xref:System.IO.Stream> anche se il file di risorse non può essere disponibile su disco al momento dell'oggetto. Se non viene trovato il file di risorse, passando l'oggetto risultante <xref:System.IO.Stream> dell'oggetto per il <xref:System.Resources.ResourceReader> costruttore cause un <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> Nelle [app .NET per Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) intercettare in alternativa l'eccezione della classe di base <see cref="T:System.IO.IOException" />. </para>
          </block>  
  
Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="name" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> non è un assembly valido.</exception>
        <exception cref="T:System.NotImplementedException">La lunghezza della risorsa è maggiore di <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo il cui spazio dei nomi viene usato per definire l'ambito del nome della risorsa del manifesto.</param>
        <param name="name">Nome della risorsa del manifesto richiesta con distinzione tra maiuscole e minuscole.</param>
        <summary>Carica la risorsa del manifesto specificata, definita per l'ambito dallo spazio dei nomi del tipo specificato, da questo assembly.</summary>
        <returns>Risorsa di manifesto oppure <see langword="null" /> se non vengono specificate risorse durante la compilazione o se la risorsa non è visibile al chiamante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, se il nome completo specificato per `type` è "MyNameSpace. MyClasses" e `name` è "Net", questo metodo di overload esegue la ricerca di una risorsa denominata "MyNameSpace.Net".  
  
 Una risorsa di manifesto è una risorsa incorporata nell'assembly in fase di compilazione (ad esempio un file di immagine). Per altre informazioni sulle risorse di manifesto, vedere [nozioni di base di Microsoft .NET Framework Resource](http://go.microsoft.com/fwlink/?LinkId=204554) in MSDN Library.  
  
 Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Questo metodo restituisce `null` se si accede a una risorsa privata in un altro assembly e il chiamante non dispone <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.  
  
 Se il manifesto dell'assembly sono elencati i file di risorse <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> restituisce un <xref:System.IO.Stream> anche se il file di risorse non può essere disponibile su disco al momento dell'oggetto. Se non viene trovato il file di risorse, passando l'oggetto risultante <xref:System.IO.Stream> dell'oggetto per il <xref:System.Resources.ResourceReader> costruttore cause un <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="name" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> non è un assembly valido.</exception>
        <exception cref="T:System.NotImplementedException">La lunghezza della risorsa è maggiore di <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome del modulo richiesto.</param>
        <summary>Ottiene il modulo specificato in questo assembly.</summary>
        <returns>Modulo richiesto o <see langword="null" /> se il modulo non viene trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in nomi di file.  
  
 Le classi di `Reflection.Emit` dello spazio dei nomi generano il nome dell'ambito per un modulo dinamico. Il nome dell'ambito può essere determinato dal <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> proprietà. Passare il tipo di modulo che si desidera `Assembly.GetModule`. Ad esempio, se si desidera che il modulo che contiene il manifesto dell'assembly, passare il nome dell'ambito del modulo da `GetModule`. In caso contrario, passare il nome del file del modulo. Gli assembly caricati da una del `Load` metodi che hanno un parametro di byte [] contengono un solo modulo, ovvero il modulo del manifesto. Cercano sempre questi moduli con il nome dell'ambito.  
  
 Un tipo può essere recuperato da un modulo specifico usando <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. La chiamata a `Module.GetType` sul modulo che contiene il manifesto non verrà avviata una ricerca dell'intero assembly. Per recuperare un tipo da un assembly, indipendentemente dal modulo cui è in, è necessario chiamare <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="name" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> non è un assembly valido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene tutti i moduli che fanno parte di questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene tutti i moduli che fanno parte di questo assembly.</summary>
        <returns>Matrice di moduli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in file di risorse pubbliche e private.  
  
> [!NOTE]
>  I moduli devono essere inviati con estensioni di file.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome del modulo nella matrice restituita che contiene il manifesto dell'assembly.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Il modulo da caricare non specifica un'estensione di file.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> per includere i moduli delle risorse; in caso contrario, <see langword="false" />.</param>
        <summary>Ottiene tutti i moduli che fanno parte di questo assembly, specificando se includere i moduli delle risorse.</summary>
        <returns>Matrice di moduli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona in file di risorse pubbliche e private.  
  
> [!NOTE]
>  I moduli devono essere inviati con estensioni di file.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Reflection.AssemblyName" /> per questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Reflection.AssemblyName" /> per questo assembly.</summary>
        <returns>Oggetto che contiene il nome visualizzato completamente analizzato per questo assembly.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso al percorso dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          <see langword="true" /> per impostare la proprietà <see cref="P:System.Reflection.Assembly.CodeBase" /> sul percorso dell'assembly dopo l'esecuzione della copia shadow; <see langword="false" /> per impostare <see cref="P:System.Reflection.Assembly.CodeBase" /> sul percorso originale.</param>
        <summary>Ottiene un oggetto <see cref="T:System.Reflection.AssemblyName" /> per questo assembly, impostando la codebase come specificato da <paramref name="copiedName" />.</summary>
        <returns>Oggetto che contiene il nome visualizzato completamente analizzato per questo assembly.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso al percorso dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto da popolare con le informazioni sulla serializzazione.</param>
        <param name="context">Contesto di destinazione della serializzazione.</param>
        <summary>Ottiene le informazioni sulla serializzazione con tutti i dati necessari per creare una nuova istanza di questo assembly.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene gli oggetti <see cref="T:System.Reflection.AssemblyName" /> per tutti gli assembly a cui fa riferimento questo assembly.</summary>
        <returns>Matrice contenente i nomi visualizzati completamente analizzati di tutti gli assembly a cui fa riferimento questo assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> proprietà di un <xref:System.Reflection.AssemblyName> oggetto restituito da questo metodo è <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> se è presente alcun algoritmo hash per l'assembly di riferimento, o se l'algoritmo hash dell'assembly di riferimento non è identificato dal <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumerazione. Nelle versioni precedenti di .NET Framework, il <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> proprietà restituita <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in questa situazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare il <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> (metodo). Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Assembly> classe.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene l'assembly satellite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Impostazioni cultura specificate.</param>
        <summary>Ottiene l'assembly satellite per le impostazioni cultura specificate.</summary>
        <returns>Assembly satellite specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli assembly satellite contengono risorse localizzate, diversamente dagli assembly principale dell'applicazione, che contengono codice eseguibile non localizzabile nonché risorse per singole impostazioni cultura che fungono dal valore predefinito o impostazioni cultura neutre.  
  
 Chiamare questo metodo per usare la versione dell'assembly corrente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">È stato trovato l'assembly satellite con un nome file corrispondente, ma <see langword="CultureInfo" /> non corrisponde a quello specificato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly satellite non è un assembly valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">Impostazioni cultura specificate.</param>
        <param name="version">Versione dell'assembly satellite.</param>
        <summary>Ottiene la versione specificata dell'assembly satellite per le impostazioni cultura specificate.</summary>
        <returns>Assembly satellite specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli assembly satellite contengono risorse localizzate, diversamente dagli assembly principale dell'applicazione, che contengono codice eseguibile non localizzabile nonché risorse per singole impostazioni cultura che fungono dal valore predefinito o impostazioni cultura neutre.  
  
 Chiamare il <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload da usare la versione dell'assembly corrente.  
  
 Se `version` è `null`, la versione dell'assembly corrente viene usata se la risorsa e l'assembly principale sono firmati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">È stato trovato l'assembly satellite con un nome file corrispondente, ma <see langword="CultureInfo" /> o la versione non corrisponde a quanto specificato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly satellite non è un assembly valido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> che rappresenta il tipo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome completo del tipo.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato nell'istanza dell'assembly.</summary>
        <returns>Oggetto che rappresenta la classe specificata o <see langword="null" /> se la classe non viene trovata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cercherà solo l'istanza dell'assembly corrente. Il `name` parametro include lo spazio dei nomi ma non l'assembly. Per cercare altri assembly per un tipo, usare il <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> overload del metodo che può includere facoltativamente un nome visualizzato dell'assembly come parte del nome del tipo.  
  
> [!NOTE]
>  Se il tipo è stato inoltrato a un altro assembly, viene comunque restituito da questo metodo. Per informazioni sull'inoltro dei tipi, vedere [l'inoltro di tipi in Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
   
  
## Examples  
 L'esempio seguente definisce una classe astratta `MeansOfTransportation` classe di `Transportation` dello spazio dei nomi. Chiama il <xref:System.Reflection.Assembly.GetType%28System.String%29> metodo per recuperare relativa <xref:System.Type> oggetto, chiama il <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> metodo per ottenere una matrice di <xref:System.Reflection.PropertyInfo> gli oggetti che rappresentano le proprietà del tipo e quindi Visualizza le informazioni del tipo astraggono le proprietà. Si noti che la chiamata al <xref:System.Reflection.Assembly.GetType%28System.String%29> metodo Usa il nome del tipo completo (vale a dire, lo spazio dei nomi con il nome del tipo).  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> non è valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> Nelle [app .NET per Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) individuare in alternativa l'eccezione della classe di base <see cref="T:System.IO.IOException" />. </para>
          </block>
          <paramref name="name" /> richiede un assembly dipendente che è stato trovato ma non ha potuto essere caricato.  
  
oppure 
L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="name" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
oppure 
 <paramref name="name" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome completo del tipo.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se il tipo non viene trovato; <see langword="false" /> per restituire <see langword="null" />.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato nell'istanza dell'assembly e facoltativamente genera un'eccezione se il tipo non viene trovato.</summary>
        <returns>Oggetto che rappresenta la classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cercherà solo l'istanza dell'assembly corrente. Il `name` parametro include lo spazio dei nomi ma non l'assembly. Per cercare altri assembly per un tipo, usare il <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> overload del metodo che può includere facoltativamente un nome visualizzato dell'assembly come parte del nome del tipo.  
  
> [!NOTE]
>  Se il tipo è stato inoltrato a un altro assembly, viene comunque restituito da questo metodo. Per informazioni sull'inoltro dei tipi, vedere [l'inoltro di tipi in Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Il `throwOnError` parametro ha effetto solo quando il tipo non viene trovato. Non influisce sulle altre eccezioni che potrebbero essere generate. In particolare, se il tipo è stato trovato ma non può essere caricato <xref:System.TypeLoadException> può essere generata anche se `throwOnError` è `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> non è valido.  
  
oppure 
La lunghezza <paramref name="name" /> supera i 1024 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
oppure 
L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="name" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
oppure 
 <paramref name="name" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nome completo del tipo.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se il tipo non viene trovato; <see langword="false" /> per restituire <see langword="null" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole nel nome del tipo; in caso contrario, <see langword="false" />.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato nell'istanza dell'assembly, con la possibilità di ignorare la distinzione tra maiuscole e minuscole e di generare un'eccezione se il tipo non viene trovato.</summary>
        <returns>Oggetto che rappresenta la classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cercherà solo l'istanza dell'assembly corrente. Il `name` parametro include lo spazio dei nomi ma non l'assembly. Per cercare altri assembly per un tipo, usare il <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> overload del metodo che può includere facoltativamente un nome visualizzato dell'assembly come parte del nome del tipo.  
  
> [!NOTE]
>  Se il tipo è stato inoltrato a un altro assembly, viene comunque restituito da questo metodo. Per informazioni sull'inoltro dei tipi, vedere [l'inoltro di tipi in Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Il `throwOnError` parametro ha effetto solo quando il tipo non viene trovato. Non influisce sulle altre eccezioni che potrebbero essere generate. In particolare, se il tipo è stato trovato ma non può essere caricato <xref:System.TypeLoadException> può essere generata anche se `throwOnError` è `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> non è valido.  
  
oppure 
La lunghezza <paramref name="name" /> supera i 1024 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> richiede un assembly dipendente che non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.  
  
oppure 
L'assembly corrente è stato caricato nel contesto di sola reflection e <paramref name="name" /> richiede un assembly dipendente che non è stato precaricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> richiede un assembly dipendente, ma il file non è un assembly valido.  
  
oppure 
 <paramref name="name" /> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene i tipi definiti in questo assembly.</summary>
        <returns>Matrice che contiene tutti i tipi definiti in questo assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matrice restituita include i tipi annidati.  
  
 Se il <xref:System.Reflection.Assembly.GetTypes%2A> metodo viene chiamato su un assembly e un tipo di tale assembly è dipendente da un tipo in un assembly che non è stato caricato (ad esempio, se deriva da un tipo nell'assembly di secondo), un <xref:System.Reflection.ReflectionTypeLoadException> viene generata un'eccezione. Ad esempio, questa situazione può verificarsi se il primo assembly è stato caricato con le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> o <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi e il secondo assembly non sia stato caricato. Può verificarsi anche con gli assembly caricati utilizzando il <xref:System.Reflection.Assembly.Load%2A> e <xref:System.Reflection.Assembly.LoadFile%2A> se il secondo assembly non è possibile individuare quando i metodi di <xref:System.Reflection.Assembly.GetTypes%2A> viene chiamato il metodo.  
  
> [!NOTE]
>  Se un tipo è stato inoltrato a un altro assembly, non è incluso nella matrice restituita. Per informazioni sull'inoltro dei tipi, vedere [l'inoltro di tipi in Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Per recuperare una raccolta di <xref:System.Reflection.TypeInfo> invece di una matrice di oggetti <xref:System.Type> oggetti, usare il <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza i parametri di un metodo su un tipo nell'assembly specificato.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">L'assembly contiene uno o più tipi che non possono essere caricati. La matrice restituita dalla proprietà <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> di questa eccezione contiene un oggetto <see cref="T:System.Type" /> per ogni tipo caricato e <see langword="null" /> per ogni tipo non caricato, mentre la proprietà <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> contiene un'eccezione per ogni tipo non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'assembly è stato caricato dalla Global Assembly Cache.</summary>
        <value>
          <see langword="true" /> se l'assembly è stato caricato dalla Global Assembly Cache; in caso contrario <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il contesto host con cui l'assembly è stato caricato.</summary>
        <value>Valore <see cref="T:System.Int64" /> che indica il contesto host con cui l'assembly è stato caricato, se presente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una stringa che rappresenta la versione di CLR (Common Language Runtime) salvata nel file che contiene il manifesto.</summary>
        <value>Nome della cartella della versione CLR. Non si tratta di un percorso completo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, il valore per .NET Framework versione 1.1 sarebbe v1.1.4322. Sono posizionati i file binari per la versione nel windir%\Microsoft.NET\Framework\v1.1.4322% percorso.  
  
 Per impostazione predefinita, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> è impostato sulla versione di CLR usata per compilare l'assembly. Tuttavia, si sia stato impostato su un altro valore in fase di compilazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo dell'attributo da controllare per l'assembly.</param>
        <param name="inherit">Questo argomento viene ignorato per gli oggetti di questo tipo.</param>
        <summary>Indica se è stato applicato un attributo specificato all'assembly.</summary>
        <returns>
          <see langword="true" /> se l'attributo è stato applicato all'assembly; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente si applica il <xref:System.Reflection.AssemblyTitleAttribute> attributo su un assembly e quindi Usa <xref:System.Reflection.Assembly.IsDefined%2A> per indicare se è stato applicato. Verifica inoltre un attributo che non è stato applicato.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />utilizza un tipo non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'assembly corrente è stato generato dinamicamente nel processo corrente tramite reflection emit.</summary>
        <value>
          <see langword="true" /> se l'assembly corrente è stato generato in modo dinamico nel processo corrente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assembly dinamici sono rappresentati dalla classe derivata <xref:System.Reflection.Emit.AssemblyBuilder>.  
  
 Quando un assembly dinamico viene salvato su disco, l'assembly salvato non è dinamico. Se l'assembly salvato viene caricato in un altro dominio dell'applicazione o processo, il <xref:System.Reflection.Assembly.IsDynamic%2A> restituisce proprietà `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'assembly corrente viene caricato con attendibilità totale.</summary>
        <value>
          <see langword="true" /> se l'assembly corrente è caricato con attendibilità totale; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica un assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <summary>Carica l'assembly con un'immagine in formato COFF (Common Object File Format) contenente un assembly generato. L'assembly viene caricato nel dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il livello di attendibilità di un assembly che viene caricato usando questo metodo è lo stesso livello di attendibilità dell'assembly chiamante. Per caricare un assembly da una matrice di byte con il livello di attendibilità del dominio dell'applicazione, usare il <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> overload del metodo. Per altre informazioni sull'utilizzo di prova con gli overload dei <xref:System.Reflection.Assembly.Load%2A> metodo che accetta le matrici di byte, vedere il <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> overload del metodo.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò è probabilmente causato da del compilatore C++ degli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere la `.reloc` indirizzi per il file eseguibile C++, specificare `/fixed:no` quando si crea un collegamento.  
  
 Si noti che questo overload del metodo crea sempre un nuovo <xref:System.Reflection.Assembly> oggetto con un proprio mapping.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Oggetto che descrive l'assembly da caricare.</param>
        <summary>Carica un assembly dato il relativo oggetto <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> Se viene generata `assemblyRef` specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice dispone di una versione diversa, le impostazioni cultura o token di chiave pubblica. Il caricatore non potrà continua la ricerca degli altri assembly che corrispondono al nome semplice. Partire da .NET Framework 4, poiché l'esecuzione di codice negli assembly remoto è disabilitata per impostazione predefinita, un <xref:System.IO.FileLoadException> viene generata anche se `assemblyRef` specifica un assembly remoto. Per abilitare l'esecuzione del codice caricato da posizioni remote, è possibile usare la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento di configurazione.     
  
> [!NOTE]
>  Non usare un <xref:System.Reflection.AssemblyName> solo con il <xref:System.Reflection.AssemblyName.CodeBase%2A> set di proprietà. Il <xref:System.Reflection.AssemblyName.CodeBase%2A> proprietà non fornisca tutti gli elementi all'identità dell'assembly (ad esempio nome o la versione), pertanto, il caricamento non si verifica in base alle regole di caricamento all'identità, come ci aspetterebbe dal <xref:System.Reflection.Assembly.Load%2A> (metodo). Al contrario, l'assembly viene caricato usando le regole di origine del caricamento. Per informazioni sugli svantaggi derivanti dall'utilizzo il contesto di origine del caricamento, vedere la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> overload del metodo oppure [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo senza alcun <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine common object file format (COFF), evidenza viene ereditato dall'assembly chiamante. Questo vale per .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante, e `Hash` e `StrongName` vengono forniti dall'assembly COFF.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene usato solo l'evidenza fornita. Evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò è probabilmente causato da del compilatore C++ degli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere la `.reloc` indirizzi per il file eseguibile C++, specificare `/fixed:no` quando si crea un collegamento.  
  
> [!NOTE]
>  Se entrambi i <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> proprietà e i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> proprietà sono impostate, il primo tentativo di caricare l'assembly viene utilizzato il nome visualizzato (inclusi versione, impostazioni cultura e così via, come restituito dal <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> proprietà). Se il file non viene trovato, <xref:System.Reflection.AssemblyName.CodeBase%2A> utilizzato per la ricerca dell'assembly. Se l'assembly viene trovato tramite <xref:System.Reflection.AssemblyName.CodeBase%2A>, il nome visualizzato viene confrontato con l'assembly. Se la corrispondenza ha esito negativo, un <xref:System.IO.FileLoadException> viene generata un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente crea un <xref:System.Reflection.AssemblyName> dell'oggetto e lo usa per caricare il `sysglobal.dll` assembly. Nell'esempio viene quindi visualizzato il nome completo dei tipi pubblici dell'assembly.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> non trovata.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> Nelle [app .NET per Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) intercettare in alternativa l'eccezione della classe di base <see cref="T:System.IO.IOException" />. </para>
          </block>  
  
Non è stato possibile caricare un file trovato.

oppure

<paramref name="assemblyRef" /> specifica un assembly remoto, ma la possibilità di eseguire codice negli assembly remoti è disabilitata. Vedere <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> non è un assembly valido. oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyRef" /> è stato compilato con una versione successiva.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Forma estesa del nome dell'assembly.</param>
        <summary>Carica un assembly in base alla forma estesa del nome.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Forma estesa del nome di un assembly è costituito il relativo nome semplice (ad esempio "System" per l'assembly System. dll) con la versione, impostazioni cultura, token di chiave pubblica e, facoltativamente, l'architettura del processore. Corrisponde all'assembly <xref:System.Reflection.Assembly.FullName%2A> proprietà. Nell'esempio seguente viene illustrato l'utilizzo di un nome molto lungo per caricare l'assembly System. dll per .NET Framework 4.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> Se viene generata `assemblyString` specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice dispone di una versione diversa, le impostazioni cultura o token di chiave pubblica. Il caricatore non potrà continua la ricerca degli altri assembly che corrispondono al nome semplice.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo senza alcun <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine common object file format (COFF), evidenza viene ereditato dall'assembly chiamante. Questo vale per .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante, e `Hash` e `StrongName` vengono forniti dall'assembly COFF.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene usato solo l'evidenza fornita. Evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò è probabilmente causato da del compilatore C++ degli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere la `.reloc` indirizzi per il file eseguibile C++, specificare `/fixed:no` quando si crea un collegamento.  
  
 In .NET Framework versione 2.0, architettura del processore viene aggiunta all'identità di assembly e può essere specificato come parte di stringhe di nomi di assembly. Ad esempio, "ProcessorArchitecture = msil". Tuttavia, il metodo consigliato per specificare un nome di assembly consiste nel creare un <xref:System.Reflection.AssemblyName> dell'oggetto e passarlo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> (metodo). Vedere <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente carica un assembly dato il relativo nome completo e vengono elencati tutti i tipi contenuti nell'assembly specificato. Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> è una stringa di lunghezza zero.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <summary>Carica l'assembly con un'immagine in formato COFF (Common Object File Format) che contiene un assembly generato e include facoltativamente i simboli per l'assembly. L'assembly viene caricato nel dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il livello di attendibilità di un assembly che viene caricato usando questo metodo è lo stesso livello di attendibilità dell'assembly chiamante. Per caricare un assembly da una matrice di byte con il livello di attendibilità del dominio dell'applicazione, usare il <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> overload del metodo. Per altre informazioni sull'utilizzo di prova con gli overload dei <xref:System.Reflection.Assembly.Load%2A> metodo che accetta le matrici di byte, vedere il <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> overload del metodo.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò è probabilmente causato da del compilatore C++ degli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere la `.reloc` indirizzi per il file eseguibile C++, specificare `/fixed:no` quando si crea un collegamento.  
  
 Si noti che questo overload del metodo crea sempre un nuovo <xref:System.Reflection.Assembly> oggetto con un proprio mapping.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Oggetto che descrive l'assembly da caricare.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly dato il relativo oggetto <see cref="T:System.Reflection.AssemblyName" />. L'assembly viene caricato nel dominio del chiamante usando l'evidenza fornita.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> Se viene generata `assemblyRef` specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice dispone di una versione diversa, le impostazioni cultura o token di chiave pubblica. Il caricatore non potrà continua la ricerca degli altri assembly che corrispondono al nome semplice.  Partire da .NET Framework 4, poiché l'esecuzione di codice negli assembly remoto è disabilitata per impostazione predefinita, un <xref:System.IO.FileLoadException> viene generata anche se `assemblyRef` specifica un assembly remoto. Per abilitare l'esecuzione del codice caricato da posizioni remote, è possibile usare la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento di configurazione.   
  
> [!NOTE]
>  Non usare un <xref:System.Reflection.AssemblyName> solo con il <xref:System.Reflection.AssemblyName.CodeBase%2A> set di proprietà. Il <xref:System.Reflection.AssemblyName.CodeBase%2A> proprietà non fornisca tutti gli elementi all'identità dell'assembly (ad esempio nome o la versione), pertanto, il caricamento non si verifica in base alle regole di caricamento all'identità, come ci aspetterebbe dal <xref:System.Reflection.Assembly.Load%2A> (metodo). Al contrario, l'assembly viene caricato usando le regole di origine del caricamento. Per informazioni sugli svantaggi derivanti dall'utilizzo il contesto di origine del caricamento, vedere la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> overload del metodo oppure [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo senza alcun <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine common object file format (COFF), evidenza viene ereditato dall'assembly chiamante. Questo vale per .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante, e `Hash` e `StrongName` vengono forniti dall'assembly COFF.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene usato solo l'evidenza fornita. Evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò è probabilmente causato da del compilatore C++ degli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere la `.reloc` indirizzi per il file eseguibile C++, specificare `/fixed:no` quando si crea un collegamento.  
  
> [!NOTE]
>  Se entrambi i <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> proprietà e i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> proprietà sono impostate, il primo tentativo di caricare l'assembly viene utilizzato il nome visualizzato (inclusi versione, impostazioni cultura e così via, come restituito dal <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> proprietà). Se il file non viene trovato, <xref:System.Reflection.AssemblyName.CodeBase%2A> utilizzato per la ricerca dell'assembly. Se l'assembly viene trovato tramite <xref:System.Reflection.AssemblyName.CodeBase%2A>, il nome visualizzato viene confrontato con l'assembly. Se la corrispondenza ha esito negativo, un <xref:System.IO.FileLoadException> viene generata un'eccezione.  
  
 Se si chiama il <xref:System.Reflection.Assembly.Load%2A> metodo più di una volta nello stesso assembly, ma con una diversa evidenza specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché non può essere l'uguaglianza e l'integrità delle specifiche di prova diversi determinato. L'evidenza che innanzitutto abbia esito positivo sia l'evidenza utilizzata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyRef" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.

oppure

<paramref name="assemblyRef" /> specifica un assembly remoto, ma la possibilità di eseguire codice negli assembly remoti è disabilitata. Vedere <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nome visualizzato dell'assembly.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly in base al nome visualizzato nel dominio del chiamante, usando l'evidenza fornita.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> Se viene generata `assemblyString` specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice dispone di una versione diversa, le impostazioni cultura o token di chiave pubblica. Il caricatore non potrà continua la ricerca degli altri assembly che corrispondono al nome semplice.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo senza alcun <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine common object file format (COFF), evidenza viene ereditato dall'assembly chiamante. Questo vale per .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante, e `Hash` e `StrongName` vengono forniti dall'assembly COFF.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene usato solo l'evidenza fornita. Evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò è probabilmente causato da del compilatore C++ degli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere la `.reloc` indirizzi per il file eseguibile C++, specificare `/fixed:no` quando si crea un collegamento.  
  
 Se si chiama questo metodo più volte nello stesso assembly, ma con una diversa evidenza specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché non è possibile determinare l'uguaglianza e l'integrità delle specifiche di evidenze diversi. L'evidenza che innanzitutto abbia esito positivo sia l'evidenza utilizzata.  
  
 In .NET Framework versione 2.0, architettura del processore viene aggiunta all'identità di assembly e può essere specificato come parte di stringhe di nomi di assembly. Ad esempio, "ProcessorArchitecture = msil". Tuttavia, il metodo consigliato per specificare un nome di assembly consiste nel creare un <xref:System.Reflection.AssemblyName> dell'oggetto e passarlo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> (metodo). Vedere <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.  
  
oppure 
Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica l'assembly con un'immagine in formato COFF (Common Object File Format) che contiene un assembly generato e include facoltativamente i simboli e l'evidenza per l'assembly. L'assembly viene caricato nel dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly viene caricato nel dominio del chiamante usando l'evidenza fornita. Vengono caricati anche i byte non elaborati che rappresentano i simboli per l'assembly.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo senza alcun <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.Load%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine COFF, l'evidenza viene ereditato dall'assembly chiamante. Questo vale per .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.  
  
    > [!NOTE]
    >  In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si usa un' <xref:System.Reflection.Assembly.Load%2A> overload del metodo con un `Byte[]` parametri per caricare un'immagine COFF, l'evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante, e `Hash` e `StrongName` vengono forniti dall'assembly COFF.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.Load%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene usato solo l'evidenza fornita. Evidenza dell'assembly chiamante e quella dell'immagine COFF vengono ignorati.  
  
 La reflection su file eseguibili C++ può generare un <xref:System.BadImageFormatException>. Ciò è probabilmente causato da del compilatore C++ degli indirizzi di rilocazione o `.reloc` sezione dal file eseguibile. Per mantenere la `.reloc` indirizzi per il file eseguibile C++, specificare `/fixed:no` quando si crea un collegamento.  
  
 Se si chiama il [\], Byte\<XRef:System.Reflection.Assembly.Load%2A > metodo più di una volta nello stesso assembly, ma con una diversa evidenza specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché il non è possibile determinare l'uguaglianza e l'integrità delle diverse specifiche di prova. L'evidenza che innanzitutto abbia esito positivo sia l'evidenza utilizzata.  
  
 Si noti che questo overload del metodo crea sempre un nuovo <xref:System.Reflection.Assembly> oggetto con un proprio mapping.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> non è <see langword="null" />.  Per impostazione predefinita, i criteri di sicurezza dall'accesso di codice legacy non sono abilitati in [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; quando non sono abilitati, <paramref name="securityEvidence" /> deve essere <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la capacità di fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <param name="securityContextSource">Origine del contesto di sicurezza.</param>
        <summary>Carica l'assembly con un'immagine in formato COFF (Common Object File Format) che contiene un assembly generato, include facoltativamente i simboli e specifica l'origine per il contesto di sicurezza. L'assembly viene caricato nel dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly viene caricato nel dominio dell'applicazione del chiamante, usando l'origine specificata per il contesto di sicurezza. Se `rawSymbolStore` è stato specificato, vengono caricati anche i byte non elaborati che rappresentano i simboli per l'assembly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
oppure 
 <paramref name="rawAssembly" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="securityContextSource" /> non è uno dei valori di enumerazione.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica il contenuto di un file di assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo del file da caricare.</param>
        <summary>Carica il contenuto di un file di assembly nel percorso specificato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Reflection.Assembly.LoadFile%2A> metodo per caricare ed esaminare gli assembly che hanno la stessa identità, ma si trovano in percorsi diversi. <xref:System.Reflection.Assembly.LoadFile%2A> non carica i file nel contesto di origine del caricamento e non consente di risolvere le dipendenze usando il percorso di caricamento, come il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo. <xref:System.Reflection.Assembly.LoadFile%2A> è utile in questo scenario limitato poiché <xref:System.Reflection.Assembly.LoadFrom%2A> non può essere utilizzato per caricare gli assembly che hanno le stesse identità ma diversi percorsi; verrà caricato solo il primo tali assembly.  

Partire da .NET Framework 4, se `path` specifica un assembly in una posizione remota, il caricamento dell'assembly è disabilitato per impostazione predefinita e il `LoadFile` metodo genera un <xref:System.IO.FileLoadException>. Per abilitare l'esecuzione del codice caricato da posizioni remote, è possibile usare la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento di configurazione.    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="path" /> non è un percorso assoluto.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.

oppure

La possibilità di eseguire codice negli assembly remoto è disabilitata. Vedere <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="path" /> è una stringa vuota ("") o non esiste.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="path" /> è stato compilato con una versione successiva.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo del file di assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly in base al percorso nel dominio del chiamante, usando l'evidenza fornita.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Reflection.Assembly.LoadFile%2A> metodo per caricare ed esaminare gli assembly che hanno la stessa identità, ma si trovano in percorsi diversi. <xref:System.Reflection.Assembly.LoadFile%2A> non carica i file nei <xref:System.Reflection.Assembly.LoadFrom%2A> contesto e non consente di risolvere le dipendenze usando il percorso di caricamento, come il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo. <xref:System.Reflection.Assembly.LoadFile%2A> è utile in questo scenario limitato poiché <xref:System.Reflection.Assembly.LoadFrom%2A> non può essere utilizzato per caricare gli assembly che hanno le stesse identità ma diversi percorsi; verrà caricato solo il primo tali assembly.  

Partire da .NET Framework 4, se `path` specifica un assembly in una posizione remota, il caricamento dell'assembly è disabilitato per impostazione predefinita e il `LoadFile` metodo genera un <xref:System.IO.FileLoadException>. Per abilitare l'esecuzione del codice caricato da posizioni remote, è possibile usare la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento di configurazione.    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="path" /> non è un percorso assoluto.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="path" /> è una stringa vuota ("") o non esiste.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.

oppure

La possibilità di eseguire codice negli assembly remoto è disabilitata. Vedere <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="path" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> non è <see langword="null" />. Per impostazione predefinita, i criteri di sicurezza dall'accesso di codice legacy non sono abilitati in [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; quando non sono abilitati, <paramref name="securityEvidence" /> deve essere <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica un assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

A partire da .NET Framework 4, la possibilità di eseguire codice negli assembly caricati da percorsi remoti è disabilitata per impostazione predefinita e la chiamata per il `LoadFrom` metodo genera un <xref:System.IO.FileLoadException>. Per caricare l'assembly ed eseguire il codice, è necessario:

- Creare in modo esplicito un ambiente sandbox per l'assembly. (Vedere [procedura: eseguire codice parzialmente attendibile in un ambiente Sandbox](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)

- Eseguire il codice dell'assembly con attendibilità totale, impostando il `enabled` attributo del [ `<loadFromRemoteSources>` elemento di configurazione](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) a `true`. Per altre informazioni, vedere la [ `<loadFromRemoteSources>` elemento di configurazione](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) articolo.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <summary>Carica un assembly in base al nome file o al percorso.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
> [!NOTE]
>  File transfer protocol (FTP) non è supportato. Se l'URI fornito per `assemblyFile` è un indirizzo FTP, l'assembly non viene caricato. Non viene generata alcuna eccezione.  
  
 `assemblyFile` può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.  
  
 Gli assembly possono essere caricati in uno dei tre contesti disponibili o possono essere caricati senza contesto:  
  
-   Il contesto di caricamento contiene assembly trovati mediante la ricerca: nella GAC, archiviate in un assembly host se è ospitato il runtime o nel <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio dell'applicazione. La maggior parte degli overload del metodo <xref:System.Reflection.Assembly.Load%2A> carica gli assembly in questo contesto.  
  
-   Il contesto di origine del caricamento contiene assembly per cui l'utente ha specificato un percorso non incluso nella directory di esecuzione del probe esegue la ricerca. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> sono esempi di metodi che vengono caricati in base al percorso. 

    Partire da .NET Framework 4, se l'URI del `assemblyFile` specifica una posizione remota, il caricamento dell'assembly è disabilitato per impostazione predefinita e il `LoadFrom` metodo genera un <xref:System.IO.FileLoadException>. Per abilitare l'esecuzione del codice caricato da posizioni remote, è possibile usare la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento di configurazione.    
  
-   Contesto reflection-only contiene assembly caricati con il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi; codice in questi contesti non possono essere eseguiti.  
  
-   Se l'utente generato o trovata l'assembly, non è in qualsiasi contesto. Questo vale per gli assembly caricati usando gli overload del <xref:System.Reflection.Assembly.Load%2A> metodo che specifica una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite reflection emit e non salvate su disco.  
  
 Il contesto di origine del caricamento consente a un assembly devono essere caricati da un percorso non incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare in quanto le informazioni sul percorso viene mantenute dal contesto.  
  
 Il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo presenta i seguenti svantaggi. In alternativa, considerare l'utilizzo di <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Se è già caricato un assembly con la stessa identità <xref:System.Reflection.Assembly.LoadFrom%2A> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>e un assembly nel contesto di caricamento in un secondo momento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo. Ciò può verificarsi quando un assembly è deserializzato.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>, e il percorso di sondaggio include un assembly con la stessa identità, ma con una posizione diversa, un' <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, o altri comportamenti imprevisti possono verificarsi.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> richiede <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> o <xref:System.Net.WebPermission> per il percorso specificato.  
  
-   Se non esiste un'immagine nativa per `assemblyFile`, non viene utilizzato. L'assembly non può essere caricato come indipendente dal dominio.  
  
-   In .NET Framework versioni 1.0 e 1.1, i criteri non vengono applicati.  
  
   
  
## Examples  
 L'esempio seguente carica un assembly in base al nome file o percorso.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.

oppure

La possibilità di eseguire codice negli assembly remoto è disabilitata. Vedere <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit. Per altre informazioni, vedere l'argomento relativo alle eccezioni.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Il nome dell'assembly supera la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly in base al nome file o al percorso e fornendo l'evidenza di sicurezza.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
> [!NOTE]
>  File transfer protocol (FTP) non è supportato. Se l'URI fornito per `assemblyFile` è un indirizzo FTP, l'assembly non viene caricato. Non viene generata alcuna eccezione.  
  
 `assemblyFile` può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.  
  
 Gli assembly possono essere caricati in uno dei tre contesti disponibili o possono essere caricati senza contesto:  
  
-   Il contesto di caricamento contiene assembly trovati mediante la ricerca: nella GAC, archiviate in un assembly host se è ospitato il runtime o nel <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio dell'applicazione. La maggior parte degli overload del metodo <xref:System.Reflection.Assembly.Load%2A> carica gli assembly in questo contesto.  
  
-   Il contesto di origine del caricamento contiene assembly per cui l'utente ha specificato un percorso non incluso nella directory di esecuzione del probe esegue la ricerca. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> sono esempi di metodi che vengono caricati in base al percorso.

    Partire da .NET Framework 4, se l'URI del `assemblyFile` specifica una posizione remota, il caricamento dell'assembly è disabilitato per impostazione predefinita e il `LoadFrom` metodo genera un <xref:System.IO.FileLoadException>. Per abilitare l'esecuzione del codice caricato da posizioni remote, è possibile usare la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento di configurazione.    
  
-   Contesto reflection-only contiene assembly caricati con il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi; codice in questi contesti non possono essere eseguiti.  
  
-   Se l'utente generato o trovata l'assembly, non è in qualsiasi contesto. Questo vale per gli assembly caricati usando gli overload del <xref:System.Reflection.Assembly.Load%2A> metodo che specifica una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite reflection emit e non salvate su disco.  
  
 Il contesto di origine del caricamento consente a un assembly devono essere caricati da un percorso non incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare in quanto le informazioni sul percorso viene mantenute dal contesto.  
  
 Il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo presenta i seguenti svantaggi. In alternativa, considerare l'utilizzo di <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Se è già caricato un assembly con la stessa identità <xref:System.Reflection.Assembly.LoadFrom%2A> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>e un assembly nel contesto di caricamento in un secondo momento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo. Questa situazione può verificarsi quando un assembly è deserializzato.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>, e il percorso di sondaggio include un assembly con la stessa identità, ma con una posizione diversa, un' <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, o altri comportamenti imprevisti possono verificarsi.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> richiede <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> o <xref:System.Net.WebPermission> per il percorso specificato.  
  
-   Se non esiste un'immagine nativa per `assemblyFile`, non viene utilizzato. L'assembly non può essere caricato come indipendente dal dominio.  
  
-   In .NET Framework versioni 1.0 e 1.1, i criteri non vengono applicati.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.LoadFrom%2A> metodo senza alcun <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
-   Se si chiama questo metodo più volte nello stesso assembly, ma con una diversa evidenza specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché non è possibile determinare l'uguaglianza e l'integrità delle specifiche di evidenze diversi. L'evidenza che innanzitutto abbia esito positivo sia l'evidenza utilizzata.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un `Byte[]` parametri per caricare un'immagine common object file format (COFF), evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante, e `Hash` e `StrongName` vengono forniti dall'assembly COFF.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene usato solo l'evidenza fornita. Evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.  
  
oppure 
<paramref name="securityEvidence" /> non è ambiguo ed è risultato non valido.

oppure

La possibilità di eseguire codice negli assembly remoto è disabilitata. Vedere <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit. Per altre informazioni, vedere l'argomento relativo alle eccezioni.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Il nome dell'assembly supera la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <param name="hashValue">Valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Algoritmo hash usato per generare un hash per i file e generare il nome sicuro.</param>
        <summary>Carica un assembly in base al nome file o al percorso, al valore hash e all'algoritmo hash.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
> [!NOTE]
>  File transfer protocol (FTP) non è supportato. Se l'URI fornito per `assemblyFile` è un indirizzo FTP, l'assembly non viene caricato. Non viene generata alcuna eccezione.  
  
 `assemblyFile` può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.  
  
 Gli assembly possono essere caricati in uno dei tre contesti disponibili o possono essere caricati senza contesto:  
  
-   Il contesto di caricamento contiene assembly trovati mediante la ricerca: nella global assembly cache, archiviate in un assembly host se è ospitato il runtime o nel <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio dell'applicazione. La maggior parte degli overload del metodo <xref:System.Reflection.Assembly.Load%2A> carica gli assembly in questo contesto.  
  
-   Il contesto di origine del caricamento contiene assembly per cui l'utente ha specificato un percorso che non è incluso nel probe. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> sono esempi di metodi che vengono caricati in base al percorso.  

    Partire da .NET Framework 4, se l'URI del `assemblyFile` specifica una posizione remota, il caricamento dell'assembly è disabilitato per impostazione predefinita e il `LoadFrom` metodo genera un <xref:System.IO.FileLoadException>. Per abilitare l'esecuzione del codice caricato da posizioni remote, è possibile usare la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento di configurazione.    
  
-   Contesto reflection-only contiene assembly caricati con il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi; codice in questi contesti non possono essere eseguiti.  
  
-   Se l'utente generato o trovata l'assembly, non è in qualsiasi contesto. Questo vale per gli assembly caricati usando gli overload del <xref:System.Reflection.Assembly.Load%2A> metodo che specifica una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite reflection emit e non salvate su disco.  
  
 Il contesto di origine del caricamento consente a un assembly devono essere caricati da un percorso che non è incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare in quanto le informazioni sul percorso viene mantenute dal contesto.  
  
 Il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo presenta i seguenti svantaggi. In alternativa, considerare l'utilizzo di <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Se è già caricato un assembly con la stessa identità <xref:System.Reflection.Assembly.LoadFrom%2A> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>e un assembly nel contesto di caricamento in un secondo momento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo. Questa situazione può verificarsi quando un assembly è deserializzato.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>, e il percorso di sondaggio include un assembly con la stessa identità, ma con una posizione diversa, un' <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, o altri comportamenti imprevisti possono verificarsi.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> richiede <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> o <xref:System.Net.WebPermission> per il percorso specificato.  
  
-   Se non esiste un'immagine nativa per `assemblyFile`, non viene utilizzato. L'assembly non può essere caricato come modulo indipendente dal dominio.  
  
 L'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non è stato trovato oppure il modulo che si sta provando a caricare non specifica un'estensione di file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.

oppure

La possibilità di eseguire codice negli assembly remoto è disabilitata. Vedere <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit. Per altre informazioni, vedere l'argomento relativo alle eccezioni.  
  
oppure 
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Il nome dell'assembly supera la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <param name="hashValue">Valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Algoritmo hash usato per generare un hash per i file e generare il nome sicuro.</param>
        <summary>Carica un assembly in base al nome file o al percorso, all'evidenza di sicurezza, al valore hash e all'algoritmo hash.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
> [!NOTE]
>  File transfer protocol (FTP) non è supportato. Se l'URI fornito per `assemblyFile` è un indirizzo FTP, l'assembly non viene caricato. Non viene generata alcuna eccezione.  
  
 `assemblyFile` può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.  
  
 Gli assembly possono essere caricati in uno dei tre contesti disponibili o possono essere caricati senza contesto:  
  
-   Il contesto di caricamento contiene assembly trovati mediante la ricerca: nella GAC, archiviate in un assembly host se è ospitato il runtime o nel <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio dell'applicazione. La maggior parte degli overload del metodo <xref:System.Reflection.Assembly.Load%2A> carica gli assembly in questo contesto.  
  
-   Il contesto di origine del caricamento contiene assembly per cui l'utente ha specificato un percorso non incluso nella directory di esecuzione del probe esegue la ricerca. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> sono esempi di metodi che vengono caricati in base al percorso.  

    Partire da .NET Framework 4, se l'URI del `assemblyFile` specifica una posizione remota, il caricamento dell'assembly è disabilitato per impostazione predefinita e il `LoadFrom` metodo genera un <xref:System.IO.FileLoadException>. Per abilitare l'esecuzione del codice caricato da posizioni remote, è possibile usare la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento di configurazione.    
  
-   Contesto reflection-only contiene assembly caricati con il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> metodi; codice in questi contesti non possono essere eseguiti.  
  
-   Se l'utente generato o trovata l'assembly, non è in qualsiasi contesto. Questo vale per gli assembly caricati usando gli overload del <xref:System.Reflection.Assembly.Load%2A> metodo che specifica una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite reflection emit e non salvate su disco.  
  
 Il contesto di origine del caricamento consente a un assembly devono essere caricati da un percorso non incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare in quanto le informazioni sul percorso viene mantenute dal contesto.  
  
 Il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo presenta i seguenti svantaggi. In alternativa, considerare l'utilizzo di <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Se è già caricato un assembly con la stessa identità <xref:System.Reflection.Assembly.LoadFrom%2A> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>e un assembly nel contesto di caricamento in un secondo momento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo. Questa situazione può verificarsi quando un assembly è deserializzato.  
  
-   Se un assembly viene caricato con <xref:System.Reflection.Assembly.LoadFrom%2A>, e il percorso di sondaggio include un assembly con la stessa identità, ma con una posizione diversa, un' <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, o altri comportamenti imprevisti possono verificarsi.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> richiede <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> o <xref:System.Net.WebPermission> per il percorso specificato.  
  
-   Se non esiste un'immagine nativa per `assemblyFile`, non viene utilizzato. L'assembly non può essere caricato come indipendente dal dominio.  
  
-   In .NET Framework versioni 1.0 e 1.1, i criteri non vengono applicati.  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per assembly e l'evidenza di sicurezza unione sono come segue:  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.LoadFrom%2A> metodo senza alcun <xref:System.Security.Policy.Evidence> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.Reflection.Assembly.LoadFrom%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
-   Se si chiama questo metodo più volte nello stesso assembly, ma con una diversa evidenza specificata, common language runtime non genera un <xref:System.IO.FileLoadException> perché non è possibile determinare l'uguaglianza e l'integrità delle specifiche di evidenze diversi. L'evidenza che innanzitutto abbia esito positivo sia l'evidenza utilizzata.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un `Byte[]` parametri per caricare un'immagine common object file format (COFF), evidenza viene combinato. `Zone`, `Url` e `Site` vengono ereditate dall'assembly chiamante, e `Hash` e `StrongName` vengono forniti dall'assembly COFF.  
  
-   Quando si usa un' <xref:System.Reflection.Assembly.LoadFrom%2A> metodo con un `Byte[]` parametro e <xref:System.Security.Policy.Evidence> per caricare un'immagine COFF, viene usato solo l'evidenza fornita. Evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.  
  
oppure 
<paramref name="securityEvidence" /> non è ambiguo ed è risultato non valido.

oppure

La possibilità di eseguire codice negli assembly remoto è disabilitata. Vedere <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit. Per altre informazioni, vedere l'argomento relativo alle eccezioni.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Il nome dell'assembly supera la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica il modulo interno a questo assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nome del modulo. Questa stringa deve corrispondere a un nome file nel manifesto dell'assembly.</param>
        <param name="rawModule">Matrice di byte costituita da un'immagine in formato COFF che contiene un modulo generato o una risorsa.</param>
        <summary>Carica il modulo, interno all'assembly, con un'immagine in formato COFF (Common Object File Format) contenente un modulo generato o un file di risorse.</summary>
        <returns>Modulo caricato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> o <paramref name="rawModule" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> non corrisponde a una voce di file nel manifesto dell'assembly.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> non è un modulo valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nome del modulo. Questa stringa deve corrispondere a un nome file nel manifesto dell'assembly.</param>
        <param name="rawModule">Matrice di byte costituita da un'immagine in formato COFF che contiene un modulo generato o una risorsa.</param>
        <param name="rawSymbolStore">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per il modulo. Deve essere <see langword="null" /> se si tratta di un file di risorse.</param>
        <summary>Carica il modulo, interno all'assembly, con un'immagine in formato COFF (Common Object File Format) contenente un modulo generato o un file di risorse. Vengono caricati anche i byte non elaborati che rappresentano i simboli per il modulo.</summary>
        <returns>Modulo caricato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> o <paramref name="rawModule" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> non corrisponde a una voce di file nel manifesto dell'assembly.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> non è un modulo valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è stato possibile caricare un file trovato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica un assembly dalla directory dell'applicazione o dalla Global Assembly Cache con un nome parziale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Gli overload del <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> metodo sono obsoleto e sono state mantenute per compatibilità con le versioni precedenti. L'alternativa non obsoleta è <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">Nome visualizzato dell'assembly.</param>
        <summary>Carica un assembly dalla directory dell'applicazione o dalla Global Assembly Cache con un nome parziale.</summary>
        <returns>Assembly caricato. Se <paramref name="partialName" /> non viene trovato, il metodo restituisce <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> metodo è obsoleto ed è stata mantenuta per compatibilità con le versioni precedenti. L'alternativa non obsoleta è <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Le applicazioni che caricano gli assembly con questo metodo saranno interessate dagli aggiornamenti di tali assembly. Pertanto, non utilizzare questo metodo. riprogettare l'applicazione per usare la <xref:System.Reflection.Assembly.Load%28System.String%29> overload del metodo o il <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> overload del metodo.  
  
 Questo metodo chiama prima <xref:System.Reflection.Assembly.Load%2A>. Se l'assembly non viene trovato, questo metodo restituisce l'assembly dalla global assembly cache con lo stesso nome semplice e il numero di versione più alto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="partialName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="partialName" /> è stato compilato con una versione successiva.</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">Nome visualizzato dell'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica un assembly dalla directory dell'applicazione o dalla Global Assembly Cache con un nome parziale. L'assembly viene caricato nel dominio del chiamante usando l'evidenza fornita.</summary>
        <returns>Assembly caricato. Se <paramref name="partialName" /> non viene trovato, il metodo restituisce <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> metodo è obsoleto ed è stata mantenuta per compatibilità con le versioni precedenti. L'alternativa non obsoleta è <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Un'evidenza è l'insieme di informazioni su cui vengono basate le decisioni inerenti i criteri di sicurezza, ad esempio le autorizzazioni che è possibile assegnare al codice.  
  
 Le applicazioni che caricano gli assembly con questo metodo saranno interessate dagli aggiornamenti di tali assembly. Pertanto, non utilizzare questo metodo. riprogettare l'applicazione per usare la <xref:System.Reflection.Assembly.Load%2A> metodo o il <xref:System.Reflection.Assembly.LoadFrom%2A> (metodo).  
  
 Questo metodo chiama prima <xref:System.Reflection.Assembly.Load%2A>. Se l'assembly non viene trovato, questo metodo restituisce l'assembly dalla global assembly cache con lo stesso nome semplice e il numero di versione più alto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due set di evidenze diversi.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="partialName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="partialName" /> è stato compilato con una versione successiva.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito e caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso completo o il percorso UNC del file caricato che contiene il manifesto.</summary>
        <value>Percorso del file caricato che contiene il manifesto. Se è stata eseguita una copia shadow del file caricato, il percorso è quello del file dopo l'esecuzione della copia shadow. Se l'assembly viene caricato da una matrice di byte, come quando si usa l'overload del metodo <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />, il valore restituito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere il percorso prima che il file è stata creata una copia shadow, usare il <xref:System.Reflection.Assembly.CodeBase%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il percorso del file caricato che contiene il manifesto.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'assembly corrente è un assembly dinamico, rappresentato da un oggetto <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso al percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il modulo contenente il manifesto per l'assembly corrente.</summary>
        <value>Modulo contenente il manifesto per l'assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il caricatore della classe Common Language Runtime non è in grado di risolvere un riferimento a un modulo interno di un assembly in modo normale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento consente il callback per trovare e caricare il modulo e lo restituisce.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta contenente i moduli dell'assembly.</summary>
        <value>Raccolta contenente i moduli dell'assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Assembly da confrontare con <c>right</c>.</param>
        <param name="right">Assembly da confrontare con <c>left</c>.</param>
        <summary>Indica se due oggetti <see cref="T:System.Reflection.Assembly" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Assembly da confrontare con <c>right</c>.</param>
        <param name="right">Assembly da confrontare con <c>left</c>.</param>
        <summary>Indica se due oggetti <see cref="T:System.Reflection.Assembly" /> non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> non è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il set di concessioni dell'assembly corrente.</summary>
        <value>Set di concessioni dell'assembly corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> gli oggetti possono contenere informazioni riservate, ad esempio i percorsi. Pertanto, l'attendibilità totale deve accedere a questi oggetti.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se l'assembly è stato caricato nel contesto ReflectionOnly.</summary>
        <value>
          <see langword="true" /> se l'assembly è stato caricato nel contesto solo reflection anziché nel contesto di esecuzione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un assembly è stato caricato nel contesto reflection-only, usando il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> metodo, è possibile eseguire codice nell'assembly. Per eseguire il codice, l'assembly deve essere caricato nel contesto di esecuzione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica un assembly nel contesto di sola reflection, in cui l'assembly può essere esaminato ma non eseguito.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <summary>Carica l'assembly da un'immagine in formato COFF (Common Object File Format) contenente un assembly generato. L'assembly viene caricato nel contesto di sola reflection del dominio applicazione del chiamante.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile eseguire codice da un assembly caricato nel contesto reflection-only. Per eseguire il codice, l'assembly deve essere caricato nel contesto di esecuzione, usando il <xref:System.Reflection.Assembly.Load%2A> (metodo).  
  
 Contesto reflection-only non è diverso da altri contesti. Gli assembly caricati nel contesto possono essere scaricati solo scaricando il dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" /> non può essere caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nome visualizzato dell'assembly, come restituito dalla proprietà <see cref="P:System.Reflection.AssemblyName.FullName" />.</param>
        <summary>Carica un assembly nel contesto di sola reflection in base al nome visualizzato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dipendenze non vengono caricate automaticamente nel contesto reflection-only.  
  
 È possibile eseguire codice da un assembly caricato nel contesto reflection-only. Per eseguire il codice, l'assembly deve essere caricato nel contesto di esecuzione, usando il <xref:System.Reflection.Assembly.Load%2A> (metodo).  
  
 Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze. Le regole per assembly e l'evidenza di sicurezza unione sono come segue:  
  
> [!NOTE]
>  La reflection sui file eseguibili compilati in C++ può generare un <xref:System.IO.FileLoadException>. Ciò è dovuto molto probabilmente il compilatore C++ degli indirizzi di rilocazione oppure della sezione. reloc dal file eseguibile. Per mantenere l'indirizzo, specificare `/fixed:no` quando si crea un collegamento.  
  
 Contesto reflection-only non è diverso da altri contesti. Gli assembly caricati nel contesto possono essere scaricati solo scaricando il dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" /> è stato trovato ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Percorso del file che contiene il manifesto dell'assembly.</param>
        <summary>Carica un assembly nel contesto di sola reflection in base al percorso.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dipendenze non vengono caricate automaticamente nel contesto reflection-only. Per caricare automaticamente le dipendenze, gestire il <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> eventi e caricare la dipendenza nel gestore dell'evento.  
  
 È possibile eseguire codice da un assembly caricato nel contesto reflection-only. Per eseguire il codice, caricare l'assembly con il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo).  
  
 Il `assemblyFile` parametro deve fare riferimento a un URI senza caratteri di escape. Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.  
  
 Il percorso specificato per `assemblyFile` è relativo alla directory corrente. L'assembly viene caricato nel dominio del chiamante.  
  
 Contesto reflection-only non è diverso da altri contesti. Gli assembly caricati nel contesto possono essere scaricati solo scaricando il dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non è stato trovato oppure il modulo che si sta provando a caricare non specifica un'estensione di file.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" /> è stato trovato ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il nome dell'assembly supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica il set di regole di sicurezza applicato da Common Language Runtime (CLR) per questo assembly.</summary>
        <value>Set di regole di sicurezza applicato da CLR per questo assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, gli assembly a cui si esegue la compilazione con il [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] dispongono di trasparenza, anche se è possibile renderle esplicitamente invece. Gli assembly compilati con le versioni precedenti di .NET Framework hanno la trasparenza di livello 1.  
  
 Vedere [Modifiche di sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il tipo dell'istanza corrente.</summary>
        <returns>Oggetto che rappresenta il tipo di <see cref="T:System.Reflection.Assembly" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il nome completo dell'assembly, noto anche come nome visualizzato.</summary>
        <returns>Nome completo dell'assembly o nome della classe se non è possibile determinare il nome completo dell'assembly.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome o percorso del file che contiene il manifesto dell'assembly.</param>
        <summary>Carica un assembly nel contesto di origine del caricamento, ignorando alcuni controlli di sicurezza.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per caricare un assembly locale che il sistema operativo ha contrassegnato come se fosse stato caricato dal Web (ad esempio, un file temporaneo che è stato scaricato da Internet o intranet). Prima di [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tali assembly sono stati caricati automaticamente in un dominio applicazione creato mediante sandbox. A partire dal [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], vengono caricati con attendibilità totale.  
  
 Come alternativa all'utilizzo di questo metodo, è possibile applicare il [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) nel file di configurazione dell'applicazione. In questo modo common language runtime ripristinare i criteri di sicurezza del [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
> [!CAUTION]
>  Se si usa una di queste soluzioni, è necessario essere certi che sia sicuro caricare `assemblyFile` con attendibilità totale.  
  
 Per una descrizione dei contesti di caricamento, incluso il contesto di origine del caricamento, vedere il <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</exception>
        <exception cref="T:System.IO.FileLoadException">Non è possibile caricare un file che non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.Security.SecurityException">È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="assemblyFile" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Il nome dell'assembly supera la lunghezza massima definita dal sistema.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>