<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Assembly.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d3d5877ccfca1ad46bc974cf9102a85adaba2a32.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3d5877ccfca1ad46bc974cf9102a85adaba2a32</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</source>
          <target state="translated">Rappresenta un assembly, ovvero un blocco predefinito di un'applicazione Common Language Runtime riutilizzabile, autodescrittivo e di cui è possibile eseguire il controllo delle versioni.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</source>
          <target state="translated">Utilizzare la <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> classe per caricare gli assembly, per esplorare i metadati e le parti costitutive dell'assembly, per individuare i tipi contenuti nell'assembly e per creare istanze di tali tipi.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>To get an array of <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per ottenere una matrice di <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> gli oggetti che rappresentano gli assembly attualmente caricati in un dominio di applicazione (ad esempio, il dominio applicazione predefinito di un progetto semplice), utilizzare il <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>To load assemblies dynamically, the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class provides the following static methods (<ph id="ph2">`Shared`</ph> methods in Visual Basic).</source>
          <target state="translated">Per caricare gli assembly in modo dinamico, il <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> classe fornisce i seguenti metodi statici (<ph id="ph2">`Shared`</ph> metodi in Visual Basic).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>Assemblies are loaded into the application domain where the load operation occurs.</source>
          <target state="translated">Gli assembly vengono caricati nel dominio applicazione in cui si verifica l'operazione di caricamento.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The recommended way to load assemblies is to use the <ph id="ph1">&lt;xref:System.AppDomain.Load%2A&gt;</ph> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</source>
          <target state="translated">Il modo consigliato per il caricamento degli assembly consiste nell'utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.Load%2A&gt;</ph> metodo, che identifica l'assembly da caricare in base al nome visualizzato (ad esempio, "Forms, Version = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089").</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The search for the assembly follows the rules described in <bpt id="p1">[</bpt>How the Runtime Locates Assemblies<ept id="p1">](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)</ept>.</source>
          <target state="translated">La ricerca per l'assembly segue le regole descritte in <bpt id="p1">[</bpt>come il Runtime individua gli assembly<ept id="p1">](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods enable you to load an assembly for reflection, but not for execution.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> metodi consentono di caricare un assembly per la reflection, ma non per l'esecuzione.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</source>
          <target state="translated">Ad esempio, un assembly destinato a una piattaforma a 64 bit può essere esaminato dal codice che è in esecuzione su una piattaforma a 32 bit.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> methods are provided for rare scenarios in which an assembly must be identified by path.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodi vengono forniti per i rari scenari in cui un assembly deve essere identificato dal percorso.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>To get an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object for the currently executing assembly, use the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> method.</source>
          <target state="translated">Per ottenere un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> oggetto per l'assembly attualmente in esecuzione, utilizzare il <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>Many members of the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class provide information about an assembly.</source>
          <target state="translated">Numero di membri della <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> classe fornisce informazioni relative a un assembly.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> method returns an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object that provides access to the parts of the assembly display name.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> metodo restituisce un <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> oggetto che fornisce accesso alle parti del nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> method lists the attributes applied to the assembly.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> metodo elenca gli attributi applicati all'assembly.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%2A&gt;</ph> method provides access to the files in the assembly manifest.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%2A&gt;</ph> metodo fornisce l'accesso ai file nel manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceNames%2A&gt;</ph> method provides the names of the resources in the assembly manifest.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceNames%2A&gt;</ph> metodo fornisce i nomi delle risorse nel manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> method lists all the types in the assembly.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> metodo elenca tutti i tipi nell'assembly.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> method lists the types that are visible to callers outside the assembly.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> metodo sono elencati i tipi che sono visibili ai chiamanti all'esterno dell'assembly.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> method can be used to search for a particular type in the assembly.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> metodo può essere utilizzato per cercare un particolare tipo nell'assembly.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%2A&gt;</ph> method can be used to search for and create instances of types in the assembly.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%2A&gt;</ph> metodo può essere utilizzato per la ricerca e creare istanze dei tipi nell'assembly.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For more information on assemblies, see the "Application Domains and Assemblies" section in the <bpt id="p1">[</bpt>Application Domains<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept> topic.</source>
          <target state="translated">Per ulteriori informazioni sugli assembly, vedere la sezione "Assembly e domini di applicazione" di <bpt id="p1">[</bpt>domini applicazione<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept> argomento.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ottenere l'assembly attualmente in esecuzione, creare un'istanza di un tipo di contenuti in tale assembly e richiamare uno dei metodi del tipo con associazione tardiva.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For this purpose, the code example defines a class named <ph id="ph1">`Example`</ph>, with a method named <ph id="ph2">`SampleMethod`</ph>.</source>
          <target state="translated">A tale scopo, l'esempio di codice definisce una classe denominata <ph id="ph1">`Example`</ph>, con un metodo denominato <ph id="ph2">`SampleMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The constructor of the class accepts an integer, which is used to compute the return value of the method.</source>
          <target state="translated">Il costruttore della classe accetta un numero intero, viene utilizzato per calcolare il valore restituito del metodo.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The code example also demonstrates the use of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> method to obtain an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object that can be used to parse the full name of the assembly.</source>
          <target state="translated">L'esempio di codice viene inoltre illustrato l'utilizzo del <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> per ottenere un <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> oggetto che può essere utilizzato per analizzare il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The example displays the version number of the assembly, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> property, and the <ph id="ph2">&lt;xref:System.Reflection.Assembly.EntryPoint%2A&gt;</ph> property.</source>
          <target state="translated">L'esempio visualizza il numero di versione dell'assembly, il <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> , proprietà e <ph id="ph2">&lt;xref:System.Reflection.Assembly.EntryPoint%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>for full trust for inheritors.</source>
          <target state="translated">per l'attendibilità totale per gli eredi.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Questa classe non può essere ereditata da codice parzialmente attendibile.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>This type is thread safe.</source>
          <target state="translated">Questo tipo è thread-safe.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.#ctor">
          <source>This constructor is invoked by derived classes during the construction of <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objects.</source>
          <target state="translated">Questo costruttore viene richiamato dalle classi derivate durante la costruzione di <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> oggetti.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.CodeBase">
          <source>Gets the location of the assembly as specified originally, for example, in an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">Ottiene il percorso dell'assembly come originariamente specificato, ad esempio in un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>The location of the assembly as specified originally.</source>
          <target state="translated">Percorso dell'assembly come originariamente specificato.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>To get the absolute path to the loaded manifest-containing file, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Per ottenere il percorso assoluto del file caricato che contiene manifesto, utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType&gt;</ph> proprietà invece.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>If the assembly was loaded as a byte array, using an overload of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</source>
          <target state="translated">Se l'assembly è stato caricato come una matrice di byte, utilizzando un overload di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo che accetta una matrice di byte, questa proprietà restituisce la posizione del chiamante del metodo, non il percorso dell'assembly caricato.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> property.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>for access to the path.</source>
          <target state="translated">Per accedere al percorso.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Locates a type from this assembly and creates an instance of it using the system activator.</source>
          <target state="translated">Individua un tipo in questo assembly e ne crea un'istanza usando l'attivatore di sistema.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> of the type to locate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> del tipo da individuare.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</source>
          <target state="translated">Individua il tipo specificato in questo assembly e ne crea un'istanza usando l'attivatore di sistema e consentendo la ricerca con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>An instance of the specified type created with the default constructor; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Istanza del tipo specificato creata con il costruttore predefinito oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The type is resolved using the default binder, without specifying culture or activation attributes, and with <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> set to <ph id="ph2">&lt;see langword="Public" /&gt;</ph> or <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</source>
          <target state="translated">Il tipo viene risolto usando il binder predefinito, senza specificare attributi delle impostazioni cultura o dell'attivazione e con <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> impostato su <ph id="ph2">&lt;see langword="Public" /&gt;</ph> o <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>If the runtime is unable to find <ph id="ph1">`typeName`</ph> in the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> instance, it returns <ph id="ph3">`null`</ph> instead of throwing an exception.</source>
          <target state="translated">Se il runtime è riuscito a trovare <ph id="ph1">`typeName`</ph> nel <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> istanza, viene restituito <ph id="ph3">`null`</ph> anziché generare un'eccezione.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>This might happen because:</source>
          <target state="translated">Questa situazione può verificarsi perché:</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>You haven't specified the fully qualified name of the type.</source>
          <target state="translated">Non sono stati specificati il nome completo del tipo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>You've specified the fully qualified type name, but its case doesn’t match the case of the type's <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">È stato specificato il nome completo del tipo, ma il relativo case non corrisponde nel caso del tipo <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>For a case-insensitive comparison of <ph id="ph1">`typeName`</ph> with the type's full name, call the <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> overload and specify <ph id="ph3">`true`</ph> for the <ph id="ph4">`ignoreCase`</ph> argument.</source>
          <target state="translated">Per un confronto senza distinzione di <ph id="ph1">`typeName`</ph> con il nome del tipo completo, chiamare il <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> overload e specificare <ph id="ph3">`true`</ph> per il <ph id="ph4">`ignoreCase`</ph> argomento.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The type doesn’t exist in the current <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> instance.</source>
          <target state="translated">Il tipo non esiste nell'oggetto <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> istanza.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The following example defines a <ph id="ph1">`Person`</ph> class and calls the <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> method to instantiate it.</source>
          <target state="translated">L'esempio seguente definisce un <ph id="ph1">`Person`</ph> classe e viene chiamato il <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> metodo un'istanza.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an empty string ("") or a string beginning with a null character.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è una stringa vuota ("") o una stringa che inizia con un carattere Null.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The current assembly was loaded into the reflection-only context.</source>
          <target state="translated">L'assembly corrente è stato caricato nel contesto di sola reflection.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>No matching constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore corrispondente.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che non è stato trovato.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L'assembly corrente è stato caricato nel contesto di sola reflection e <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che non è stato precaricato.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente, ma il file non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> of the type to locate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> del tipo da individuare.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare la distinzione tra maiuscole e minuscole nel nome del tipo; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</source>
          <target state="translated">Individua il tipo specificato in questo assembly e ne crea un'istanza usando l'attivatore di sistema e consentendo la ricerca con distinzione facoltativa tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>An instance of the specified type created with the default constructor; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Istanza del tipo specificato creata con il costruttore predefinito oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The type is resolved using the default binder, without specifying culture or activation attributes, and with <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> set to <ph id="ph2">&lt;see langword="Public" /&gt;</ph> or <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</source>
          <target state="translated">Il tipo viene risolto usando il binder predefinito, senza specificare attributi delle impostazioni cultura o dell'attivazione e con <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> impostato su <ph id="ph2">&lt;see langword="Public" /&gt;</ph> o <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>If the runtime is unable to find <ph id="ph1">`typeName`</ph> in the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> instance, it returns <ph id="ph3">`null`</ph> instead of throwing an exception.</source>
          <target state="translated">Se il runtime è riuscito a trovare <ph id="ph1">`typeName`</ph> nel <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> istanza, viene restituito <ph id="ph3">`null`</ph> anziché generare un'eccezione.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>This might happen because:</source>
          <target state="translated">Questa situazione può verificarsi perché:</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>You haven't specified the fully qualified name of the type.</source>
          <target state="translated">Non sono stati specificati il nome completo del tipo.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The type doesn’t exist in the current <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> instance.</source>
          <target state="translated">Il tipo non esiste nell'oggetto <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> istanza.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The following example defines a <ph id="ph1">`Person`</ph> class.</source>
          <target state="translated">L'esempio seguente definisce un <ph id="ph1">`Person`</ph> classe.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> method to instantiate it, but because the casing of the <ph id="ph2">`typeName`</ph> argument doesn’t match that of the type's <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph> property, the method returns <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Chiama quindi il <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> metodo per creare un'istanza, tuttavia, poiché le maiuscole e minuscole del <ph id="ph2">`typeName`</ph> argomento non corrisponde a quello del tipo <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph> proprietà, il metodo restituisce <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>When the example passes the same string to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> overload and specifies that the comparison should be case-insensitive, the <ph id="ph2">`Person`</ph> class is found, and a <ph id="ph3">`Person`</ph> object is successfully instantiated.</source>
          <target state="translated">Quando l'esempio passa la stessa stringa per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> overload e specifica che il confronto deve essere tra maiuscole e minuscole, il <ph id="ph2">`Person`</ph> classe viene trovata e un <ph id="ph3">`Person`</ph> oggetto viene creata un'istanza.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an empty string ("") or a string beginning with a null character.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è una stringa vuota ("") o una stringa che inizia con un carattere Null.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context.</source>
          <target state="translated">L'assembly corrente è stato caricato nel contesto di sola reflection.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>No matching constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore corrispondente.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che non è stato trovato.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L'assembly corrente è stato caricato nel contesto di sola reflection e <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che non è stato precaricato.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente, ma il file non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> of the type to locate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> del tipo da individuare.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare la distinzione tra maiuscole e minuscole nel nome del tipo; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">Maschera di bit che influenza le modalità di esecuzione della ricerca.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The value is a combination of bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Il valore è una combinazione di flag di bit dell'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Oggetto che consente il binding, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> tramite reflection.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array that contains the arguments to be passed to the constructor.</source>
          <target state="translated">Matrice contenente gli argomenti da passare al costruttore.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</source>
          <target state="translated">La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is desired, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Per usare il costruttore predefinito, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> deve essere una matrice vuota o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Istanza di <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> usata per regolare la coercizione dei tipi.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>(This is necessary to convert a <ph id="ph1">&lt;see langword="String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see langword="Double" /&gt;</ph> value, for example, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">Si tratta di un parametro necessario per convertire un oggetto <ph id="ph1">&lt;see langword="String" /&gt;</ph> che rappresenta, ad esempio, il numero 1000 in un valore <ph id="ph2">&lt;see langword="Double" /&gt;</ph>, dal momento che questo numero è rappresentato in modo diverso nelle varie impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</source>
          <target state="translated">Individua il tipo specificato in questo assembly e ne crea un'istanza usando l'attivatore di sistema, consentendo la ricerca con distinzione facoltativa tra maiuscole e minuscole e usando le impostazioni cultura, gli argomenti e gli attributi di attivazione e di binding specificati.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An instance of the specified type, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Istanza del tipo specificato o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</source>
          <target state="translated">Gli argomenti forniti vengono usati per risolvere il tipo e per associare il costruttore usato per creare l'istanza.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an empty string ("") or a string beginning with a null character.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è una stringa vuota ("") o una stringa che inizia con un carattere Null.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The current assembly was loaded into the reflection-only context.</source>
          <target state="translated">L'assembly corrente è stato caricato nel contesto di sola reflection.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore corrispondente.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A non-empty activation attributes array is passed to a type that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Una matrice di attributi di attivazione non vuota viene passata a un tipo che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che non è stato trovato.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L'assembly corrente è stato caricato nel contesto di sola reflection e <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che non è stato precaricato.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente, ma il file non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>to create an instance of a delegate.</source>
          <target state="translated">Per creare un'istanza di un delegato.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The display name of an assembly.</source>
          <target state="translated">Nome visualizzato di un assembly.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The full name of a type.</source>
          <target state="translated">Nome completo di un tipo.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>Creates the name of a type qualified by the display name of its assembly.</source>
          <target state="translated">Crea il nome di un tipo qualificato dal nome visualizzato del relativo assembly.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The full name of the type qualified by the display name of the assembly.</source>
          <target state="translated">Nome completo del tipo qualificato dal nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The format of the returned string is:</source>
          <target state="translated">Il formato della stringa restituita è:</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source><ph id="ph1">\&lt;</ph>FullTypeName&gt;, <ph id="ph2">\&lt;</ph>AssemblyDisplayName&gt;</source>
          <target state="translated"><ph id="ph1">\&lt;</ph>FullTypeName&gt;, <ph id="ph2">\&lt;</ph>AssemblyDisplayName&gt;</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per una descrizione del formato del nome visualizzato di un assembly.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</source>
          <target state="translated">Per le modifiche nelle versioni di common language runtime, utilizzare questo metodo anziché costruire il nome completo manualmente.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>For information about qualified assembly names, see <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per informazioni sui nomi di assembly completo, vedere <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.CustomAttributes">
          <source>Gets a collection that contains this assembly's custom attributes.</source>
          <target state="translated">Ottiene una raccolta che contiene gli attributi personalizzati di questo assembly.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CustomAttributes">
          <source>A collection that contains this assembly's custom attributes.</source>
          <target state="translated">Raccolta che contiene gli attributi personalizzati di questo assembly.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>Gets a collection of the types defined in this assembly.</source>
          <target state="translated">Ottiene una raccolta dei tipi definiti in questo assembly.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>A collection of the types defined in this assembly.</source>
          <target state="translated">Raccolta dei tipi definiti in questo assembly.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> property is comparable to the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> method, except that the <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> property returns a collection of <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objects, and the <ph id="ph5">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> method returns an array of <ph id="ph6">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> proprietà è confrontabile con il <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> (metodo), con la differenza che il <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> proprietà restituisce una raccolta di <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> oggetti e il <ph id="ph5">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> metodo restituisce una matrice di <ph id="ph6">&lt;xref:System.Type&gt;</ph> oggetti.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>The returned array includes nested types.</source>
          <target state="translated">La matrice restituita include i tipi annidati.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.EntryPoint">
          <source>Gets the entry point of this assembly.</source>
          <target state="translated">Ottiene il punto di ingresso di questo assembly.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EntryPoint">
          <source>An object that represents the entry point of this assembly.</source>
          <target state="translated">Oggetto che rappresenta il punto di ingresso di questo assembly.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EntryPoint">
          <source>If no entry point is found (for example, the assembly is a DLL), <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Se non viene trovato alcun punto di ingresso, ad esempio se l'assembly è un file DLL, viene restituito <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source>The object to compare with this instance.</source>
          <target state="translated">Oggetto da confrontare con questa istanza.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source>Determines whether this assembly and the specified object are equal.</source>
          <target state="translated">Determina se questo assembly e l'oggetto specificato sono uguali.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is equal to this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="o" /&gt;</ph> è uguale all'istanza. In caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.Equals%2A&gt;</ph> method performs a test for reference equality to determine whether the current instance and <ph id="ph2">`o`</ph> are equal.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Equals%2A&gt;</ph> metodo esegue un test di uguaglianza di riferimenti determinare se l'istanza corrente e <ph id="ph2">`o`</ph> sono uguali.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>Gets the URI, including escape characters, that represents the codebase.</source>
          <target state="translated">Ottiene l'URI, inclusi i caratteri di escape, che rappresenta la codebase.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>A URI with escape characters.</source>
          <target state="translated">URI con caratteri di escape.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>for access to the path.</source>
          <target state="translated">Per accedere al percorso.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Evidence">
          <source>Gets the evidence for this assembly.</source>
          <target state="translated">Ottiene l'evidenza per questo assembly.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>The evidence for this assembly.</source>
          <target state="translated">Evidenza per questo assembly.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</source>
          <target state="translated">Un'evidenza è l'insieme di informazioni su cui vengono basate le decisioni inerenti i criteri di sicurezza, ad esempio le autorizzazioni che è possibile assegnare al codice.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ExportedTypes">
          <source>Gets a collection of the public types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">Ottiene una raccolta dei tipi pubblici definiti in questo assembly visibili all'esterno dell'assembly.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ExportedTypes">
          <source>A collection of the public types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">Raccolta dei tipi pubblici definiti in questo assembly visibili all'esterno dell'assembly.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.FullName">
          <source>Gets the display name of the assembly.</source>
          <target state="translated">Ottiene il nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per una descrizione del formato del nome visualizzato di un assembly.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>Writing your own code to parse display names is not recommended.</source>
          <target state="translated">Non è consigliabile scrivere il proprio codice per analizzare i nomi visualizzati.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>Instead, pass the display name to the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.%23ctor%2A&gt;</ph> constructor, which parses it and populates the appropriate fields of the new <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>.</source>
          <target state="translated">Al contrario, passare il nome visualizzato per il <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.%23ctor%2A&gt;</ph> costruttore, che analizza e compila i campi appropriati del nuovo <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Tuttavia, non è incluso nella stringa restituita dal <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> proprietà, per motivi di compatibilità.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type (<ph id="ph2">`int`</ph> in C#, <ph id="ph3">`Integer`</ph> in Visual Basic).</source>
          <target state="translated">L'esempio seguente recupera il nome visualizzato dell'assembly attualmente in esecuzione e il nome visualizzato dell'assembly che contiene il <ph id="ph1">&lt;xref:System.Int32&gt;</ph> tipo (<ph id="ph2">`int`</ph> in c#, <ph id="ph3">`Integer`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>An object representing a type in the assembly that will be returned.</source>
          <target state="translated">Oggetto che rappresenta un tipo nell'assembly che verrà restituito.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>Gets the currently loaded assembly in which the specified type is defined.</source>
          <target state="translated">Ottiene l'assembly attualmente caricato in cui è definito il tipo specificato.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>The assembly in which the specified type is defined.</source>
          <target state="translated">Assembly in cui è definito il tipo specificato.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>Calling this method is equivalent to retrieving the value of the  <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Chiamare questo metodo equivale a recuperare il valore della <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> property typically offers superior performance.</source>
          <target state="translated">Tuttavia, il <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> proprietà offre in genere prestazioni migliori.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>In order to call this method, you must have a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object, which means that the assembly in which the class is defined must already be loaded.</source>
          <target state="translated">Per chiamare questo metodo, è necessario un <ph id="ph1">&lt;xref:System.Type&gt;</ph> oggetto, che indica che l'assembly in cui è definita la classe deve essere già caricato.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>The following example retrieves the assembly that contains the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type and displays its name and file location.</source>
          <target state="translated">L'esempio seguente recupera l'assembly che contiene il <ph id="ph1">&lt;xref:System.Int32&gt;</ph> digitare e visualizza il nome e il percorso file.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> of the method that invoked the currently executing method.</source>
          <target state="translated">Restituisce l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> del metodo che ha richiamato il metodo attualmente in esecuzione.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>The <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> object of the method that invoked the currently executing method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> del metodo che ha richiamato il metodo attualmente in esecuzione.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>If the method that calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> may differ unexpectedly.</source>
          <target state="translated">Se il metodo che chiama il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> metodo espansione inline dal compilatore just-in-time (JIT), o se il chiamante è espanso inline, l'assembly restituito da <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> possono variare in modo imprevisto.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>For example, consider the following methods and assemblies:</source>
          <target state="translated">Si consideri, ad esempio, i metodi e gli assembly seguenti:</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Method <ph id="ph1">`M1`</ph> in assembly <ph id="ph2">`A1`</ph> calls <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</source>
          <target state="translated">Metodo <ph id="ph1">`M1`</ph> nell'assembly <ph id="ph2">`A1`</ph> chiamate <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Method <ph id="ph1">`M2`</ph> in assembly <ph id="ph2">`A2`</ph> calls <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">Metodo <ph id="ph1">`M2`</ph> nell'assembly <ph id="ph2">`A2`</ph> chiamate <ph id="ph3">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Method <ph id="ph1">`M3`</ph> in assembly <ph id="ph2">`A3`</ph> calls <ph id="ph3">`M2`</ph>.</source>
          <target state="translated">Metodo <ph id="ph1">`M3`</ph> nell'assembly <ph id="ph2">`A3`</ph> chiamate <ph id="ph3">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>When <ph id="ph1">`M1`</ph> is not inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A2`</ph>.</source>
          <target state="translated">Quando <ph id="ph1">`M1`</ph> non inline, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> restituisce <ph id="ph3">`A2`</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>When <ph id="ph1">`M1`</ph> is inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A3`</ph>.</source>
          <target state="translated">Quando <ph id="ph1">`M1`</ph> inline, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> restituisce <ph id="ph3">`A3`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Similarly, when <ph id="ph1">`M2`</ph> is not inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A2`</ph>.</source>
          <target state="translated">Analogamente, quando <ph id="ph1">`M2`</ph> non inline, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> restituisce <ph id="ph3">`A2`</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>When <ph id="ph1">`M2`</ph> is inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A3`</ph>.</source>
          <target state="translated">Quando <ph id="ph1">`M2`</ph> inline, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> restituisce <ph id="ph3">`A3`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>This effect also occurs when <ph id="ph1">`M1`</ph> executes as a tail call from <ph id="ph2">`M2`</ph>, or when <ph id="ph3">`M2`</ph> executes as a tail call from <ph id="ph4">`M3`</ph>.</source>
          <target state="translated">Questo effetto si verifica anche quando <ph id="ph1">`M1`</ph> viene eseguito come una chiamata tail da <ph id="ph2">`M2`</ph>, o quando <ph id="ph3">`M2`</ph> viene eseguito come una chiamata tail da <ph id="ph4">`M3`</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>You can prevent the JIT compiler from inlining the method that calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>, by applying the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph> attribute with the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType&gt;</ph> flag, but there is no similar mechanism for preventing tail calls.</source>
          <target state="translated">È possibile impedire al compilatore JIT inline che chiama il metodo di <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>, applicando il <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph> attributo con il <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType&gt;</ph> flag, ma non è disponibile alcun meccanismo simile per impedire le chiamate tail.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>The following example gets the calling assembly of the current method.</source>
          <target state="translated">Nell'esempio seguente ottiene l'assembly chiamante del metodo corrente.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the custom attributes for this assembly.</source>
          <target state="translated">Ottiene gli attributi personalizzati per questo assembly.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of type <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Questo argomento viene ignorato per gli oggetti di tipo <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Gets all the custom attributes for this assembly.</source>
          <target state="translated">Ottiene tutti gli attributi personalizzati per questo assembly.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>An array that contains the custom attributes for this assembly.</source>
          <target state="translated">Matrice contenente gli attributi personalizzati per questo assembly.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>This method implements the corresponding <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> interface method.</source>
          <target state="translated">Questo metodo implementa corrispondente <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> metodo di interfaccia.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Therefore, the <ph id="ph1">`inherit`</ph> parameter must be specified even though it is ignored.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`inherit`</ph> parametro deve essere specificato anche se viene ignorata.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</source>
          <target state="translated">Un pseudo-attributo indica i bit di metadati di base che deve essere impostata quando l'attributo è presenta.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</source>
          <target state="translated">A differenza di un attributo personalizzato che estende i metadati per un tipo e viene salvato insieme al tipo, uno pseudo-attributo modifica i metadati per il tipo e quindi viene eliminato.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Some of the resulting bits cannot be accessed using existing reflection APIs.</source>
          <target state="translated">Alcuni dei bit risultante non sono accessibili tramite l'API di reflection esistenti.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</source>
          <target state="translated">Nella tabella seguente sono riepilogati i diversi pseudo- attributi e le funzioni di accesso per i bit sono disponibili nella reflection.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Pseudo-Attribute</source>
          <target state="translated">Pseudo-Attribute</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Metadata Bits</source>
          <target state="translated">Bit di metadati</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Reflection Accessor</source>
          <target state="translated">Funzione di accesso di Reflection</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>DllImportAttribute</source>
          <target state="translated">DllImportAttribute</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorPInvokeMap</source>
          <target state="translated">CorPInvokeMap</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>DLL name</source>
          <target state="translated">Nome della DLL</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor for PInvokeMap for ordinary method/global method attributes.</source>
          <target state="translated">Nessuna funzione di accesso per PInvokeMap per gli attributi del metodo normale metodo globale.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor for DLL name.</source>
          <target state="translated">Nessuna funzione di accesso per il nome DLL.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>GuidAttribute</source>
          <target state="translated">GuidAttribute</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Stored as a real custom attribute.</source>
          <target state="translated">Archiviato come un attributo personalizzato reale.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Accessed as a real custom attribute.</source>
          <target state="translated">Accedere come un attributo personalizzato reale.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ComImportAttribute</source>
          <target state="translated">ComImportAttribute</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdImport</source>
          <target state="translated">CorTypeAttr.tdImport</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.Import</source>
          <target state="translated">Type.Attributes.Import</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>SerializableAttribute</source>
          <target state="translated">SerializableAttribute</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdSerializable</source>
          <target state="translated">CorTypeAttr.tdSerializable</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.Serializable</source>
          <target state="translated">Type.Attributes.Serializable</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>NonSerializedAttribute</source>
          <target state="translated">NonSerializedAttribute</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorFieldAttr.fdNotSerialized</source>
          <target state="translated">CorFieldAttr.fdNotSerialized</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>FieldInfo.Attributes.NotSerialized</source>
          <target state="translated">FieldInfo.Attributes.NotSerialized</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MethodImplAttribute</source>
          <target state="translated">MethodImplAttribute</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorMethodImpl</source>
          <target state="translated">CorMethodImpl</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags()</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags()</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MarshalAsAttribute</source>
          <target state="translated">MarshalAsAttribute</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Various bits.</source>
          <target state="translated">Vari bit.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Nessuna funzione di accesso.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>PreserveSigAttribute</source>
          <target state="translated">PreserveSigAttribute</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorMethodImpl.miOLE</source>
          <target state="translated">CorMethodImpl.miOLE</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>InAttribute</source>
          <target state="translated">InAttribute</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorParamAttr.pdIn</source>
          <target state="translated">CorParamAttr.pdIn</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ParameterInfo.Attributes.In</source>
          <target state="translated">ParameterInfo.Attributes.In</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>OutAttribute</source>
          <target state="translated">OutAttribute</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorParamAttr.pdOut</source>
          <target state="translated">CorParamAttr.pdOut</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ParameterInfo.Attributes.Out</source>
          <target state="translated">ParameterInfo.Attributes.Out</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>StructLayoutAttribute</source>
          <target state="translated">StructLayoutAttribute</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdLayoutSequential</source>
          <target state="translated">CorTypeAttr.tdLayoutSequential</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdExplicitLayout</source>
          <target state="translated">CorTypeAttr.tdExplicitLayout</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdAnsiClass</source>
          <target state="translated">CorTypeAttr.tdAnsiClass</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdUnicodeClass</source>
          <target state="translated">CorTypeAttr.tdUnicodeClass</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdAutoClass</source>
          <target state="translated">CorTypeAttr.tdAutoClass</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Class packing.</source>
          <target state="translated">Compressione di classe.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.LayoutSequential</source>
          <target state="translated">Type.Attributes.LayoutSequential</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.ExplicitLayout</source>
          <target state="translated">Type.Attributes.ExplicitLayout</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.AnsiClass</source>
          <target state="translated">Type.Attributes.AnsiClass</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.UnicodeClass</source>
          <target state="translated">Type.Attributes.UnicodeClass</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.AutoClass</source>
          <target state="translated">Type.Attributes.AutoClass</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Nessuna funzione di accesso.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>FieldOffsetAttribute</source>
          <target state="translated">FieldOffsetAttribute</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Field offset.</source>
          <target state="translated">Offset di campo.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Nessuna funzione di accesso.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>AssemblyLoadAttribute</source>
          <target state="translated">AssemblyLoadAttribute</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorAssemblyFlags</source>
          <target state="translated">CorAssemblyFlags</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor or enumerator.</source>
          <target state="translated">Nessuna funzione di accesso o enumeratore.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type for which the custom attributes are to be returned.</source>
          <target state="translated">Tipo per cui restituire gli attributi personalizzati.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of type <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Questo argomento viene ignorato per gli oggetti di tipo <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Gets the custom attributes for this assembly as specified by type.</source>
          <target state="translated">Ottiene gli attributi personalizzati per questo assembly, come specificato dal tipo.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array that contains the custom attributes for this assembly as specified by <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated">Matrice contenente gli attributi personalizzati per questo assembly, come specificato da <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method implements the corresponding <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> interface method.</source>
          <target state="translated">Questo metodo implementa corrispondente <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> metodo di interfaccia.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Therefore, the <ph id="ph1">`inherit`</ph> parameter must be specified even though it is ignored.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`inherit`</ph> parametro deve essere specificato anche se viene ignorata.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</source>
          <target state="translated">Un pseudo-attributo indica i bit di metadati di base che deve essere impostata quando l'attributo è presenta.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</source>
          <target state="translated">A differenza di un attributo personalizzato che estende i metadati per un tipo e viene salvato insieme al tipo, uno pseudo-attributo modifica i metadati per il tipo e quindi viene eliminato.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Some of the resulting bits cannot be accessed using existing reflection APIs.</source>
          <target state="translated">Alcuni dei bit risultante non sono accessibili tramite l'API di reflection esistenti.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</source>
          <target state="translated">Nella tabella seguente sono riepilogati i diversi pseudo- attributi e le funzioni di accesso per i bit sono disponibili nella reflection.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Pseudo-Attribute</source>
          <target state="translated">Pseudo-Attribute</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Metadata Bits</source>
          <target state="translated">Bit di metadati</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Reflection Accessor</source>
          <target state="translated">Funzione di accesso di Reflection</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>DllImportAttribute</source>
          <target state="translated">DllImportAttribute</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorPInvokeMap</source>
          <target state="translated">CorPInvokeMap</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>DLL name</source>
          <target state="translated">Nome della DLL</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor for PInvokeMap for ordinary method/global method attributes.</source>
          <target state="translated">Nessuna funzione di accesso per PInvokeMap per gli attributi del metodo normale metodo globale.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor for DLL name.</source>
          <target state="translated">Nessuna funzione di accesso per il nome DLL.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>GuidAttribute</source>
          <target state="translated">GuidAttribute</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Stored as a real custom attribute.</source>
          <target state="translated">Archiviato come un attributo personalizzato reale.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Accessed as a real custom attribute.</source>
          <target state="translated">Accedere come un attributo personalizzato reale.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ComImportAttribute</source>
          <target state="translated">ComImportAttribute</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdImport</source>
          <target state="translated">CorTypeAttr.tdImport</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.Import</source>
          <target state="translated">Type.Attributes.Import</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>SerializableAttribute</source>
          <target state="translated">SerializableAttribute</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdSerializable</source>
          <target state="translated">CorTypeAttr.tdSerializable</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.Serializable</source>
          <target state="translated">Type.Attributes.Serializable</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>NonSerializedAttribute</source>
          <target state="translated">NonSerializedAttribute</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorFieldAttr.fdNotSerialized</source>
          <target state="translated">CorFieldAttr.fdNotSerialized</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>FieldInfo.Attributes.NotSerialized</source>
          <target state="translated">FieldInfo.Attributes.NotSerialized</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MethodImplAttribute</source>
          <target state="translated">MethodImplAttribute</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorMethodImpl</source>
          <target state="translated">CorMethodImpl</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags()</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags()</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MarshalAsAttribute</source>
          <target state="translated">MarshalAsAttribute</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Various bits.</source>
          <target state="translated">Vari bit.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Nessuna funzione di accesso.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>PreserveSigAttribute</source>
          <target state="translated">PreserveSigAttribute</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorMethodImpl.miOLE</source>
          <target state="translated">CorMethodImpl.miOLE</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>InAttribute</source>
          <target state="translated">InAttribute</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorParamAttr.pdIn</source>
          <target state="translated">CorParamAttr.pdIn</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ParameterInfo.Attributes.In</source>
          <target state="translated">ParameterInfo.Attributes.In</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>OutAttribute</source>
          <target state="translated">OutAttribute</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorParamAttr.pdOut</source>
          <target state="translated">CorParamAttr.pdOut</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ParameterInfo.Attributes.Out</source>
          <target state="translated">ParameterInfo.Attributes.Out</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>StructLayoutAttribute</source>
          <target state="translated">StructLayoutAttribute</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdLayoutSequential</source>
          <target state="translated">CorTypeAttr.tdLayoutSequential</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdExplicitLayout</source>
          <target state="translated">CorTypeAttr.tdExplicitLayout</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdAnsiClass</source>
          <target state="translated">CorTypeAttr.tdAnsiClass</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdUnicodeClass</source>
          <target state="translated">CorTypeAttr.tdUnicodeClass</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdAutoClass</source>
          <target state="translated">CorTypeAttr.tdAutoClass</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Class packing.</source>
          <target state="translated">Compressione di classe.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.LayoutSequential</source>
          <target state="translated">Type.Attributes.LayoutSequential</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.ExplicitLayout</source>
          <target state="translated">Type.Attributes.ExplicitLayout</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.AnsiClass</source>
          <target state="translated">Type.Attributes.AnsiClass</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.UnicodeClass</source>
          <target state="translated">Type.Attributes.UnicodeClass</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.AutoClass</source>
          <target state="translated">Type.Attributes.AutoClass</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Nessuna funzione di accesso.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>FieldOffsetAttribute</source>
          <target state="translated">FieldOffsetAttribute</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Field offset.</source>
          <target state="translated">Offset di campo.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">Nessuna funzione di accesso.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>AssemblyLoadAttribute</source>
          <target state="translated">AssemblyLoadAttribute</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorAssemblyFlags</source>
          <target state="translated">CorAssemblyFlags</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor or enumerator.</source>
          <target state="translated">Nessuna funzione di accesso o enumeratore.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a runtime type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> non è un tipo da runtime.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Returns information about the attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, expressed as <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects.</source>
          <target state="translated">Restituisce informazioni sugli attributi applicati all'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> corrente, espresse sotto forma di oggetti <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current assembly.</source>
          <target state="translated">Elenco generico di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> che rappresentano i dati relativi agli attributi applicati all'assembly corrente.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Utilizzare questo metodo per esaminare gli attributi personalizzati del codice nel contesto ReflectionOnly, in casi in cui gli attributi personalizzati sono definiti nel codice caricato nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Methods like <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Metodi come <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> non può essere utilizzato in questi casi, perché creano istanze degli attributi.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">Impossibile eseguire il codice nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>For more information and for example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Per ulteriori informazioni e ad esempio di codice, vedere la <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>Gets the process executable in the default application domain.</source>
          <target state="translated">Ottiene l'eseguibile del processo nel dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>In other application domains, this is the first executable that was executed by <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</source>
          <target state="translated">In altri domini applicazione, si tratta del primo eseguibile eseguito da <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>The assembly that is the process executable in the default application domain, or the first executable that was executed by <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</source>
          <target state="translated">Assembly che rappresenta l'eseguibile del processo nel dominio applicazione predefinito oppure il primo eseguibile eseguito da <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>Can return <ph id="ph1">&lt;see langword="null" /&gt;</ph> when called from unmanaged code.</source>
          <target state="translated">Può restituire <ph id="ph1">&lt;see langword="null" /&gt;</ph> se chiamato da codice non gestito.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> method can return <ph id="ph2">`null`</ph> when a managed assembly has been loaded from an unmanaged application.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> metodo può restituire <ph id="ph2">`null`</ph> quando un assembly gestito è stato caricato da un'applicazione non gestita.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</source>
          <target state="translated">Ad esempio, se un'applicazione non gestita crea un'istanza di un componente COM, scritto in c#, una chiamata al <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> metodo dal componente c# restituisce null, perché il punto di ingresso per il processo è il codice non gestito, piuttosto che un assembly gestito.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>Gets the assembly that contains the code that is currently executing.</source>
          <target state="translated">Ottiene l'assembly che contiene il codice attualmente in esecuzione.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>The assembly that contains the code that is currently executing.</source>
          <target state="translated">Assembly che contiene il codice attualmente in esecuzione.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</source>
          <target state="translated">Per motivi di prestazioni, è necessario chiamare questo metodo solo quando non si conosce in fase di progettazione quali assembly attualmente in esecuzione.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>The recommended way to retrieve an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents the current assembly is to use the <ph id="ph2">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property of a type found in the assembly, as the following example illustrates.</source>
          <target state="translated">Il metodo consigliato per recuperare un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> oggetto che rappresenta l'assembly corrente consiste nell'utilizzare il <ph id="ph2">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> trovare la proprietà di un tipo nell'assembly, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>To get the assembly that contains the method that called the currently executing code, use <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</source>
          <target state="translated">Per ottenere l'assembly che contiene il metodo che ha chiamato il codice attualmente in esecuzione, utilizzare <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property to get the currently executing assembly based on a type contained in that assembly.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> basata su proprietà per ottenere l'assembly attualmente in esecuzione su un tipo di contenuti in tale assembly.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>It also calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> method to show that it returns an <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents the same assembly.</source>
          <target state="translated">Chiama anche il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> metodo per mostrare che restituisce un <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> oggetto che rappresenta lo stesso assembly.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>Gets the public types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">Ottiene i tipi pubblici definiti nell'assembly visibili all'esterno dell'assembly.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>An array that represents the types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">Matrice che rappresenta i tipi definiti nell'assembly visibili all'esterno dell'assembly.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>The only types visible outside an assembly are public types and public types nested within other public types.</source>
          <target state="translated">Gli unici tipi visibili all'esterno di un assembly sono tipi pubblici e i tipi pubblici annidati all'interno di altri tipi pubblici.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>The following code sample defines a number of classes with various access levels, and calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> to display the ones that are visible from outside the assembly.</source>
          <target state="translated">Esempio di codice seguente definisce una serie di classi con vari livelli di accesso e chiamate <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> per visualizzare quelli visibili all'esterno dell'assembly.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>The assembly is a dynamic assembly.</source>
          <target state="translated">L'assembly è un assembly dinamico.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>Unable to load a dependent assembly.</source>
          <target state="translated">Non è possibile caricare un assembly dipendente.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The name of the specified file.</source>
          <target state="translated">Nome del file specificato.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>Do not include the path to the file.</source>
          <target state="translated">Non includere il percorso del file.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> for the specified file in the file table of the manifest of this assembly.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> per il file specificato nella tabella file del manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>A stream that contains the specified file, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the file is not found.</source>
          <target state="translated">Flusso che contiene il file specificato o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se il file non viene trovato.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>This method works on both public and private resource files.</source>
          <target state="translated">Questo metodo funziona in entrambi i file di risorse pubbliche e private.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The <ph id="ph1">`name`</ph> should not include the path to the file.</source>
          <target state="translated">Il <ph id="ph1">`name`</ph> non deve includere il percorso del file.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>for access to the path and for reading the specified file.</source>
          <target state="translated">Per accedere al percorso e la lettura del file specificato.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph> e <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the files in the file table of an assembly manifest.</source>
          <target state="translated">Ottiene i file della tabella file di un manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>Gets the files in the file table of an assembly manifest.</source>
          <target state="translated">Ottiene i file della tabella file di un manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>An array of streams that contain the files.</source>
          <target state="translated">Matrice di flussi che contengono i file.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFiles">
          <source>This method works on public and private resource files.</source>
          <target state="translated">Questo metodo funziona in file di risorse pubbliche e private.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFiles">
          <source>This overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29&gt;</ph> overload and specifying <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Questo overload equivale alla chiamata di <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29&gt;</ph> overload e specificare <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>A file was not found.</source>
          <target state="translated">File non trovato.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>A file was not a valid assembly.</source>
          <target state="translated">Un file non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per includere i moduli delle risorse; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</source>
          <target state="translated">Ottiene i file della tabella file di un manifesto dell'assembly, specificando se includere i moduli delle risorse.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>An array of streams that contain the files.</source>
          <target state="translated">Matrice di flussi che contengono i file.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>This method works on public and private resource files.</source>
          <target state="translated">Questo metodo funziona in file di risorse pubbliche e private.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>A file was not found.</source>
          <target state="translated">File non trovato.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>A file was not a valid assembly.</source>
          <target state="translated">Un file non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Restituisce il codice hash per l'istanza.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Codice hash di un intero con segno a 32 bit.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets all the loaded modules that are part of this assembly.</source>
          <target state="translated">Ottiene tutti i moduli caricati che fanno parte di questo assembly.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules">
          <source>Gets all the loaded modules that are part of this assembly.</source>
          <target state="translated">Ottiene tutti i moduli caricati che fanno parte di questo assembly.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules">
          <source>An array of modules.</source>
          <target state="translated">Matrice di moduli.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per includere i moduli delle risorse; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)">
          <source>Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</source>
          <target state="translated">Ottiene tutti i moduli caricati che fanno parte di questo assembly, specificando se includere i moduli delle risorse.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)">
          <source>An array of modules.</source>
          <target state="translated">Matrice di moduli.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>The case-sensitive name of the resource.</source>
          <target state="translated">Nome della risorsa con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>Returns information about how the given resource has been persisted.</source>
          <target state="translated">Restituisce informazioni sul modo in cui la risorsa specificata è stata resa persistente.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>An object that is populated with information about the resource's topology, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the resource is not found.</source>
          <target state="translated">Oggetto popolato con informazioni relative alla topologia della risorsa oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se la risorsa non viene trovata.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>Returns the names of all the resources in this assembly.</source>
          <target state="translated">Restituisce i nomi di tutte le risorse di questo assembly.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>An array that contains the names of all the resources.</source>
          <target state="translated">Matrice che contiene i nomi di tutte le risorse.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can use each resource name in the array returned by this method as follows:</source>
          <target state="translated">È possibile utilizzare ogni nome di risorsa nella matrice restituita da questo metodo, come indicato di seguito:</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can pass the resource name to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceInfo%2A&gt;</ph> method to get additional information about the resource.</source>
          <target state="translated">È possibile passare il nome della risorsa per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceInfo%2A&gt;</ph> metodo per ottenere ulteriori informazioni sulla risorsa.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <ph id="ph1">&lt;xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate the resource manager.</source>
          <target state="translated">Se il nome identifica un file con estensione resources binari, è possibile rimuovere l'estensione del file. Resources e passarlo al <ph id="ph1">&lt;xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType&gt;</ph> costruttore per creare un'istanza di gestione risorse.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can pass the resource name to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object that you can then pass to the <ph id="ph3">&lt;xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">È possibile passare il nome della risorsa per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> metodo per recuperare un <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> oggetto che è quindi possibile passare il <ph id="ph3">&lt;xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can pass the resource name to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object that you can then pass to the <ph id="ph3">&lt;xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">È possibile passare il nome della risorsa per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> metodo per recuperare un <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> oggetto che è quindi possibile passare il <ph id="ph3">&lt;xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> costruttore.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads the specified manifest resource from this assembly.</source>
          <target state="translated">Carica la risorsa del manifesto specificata da questo assembly.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The case-sensitive name of the manifest resource being requested.</source>
          <target state="translated">Nome della risorsa del manifesto richiesta con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Loads the specified manifest resource from this assembly.</source>
          <target state="translated">Carica la risorsa del manifesto specificata da questo assembly.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The manifest resource; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no resources were specified during compilation or if the resource is not visible to the caller.</source>
          <target state="translated">Risorsa di manifesto oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se non vengono specificate risorse durante la compilazione o se la risorsa non è visibile al chiamante.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</source>
          <target state="translated">Una risorsa di manifesto è una risorsa incorporata nell'assembly in fase di compilazione (ad esempio un file di immagine).</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>For more information about manifest resources, see <bpt id="p1">[</bpt>Microsoft .NET Framework Resource Basics<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> in the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni sulle risorse di manifesto, vedere <bpt id="p1">[</bpt>concetti fondamentali sulle risorse di Microsoft .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> in MSDN Library.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>This method returns <ph id="ph1">`null`</ph> if a private resource in another assembly is accessed and the caller does not have <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Questo metodo restituisce <ph id="ph1">`null`</ph> se si accede a una risorsa privata in un altro assembly e il chiamante non dispone <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>If the assembly manifest lists a resource file, <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object even if the resource file cannot be found on disk at the time.</source>
          <target state="translated">Se il manifesto dell'assembly include un file di risorse, <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> restituisce un <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> anche se il file di risorse non è disponibile su disco al momento dell'oggetto.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>If the resource file is not found, passing the resulting <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> constructor causes an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se non viene trovato il file di risorse, passando il valore risultante <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> dell'oggetto per il <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> cause costruttore un <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">In <bpt id="p1">[</bpt>.NET per app di Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o nella <bpt id="p2">[</bpt>libreria di classi portabile<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> rilevare invece l'eccezione della classe di base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Resource length is greater than <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La lunghezza della risorsa è maggiore di <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The type whose namespace is used to scope the manifest resource name.</source>
          <target state="translated">Tipo il cui spazio dei nomi viene usato per definire l'ambito del nome della risorsa del manifesto.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The case-sensitive name of the manifest resource being requested.</source>
          <target state="translated">Nome della risorsa del manifesto richiesta con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</source>
          <target state="translated">Carica la risorsa del manifesto specificata, definita per l'ambito dallo spazio dei nomi del tipo specificato, da questo assembly.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The manifest resource; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no resources were specified during compilation or if the resource is not visible to the caller.</source>
          <target state="translated">Risorsa di manifesto oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se non vengono specificate risorse durante la compilazione o se la risorsa non è visibile al chiamante.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>For example, if the full name specified for <ph id="ph1">`type`</ph> is "MyNameSpace.MyClasses" and <ph id="ph2">`name`</ph> is "Net", this method overload searches for a resource named "MyNameSpace.Net".</source>
          <target state="translated">Ad esempio, se il nome completo specificato per <ph id="ph1">`type`</ph> è "MyNameSpace. MyClasses" e <ph id="ph2">`name`</ph> è "Net", questo metodo di overload Cerca una risorsa denominata "MyNameSpace.Net".</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</source>
          <target state="translated">Una risorsa di manifesto è una risorsa incorporata nell'assembly in fase di compilazione (ad esempio un file di immagine).</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>For more information about manifest resources, see <bpt id="p1">[</bpt>Microsoft .NET Framework Resource Basics<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> in the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni sulle risorse di manifesto, vedere <bpt id="p1">[</bpt>concetti fondamentali sulle risorse di Microsoft .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> in MSDN Library.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Informazioni sulle risorse viene restituite solo se la risorsa è visibile al chiamante oppure il chiamante ha <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>This method returns <ph id="ph1">`null`</ph> if a private resource in another assembly is accessed and the caller does not have <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Questo metodo restituisce <ph id="ph1">`null`</ph> se si accede a una risorsa privata in un altro assembly e il chiamante non dispone <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>If the assembly manifest lists a resource file, <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object even if the resource file cannot be found on disk at the time.</source>
          <target state="translated">Se il manifesto dell'assembly include un file di risorse, <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> restituisce un <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> anche se il file di risorse non è disponibile su disco al momento dell'oggetto.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>If the resource file is not found, passing the resulting <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> constructor causes an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se non viene trovato il file di risorse, passando il valore risultante <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> dell'oggetto per il <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> cause costruttore un <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Resource length is greater than <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La lunghezza della risorsa è maggiore di <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Quando viene richiamato ad associazione tardiva tramite meccanismi, ad esempio <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The name of the module being requested.</source>
          <target state="translated">Nome del modulo richiesto.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Gets the specified module in this assembly.</source>
          <target state="translated">Ottiene il modulo specificato in questo assembly.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The module being requested, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the module is not found.</source>
          <target state="translated">Modulo richiesto o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se il modulo non viene trovato.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>This method works on file names.</source>
          <target state="translated">Questo metodo funziona sui nomi di file.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Classes in the <ph id="ph1">`Reflection.Emit`</ph> namespace emit the scope name for a dynamic module.</source>
          <target state="translated">Classi di <ph id="ph1">`Reflection.Emit`</ph> dello spazio dei nomi creano il nome dell'ambito per un modulo dinamico.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The scope name can be determined by the <ph id="ph1">&lt;xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Il nome ambito può essere determinato mediante la <ph id="ph1">&lt;xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Pass the kind of module you want to <ph id="ph1">`Assembly.GetModule`</ph>.</source>
          <target state="translated">Passare il tipo di modulo che si desidera <ph id="ph1">`Assembly.GetModule`</ph>.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>For example, if you want the module that contains the assembly manifest, pass the scope name of the module to <ph id="ph1">`GetModule`</ph>.</source>
          <target state="translated">Ad esempio, se si desidera il modulo che contiene il manifesto dell'assembly, passare il nome dell'ambito del modulo da <ph id="ph1">`GetModule`</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Otherwise, pass the file name of the module.</source>
          <target state="translated">In caso contrario, passare il nome del file del modulo.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Assemblies loaded by one of the <ph id="ph1">`Load`</ph> methods that have a byte[] parameter have only one module, and that is the manifest module.</source>
          <target state="translated">Gli assembly caricati da una del <ph id="ph1">`Load`</ph> metodi che hanno un parametro byte [] contengono un solo modulo, ovvero il modulo del manifesto.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Always seek these modules using the scope name.</source>
          <target state="translated">Ricercare sempre questi moduli utilizzando il nome dell'ambito.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Un tipo può essere recuperato da un modulo specifico tramite <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Calling <ph id="ph1">`Module.GetType`</ph> on the module containing the manifest will not initiate a search of the entire assembly.</source>
          <target state="translated">La chiamata <ph id="ph1">`Module.GetType`</ph> sul modulo che contiene il manifesto non verrà avviata una ricerca dell'intero assembly.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per recuperare un tipo da un assembly, indipendentemente dalla quale è in, è necessario chiamare <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets all the modules that are part of this assembly.</source>
          <target state="translated">Ottiene tutti i moduli che fanno parte di questo assembly.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules">
          <source>Gets all the modules that are part of this assembly.</source>
          <target state="translated">Ottiene tutti i moduli che fanno parte di questo assembly.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules">
          <source>An array of modules.</source>
          <target state="translated">Matrice di moduli.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules">
          <source>This method works on public and private resource files.</source>
          <target state="translated">Questo metodo funziona in file di risorse pubbliche e private.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules">
          <source>Modules must be emitted with file name extensions.</source>
          <target state="translated">I moduli devono essere generati con estensioni di file.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules">
          <source>The following example displays the name of the module in the returned array that contains the assembly manifest.</source>
          <target state="translated">Nell'esempio seguente visualizza il nome del modulo nella matrice restituita che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules">
          <source>The module to be loaded does not specify a file name extension.</source>
          <target state="translated">Il modulo da caricare non specifica un'estensione di file.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per includere i moduli delle risorse; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>Gets all the modules that are part of this assembly, specifying whether to include resource modules.</source>
          <target state="translated">Ottiene tutti i moduli che fanno parte di questo assembly, specificando se includere i moduli delle risorse.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>An array of modules.</source>
          <target state="translated">Matrice di moduli.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>This method works on public and private resource files.</source>
          <target state="translated">Questo metodo funziona in file di risorse pubbliche e private.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>Modules must be emitted with file name extensions.</source>
          <target state="translated">I moduli devono essere generati con estensioni di file.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> for this assembly.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> per questo assembly.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> for this assembly.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> per questo assembly.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName">
          <source>An object that contains the fully parsed display name for this assembly.</source>
          <target state="translated">Oggetto che contiene il nome visualizzato completamente analizzato per questo assembly.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName">
          <source>for access to the path of the assembly.</source>
          <target state="translated">Per accedere al percorso dell'assembly.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the <ph id="ph2">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> to the location of the assembly after it was shadow copied; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to set <ph id="ph4">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> to the original location.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per impostare la proprietà <ph id="ph2">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> sul percorso dell'assembly dopo l'esecuzione della copia shadow; <ph id="ph3">&lt;see langword="false" /&gt;</ph> per impostare <ph id="ph4">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> sul percorso originale.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> for this assembly, setting the codebase as specified by <ph id="ph2">&lt;paramref name="copiedName" /&gt;</ph>.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> per questo assembly, impostando la codebase come specificato da <ph id="ph2">&lt;paramref name="copiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>An object that contains the fully parsed display name for this assembly.</source>
          <target state="translated">Oggetto che contiene il nome visualizzato completamente analizzato per questo assembly.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>for access to the path of the assembly.</source>
          <target state="translated">Per accedere al percorso dell'assembly.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object to be populated with serialization information.</source>
          <target state="translated">Oggetto da popolare con le informazioni sulla serializzazione.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination context of the serialization.</source>
          <target state="translated">Contesto di destinazione della serializzazione.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Gets serialization information with all of the data needed to reinstantiate this assembly.</source>
          <target state="translated">Ottiene le informazioni sulla serializzazione con tutti i dati necessari per creare una nuova istanza di questo assembly.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> objects for all the assemblies referenced by this assembly.</source>
          <target state="translated">Ottiene gli oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> per tutti gli assembly a cui fa riferimento questo assembly.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</source>
          <target state="translated">Matrice contenente i nomi visualizzati completamente analizzati di tutti gli assembly a cui fa riferimento questo assembly.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> property of an <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object that is returned by this method is <ph id="ph4">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType&gt;</ph> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <ph id="ph5">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> proprietà di un <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> oggetto restituito da questo metodo è <ph id="ph4">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType&gt;</ph> se è presente alcun algoritmo hash per l'assembly di riferimento, o se l'algoritmo hash dell'assembly di riferimento non è identificato dal <ph id="ph5">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>In previous versions of the .NET Framework, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> property returned <ph id="ph2">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType&gt;</ph> in this situation.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, il <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> proprietà restituita <ph id="ph2">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType&gt;</ph> in questa situazione.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>The following code example demonstrates calling the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetReferencedAssemblies%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrata la chiamata di <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetReferencedAssemblies%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the satellite assembly.</source>
          <target state="translated">Ottiene l'assembly satellite.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The specified culture.</source>
          <target state="translated">Impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Gets the satellite assembly for the specified culture.</source>
          <target state="translated">Ottiene l'assembly satellite per le impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The specified satellite assembly.</source>
          <target state="translated">Assembly satellite specificato.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</source>
          <target state="translated">Gli assembly satellite contengono risorse localizzate, distinte dall'assembly principale dell'applicazione, che contengono codice eseguibile non localizzabile nonché risorse per singole impostazioni cultura utilizzate come impostazioni cultura neutre o predefinito.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Call this method to use your current assembly version.</source>
          <target state="translated">Chiamare questo metodo per utilizzare la versione dell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The assembly cannot be found.</source>
          <target state="translated">L'assembly non è stato trovato.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The satellite assembly with a matching file name was found, but the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> did not match the one specified.</source>
          <target state="translated">È stato trovato l'assembly satellite con un nome file corrispondente, ma <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> non corrisponde a quello specificato.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The satellite assembly is not a valid assembly.</source>
          <target state="translated">L'assembly satellite non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The specified culture.</source>
          <target state="translated">Impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The version of the satellite assembly.</source>
          <target state="translated">Versione dell'assembly satellite.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Gets the specified version of the satellite assembly for the specified culture.</source>
          <target state="translated">Ottiene la versione specificata dell'assembly satellite per le impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The specified satellite assembly.</source>
          <target state="translated">Assembly satellite specificato.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</source>
          <target state="translated">Gli assembly satellite contengono risorse localizzate, distinte dall'assembly principale dell'applicazione, che contengono codice eseguibile non localizzabile nonché risorse per singole impostazioni cultura utilizzate come impostazioni cultura neutre o predefinito.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29&gt;</ph> overload to use your current assembly version.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29&gt;</ph> overload da utilizzare la versione dell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>If <ph id="ph1">`version`</ph> is <ph id="ph2">`null`</ph>, the current assembly version is used if both the resource and main assemblies are signed.</source>
          <target state="translated">Se <ph id="ph1">`version`</ph> è <ph id="ph2">`null`</ph>, la versione dell'assembly corrente viene utilizzata se la risorsa e l'assembly principale sono firmati.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The satellite assembly with a matching file name was found, but the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> or the version did not match the one specified.</source>
          <target state="translated">È stato trovato l'assembly satellite con un nome file corrispondente, ma <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> o la versione non corrisponde a quanto specificato.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The assembly cannot be found.</source>
          <target state="translated">L'assembly non è stato trovato.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The satellite assembly is not a valid assembly.</source>
          <target state="translated">L'assembly satellite non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the specified type.</source>
          <target state="translated">Ottiene l'oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo specificato.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The full name of the type.</source>
          <target state="translated">Nome completo del tipo.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object with the specified name in the assembly instance.</source>
          <target state="translated">Ottiene l'oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> con il nome specificato nell'istanza dell'assembly.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>An object that represents the specified class, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the class is not found.</source>
          <target state="translated">Oggetto che rappresenta la classe specificata o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se la classe non viene trovata.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>This method only searches the current assembly instance.</source>
          <target state="translated">Questo metodo cerca solo l'istanza dell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The <ph id="ph1">`name`</ph> parameter includes the namespace but not the assembly.</source>
          <target state="translated">Il <ph id="ph1">`name`</ph> parametro include lo spazio dei nomi ma non l'assembly.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>To search other assemblies for a type, use the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> method overload, which can optionally include an assembly display name as part of the type name.</source>
          <target state="translated">Per cercare altri assembly per un tipo, usare il <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> overload del metodo, che può includere un nome visualizzato dell'assembly come parte del nome del tipo.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Se il tipo è stato inoltrato a un altro assembly, viene comunque restituito da questo metodo.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Per informazioni sull'inoltro dei tipi, vedere <bpt id="p1">[</bpt>inoltro dei tipi in Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The following example defines an abstract <ph id="ph1">`MeansOfTransportation`</ph> class in the <ph id="ph2">`Transportation`</ph> namespace.</source>
          <target state="translated">L'esempio seguente definisce una classe astratta <ph id="ph1">`MeansOfTransportation`</ph> classe il <ph id="ph2">`Transportation`</ph> dello spazio dei nomi.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>It calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> method to retrieve its <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, calls the <ph id="ph3">&lt;xref:System.Type.GetProperties%2A?displayProperty=nameWithType&gt;</ph> method to get an array of <ph id="ph4">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects that represent the type's properties, and then displays information on the type's abstract properties.</source>
          <target state="translated">Chiama il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> metodo per recuperare il relativo <ph id="ph2">&lt;xref:System.Type&gt;</ph> oggetto, chiama il <ph id="ph3">&lt;xref:System.Type.GetProperties%2A?displayProperty=nameWithType&gt;</ph> metodo per ottenere una matrice di <ph id="ph4">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> gli oggetti che rappresentano le proprietà del tipo e quindi Visualizza le informazioni del tipo astraggono proprietà.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>Note that the call to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> method uses the type's fully qualified name (that is, its namespace along with its type name).</source>
          <target state="translated">Si noti che la chiamata al <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> metodo utilizza il nome completo del tipo (ovvero, lo spazio dei nomi con il nome del tipo).</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che non è stato trovato.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">In <bpt id="p1">[</bpt>.NET per app di Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o nella <bpt id="p2">[</bpt>libreria di classi portabile<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> rilevare invece l'eccezione della classe di base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;/para&gt;</ph><ph id="ph2">
</ph><ph id="ph3">&lt;/block&gt;</ph><ph id="ph4">
</ph><ph id="ph5">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;/para&gt;</ph><ph id="ph2">
</ph><ph id="ph3">&lt;/block&gt;</ph><ph id="ph4">
</ph><ph id="ph5">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L'assembly corrente è stato caricato nel contesto di sola reflection e <ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che non è stato precaricato.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente, ma il file non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The full name of the type.</source>
          <target state="translated">Nome completo del tipo.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type is not found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per generare un'eccezione se il tipo non viene trovato; <ph id="ph2">&lt;see langword="false" /&gt;</ph> per restituire <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</source>
          <target state="translated">Ottiene l'oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> con il nome specificato nell'istanza dell'assembly e facoltativamente genera un'eccezione se il tipo non viene trovato.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>An object that represents the specified class.</source>
          <target state="translated">Oggetto che rappresenta la classe specificata.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>This method only searches the current assembly instance.</source>
          <target state="translated">Questo metodo cerca solo l'istanza dell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`name`</ph> parameter includes the namespace but not the assembly.</source>
          <target state="translated">Il <ph id="ph1">`name`</ph> parametro include lo spazio dei nomi ma non l'assembly.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>To search other assemblies for a type, use the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> method overload, which can optionally include an assembly display name as part of the type name.</source>
          <target state="translated">Per cercare altri assembly per un tipo, usare il <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> overload del metodo, che può includere un nome visualizzato dell'assembly come parte del nome del tipo.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Se il tipo è stato inoltrato a un altro assembly, viene comunque restituito da questo metodo.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Per informazioni sull'inoltro dei tipi, vedere <bpt id="p1">[</bpt>inoltro dei tipi in Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter only affects what happens when the type is not found.</source>
          <target state="translated">Il <ph id="ph1">`throwOnError`</ph> parametro ha effetto solo quando il tipo non è stato trovato.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Non si applica le eccezioni eventualmente generate.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">In particolare, se il tipo è stato trovato ma non può essere caricato, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> possono essere generate anche se <ph id="ph2">`throwOnError`</ph> è <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> exceeds 1024 characters.</source>
          <target state="translated">La lunghezza <ph id="ph1">&lt;paramref name="name" /&gt;</ph> supera i 1024 caratteri.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> e il tipo non è stato trovato.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che non è stato trovato.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L'assembly corrente è stato caricato nel contesto di sola reflection e <ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che non è stato precaricato.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente, ma il file non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The full name of the type.</source>
          <target state="translated">Nome completo del tipo.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type is not found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per generare un'eccezione se il tipo non viene trovato; <ph id="ph2">&lt;see langword="false" /&gt;</ph> per restituire <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per ignorare la distinzione tra maiuscole e minuscole nel nome del tipo; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</source>
          <target state="translated">Ottiene l'oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> con il nome specificato nell'istanza dell'assembly, con la possibilità di ignorare la distinzione tra maiuscole e minuscole e di generare un'eccezione se il tipo non viene trovato.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An object that represents the specified class.</source>
          <target state="translated">Oggetto che rappresenta la classe specificata.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This method only searches the current assembly instance.</source>
          <target state="translated">Questo metodo cerca solo l'istanza dell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`name`</ph> parameter includes the namespace but not the assembly.</source>
          <target state="translated">Il <ph id="ph1">`name`</ph> parametro include lo spazio dei nomi ma non l'assembly.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To search other assemblies for a type, use the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> method overload, which can optionally include an assembly display name as part of the type name.</source>
          <target state="translated">Per cercare altri assembly per un tipo, usare il <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> overload del metodo, che può includere un nome visualizzato dell'assembly come parte del nome del tipo.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Se il tipo è stato inoltrato a un altro assembly, viene comunque restituito da questo metodo.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Per informazioni sull'inoltro dei tipi, vedere <bpt id="p1">[</bpt>inoltro dei tipi in Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter only affects what happens when the type is not found.</source>
          <target state="translated">Il <ph id="ph1">`throwOnError`</ph> parametro ha effetto solo quando il tipo non è stato trovato.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Non si applica le eccezioni eventualmente generate.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">In particolare, se il tipo è stato trovato ma non può essere caricato, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> possono essere generate anche se <ph id="ph2">`throwOnError`</ph> è <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> non è valido.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> exceeds 1024 characters.</source>
          <target state="translated">La lunghezza <ph id="ph1">&lt;paramref name="name" /&gt;</ph> supera i 1024 caratteri.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> e il tipo non è stato trovato.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che non è stato trovato.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che è stato trovato ma che non è stato possibile caricare.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">L'assembly corrente è stato caricato nel contesto di sola reflection e <ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che non è stato precaricato.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente, ma il file non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> richiede un assembly dipendente che è stato compilato per una versione del runtime successiva a quella attualmente caricata.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>Gets the types defined in this assembly.</source>
          <target state="translated">Ottiene i tipi definiti in questo assembly.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>An array that contains all the types that are defined in this assembly.</source>
          <target state="translated">Matrice che contiene tutti i tipi definiti in questo assembly.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The returned array includes nested types.</source>
          <target state="translated">La matrice restituita include i tipi annidati.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <ph id="ph2">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> is thrown.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> metodo viene chiamato su un assembly e un tipo di tale assembly è dipendente da un tipo in un assembly che non è stato caricato (ad esempio, se deriva da un tipo nel secondo assembly), un <ph id="ph2">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>For example, this can happen if the first assembly was loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods, and the second assembly was not loaded.</source>
          <target state="translated">Ad esempio, questa situazione può verificarsi se il primo assembly è stato caricato con le <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> metodi e il secondo assembly non è stato caricato.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>It can also happen with assemblies loaded using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> methods if the second assembly cannot be located when the <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> method is called.</source>
          <target state="translated">Questo può verificarsi anche con gli assembly caricati utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodi se il secondo assembly non viene trovato quando la <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> metodo viene chiamato.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>If a type has been forwarded to another assembly, it is not included in the returned array.</source>
          <target state="translated">Se un tipo è stato inoltrato a un altro assembly, non è incluso nella matrice restituita.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Per informazioni sull'inoltro dei tipi, vedere <bpt id="p1">[</bpt>inoltro dei tipi in Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>To retrieve a collection of <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objects instead of an array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects, use the <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per recuperare una raccolta di <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> oggetti anziché una matrice di <ph id="ph2">&lt;xref:System.Type&gt;</ph> oggetti, utilizzare il <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The following example displays parameters of one method on a type in the specified assembly.</source>
          <target state="translated">L'esempio seguente mostra i parametri di un metodo su un tipo nell'assembly specificato.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The assembly contains one or more types that cannot be loaded.</source>
          <target state="translated">L'assembly contiene uno o più tipi che non possono essere caricati.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The array returned by the <ph id="ph1">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /&gt;</ph> property of this exception contains a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object for each type that was loaded and <ph id="ph3">&lt;see langword="null" /&gt;</ph> for each type that could not be loaded, while the <ph id="ph4">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /&gt;</ph> property contains an exception for each type that could not be loaded.</source>
          <target state="translated">La matrice restituita dalla proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /&gt;</ph> di questa eccezione contiene un oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> per ogni tipo caricato e <ph id="ph3">&lt;see langword="null" /&gt;</ph> per ogni tipo non caricato, mentre la proprietà <ph id="ph4">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /&gt;</ph> contiene un'eccezione per ogni tipo non caricato.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.GlobalAssemblyCache">
          <source>Gets a value indicating whether the assembly was loaded from the global assembly cache.</source>
          <target state="translated">Ottiene un valore che indica se l'assembly è stato caricato dalla Global Assembly Cache.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.GlobalAssemblyCache">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the assembly was loaded from the global assembly cache; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'assembly è stato caricato dalla Global Assembly Cache; in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.HostContext">
          <source>Gets the host context with which the assembly was loaded.</source>
          <target state="translated">Ottiene il contesto host con cui l'assembly è stato caricato.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.HostContext">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> value that indicates the host context with which the assembly was loaded, if any.</source>
          <target state="translated">Valore <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> che indica il contesto host con cui l'assembly è stato caricato, se presente.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</source>
          <target state="translated">Ottiene una stringa che rappresenta la versione di CLR (Common Language Runtime) salvata nel file che contiene il manifesto.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>The CLR version folder name.</source>
          <target state="translated">Nome della cartella della versione CLR.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>This is not a full path.</source>
          <target state="translated">Non si tratta di un percorso completo.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</source>
          <target state="translated">Ad esempio, il valore per la versione 1.1 di .NET Framework sarebbe v 1.1.4322.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</source>
          <target state="translated">I file binari per tale versione potrebbe trovarsi nel windir%\Microsoft.NET\Framework\v1.1.4322% percorso.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>By default, <ph id="ph1">&lt;xref:System.Reflection.Assembly.ImageRuntimeVersion%2A&gt;</ph> is set to the version of the CLR used to build the assembly.</source>
          <target state="translated">Per impostazione predefinita, <ph id="ph1">&lt;xref:System.Reflection.Assembly.ImageRuntimeVersion%2A&gt;</ph> è impostata sulla versione di CLR utilizzata per compilare l'assembly.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>However, it might have been set to another value at compile time.</source>
          <target state="translated">Tuttavia, si potrebbe essere impostato su un altro valore in fase di compilazione.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>The type of the attribute to be checked for this assembly.</source>
          <target state="translated">Tipo dell'attributo da controllare per l'assembly.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Questo argomento viene ignorato per gli oggetti di questo tipo.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>Indicates whether or not a specified attribute has been applied to the assembly.</source>
          <target state="translated">Indica se è stato applicato un attributo specificato all'assembly.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the attribute has been applied to the assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'attributo è stato applicato all'assembly; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>The following code example applies the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute to an assembly and then uses <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsDefined%2A&gt;</ph> to indicate whether it was applied.</source>
          <target state="translated">L'esempio di codice seguente applica il <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attributo per un assembly e quindi Usa <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsDefined%2A&gt;</ph> per indicare se è stato applicato.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>It also tests an attribute that was not applied.</source>
          <target state="translated">Verifica inoltre un attributo che non è stato applicato.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> uses an invalid type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>utilizza un tipo non valido.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</source>
          <target state="translated">Ottiene un valore che indica se l'assembly corrente è stato generato dinamicamente nel processo corrente tramite reflection emit.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current assembly was generated dynamically in the current process; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'assembly corrente è stato generato in modo dinamico nel processo corrente; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>Dynamic assemblies are represented by the derived class <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>.</source>
          <target state="translated">Gli assembly dinamici sono rappresentati dalla classe derivata <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</source>
          <target state="translated">Quando un assembly dinamico viene salvato su disco, l'assembly salvato non è dinamico.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>If the saved assembly is loaded into another application domain or process, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsDynamic%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Se l'assembly salvato viene caricato in un altro dominio applicazione o processo, il <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsDynamic%2A&gt;</ph> restituisce proprietà <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.IsFullyTrusted">
          <source>Gets a value that indicates whether the current assembly is loaded with full trust.</source>
          <target state="translated">Ottiene un valore che indica se l'assembly corrente viene caricato con attendibilità totale.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsFullyTrusted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current assembly is loaded with full trust; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'assembly corrente è caricato con attendibilità totale; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly.</source>
          <target state="translated">Carica un assembly.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</source>
          <target state="translated">Carica l'assembly con un'immagine in formato COFF (Common Object File Format) contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">L'assembly viene caricato nel dominio applicazione del chiamante.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</source>
          <target state="translated">Il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità dell'assembly chiamante.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>To load an assembly from a byte array with the trust level of the application domain, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> method overload.</source>
          <target state="translated">Per caricare un assembly da una matrice di byte con il livello di attendibilità del dominio dell'applicazione, utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>For more information about the use of evidence with overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that take byte arrays, see the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni sull'utilizzo dell'evidenza con overload di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo che accetta le matrici di byte, vedere il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La reflection su file eseguibili C++ può generare un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o <ph id="ph1">`.reloc`</ph> sezione dal file eseguibile.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Per mantenere il <ph id="ph1">`.reloc`</ph> indirizzo per il file eseguibile C++, specificare <ph id="ph2">`/fixed:no`</ph> quando ci si sta collegando.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Note that this method overload always creates a new <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object with its own mapping.</source>
          <target state="translated">Si noti che questo overload del metodo crea sempre un nuovo <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> oggetto con il proprio mapping.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The object that describes the assembly to be loaded.</source>
          <target state="translated">Oggetto che descrive l'assembly da caricare.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Loads an assembly given its <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">Carica un assembly dato il relativo oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyRef`</ph> specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> viene generata se <ph id="ph2">`assemblyRef`</ph> specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice con una versione diversa, le impostazioni cultura o token di chiave pubblica.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">Il caricatore non continuare la ricerca degli altri assembly che corrispondono al nome semplice.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Do not use an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> with only the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property set.</source>
          <target state="translated">Non utilizzare un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> solo con il <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> set di proprietà.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> proprietà non fornisca tutti gli elementi dell'identità dell'assembly (ad esempio nome o la versione), quindi il caricamento non si verifica in base alle regole di caricamento all'identità, come ci si aspetta dal <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Instead, the assembly is loaded using load-from rules.</source>
          <target state="translated">Al contrario, l'assembly viene caricato utilizzando le regole di caricamento.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>For information about the disadvantages of using the load-from context, see the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> method overload or <bpt id="p1">[</bpt>Best Practices for Assembly Loading<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</source>
          <target state="translated">Per informazioni sugli svantaggi derivanti dall'utilizzo il contesto di caricamento, vedere il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> overload del metodo o <bpt id="p1">[</bpt>le procedure consigliate per il caricamento di Assembly<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo senza <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine common object file formato COFF (), la prova viene ereditata dall'assembly chiamante.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine COFF, l'evidenza viene combinato.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> e <ph id="ph3">`Site`</ph> vengono ereditate dall'assembly chiamante e <ph id="ph4">`Hash`</ph> e <ph id="ph5">`StrongName`</ph> provengono dall'assembly COFF.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">`Byte[]`</ph> parametro e <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La reflection su file eseguibili C++ può generare un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o <ph id="ph1">`.reloc`</ph> sezione dal file eseguibile.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Per mantenere il <ph id="ph1">`.reloc`</ph> indirizzo per il file eseguibile C++, specificare <ph id="ph2">`/fixed:no`</ph> quando ci si sta collegando.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If both the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property).</source>
          <target state="translated">Se entrambi i <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> proprietà e <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> proprietà sono impostate, il primo tentativo di caricare l'assembly viene utilizzato il nome visualizzato (compreso versione, impostazioni cultura e così via, restituito dal <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> proprietà).</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> is used to search for the assembly.</source>
          <target state="translated">Se il file non viene trovato, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> viene utilizzato per cercare l'assembly.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If the assembly is found using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, the display name is matched against the assembly.</source>
          <target state="translated">Se l'assembly viene trovato tramite <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, il nome visualizzato viene confrontato con l'assembly.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If the match fails, a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown.</source>
          <target state="translated">Se la corrispondenza ha esito negativo, un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The following example instantiates an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and uses it to load the <ph id="ph2">`sysglobal.dll`</ph> assembly.</source>
          <target state="translated">Nell'esempio seguente viene creata un'istanza di un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> dell'oggetto che viene utilizzato per caricare il <ph id="ph2">`sysglobal.dll`</ph> assembly.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The example then displays the full name of the assembly's public types.</source>
          <target state="translated">Nell'esempio viene quindi visualizzato il nome completo di tipi pubblici dell'assembly.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">In <bpt id="p1">[</bpt>.NET per app di Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> o nella <bpt id="p2">[</bpt>libreria di classi portabile<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> rilevare invece l'eccezione della classe di base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The long form of the assembly name.</source>
          <target state="translated">Forma estesa del nome dell'assembly.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Loads an assembly given the long form of its name.</source>
          <target state="translated">Carica un assembly in base alla forma estesa del nome.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</source>
          <target state="translated">La forma estesa del nome dell'assembly è costituito il relativo nome semplice (ad esempio "System" per l'assembly System. dll) con la versione, impostazioni cultura, token di chiave pubblica e, facoltativamente, l'architettura del processore.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>It corresponds to the assembly's <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> property.</source>
          <target state="translated">Corrisponde all'assembly <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'utilizzo di un nome lungo per caricare l'assembly System.dll per .NET Framework 4.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyString`</ph> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> viene generata se <ph id="ph2">`assemblyString`</ph> specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice con una versione diversa, le impostazioni cultura o token di chiave pubblica.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">Il caricatore non continuare la ricerca degli altri assembly che corrispondono al nome semplice.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo senza <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine common object file formato COFF (), la prova viene ereditata dall'assembly chiamante.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine COFF, l'evidenza viene combinato.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> e <ph id="ph3">`Site`</ph> vengono ereditate dall'assembly chiamante e <ph id="ph4">`Hash`</ph> e <ph id="ph5">`StrongName`</ph> provengono dall'assembly COFF.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">`Byte[]`</ph> parametro e <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La reflection su file eseguibili C++ può generare un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o <ph id="ph1">`.reloc`</ph> sezione dal file eseguibile.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Per mantenere il <ph id="ph1">`.reloc`</ph> indirizzo per il file eseguibile C++, specificare <ph id="ph2">`/fixed:no`</ph> quando ci si sta collegando.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Ad esempio, "ProcessorArchitecture = msil".</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>However, the recommended way to specify an assembly name is to create an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and pass it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Tuttavia, il metodo consigliato per specificare un nome di assembly consiste nel creare un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> e passarlo a un overload appropriato del <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</source>
          <target state="translated">Nell'esempio seguente carica un assembly dato il relativo nome completo e vengono elencati tutti i tipi contenuti nell'assembly specificato.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è una stringa di lunghezza zero.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>A byte array that contains the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per l'assembly.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</source>
          <target state="translated">Carica l'assembly con un'immagine in formato COFF (Common Object File Format) che contiene un assembly generato e include facoltativamente i simboli per l'assembly.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">L'assembly viene caricato nel dominio applicazione del chiamante.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</source>
          <target state="translated">Il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità dell'assembly chiamante.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>To load an assembly from a byte array with the trust level of the application domain, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> method overload.</source>
          <target state="translated">Per caricare un assembly da una matrice di byte con il livello di attendibilità del dominio dell'applicazione, utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>For more information about the use of evidence with overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that take byte arrays, see the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni sull'utilizzo dell'evidenza con overload di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo che accetta le matrici di byte, vedere il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La reflection su file eseguibili C++ può generare un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o <ph id="ph1">`.reloc`</ph> sezione dal file eseguibile.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Per mantenere il <ph id="ph1">`.reloc`</ph> indirizzo per il file eseguibile C++, specificare <ph id="ph2">`/fixed:no`</ph> quando ci si sta collegando.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Note that this method overload always creates a new <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object with its own mapping.</source>
          <target state="translated">Si noti che questo overload del metodo crea sempre un nuovo <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> oggetto con il proprio mapping.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The object that describes the assembly to be loaded.</source>
          <target state="translated">Oggetto che descrive l'assembly da caricare.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">Carica un assembly dato il relativo oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the domain of the caller using the supplied evidence.</source>
          <target state="translated">L'assembly viene caricato nel dominio del chiamante usando l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyRef`</ph> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> viene generata se <ph id="ph2">`assemblyRef`</ph> specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice con una versione diversa, le impostazioni cultura o token di chiave pubblica.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">Il caricatore non continuare la ricerca degli altri assembly che corrispondono al nome semplice.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Do not use an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> with only the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property set.</source>
          <target state="translated">Non utilizzare un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> solo con il <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> set di proprietà.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> proprietà non fornisca tutti gli elementi dell'identità dell'assembly (ad esempio nome o la versione), quindi il caricamento non si verifica in base alle regole di caricamento all'identità, come ci si aspetta dal <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Instead, the assembly is loaded using load-from rules.</source>
          <target state="translated">Al contrario, l'assembly viene caricato utilizzando le regole di caricamento.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>For information about the disadvantages of using the load-from context, see the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> method overload or <bpt id="p1">[</bpt>Best Practices for Assembly Loading<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</source>
          <target state="translated">Per informazioni sugli svantaggi derivanti dall'utilizzo il contesto di caricamento, vedere il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> overload del metodo o <bpt id="p1">[</bpt>le procedure consigliate per il caricamento di Assembly<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo senza <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine common object file formato COFF (), la prova viene ereditata dall'assembly chiamante.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine COFF, l'evidenza viene combinato.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> e <ph id="ph3">`Site`</ph> vengono ereditate dall'assembly chiamante e <ph id="ph4">`Hash`</ph> e <ph id="ph5">`StrongName`</ph> provengono dall'assembly COFF.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">`Byte[]`</ph> parametro e <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La reflection su file eseguibili C++ può generare un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o <ph id="ph1">`.reloc`</ph> sezione dal file eseguibile.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Per mantenere il <ph id="ph1">`.reloc`</ph> indirizzo per il file eseguibile C++, specificare <ph id="ph2">`/fixed:no`</ph> quando ci si sta collegando.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If both the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property).</source>
          <target state="translated">Se entrambi i <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> proprietà e <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> proprietà sono impostate, il primo tentativo di caricare l'assembly viene utilizzato il nome visualizzato (compreso versione, impostazioni cultura e così via, restituito dal <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> proprietà).</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> is used to search for the assembly.</source>
          <target state="translated">Se il file non viene trovato, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> viene utilizzato per cercare l'assembly.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If the assembly is found using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, the display name is matched against the assembly.</source>
          <target state="translated">Se l'assembly viene trovato tramite <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, il nome visualizzato viene confrontato con l'assembly.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If the match fails, a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown.</source>
          <target state="translated">Se la corrispondenza ha esito negativo, un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph2">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Se si chiama il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo più di una volta nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <ph id="ph2">&lt;xref:System.IO.FileLoadException&gt;</ph> perché non può essere l'uguaglianza e l'integrità delle diverse specifiche di prova determinato.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</source>
          <target state="translated">Carica un assembly in base al nome visualizzato nel dominio del chiamante, usando l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyString`</ph> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> viene generata se <ph id="ph2">`assemblyString`</ph> specifica il nome completo dell'assembly e il primo assembly che corrisponde al nome semplice con una versione diversa, le impostazioni cultura o token di chiave pubblica.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">Il caricatore non continuare la ricerca degli altri assembly che corrispondono al nome semplice.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo senza <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine common object file formato COFF (), la prova viene ereditata dall'assembly chiamante.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine COFF, l'evidenza viene combinato.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> e <ph id="ph3">`Site`</ph> vengono ereditate dall'assembly chiamante e <ph id="ph4">`Hash`</ph> e <ph id="ph5">`StrongName`</ph> provengono dall'assembly COFF.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">`Byte[]`</ph> parametro e <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La reflection su file eseguibili C++ può generare un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o <ph id="ph1">`.reloc`</ph> sezione dal file eseguibile.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Per mantenere il <ph id="ph1">`.reloc`</ph> indirizzo per il file eseguibile C++, specificare <ph id="ph2">`/fixed:no`</ph> quando ci si sta collegando.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Se si chiama questo metodo più volte nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> perché non è possibile determinare l'uguaglianza e l'integrità delle diverse specifiche di prova.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Ad esempio, "ProcessorArchitecture = msil".</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>However, the recommended way to specify an assembly name is to create an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and pass it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Tuttavia, il metodo consigliato per specificare un nome di assembly consiste nel creare un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> e passarlo a un overload appropriato del <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>A byte array that contains the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per l'assembly.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</source>
          <target state="translated">Carica l'assembly con un'immagine in formato COFF (Common Object File Format) che contiene un assembly generato e include facoltativamente i simboli e l'evidenza per l'assembly.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">L'assembly viene caricato nel dominio applicazione del chiamante.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the domain of the caller using the supplied evidence.</source>
          <target state="translated">L'assembly viene caricato nel dominio del chiamante usando l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The raw bytes representing the symbols for the assembly are also loaded.</source>
          <target state="translated">Vengono caricati anche i byte non elaborati che rappresentano i simboli per l'assembly.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo senza <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is inherited from the calling assembly.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine COFF, l'evidenza viene ereditata dall'assembly chiamante.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">Si applica a .NET Framework versione 1.1 Service Pack 1 (SP1) e versioni successive.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">In .NET Framework versione 1.0 e nella versione 1.1 senza SP1, quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> overload del metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine COFF, l'evidenza viene combinato.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> e <ph id="ph3">`Site`</ph> vengono ereditate dall'assembly chiamante e <ph id="ph4">`Hash`</ph> e <ph id="ph5">`StrongName`</ph> provengono dall'assembly COFF.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo con un <ph id="ph2">`Byte[]`</ph> parametro e <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image are ignored.</source>
          <target state="translated">L'evidenza dell'assembly chiamante e quella dell'immagine COFF vengono ignorati.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">La reflection su file eseguibili C++ può generare un <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">Ciò viene solitamente causato dal compilatore C++ rimuovendo gli indirizzi di rilocazione o <ph id="ph1">`.reloc`</ph> sezione dal file eseguibile.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Per mantenere il <ph id="ph1">`.reloc`</ph> indirizzo per il file eseguibile C++, specificare <ph id="ph2">`/fixed:no`</ph> quando ci si sta collegando.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>If you call the [<ph id="ph1">\]</ph>, Byte<ph id="ph2">\&lt;</ph>xref:System.Reflection.Assembly.Load%2A&gt; method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph3">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Se si chiama il [<ph id="ph1">\]</ph>, Byte<ph id="ph2">\&lt;</ph>xref:System.Reflection.Assembly.Load%2A &gt; metodo più di una volta nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <ph id="ph3">&lt;xref:System.IO.FileLoadException&gt;</ph> perché il Impossibile determinare l'uguaglianza e l'integrità delle diverse specifiche di prova.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Note that this method overload always creates a new <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object with its own mapping.</source>
          <target state="translated">Si noti che questo overload del metodo crea sempre un nuovo <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> oggetto con il proprio mapping.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>By default, legacy CAS policy is not enabled in the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>; when it is not enabled, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> must be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Per impostazione predefinita, i criteri di sicurezza dall'accesso di codice legacy non sono abilitati in <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>; quando non sono abilitati, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> deve essere <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>for the ability to supply evidence.</source>
          <target state="translated">Per poter fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>A byte array that contains the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per l'assembly.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The source of the security context.</source>
          <target state="translated">Origine del contesto di sicurezza.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</source>
          <target state="translated">Carica l'assembly con un'immagine in formato COFF (Common Object File Format) che contiene un assembly generato, include facoltativamente i simboli e specifica l'origine per il contesto di sicurezza.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">L'assembly viene caricato nel dominio applicazione del chiamante.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The assembly is loaded into the application domain of the caller using the specified source for the security context.</source>
          <target state="translated">L'assembly viene caricato nel dominio applicazione del chiamante usando l'origine specificata per il contesto di sicurezza.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>If <ph id="ph1">`rawSymbolStore`</ph> was specified, the raw bytes that represent the symbols for the assembly are also loaded.</source>
          <target state="translated">Se <ph id="ph1">`rawSymbolStore`</ph> è stato specificato, vengono caricati anche i byte non elaborati che rappresentano i simboli per l'assembly.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The value of <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> is not one of the enumeration values.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> non è uno dei valori di enumerazione.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads the contents of an assembly file.</source>
          <target state="translated">Carica il contenuto di un file di assembly.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The fully qualified path of the file to load.</source>
          <target state="translated">Percorso completo del file da caricare.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Loads the contents of an assembly file on the specified path.</source>
          <target state="translated">Carica il contenuto di un file di assembly nel percorso specificato.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method to load and examine assemblies that have the same identity, but are located in different paths.<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph></source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo per caricare ed esaminare gli assembly che hanno la stessa identità, ma si trovano in percorsi diversi.<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method does.</source>
          <target state="translated">Carica i file nel contesto di caricamento e non viene risolto le dipendenze tramite il percorso di caricamento, come il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> is useful in this limited scenario because <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> è utile in questo scenario limitato perché <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> non può essere utilizzato per caricare gli assembly che ha le stesse identità ma percorsi diversi; verrà caricato solo il primo assembly di questo tipo.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> argument is not an absolute path.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="path" /&gt;</ph> non è un percorso assoluto.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is an empty string ("") or does not exist.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota ("") o non esiste.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="path" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The fully qualified path of the assembly file.</source>
          <target state="translated">Percorso completo del file di assembly.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</source>
          <target state="translated">Carica un assembly in base al percorso nel dominio del chiamante, usando l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method to load and examine assemblies that have the same identity, but are located in different paths.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo per caricare ed esaminare gli assembly che hanno la stessa identità, ma si trovano in percorsi diversi.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> does not load files into the <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> context, and does not resolve dependencies using the load path, as the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method does.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> Carica i file nel <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> contesto e non consente di risolvere le dipendenze tramite il percorso di caricamento, come il <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> is useful in this limited scenario because <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> è utile in questo scenario limitato perché <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> non può essere utilizzato per caricare gli assembly che ha le stesse identità ma percorsi diversi; verrà caricato solo il primo assembly di questo tipo.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> argument is not an absolute path.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="path" /&gt;</ph> non è un percorso assoluto.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is an empty string ("") or does not exist.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è una stringa vuota ("") o non esiste.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="path" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="path" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>By default, legacy CAS policy is not enabled in the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>; when it is not enabled, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> must be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Per impostazione predefinita, i criteri di sicurezza dall'accesso di codice legacy non sono abilitati in <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>; quando non sono abilitati, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> deve essere <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly.</source>
          <target state="translated">Carica un assembly.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nome o percorso del file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Loads an assembly given its file name or path.</source>
          <target state="translated">Carica un assembly in base al nome file o al percorso.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Il <ph id="ph1">`assemblyFile`</ph> parametro deve fare riferimento a un URI senza caratteri di escape.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">Protocollo file transfer protocol (FTP) non è supportata.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">Se l'URI fornito per <ph id="ph1">`assemblyFile`</ph> è un indirizzo FTP, l'assembly non viene caricato.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">Assembly può essere caricato in uno dei tre contesti, o può essere caricato senza contesto:</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">Il contesto di caricamento contiene assembly trovati tramite sondaggio: nella GAC, archiviate in un assembly host se è ospitato il runtime o nel <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated">La maggior parte degli overload del metodo <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> carica gli assembly in questo contesto.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</source>
          <target state="translated">Il contesto di caricamento contiene assembly per cui l'utente ha fornito un percorso non incluso nella directory di ricerca mediante la ricerca.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sono esempi di metodi che vengono caricati in base al percorso.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">Contesto reflection-only contiene gli assembly caricati con il <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> metodi; codice in tali contesti non possono essere eseguiti.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">Se l'utente generato o l'assembly è stato trovato, non è in qualsiasi contesto.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">Questo vale per gli assembly caricati tramite gli overload di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo che specificano una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite la reflection emit e non salvate su disco.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">Il contesto di caricamento consente a un assembly devono essere caricati da un percorso non incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare perché le informazioni sul percorso vengono mantenute dal contesto.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo presenta gli svantaggi seguenti.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">In alternativa, considerare l'utilizzo di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">Se è già caricato un assembly con la stessa identità <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">Se un assembly viene caricato con <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>e successivamente un assembly nel contesto di caricamento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>This can occur when an assembly is de-serialized.</source>
          <target state="translated">Ciò può verificarsi quando un assembly viene deserializzato.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">Se un assembly viene caricato con <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, e il percorso di sondaggio include un assembly con un percorso diverso, ma con la stessa identità un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, oppure possono avvenire in altri comportamenti imprevisti.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> richiede <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph> o <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph> per il percorso specificato.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">Se esiste un'immagine nativa per <ph id="ph1">`assemblyFile`</ph>, non viene utilizzato.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The assembly cannot be loaded as domain neutral.</source>
          <target state="translated">L'assembly non può essere caricato come indipendente dal dominio.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>In the .NET Framework version 1.0 and 1.1, policy is not applied.</source>
          <target state="translated">In .NET Framework versioni 1.0 e 1.1, i criteri non vengono applicati.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The following example loads an assembly given its file name or path.</source>
          <target state="translated">Nell'esempio seguente carica un assembly in base al nome del file o al percorso.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>See the exception topic for more information.</source>
          <target state="translated">Per altre informazioni, vedere l'argomento relativo alle eccezioni.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">È stata specificata una base di codici che non inizia con "file://" senza la classe <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> richiesta.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">per la lettura di un URI che inizia con "file://".</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nome o percorso del file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its file name or path and supplying security evidence.</source>
          <target state="translated">Carica un assembly in base al nome file o al percorso e fornendo l'evidenza di sicurezza.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Il <ph id="ph1">`assemblyFile`</ph> parametro deve fare riferimento a un URI senza caratteri di escape.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">Protocollo file transfer protocol (FTP) non è supportata.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">Se l'URI fornito per <ph id="ph1">`assemblyFile`</ph> è un indirizzo FTP, l'assembly non viene caricato.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">Assembly può essere caricato in uno dei tre contesti, o può essere caricato senza contesto:</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">Il contesto di caricamento contiene assembly trovati tramite sondaggio: nella GAC, archiviate in un assembly host se è ospitato il runtime o nel <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated">La maggior parte degli overload del metodo <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> carica gli assembly in questo contesto.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</source>
          <target state="translated">Il contesto di caricamento contiene assembly per cui l'utente ha fornito un percorso non incluso nella directory di ricerca mediante la ricerca.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sono esempi di metodi che vengono caricati in base al percorso.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">Contesto reflection-only contiene gli assembly caricati con il <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> metodi; codice in tali contesti non possono essere eseguiti.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">Se l'utente generato o l'assembly è stato trovato, non è in qualsiasi contesto.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">Questo vale per gli assembly caricati tramite gli overload di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo che specificano una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite la reflection emit e non salvate su disco.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">Il contesto di caricamento consente a un assembly devono essere caricati da un percorso non incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare perché le informazioni sul percorso vengono mantenute dal contesto.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo presenta gli svantaggi seguenti.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">In alternativa, considerare l'utilizzo di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">Se è già caricato un assembly con la stessa identità <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">Se un assembly viene caricato con <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>e successivamente un assembly nel contesto di caricamento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>This can occur when an assembly is deserialized.</source>
          <target state="translated">Questa situazione può verificarsi quando un assembly è deserializzato.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">Se un assembly viene caricato con <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, e il percorso di sondaggio include un assembly con un percorso diverso, ma con la stessa identità un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, oppure possono avvenire in altri comportamenti imprevisti.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> richiede <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph> o <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph> per il percorso specificato.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">Se esiste un'immagine nativa per <ph id="ph1">`assemblyFile`</ph>, non viene utilizzato.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The assembly cannot be loaded as domain neutral.</source>
          <target state="translated">L'assembly non può essere caricato come indipendente dal dominio.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and 1.1, policy is not applied.</source>
          <target state="translated">In .NET Framework versioni 1.0 e 1.1, i criteri non vengono applicati.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo senza <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Se si chiama questo metodo più volte nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> perché non è possibile determinare l'uguaglianza e l'integrità delle diverse specifiche di prova.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is combined.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine common object file formato COFF (), la prova viene combinato.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> e <ph id="ph3">`Site`</ph> vengono ereditate dall'assembly chiamante e <ph id="ph4">`Hash`</ph> e <ph id="ph5">`StrongName`</ph> provengono dall'assembly COFF.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo con un <ph id="ph2">`Byte[]`</ph> parametro e <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not ambiguous and is determined to be invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> non è ambiguo ed è risultato non valido.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>See the exception topic for more information.</source>
          <target state="translated">Per altre informazioni, vedere l'argomento relativo alle eccezioni.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">È stata specificata una base di codici che non inizia con "file://" senza la classe <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> richiesta.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">per la lettura di un URI che inizia con "file://".</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nome o percorso del file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value of the computed hash code.</source>
          <target state="translated">Valore del codice hash calcolato.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The hash algorithm used for hashing files and for generating the strong name.</source>
          <target state="translated">Algoritmo hash usato per generare un hash per i file e generare il nome sicuro.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Loads an assembly given its file name or path, hash value, and hash algorithm.</source>
          <target state="translated">Carica un assembly in base al nome file o al percorso, al valore hash e all'algoritmo hash.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Il <ph id="ph1">`assemblyFile`</ph> parametro deve fare riferimento a un URI senza caratteri di escape.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">Protocollo file transfer protocol (FTP) non è supportata.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">Se l'URI fornito per <ph id="ph1">`assemblyFile`</ph> è un indirizzo FTP, l'assembly non viene caricato.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">Assembly può essere caricato in uno dei tre contesti, o può essere caricato senza contesto:</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">Il contesto di caricamento contiene assembly trovati tramite sondaggio: nella global assembly cache, archiviate in un assembly host se è ospitato il runtime o nel <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated">La maggior parte degli overload del metodo <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> carica gli assembly in questo contesto.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context contains assemblies for which the user provided a path that is not included in probing.</source>
          <target state="translated">Il contesto di caricamento contiene assembly per cui l'utente ha fornito un percorso che non è incluso nella ricerca.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sono esempi di metodi che vengono caricati in base al percorso.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">Contesto reflection-only contiene gli assembly caricati con il <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> metodi; codice in tali contesti non possono essere eseguiti.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">Se l'utente generato o l'assembly è stato trovato, non è in qualsiasi contesto.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">Questo vale per gli assembly caricati tramite gli overload di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo che specificano una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite la reflection emit e non salvate su disco.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">Il contesto di caricamento consente a un assembly devono essere caricati da un percorso che non è incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare perché le informazioni sul percorso vengono mantenute dal contesto.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo presenta gli svantaggi seguenti.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">In alternativa, considerare l'utilizzo di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">Se è già caricato un assembly con la stessa identità <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">Se un assembly viene caricato con <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>e successivamente un assembly nel contesto di caricamento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This can occur when an assembly is deserialized.</source>
          <target state="translated">Questa situazione può verificarsi quando un assembly è deserializzato.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">Se un assembly viene caricato con <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, e il percorso di sondaggio include un assembly con un percorso diverso, ma con la stessa identità un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, oppure possono avvenire in altri comportamenti imprevisti.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> richiede <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph> o <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph> per il percorso specificato.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">Se esiste un'immagine nativa per <ph id="ph1">`assemblyFile`</ph>, non viene utilizzato.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly cannot be loaded as domain-neutral.</source>
          <target state="translated">L'assembly non può essere caricato come modulo indipendente dal dominio.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">L'assembly viene caricato con l'evidenza fornita dal caricamento.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a file name extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è stato trovato oppure il modulo che si sta provando a caricare non specifica un'estensione di file.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>See the exception topic for more information.</source>
          <target state="translated">Per altre informazioni, vedere l'argomento relativo alle eccezioni.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">È stata specificata una base di codici che non inizia con "file://" senza la classe <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> richiesta.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">per la lettura di un URI che inizia con "file://".</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nome o percorso del file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value of the computed hash code.</source>
          <target state="translated">Valore del codice hash calcolato.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The hash algorithm used for hashing files and for generating the strong name.</source>
          <target state="translated">Algoritmo hash usato per generare un hash per i file e generare il nome sicuro.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</source>
          <target state="translated">Carica un assembly in base al nome file o al percorso, all'evidenza di sicurezza, al valore hash e all'algoritmo hash.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Il <ph id="ph1">`assemblyFile`</ph> parametro deve fare riferimento a un URI senza caratteri di escape.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">Protocollo file transfer protocol (FTP) non è supportata.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">Se l'URI fornito per <ph id="ph1">`assemblyFile`</ph> è un indirizzo FTP, l'assembly non viene caricato.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> può essere assoluto o relativo alla directory corrente, e l'assembly viene caricato nel dominio del chiamante.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">Assembly può essere caricato in uno dei tre contesti, o può essere caricato senza contesto:</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">Il contesto di caricamento contiene assembly trovati tramite sondaggio: nella GAC, archiviate in un assembly host se è ospitato il runtime o nel <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated">La maggior parte degli overload del metodo <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> carica gli assembly in questo contesto.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</source>
          <target state="translated">Il contesto di caricamento contiene assembly per cui l'utente ha fornito un percorso non incluso nella directory di ricerca mediante la ricerca.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> sono esempi di metodi che vengono caricati in base al percorso.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">Contesto reflection-only contiene gli assembly caricati con il <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> metodi; codice in tali contesti non possono essere eseguiti.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">Se l'utente generato o l'assembly è stato trovato, non è in qualsiasi contesto.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">Questo vale per gli assembly caricati tramite gli overload di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo che specificano una matrice di byte contenente un assembly e ad assembly dinamici temporanei creati tramite la reflection emit e non salvate su disco.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">Il contesto di caricamento consente a un assembly devono essere caricati da un percorso non incluso nel sondaggio e consente ancora di dipendenze in tale percorso per trovare e caricare perché le informazioni sul percorso vengono mantenute dal contesto.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo presenta gli svantaggi seguenti.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">In alternativa, considerare l'utilizzo di <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">Se è già caricato un assembly con la stessa identità <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> restituisce l'assembly caricato anche se è stato specificato un percorso diverso.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">Se un assembly viene caricato con <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>e successivamente un assembly nel contesto di caricamento tenta di caricare l'assembly stesso tramite il nome visualizzato, il tentativo di caricamento ha esito negativo.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This can occur when an assembly is deserialized.</source>
          <target state="translated">Questa situazione può verificarsi quando un assembly è deserializzato.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">Se un assembly viene caricato con <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, e il percorso di sondaggio include un assembly con un percorso diverso, ma con la stessa identità un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, oppure possono avvenire in altri comportamenti imprevisti.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> richiede <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph> o <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph> per il percorso specificato.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">Se esiste un'immagine nativa per <ph id="ph1">`assemblyFile`</ph>, non viene utilizzato.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly cannot be loaded as domain neutral.</source>
          <target state="translated">L'assembly non può essere caricato come indipendente dal dominio.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>In the .NET Framework version 1.0 and 1.1, policy is not applied.</source>
          <target state="translated">In .NET Framework versioni 1.0 e 1.1, i criteri non vengono applicati.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo senza <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro, l'assembly viene caricato con l'evidenza fornita dal caricamento.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">Se si chiama questo metodo più volte nello stesso assembly ma con una prova diversa specificata, common language runtime non genera un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> perché non è possibile determinare l'uguaglianza e l'integrità delle diverse specifiche di prova.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">L'evidenza che innanzitutto ha esito positivo è l'evidenza utilizzata.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is combined.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo con un <ph id="ph2">`Byte[]`</ph> parametro per caricare un'immagine common object file formato COFF (), la prova viene combinato.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> e <ph id="ph3">`Site`</ph> vengono ereditate dall'assembly chiamante e <ph id="ph4">`Hash`</ph> e <ph id="ph5">`StrongName`</ph> provengono dall'assembly COFF.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">Quando si utilizza un <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> metodo con un <ph id="ph2">`Byte[]`</ph> parametro e <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> per caricare un'immagine COFF, viene utilizzato solo l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">L'evidenza dell'assembly chiamante e quella dell'immagine COFF viene ignorati.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not ambiguous and is determined to be invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> non è ambiguo ed è risultato non valido.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido; ad esempio, un assembly a 32 bit in un processo a 64 bit.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>See the exception topic for more information.</source>
          <target state="translated">Per altre informazioni, vedere l'argomento relativo alle eccezioni.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">È stata specificata una base di codici che non inizia con "file://" senza la classe <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> richiesta.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">per la lettura di un URI che inizia con "file://".</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads the module internal to this assembly.</source>
          <target state="translated">Carica il modulo interno a questo assembly.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>The name of the module.</source>
          <target state="translated">Nome del modulo.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>This string must correspond to a file name in this assembly's manifest.</source>
          <target state="translated">Questa stringa deve corrispondere a un nome file nel manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted module, or a resource.</source>
          <target state="translated">Matrice di byte costituita da un'immagine in formato COFF che contiene un modulo generato o una risorsa.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</source>
          <target state="translated">Carica il modulo, interno all'assembly, con un'immagine in formato COFF (Common Object File Format) contenente un modulo generato o un file di risorse.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>The loaded module.</source>
          <target state="translated">Modulo caricato.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> does not match a file entry in this assembly's manifest.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> non corrisponde a una voce di file nel manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> is not a valid module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> non è un modulo valido.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>The name of the module.</source>
          <target state="translated">Nome del modulo.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>This string must correspond to a file name in this assembly's manifest.</source>
          <target state="translated">Questa stringa deve corrispondere a un nome file nel manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted module, or a resource.</source>
          <target state="translated">Matrice di byte costituita da un'immagine in formato COFF che contiene un modulo generato o una risorsa.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>A byte array containing the raw bytes representing the symbols for the module.</source>
          <target state="translated">Matrice di byte contenente i byte non elaborati che rappresentano i simboli per il modulo.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>Must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if this is a resource file.</source>
          <target state="translated">Deve essere <ph id="ph1">&lt;see langword="null" /&gt;</ph> se si tratta di un file di risorse.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</source>
          <target state="translated">Carica il modulo, interno all'assembly, con un'immagine in formato COFF (Common Object File Format) contenente un modulo generato o un file di risorse.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>The raw bytes representing the symbols for the module are also loaded.</source>
          <target state="translated">Vengono caricati anche i byte non elaborati che rappresentano i simboli per il modulo.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>The loaded module.</source>
          <target state="translated">Modulo caricato.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> does not match a file entry in this assembly's manifest.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> non corrisponde a una voce di file nel manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> is not a valid module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> non è un modulo valido.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è stato possibile caricare un file trovato.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly from the application directory or from the global assembly cache using a partial name.</source>
          <target state="translated">Carica un assembly dalla directory dell'applicazione o dalla Global Assembly Cache con un nome parziale.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType&gt;</ph> method are obsolete and have been retained for backward compatibility.</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType&gt;</ph> metodo sono obsoleto e sono state mantenute per la compatibilità con le versioni precedenti.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The non-obsolete alternative is <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L'alternativa non obsoleta è <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Loads an assembly from the application directory or from the global assembly cache using a partial name.</source>
          <target state="translated">Carica un assembly dalla directory dell'applicazione o dalla Global Assembly Cache con un nome parziale.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> is not found, this method returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> non viene trovato, il metodo restituisce <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29&gt;</ph> method is obsolete and has been retained for backward compatibility.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29&gt;</ph> metodo è obsoleto ed è stato mantenuto per compatibilità con le versioni precedenti.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The non-obsolete alternative is <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L'alternativa non obsoleta è <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Applications that load assemblies with this method will be affected by upgrades of those assemblies.</source>
          <target state="translated">Applicazioni che caricano gli assembly con questo metodo saranno interessate dagli aggiornamenti di tali assembly.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Therefore, do not use this method; redesign the application to use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29&gt;</ph> method overload or the <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">Pertanto, non utilizzare questo metodo. riprogettare l'applicazione utilizzi la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29&gt;</ph> overload del metodo o <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>This method first calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo chiama innanzitutto <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</source>
          <target state="translated">Se l'assembly non viene trovato, questo metodo restituisce l'assembly dalla global assembly cache con lo stesso nome semplice e il numero di versione più alto.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly from the application directory or from the global assembly cache using a partial name.</source>
          <target state="translated">Carica un assembly dalla directory dell'applicazione o dalla Global Assembly Cache con un nome parziale.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the domain of the caller using the supplied evidence.</source>
          <target state="translated">L'assembly viene caricato nel dominio del chiamante usando l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> is not found, this method returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> non viene trovato, il metodo restituisce <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29&gt;</ph> method is obsolete and has been retained for backward compatibility.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29&gt;</ph> metodo è obsoleto ed è stato mantenuto per compatibilità con le versioni precedenti.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The non-obsolete alternative is <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L'alternativa non obsoleta è <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</source>
          <target state="translated">Un'evidenza è l'insieme di informazioni su cui vengono basate le decisioni inerenti i criteri di sicurezza, ad esempio le autorizzazioni che è possibile assegnare al codice.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Applications that load assemblies with this method will be affected by upgrades of those assemblies.</source>
          <target state="translated">Applicazioni che caricano gli assembly con questo metodo saranno interessate dagli aggiornamenti di tali assembly.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Therefore, do not use this method; redesign the application to use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method.</source>
          <target state="translated">Pertanto, non utilizzare questo metodo. riprogettare l'applicazione utilizzi la <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo o <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>This method first calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo chiama innanzitutto <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</source>
          <target state="translated">Se l'assembly non viene trovato, questo metodo restituisce l'assembly dalla global assembly cache con lo stesso nome semplice e il numero di versione più alto.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different sets of evidence.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due set di evidenze diversi.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>for calling unmanaged code and to load an assembly with evidence.</source>
          <target state="translated">per chiamare codice non gestito e per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Location">
          <source>Gets the full path or UNC location of the loaded file that contains the manifest.</source>
          <target state="translated">Ottiene il percorso completo o il percorso UNC del file caricato che contiene il manifesto.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>The location of the loaded file that contains the manifest.</source>
          <target state="translated">Percorso del file caricato che contiene il manifesto.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</source>
          <target state="translated">Se è stata eseguita una copia shadow del file caricato, il percorso è quello del file dopo l'esecuzione della copia shadow.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>If the assembly is loaded from a byte array, such as when using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /&gt;</ph> method overload, the value returned is an empty string ("").</source>
          <target state="translated">Se l'assembly viene caricato da una matrice di byte, come quando si usa l'overload del metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /&gt;</ph>, il valore restituito è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>To get the location before the file has been shadow-copied, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> property.</source>
          <target state="translated">Per ottenere il percorso prima che il file è stato replicato, utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>The following example displays the location of the loaded file that contains the manifest.</source>
          <target state="translated">Nell'esempio seguente visualizza il percorso del file caricato che contiene il manifesto.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Location">
          <source>The current assembly is a dynamic assembly, represented by an <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> object.</source>
          <target state="translated">L'assembly corrente è un assembly dinamico, rappresentato da un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>for access to the path.</source>
          <target state="translated">Per accedere al percorso.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ManifestModule">
          <source>Gets the module that contains the manifest for the current assembly.</source>
          <target state="translated">Ottiene il modulo contenente il manifesto per l'assembly corrente.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ManifestModule">
          <source>The module that contains the manifest for the assembly.</source>
          <target state="translated">Modulo contenente il manifesto per l'assembly.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</source>
          <target state="translated">Si verifica quando il caricatore della classe Common Language Runtime non è in grado di risolvere un riferimento a un modulo interno di un assembly in modo normale.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>This event gives the callback a chance to find and load the module itself and return it.</source>
          <target state="translated">Questo evento offre l'opportunità di trovare e caricare il modulo e restituirlo il callback.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Modules">
          <source>Gets a collection that contains the modules in this assembly.</source>
          <target state="translated">Ottiene una raccolta contenente i moduli dell'assembly.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Modules">
          <source>A collection that contains the modules in this assembly.</source>
          <target state="translated">Raccolta contenente i moduli dell'assembly.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Assembly da confrontare con <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Assembly da confrontare con <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica se due oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> sono uguali.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> è uguale a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Assembly da confrontare con <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Assembly da confrontare con <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica se due oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> non sono uguali.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> non è uguale a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>Gets the grant set of the current assembly.</source>
          <target state="translated">Ottiene il set di concessioni dell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>The grant set of the current assembly.</source>
          <target state="translated">Set di concessioni dell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source><ph id="ph1">&lt;xref:System.Security.PermissionSet&gt;</ph> objects can contain sensitive information such as paths.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.PermissionSet&gt;</ph> gli oggetti possono contenere informazioni riservate, ad esempio i percorsi.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>Therefore, full trust is required to access these objects.</source>
          <target state="translated">Pertanto, l'attendibilità totale deve accedere a questi oggetti.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value indicating whether this assembly was loaded into the reflection-only context.</source>
          <target state="translated">Ottiene un valore <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> che indica se l'assembly è stato caricato nel contesto ReflectionOnly.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'assembly è stato caricato nel contesto solo reflection anziché nel contesto di esecuzione; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source>If an assembly has been loaded into the reflection-only context, using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, you cannot execute code in the assembly.</source>
          <target state="translated">Se un assembly è stato caricato nel contesto reflection-only, utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> (metodo), non è possibile eseguire codice nell'assembly.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source>To execute code, the assembly must be loaded into the execution context.</source>
          <target state="translated">Per eseguire il codice, l'assembly deve essere caricato nel contesto di esecuzione.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly into the reflection-only context, where it can be examined but not executed.</source>
          <target state="translated">Carica un assembly nel contesto di sola reflection, in cui l'assembly può essere esaminato ma non eseguito.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Matrice di byte costituita da un'immagine in formato COFF contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</source>
          <target state="translated">Carica l'assembly da un'immagine in formato COFF (Common Object File Format) contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>The assembly is loaded into the reflection-only context of the caller's application domain.</source>
          <target state="translated">L'assembly viene caricato nel contesto di sola reflection del dominio applicazione del chiamante.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>You cannot execute code from an assembly loaded into the reflection-only context.</source>
          <target state="translated">È possibile eseguire codice da un assembly caricato nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>To execute code, the assembly must be loaded into the execution context as well, using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Per eseguire il codice, l'assembly deve essere caricato nel contesto di esecuzione, nonché tramite il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>The reflection-only context is no different from other contexts.</source>
          <target state="translated">Contesto reflection-only non è diverso da altri contesti.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</source>
          <target state="translated">Gli assembly caricati nel contesto possono essere scaricati solo scaricando il dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> cannot be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> non può essere caricato.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The display name of the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Reflection.AssemblyName.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome visualizzato dell'assembly, come restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.AssemblyName.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Loads an assembly into the reflection-only context, given its display name.</source>
          <target state="translated">Carica un assembly nel contesto di sola reflection in base al nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Dependencies are not automatically loaded into the reflection-only context.</source>
          <target state="translated">Le dipendenze non vengono caricate automaticamente nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>You cannot execute code from an assembly loaded into the reflection-only context.</source>
          <target state="translated">È possibile eseguire codice da un assembly caricato nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>To execute code, the assembly must be loaded into the execution context as well, using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Per eseguire il codice, l'assembly deve essere caricato nel contesto di esecuzione, nonché tramite il <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">Se sussistano o meno le autorizzazioni per l'utilizzo di un assembly lo si evince dalle evidenze.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">Le regole per l'assembly e l'evidenza di sicurezza unione sono come segue:</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Reflecting on executable files compiled in C++ might throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>.</source>
          <target state="translated">La reflection sui file eseguibili compilati in C++ può generare un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</source>
          <target state="translated">Ciò è probabilmente causato dal compilatore C++ rimozione indirizzi di rilocazione oppure della sezione. reloc dal file eseguibile.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>To preserve the .reloc address, specify <ph id="ph1">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">Per mantenere l'indirizzo, specificare <ph id="ph1">`/fixed:no`</ph> quando ci si sta collegando.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The reflection-only context is no different from other contexts.</source>
          <target state="translated">Contesto reflection-only non è diverso da altri contesti.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</source>
          <target state="translated">Gli assembly caricati nel contesto possono essere scaricati solo scaricando il dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is found, but cannot be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è stato trovato ma non può essere caricato.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Percorso del file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Loads an assembly into the reflection-only context, given its path.</source>
          <target state="translated">Carica un assembly nel contesto di sola reflection in base al percorso.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Dependencies are not automatically loaded into the reflection-only context.</source>
          <target state="translated">Le dipendenze non vengono caricate automaticamente nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>To automatically load dependencies, handle the <ph id="ph1">&lt;xref:System.AppDomain.ReflectionOnlyAssemblyResolve&gt;</ph> event and load the dependency in the event handler.</source>
          <target state="translated">Per caricare automaticamente le dipendenze, gestire il <ph id="ph1">&lt;xref:System.AppDomain.ReflectionOnlyAssemblyResolve&gt;</ph> evento e caricare la dipendenza nel gestore eventi.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>You cannot execute code from an assembly that has been loaded into the reflection-only context.</source>
          <target state="translated">È possibile eseguire codice da un assembly che è stato caricato nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>To execute the code, load the assembly with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Per eseguire il codice, caricare l'assembly con il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated">Il <ph id="ph1">`assemblyFile`</ph> parametro deve fare riferimento a un URI senza caratteri di escape.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">Questo metodo fornisce i caratteri di escape per tutti i caratteri non validi nell'URI.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The path specified for <ph id="ph1">`assemblyFile`</ph> is relative to the current directory.</source>
          <target state="translated">Il percorso specificato per <ph id="ph1">`assemblyFile`</ph> è relativo alla directory corrente.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The assembly is loaded into the domain of the caller.</source>
          <target state="translated">L'assembly viene caricato nel dominio del chiamante.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The reflection-only context is no different from other contexts.</source>
          <target state="translated">Contesto reflection-only non è diverso da altri contesti.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</source>
          <target state="translated">Gli assembly caricati nel contesto possono essere scaricati solo scaricando il dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a file name extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è stato trovato oppure il modulo che si sta provando a caricare non specifica un'estensione di file.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is found, but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato trovato ma non può essere caricato.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">È stata specificata una base di codici che non inizia con "file://" senza la classe <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> richiesta.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">per la lettura di un URI che inizia con "file://".</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</source>
          <target state="translated">Ottiene un valore che indica il set di regole di sicurezza applicato da Common Language Runtime (CLR) per questo assembly.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>The security rule set that the CLR enforces for this assembly.</source>
          <target state="translated">Set di regole di sicurezza applicato da CLR per questo assembly.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>By default, assemblies that you compile with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> have  transparency, although you can explicitly make them  instead.</source>
          <target state="translated">Per impostazione predefinita, gli assembly che si compila con il <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> dispongono di trasparenza, anche se è possibile renderle esplicitamente invece.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</source>
          <target state="translated">Gli assembly che sono stati compilati con le versioni precedenti di .NET Framework dispongono di trasparenza di livello 1.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>See <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Vedere <bpt id="p1">[</bpt>Modifiche di sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType">
          <source>Returns the type of the current instance.</source>
          <target state="translated">Restituisce il tipo dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType">
          <source>An object that represents the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> type.</source>
          <target state="translated">Oggetto che rappresenta il tipo di <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ToString">
          <source>Returns the full name of the assembly, also known as the display name.</source>
          <target state="translated">Restituisce il nome completo dell'assembly, noto anche come nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ToString">
          <source>The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</source>
          <target state="translated">Nome completo dell'assembly o nome della classe se non è possibile determinare il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">Nome o percorso del file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Loads an assembly into the load-from context, bypassing some security checks.</source>
          <target state="translated">Carica un assembly nel contesto di origine del caricamento, ignorando alcuni controlli di sicurezza.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</source>
          <target state="translated">Utilizzare questo metodo per caricare un assembly locale che il sistema operativo è contrassegnato come se fosse stato caricato dal Web (ad esempio, un file temporaneo è stato scaricato da Internet o intranet).</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Before the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, such assemblies were automatically loaded into a sandboxed application domain.</source>
          <target state="translated">Prima di <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, tali assembly sono stati caricati automaticamente in un dominio applicazione sandboxed.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, they are loaded with full trust.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, vengono caricati con attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>As an alternative to using this method, you can apply the <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept> in your application configuration file.</source>
          <target state="translated">Come alternativa all'utilizzo di questo metodo, è possibile applicare il <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> elemento<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept> nel file di configurazione dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>This causes the common language runtime to revert to the security policy of the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</source>
          <target state="translated">In questo modo common language runtime per i criteri di sicurezza di ripristinare il <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>If you use either of these solutions, you must be certain that it is safe to load <ph id="ph1">`assemblyFile`</ph> with full trust.</source>
          <target state="translated">Se si utilizza una di queste soluzioni, è necessario assicurarsi che sia possibile caricare <ph id="ph1">`assemblyFile`</ph> con attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>For a discussion of load contexts, including the load-from context, see the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">Per una descrizione dei contesti di caricamento, incluso il contesto di caricamento, vedere il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non viene trovato oppure il modulo che si sta provando a caricare non specifica un'estensione del nome file.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">Non è possibile caricare un file che non è stato trovato.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">È stata specificata una base di codici che non inizia con "file://" senza la classe <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> richiesta.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">La lunghezza del nome dell'assembly supera il numero di caratteri specificato da MAX_PATH.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>