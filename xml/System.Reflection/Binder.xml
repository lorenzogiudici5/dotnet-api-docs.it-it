<Type Name="Binder" FullName="System.Reflection.Binder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8552a20cca449c5e862ef2077f766f62d3f5197b" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52197947" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Binder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Binder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Binder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Binder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binder abstract" />
  <TypeSignature Language="F#" Value="type Binder = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Seleziona un membro da un elenco di candidati ed esegue la conversione dal tipo di argomento effettivo al tipo di argomento formale.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni del <xref:System.Reflection.Binder> classe vengono utilizzate dai metodi, ad esempio <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>, che consente di selezionare da un set di possibili membri per l'esecuzione, basato su un set di tipi di parametri e valori di argomento. <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, che seleziona un metodo basato su tipi di parametro e così via.  
  
 Un'implementazione predefinita del <xref:System.Reflection.Binder> classe viene fornita dal <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente implementa e illustra tutti i membri del `Binder` classe. Il metodo privato `CanConvertFrom` Cerca tipi compatibili per un determinato tipo.  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Quando si eredita da <see cref="T:System.Reflection.Binder" />, è necessario eseguire l'override dei membri seguenti: <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, <see cref="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />, <see cref="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />, <see cref="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />, e <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Binder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Binder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Reflection.Binder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene chiamato dai costruttori delle classi derivate, per inizializzare lo stato di questo tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindToField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo BindToField (System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo BindToField(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.FieldInfo[] match, object value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToField (bindingAttr As BindingFlags, match As FieldInfo(), value As Object, culture As CultureInfo) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ BindToField(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ match, System::Object ^ value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member BindToField : System.Reflection.BindingFlags * System.Reflection.FieldInfo[] * obj * System.Globalization.CultureInfo -&gt; System.Reflection.FieldInfo" Usage="binder.BindToField (bindingAttr, match, value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.FieldInfo[]" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinazione bit per bit dei valori di <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Gruppo di campi candidati per la corrispondenza. Quando ad esempio l'oggetto <see cref="T:System.Reflection.Binder" /> viene utilizzato dall'overload <see cref="Overload:System.Type.InvokeMember" />, questo parametro specifica il gruppo di campi individuati come possibili corrispondenze da reflection, in genere perché sono contraddistinti dal nome di membro corretto. L'implementazione predefinita fornita dalla proprietà <see cref="P:System.Type.DefaultBinder" /> modifica l'ordine di questa matrice.</param>
        <param name="value">Valore del campo utilizzato per individuare un campo corrispondente.</param>
        <param name="culture">Istanza della classe <see cref="T:System.Globalization.CultureInfo" /> utilizzata per controllare l'assegnazione dei tipi di dati in implementazioni del gestore di associazione che prevedono l'assegnazione dei tipi. Se <paramref name="culture" /> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.  
  
Nota   Se ad esempio un'implementazione del binder consente la coercizione di valori di stringa a tipi numerici, questo parametro è necessario per convertire un valore <see langword="String" /> che rappresenta 1000 in un valore <see langword="Double" />, poiché 1000 viene rappresentato in modo diverso dalle diverse impostazioni cultura. Con il gestore di associazione predefinito non sono previste tali assegnazioni di stringhe.</param>
        <summary>Seleziona un campo dal gruppo di campi indicato, in base ai criteri specificati.</summary>
        <returns>Il campo corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `bindingAttr` non include <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, l'implementazione dello strumento di associazione predefinita fornita dalla <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> restituisce semplicemente il primo elemento della `match`. Non viene eseguita alcuna selezione.  
  
 Questo metodo consente di controllare l'associazione fornita dal <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Per il gestore di associazione predefinito, il parametro <paramref name="bindingAttr" /> include il membro <see cref="F:System.Reflection.BindingFlags.SetField" />, mentre il parametro <paramref name="match" /> contiene più campi che rappresentano corrispondenze ugualmente valide per il parametro <paramref name="value" />. Ad esempio, <paramref name="value" /> contiene un oggetto <c>MyClass</c> che implementa l'interfaccia <c>IMyClass</c> e <paramref name="match" /> contiene un campo di tipo <c>MyClass</c> e un campo di tipo <c>IMyClass</c>.</exception>
        <exception cref="T:System.MissingFieldException">Per il gestore di associazione predefinito, il parametro <paramref name="bindingAttr" /> include il membro <see cref="F:System.Reflection.BindingFlags.SetField" />, mentre il parametro <paramref name="match" /> non contiene campi che possono accettare il parametro <paramref name="value" />.</exception>
        <exception cref="T:System.NullReferenceException">Per il gestore di associazione predefinito, il parametro <paramref name="bindingAttr" /> include il membro <see cref="F:System.Reflection.BindingFlags.SetField" />, mentre il valore del parametro <paramref name="match" /> è <see langword="null" /> o una matrice vuota.  
  
oppure 
 Il parametro <paramref name="bindingAttr" /> include il membro <see cref="F:System.Reflection.BindingFlags.SetField" /> mentre il valore del parametro <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
      </Docs>
    </Member>
    <Member MemberName="BindToMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase BindToMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase BindToMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, object[]&amp; args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] names, [out] object&amp; state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToMethod (bindingAttr As BindingFlags, match As MethodBase(), ByRef args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, names As String(), ByRef state As Object) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ BindToMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;System::Object ^&gt; ^ % args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ names, [Runtime::InteropServices::Out] System::Object ^ % state);" />
      <MemberSignature Language="F#" Value="abstract member BindToMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] *  * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] *  -&gt; System.Reflection.MethodBase" Usage="binder.BindToMethod (bindingAttr, match, args, modifiers, culture, names, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="names" Type="System.String[]" />
        <Parameter Name="state" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinazione bit per bit dei valori di <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Gruppo di metodi candidati per la corrispondenza. Quando ad esempio l'oggetto <see cref="T:System.Reflection.Binder" /> viene utilizzato dall'overload <see cref="Overload:System.Type.InvokeMember" />, questo parametro specifica il gruppo di metodi individuati come possibili corrispondenze da reflection, in genere perché sono contraddistinti dal nome di membro corretto. L'implementazione predefinita fornita dalla proprietà <see cref="P:System.Type.DefaultBinder" /> modifica l'ordine di questa matrice.</param>
        <param name="args">Gli argomenti passati. Il gestore di associazione può cambiare l'ordine degli argomenti in questa matrice, ad esempio modificando l'ordine degli argomenti se si utilizza il parametro <paramref name="names" /> per specificare un ordine diverso da quello posizionale. Se un'implementazione del gestore di associazione prevede l'assegnazione dei tipi di argomento, sarà possibile modificare anche i tipi e i valori degli argomenti.</param>
        <param name="modifiers">Matrice di modificatori di parametro che consentono di utilizzare l'associazione con le firme di parametro in cui sono stati modificati i tipi. Questo parametro non viene utilizzato nell'implementazione predefinita del gestore di associazione.</param>
        <param name="culture">Istanza della classe <see cref="T:System.Globalization.CultureInfo" /> utilizzata per controllare l'assegnazione dei tipi di dati in implementazioni del gestore di associazione che prevedono l'assegnazione dei tipi. Se <paramref name="culture" /> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.  
  
Nota   Se ad esempio un'implementazione del binder consente la coercizione di valori di stringa a tipi numerici, questo parametro è necessario per convertire un valore <see langword="String" /> che rappresenta 1000 in un valore <see langword="Double" />, poiché 1000 viene rappresentato in modo diverso dalle diverse impostazioni cultura. Con il gestore di associazione predefinito non sono previste tali assegnazioni di stringhe.</param>
        <param name="names">Nomi di parametro, se i nomi di parametro devono essere tenuti in considerazione durante al corrispondenza, oppure <see langword="null" /> se gli argomenti devono essere considerati come puramente posizionali. È ad esempio necessario utilizzare i nomi di parametro se gli argomenti non vengono forniti nell'ordine posizionale.</param>
        <param name="state">Dopo la restituzione del metodo, il parametro <paramref name="state" /> contiene un oggetto fornito dal gestore di associazione che tiene traccia del riordino degli argomenti. Il gestore di associazione crea questo oggetto e ne è l'unico consumer. Se il valore del parametro <paramref name="state" /> non è <see langword="null" /> quando viene restituito <see langword="BindToMethod" />, sarà necessario passare <paramref name="state" /> al metodo <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" /> se si desidera ripristinare l'ordine originale del parametro <paramref name="args" />, in modo che ad esempio sia possibile recuperare i valori dei parametri <see langword="ref" /> (parametri <see langword="ByRef" /> in Visual Basic).</param>
        <summary>Seleziona un metodo da richiamare dal gruppo di metodi indicato sulla base degli argomenti forniti.</summary>
        <returns>Metodo corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il binder predefinito prende in considerazione entrambi i parametri con valori e `params` matrici (`ParamArray` matrici in Visual Basic). Di conseguenza, è possibile trovare una corrispondenza nei casi in cui `args` e `match` non contengono lo stesso numero di elementi.  
  
 Lo strumento di associazione consente a un client eseguire il mapping della matrice di argomenti riportandola alla forma originale se la matrice di argomenti è stata modificata da <xref:System.Reflection.Binder.BindToMethod%2A>. Usare questa funzionalità di modifica del mapping per ottenere nuovamente gli argomenti per riferimento quando sono presenti tali argomenti. Quando si passano argomenti in base al nome, lo strumento di associazione Riordina la matrice di argomenti. Il `state` parametro tiene traccia del riordino degli argomenti, rendendo il gestore di associazione <xref:System.Reflection.Binder.ReorderArgumentArray%2A> metodo per riordinare la matrice di argomenti nel formato originale.  
  
 Il <xref:System.Reflection.Binder.BindToMethod%2A> metodo viene utilizzato dal <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Per il gestore di associazione predefinito, il parametro <paramref name="match" /> contiene più metodi che rappresentano corrispondenze ugualmente valide per il parametro <paramref name="args" />. Ad esempio, <paramref name="args" /> contiene un oggetto <c>MyClass</c> che implementa l'interfaccia <c>IMyClass</c>, mentre <paramref name="match" /> contiene un metodo che accetta <c>MyClass</c> e un metodo che accetta <c>IMyClass</c>.</exception>
        <exception cref="T:System.MissingMethodException">Per il gestore di associazione predefinito, il parametro <paramref name="match" /> non contiene metodi che possono accettare gli argomenti forniti nel parametro <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentException">Per il gestore di associazione predefinito, il valore del parametro <paramref name="match" /> è <see langword="null" /> o una matrice vuota.</exception>
        <altmember cref="T:System.Reflection.MethodBase" />
      </Docs>
    </Member>
    <Member MemberName="CanChangeType">
      <MemberSignature Language="C#" Value="public virtual bool CanChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.CanChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool&#xA;override this.CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool" Usage="binder.CanChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="type">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public abstract object ChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ ChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member ChangeType : obj * Type * System.Globalization.CultureInfo -&gt; obj" Usage="binder.ChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da modificare in un nuovo <see langword="Type" />.</param>
        <param name="type">Nuovo <see langword="Type" /> assegnato a <paramref name="value" />.</param>
        <param name="culture">Istanza dell'oggetto <see cref="T:System.Globalization.CultureInfo" /> utilizzata per controllare l'assegnazione forzata dei tipi di dati. Se <paramref name="culture" /> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.  
  
Nota   Questo parametro, ad esempio, è necessario per convertire un oggetto <see langword="String" /> che rappresenta 1000 in un valore <see langword="Double" />, poiché 1000 viene rappresentato in modo diverso dalle diverse impostazioni cultura.</param>
        <summary>Modifica il tipo di <see langword="Object" /> specificato nel <see langword="Type" /> specificato.</summary>
        <returns>Oggetto che contiene il valore dato come nuovo tipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La reflection dei modelli di regole di accessibilità di common type system. Ad esempio, se il chiamante è nello stesso assembly, il chiamante necessita di speciali autorizzazioni per membri interni. In caso contrario, il chiamante deve avere <xref:System.Security.Permissions.ReflectionPermission>. Ciò è coerente con ricerca di membri che sono protetti, privati e così via.  
  
 Il principio generale è che `ChangeType` deve eseguire solo un ampliamento coercizioni, che non comportano la perdita dei dati. Un esempio di una coercizione di ampliamento consiste nell'assegnare un valore che è un intero con segno a 32 bit su un valore che è un intero con segno a 64 bit. Questa operazione si differenzia da un tipo di assegnazione forzata, che potrebbe perdere dati. Un esempio di coercizione di restrizione consiste nell'assegnare un intero con segno a 64 bit in un intero con segno a 32 bit.  
  
 La tabella seguente elenca i coercizioni eseguite per l'impostazione predefinita `ChangeType`.  
  
|Tipo di origine|Tipo di destinazione|  
|-----------------|-----------------|  
|Qualsiasi tipo|Il tipo di base.|  
|Qualsiasi tipo|Implementa l'interfaccia.|  
|Char|UInt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Non-reference|Per riferimento.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReorderArgumentArray">
      <MemberSignature Language="C#" Value="public abstract void ReorderArgumentArray (ref object[] args, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReorderArgumentArray(object[]&amp; args, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ReorderArgumentArray (ByRef args As Object(), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ReorderArgumentArray(cli::array &lt;System::Object ^&gt; ^ % args, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member ReorderArgumentArray :  * obj -&gt; unit" Usage="binder.ReorderArgumentArray (args, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="args">Gli argomenti effettivi passati. Possono essere modificati sia i tipi che i valori degli argomenti.</param>
        <param name="state">Un oggetto fornito dal gestore di associazione che tiene traccia del riordino degli argomenti.</param>
        <summary>Al completamento del metodo <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, ripristina l'argomento <paramref name="args" /> allo stato in cui è stato restituito da <see langword="BindToMethod" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Common language runtime chiama questo metodo se `state` non è `null` dopo la restituzione da `BindToMethod`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase SelectMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase SelectMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectMethod (bindingAttr As BindingFlags, match As MethodBase(), types As Type(), modifiers As ParameterModifier()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ SelectMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodBase" Usage="binder.SelectMethod (bindingAttr, match, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinazione bit per bit dei valori di <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Gruppo di metodi candidati per la corrispondenza. Quando ad esempio l'oggetto <see cref="T:System.Reflection.Binder" /> viene utilizzato dall'overload <see cref="Overload:System.Type.InvokeMember" />, questo parametro specifica il gruppo di metodi individuati come possibili corrispondenze da reflection, in genere perché sono contraddistinti dal nome di membro corretto. L'implementazione predefinita fornita dalla proprietà <see cref="P:System.Type.DefaultBinder" /> modifica l'ordine di questa matrice.</param>
        <param name="types">Tipi di parametro utilizzati per individuare un metodo corrispondente.</param>
        <param name="modifiers">Matrice di modificatori di parametro che consentono di utilizzare l'associazione con le firme di parametro in cui sono stati modificati i tipi.</param>
        <summary>Seleziona un metodo dall'insieme di metodi indicato, in base al tipo di argomento.</summary>
        <returns>Metodo corrispondente, se disponibile. In caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve restituire `null` se nessun metodo corrisponde ai criteri. Questo metodo controlla la selezione fornita per il `GetConstructor` e `GetMethod` metodi su `Type`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Per il gestore di associazione predefinito, il parametro <paramref name="match" /> contiene più metodi che rappresentano corrispondenze ugualmente valide per i tipi di parametro descritti dal parametro <paramref name="types" />. Ad esempio, la matrice in <paramref name="types" /> contiene un oggetto <see cref="T:System.Type" /> per <c>MyClass</c>, mentre la matrice in <paramref name="match" /> contiene un metodo che accetta una classe di base di <c>MyClass</c> e un metodo che accetta un'interfaccia implementata da <c>MyClass</c>.</exception>
        <exception cref="T:System.ArgumentException">Per il gestore di associazione predefinito, il valore del parametro <paramref name="match" /> è <see langword="null" /> o una matrice vuota.  
  
oppure 
Un elemento del parametro <paramref name="types" /> deriva dalla classe <see cref="T:System.Type" />, ma non è di tipo <see langword="RuntimeType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectProperty">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo SelectProperty (System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, Type returnType, Type[] indexes, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo SelectProperty(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.PropertyInfo[] match, class System.Type returnType, class System.Type[] indexes, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectProperty (bindingAttr As BindingFlags, match As PropertyInfo(), returnType As Type, indexes As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::PropertyInfo ^ SelectProperty(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ match, Type ^ returnType, cli::array &lt;Type ^&gt; ^ indexes, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectProperty : System.Reflection.BindingFlags * System.Reflection.PropertyInfo[] * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="binder.SelectProperty (bindingAttr, match, returnType, indexes, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.PropertyInfo[]" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="indexes" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinazione bit per bit dei valori di <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Gruppo di proprietà candidate per la corrispondenza. Quando ad esempio l'oggetto <see cref="T:System.Reflection.Binder" /> viene utilizzato dall'overload <see cref="Overload:System.Type.InvokeMember" />, questo parametro specifica il gruppo di proprietà individuate come possibili corrispondenze da reflection, in genere perché sono contraddistinte dal nome di membro corretto. L'implementazione predefinita fornita dalla proprietà <see cref="P:System.Type.DefaultBinder" /> modifica l'ordine di questa matrice.</param>
        <param name="returnType">Valore restituito che la proprietà corrispondente deve avere.</param>
        <param name="indexes">Tipi di indice della proprietà cercata. Utilizzati per le proprietà di indice, come l'indicizzatore per una classe.</param>
        <param name="modifiers">Matrice di modificatori di parametro che consentono di utilizzare l'associazione con le firme di parametro in cui sono stati modificati i tipi.</param>
        <summary>Seleziona una proprietà dal gruppo di proprietà indicato, in base ai criteri specificati.</summary>
        <returns>Proprietà corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo controlla la selezione fornita per il `GetProperty` metodo su `Type`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Per il gestore di associazione predefinito, il parametro <paramref name="match" /> contiene più proprietà che rappresentano corrispondenze ugualmente valide per i parametri <paramref name="returnType" /> e <paramref name="indexes" />.</exception>
        <exception cref="T:System.ArgumentException">Per il gestore di associazione predefinito, il valore del parametro <paramref name="match" /> è <see langword="null" /> o una matrice vuota.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>