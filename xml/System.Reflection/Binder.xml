<Type Name="Binder" FullName="System.Reflection.Binder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0c8b1993fab848c2a7c5f4c863cfd40a6da35251" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36543301" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Binder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Binder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Binder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Binder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binder abstract" />
  <TypeSignature Language="F#" Value="type Binder = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Selects a member from a list of candidates, and performs type conversion from actual argument type to formal argument type.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni del <xref:System.Reflection.Binder> classe vengono utilizzate da metodi quali <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>, che consente di selezionare da un set di possibili membri da eseguire, in base a un set di tipi di parametro e valori di argomento. <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, che seleziona un metodo basato su tipi di parametro e così via.  
  
 Un'implementazione predefinita del <xref:System.Reflection.Binder> classe viene fornita per il <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente implementa e illustra tutti i membri del `Binder` classe. Il metodo privato `CanConvertFrom` Trova tipi compatibili per un determinato tipo.  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Quando si eredita da <see cref="T:System.Reflection.Binder" />, è necessario eseguire l'override dei membri seguenti: <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, <see cref="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />, <see cref="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />, <see cref="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />, e <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Binder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Binder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Reflection.Binder" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene chiamato dai costruttori di classi derivate per inizializzare lo stato in questo tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindToField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo BindToField (System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo BindToField(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.FieldInfo[] match, object value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToField (bindingAttr As BindingFlags, match As FieldInfo(), value As Object, culture As CultureInfo) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ BindToField(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ match, System::Object ^ value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member BindToField : System.Reflection.BindingFlags * System.Reflection.FieldInfo[] * obj * System.Globalization.CultureInfo -&gt; System.Reflection.FieldInfo" Usage="binder.BindToField (bindingAttr, match, value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.FieldInfo[]" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values.</param>
        <param name="match">The set of fields that are candidates for matching. For example, when a <see cref="T:System.Reflection.Binder" /> object is used by <see cref="Overload:System.Type.InvokeMember" />, this parameter specifies the set of fields that reflection has determined to be possible matches, typically because they have the correct member name. The default implementation provided by <see cref="P:System.Type.DefaultBinder" /> changes the order of this array.</param>
        <param name="value">The field value used to locate a matching field.</param>
        <param name="culture">An instance of <see cref="T:System.Globalization.CultureInfo" /> that is used to control the coercion of data types, in binder implementations that coerce types. If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.  Note   For example, if a binder implementation allows coercion of string values to numeric types, this parameter is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, because 1000 is represented differently by different cultures. The default binder does not do such string coercions.</param>
        <summary>Selects a field from the given set of fields, based on the specified criteria.</summary>
        <returns>The matching field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `bindingAttr` non include <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, l'implementazione dello strumento di associazione predefiniti fornito da <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> restituisce semplicemente il primo elemento della `match`. Non viene eseguita alcuna selezione.  
  
 Questo metodo consente di controllare l'associazione fornita dal <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">For the default binder, <paramref name="bindingAttr" /> includes <see cref="F:System.Reflection.BindingFlags.SetField" />, and <paramref name="match" /> contains multiple fields that are equally good matches for <paramref name="value" />. For example, <paramref name="value" /> contains a <c>MyClass</c> object that implements the <c>IMyClass</c> interface, and <paramref name="match" /> contains a field of type <c>MyClass</c> and a field of type <c>IMyClass</c>.</exception>
        <exception cref="T:System.MissingFieldException">For the default binder, <paramref name="bindingAttr" /> includes <see cref="F:System.Reflection.BindingFlags.SetField" />, and <paramref name="match" /> contains no fields that can accept <paramref name="value" />.</exception>
        <exception cref="T:System.NullReferenceException">For the default binder, <paramref name="bindingAttr" /> includes <see cref="F:System.Reflection.BindingFlags.SetField" />, and <paramref name="match" /> is <see langword="null" /> or an empty array.  -or-  <paramref name="bindingAttr" /> includes <see cref="F:System.Reflection.BindingFlags.SetField" />, and <paramref name="value" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
      </Docs>
    </Member>
    <Member MemberName="BindToMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase BindToMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase BindToMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, object[]&amp; args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] names, [out] object&amp; state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToMethod (bindingAttr As BindingFlags, match As MethodBase(), ByRef args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, names As String(), ByRef state As Object) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ BindToMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;System::Object ^&gt; ^ % args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ names, [Runtime::InteropServices::Out] System::Object ^ % state);" />
      <MemberSignature Language="F#" Value="abstract member BindToMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] *  * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] *  -&gt; System.Reflection.MethodBase" Usage="binder.BindToMethod (bindingAttr, match, args, modifiers, culture, names, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="args" Type="System.Object[]&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="names" Type="System.String[]" />
        <Parameter Name="state" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values.</param>
        <param name="match">The set of methods that are candidates for matching. For example, when a <see cref="T:System.Reflection.Binder" /> object is used by <see cref="Overload:System.Type.InvokeMember" />, this parameter specifies the set of methods that reflection has determined to be possible matches, typically because they have the correct member name. The default implementation provided by <see cref="P:System.Type.DefaultBinder" /> changes the order of this array.</param>
        <param name="args">The arguments that are passed in. The binder can change the order of the arguments in this array; for example, the default binder changes the order of arguments if the <c>names</c> parameter is used to specify an order other than positional order. If a binder implementation coerces argument types, the types and values of the arguments can be changed as well.</param>
        <param name="modifiers">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified. The default binder implementation does not use this parameter.</param>
        <param name="culture">An instance of <see cref="T:System.Globalization.CultureInfo" /> that is used to control the coercion of data types, in binder implementations that coerce types. If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.  Note   For example, if a binder implementation allows coercion of string values to numeric types, this parameter is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, because 1000 is represented differently by different cultures. The default binder does not do such string coercions.</param>
        <param name="names">The parameter names, if parameter names are to be considered when matching, or <see langword="null" /> if arguments are to be treated as purely positional. For example, parameter names must be used if arguments are not supplied in positional order.</param>
        <param name="state">After the method returns, <c>state</c> contains a binder-provided object that keeps track of argument reordering. The binder creates this object, and the binder is the sole consumer of this object. If <c>state</c> is not <see langword="null" /> when <see langword="BindToMethod" /> returns, you must pass <c>state</c> to the <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" /> method if you want to restore <c>args</c> to its original order, for example, so that you can retrieve the values of <see langword="ref" /> parameters (<see langword="ByRef" /> parameters in Visual Basic).</param>
        <summary>Selects a method to invoke from the given set of methods, based on the supplied arguments.</summary>
        <returns>The matching method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il binder predefinito prende in considerazione entrambi i parametri con valori e `params` matrici (`ParamArray` matrici in Visual Basic). Pertanto, è possibile trovare una corrispondenza nei casi in cui `args` e `match` non contengono lo stesso numero di elementi.  
  
 Lo strumento di associazione consente a un client eseguire il mapping della matrice di argomenti alla forma originale se la matrice di argomenti è stata modificata da <xref:System.Reflection.Binder.BindToMethod%2A>. Utilizzare questa funzionalità di modifica del mapping per ottenere nuovamente gli argomenti per riferimento quando sono presenti tali argomenti. Quando si passano argomenti in base al nome, lo strumento di associazione Riordina la matrice di argomenti. Il `state` parametro tiene traccia di riordino degli argomenti, rendendo il gestore di associazione <xref:System.Reflection.Binder.ReorderArgumentArray%2A> metodo per riordinare la matrice di argomenti alla forma originale.  
  
 Il <xref:System.Reflection.Binder.BindToMethod%2A> metodo viene utilizzato il <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">For the default binder, <paramref name="match" /> contains multiple methods that are equally good matches for <paramref name="args" />. For example, <paramref name="args" /> contains a <c>MyClass</c> object that implements the <c>IMyClass</c> interface, and <paramref name="match" /> contains a method that takes <c>MyClass</c> and a method that takes <c>IMyClass</c>.</exception>
        <exception cref="T:System.MissingMethodException">For the default binder, <paramref name="match" /> contains no methods that can accept the arguments supplied in <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentException">For the default binder, <paramref name="match" /> is <see langword="null" /> or an empty array.</exception>
        <altmember cref="T:System.Reflection.MethodBase" />
      </Docs>
    </Member>
    <Member MemberName="CanChangeType">
      <MemberSignature Language="C#" Value="public virtual bool CanChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.CanChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool&#xA;override this.CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool" Usage="binder.CanChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="type">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public abstract object ChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ ChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member ChangeType : obj * Type * System.Globalization.CultureInfo -&gt; obj" Usage="binder.ChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">The object to change into a new <see langword="Type" />.</param>
        <param name="type">The new <see langword="Type" /> that <c>value</c> will become.</param>
        <param name="culture">An instance of <see cref="T:System.Globalization.CultureInfo" /> that is used to control the coercion of data types. If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.  Note   For example, this parameter is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, because 1000 is represented differently by different cultures.</param>
        <summary>Changes the type of the given <see langword="Object" /> to the given <see langword="Type" />.</summary>
        <returns>An object that contains the given value as the new type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reflection modella le regole di accessibilità di common type system. Ad esempio, se il chiamante è nello stesso assembly, il chiamante necessita di speciali autorizzazioni per i membri interni. In caso contrario, il chiamante deve <xref:System.Security.Permissions.ReflectionPermission>. Ciò è coerente con la ricerca di membri che sono protetti, privato e così via.  
  
 Il principio generale è che `ChangeType` deve eseguire solo widening coercizioni, che non comportano la perdita dei dati. Un esempio di una coercizione di ampliamento consiste nell'assegnare un valore che è un intero con segno a 32 bit su un valore che è un intero con segno a 64 bit. Ciò si differenzia da un tipo di assegnazione forzata, che potrebbe perdere dati. Un esempio di una coercizione di restrizione consiste nell'assegnare un intero con segno a 64 bit in un intero con segno a 32 bit.  
  
 La tabella seguente elenca le coercizioni eseguite dall'oggetto predefinito `ChangeType`.  
  
|Tipo di origine|Tipo di destinazione|  
|-----------------|-----------------|  
|Qualsiasi tipo|Il tipo di base.|  
|Qualsiasi tipo|Implementa l'interfaccia.|  
|Char|UInt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Non-riferimento|In base al riferimento.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReorderArgumentArray">
      <MemberSignature Language="C#" Value="public abstract void ReorderArgumentArray (ref object[] args, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReorderArgumentArray(object[]&amp; args, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ReorderArgumentArray (ByRef args As Object(), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ReorderArgumentArray(cli::array &lt;System::Object ^&gt; ^ % args, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member ReorderArgumentArray :  * obj -&gt; unit" Usage="binder.ReorderArgumentArray (args, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]&amp;" RefType="ref" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="args">The actual arguments that are passed in. Both the types and values of the arguments can be changed.</param>
        <param name="state">A binder-provided object that keeps track of argument reordering.</param>
        <summary>Upon returning from <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, restores the <paramref name="args" /> argument to what it was when it came from <see langword="BindToMethod" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Common language runtime chiama questo metodo se `state` non è `null` dopo la restituzione da `BindToMethod`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase SelectMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase SelectMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectMethod (bindingAttr As BindingFlags, match As MethodBase(), types As Type(), modifiers As ParameterModifier()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ SelectMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodBase" Usage="binder.SelectMethod (bindingAttr, match, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values.</param>
        <param name="match">The set of methods that are candidates for matching. For example, when a <see cref="T:System.Reflection.Binder" /> object is used by <see cref="Overload:System.Type.InvokeMember" />, this parameter specifies the set of methods that reflection has determined to be possible matches, typically because they have the correct member name. The default implementation provided by <see cref="P:System.Type.DefaultBinder" /> changes the order of this array.</param>
        <param name="types">The parameter types used to locate a matching method.</param>
        <param name="modifiers">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</param>
        <summary>Selects a method from the given set of methods, based on the argument type.</summary>
        <returns>The matching method, if found; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve restituire `null` se nessun metodo corrisponde ai criteri. Questo metodo controlla la selezione fornita per il `GetConstructor` e `GetMethod` metodi su `Type`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">For the default binder, <paramref name="match" /> contains multiple methods that are equally good matches for the parameter types described by <paramref name="types" />. For example, the array in <paramref name="types" /> contains a <see cref="T:System.Type" /> object for <c>MyClass</c> and the array in <paramref name="match" /> contains a method that takes a base class of <c>MyClass</c> and a method that takes an interface that <c>MyClass</c> implements.</exception>
        <exception cref="T:System.ArgumentException">For the default binder, <paramref name="match" /> is <see langword="null" /> or an empty array.  -or-  An element of <paramref name="types" /> derives from <see cref="T:System.Type" />, but is not of type <see langword="RuntimeType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectProperty">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo SelectProperty (System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, Type returnType, Type[] indexes, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo SelectProperty(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.PropertyInfo[] match, class System.Type returnType, class System.Type[] indexes, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectProperty (bindingAttr As BindingFlags, match As PropertyInfo(), returnType As Type, indexes As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::PropertyInfo ^ SelectProperty(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ match, Type ^ returnType, cli::array &lt;Type ^&gt; ^ indexes, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectProperty : System.Reflection.BindingFlags * System.Reflection.PropertyInfo[] * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="binder.SelectProperty (bindingAttr, match, returnType, indexes, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.PropertyInfo[]" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="indexes" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values.</param>
        <param name="match">The set of properties that are candidates for matching. For example, when a <see cref="T:System.Reflection.Binder" /> object is used by <see cref="Overload:System.Type.InvokeMember" />, this parameter specifies the set of properties that reflection has determined to be possible matches, typically because they have the correct member name. The default implementation provided by <see cref="P:System.Type.DefaultBinder" /> changes the order of this array.</param>
        <param name="returnType">The return value the matching property must have.</param>
        <param name="indexes">The index types of the property being searched for. Used for index properties such as the indexer for a class.</param>
        <param name="modifiers">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</param>
        <summary>Selects a property from the given set of properties, based on the specified criteria.</summary>
        <returns>The matching property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo controlla la selezione fornita per il `GetProperty` metodo su `Type`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">For the default binder, <paramref name="match" /> contains multiple properties that are equally good matches for <paramref name="returnType" /> and <paramref name="indexes" />.</exception>
        <exception cref="T:System.ArgumentException">For the default binder, <paramref name="match" /> is <see langword="null" /> or an empty array.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>