<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodInfo.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cd4ae293dba419bbcd758325322617d8b6cce4b7.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd4ae293dba419bbcd758325322617d8b6cce4b7</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodInfo">
          <source>Discovers the attributes of a method and provides access to method metadata.</source>
          <target state="translated">Individua gli attributi di un metodo e consente di accedere ai relativi metadati.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class represents a method of a type.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> classe rappresenta un metodo di un tipo.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can use a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object to obtain information about the method that the object represents and to invoke the method.</source>
          <target state="translated">È possibile utilizzare un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto per ottenere informazioni sul metodo che rappresenta l'oggetto e richiamare il metodo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can determine the method's visibility by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsPrivate%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> properties.</source>
          <target state="translated">È possibile determinare la visibilità del metodo tramite il recupero dei valori del <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsPrivate%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can discover what attributes are applied to the method by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Attributes%2A&gt;</ph> property or calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> method.</source>
          <target state="translated">È possibile individuare gli attributi che vengono applicati al metodo per il recupero del valore del <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Attributes%2A&gt;</ph> proprietà o chiamare il <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> properties.</source>
          <target state="translated">È possibile determinare se il metodo è un metodo generico, aperto un metodo generico costruito o un costruito chiuso un metodo generico, recuperando i valori del <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can get information about the method's parameters and return type from the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ReturnParameter%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> properties.</source>
          <target state="translated">È possibile ottenere informazioni sui parametri del metodo e tipo da restituire il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ReturnParameter%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can execute a method on a class instance by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">È possibile eseguire un metodo in un'istanza della classe chiamando il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a constructed generic method from one that represents a generic method definition by calling the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">È possibile creare un'istanza di un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta un metodo generico costruito da uno che rappresenta una definizione di metodo generico chiamando il <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> instances by calling the <ph id="ph2">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Type.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method, or by calling the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
          <target state="translated">È possibile creare un'istanza di un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> istanze chiamando il <ph id="ph2">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.Type.GetMethod%2A?displayProperty=nameWithType&gt;</ph> metodo, o chiamando il <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> metodo di un <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta una definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>for full trust for inheritors.</source>
          <target state="translated">per l'attendibilità totale per gli eredi.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Questa classe non può essere ereditata da codice parzialmente attendibile.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>This type is thread safe.</source>
          <target state="translated">Questo tipo è thread-safe.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, you must override <ph id="ph2">&lt;see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" /&gt;</ph>, <ph id="ph3">&lt;see cref="P:System.Reflection.MethodInfo.ReturnType" /&gt;</ph>, <ph id="ph4">&lt;see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph9">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph11">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph12">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph13">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph14">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph15">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, and <ph id="ph16">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">Quando si eredita da <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, è necessario eseguire l'override <ph id="ph2">&lt;see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" /&gt;</ph>, <ph id="ph3">&lt;see cref="P:System.Reflection.MethodInfo.ReturnType" /&gt;</ph>, <ph id="ph4">&lt;see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph9">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph11">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph12">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph13">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph14">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph15">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, e <ph id="ph16">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodInfo">
          <source>Creates a delegate from this method.</source>
          <target state="translated">Crea un delegato da questo metodo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>The type of the delegate to create.</source>
          <target state="translated">Tipo del delegato da creare.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>Creates a delegate of the specified type from this method.</source>
          <target state="translated">Crea un delegato del tipo specificato da questo metodo.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>The delegate for this method.</source>
          <target state="translated">Delegato per questo metodo.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The type of the delegate to create.</source>
          <target state="translated">Tipo del delegato da creare.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The object targeted by the delegate.</source>
          <target state="translated">Oggetto impostato come destinazione dal delegato.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>Creates a delegate of the specified type with the specified target from this method.</source>
          <target state="translated">Crea un delegato del tipo specificato con la destinazione specificata da questo metodo.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The delegate for this method.</source>
          <target state="translated">Delegato per questo metodo.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto da confrontare con questa istanza o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">Restituisce un valore che indica se questa istanza è uguale a un oggetto specificato.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> è uguale al tipo e al valore di questa istanza; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</source>
          <target state="translated">Quando ne viene eseguito l'override in una classe derivata,, restituisce l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> relativo al metodo presente nella classe base diretta o indiretta in cui il metodo rappresentato da questa istanza è stato inizialmente dichiarato.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object for the first implementation of this method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> per la prima implementazione di questo metodo.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the first definition of the specified method in the class hierarchy.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> metodo restituisce la prima definizione del metodo specificato nella gerarchia delle classi.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can determine the type on which the first definition of the method is found by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">È possibile determinare il tipo in cui si trova la prima definizione del metodo recuperando il valore di <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> proprietà sull'oggetto restituito <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method behaves as follows:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> metodo si comporta come segue:</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an interface implementation, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Se l'oggetto corrente <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto rappresenta un'implementazione di interfaccia, il <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> il metodo restituisce l'attuale <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that overrides a virtual definition in a base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the virtual definition.</source>
          <target state="translated">Se corrente <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto rappresenta un metodo che esegue l'override di una definizione virtuale in una classe base, il <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> metodo restituisce un <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta la definizione virtuale.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is specified with the <ph id="ph2">`new`</ph> keyword in C# or the <ph id="ph3">`Shadows`</ph> keyword in Visual Basic (as in <ph id="ph4">`newslot`</ph>, as described in <bpt id="p1">[</bpt>Common Type System<ept id="p1">](~/docs/standard/base-types/common-type-system.md)</ept>), the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Se corrente <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto rappresenta un metodo specificato con il <ph id="ph2">`new`</ph> (parola chiave) in c# o <ph id="ph3">`Shadows`</ph> parola chiave in Visual Basic (come in <ph id="ph4">`newslot`</ph>, come descritto in <bpt id="p1">[</bpt>Common Type System<ept id="p1">](~/docs/standard/base-types/common-type-system.md)</ept>), il <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> il metodo restituisce l'attuale <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an inherited method (that is, the current method does not provide its own implementation), the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the lowest method in the class hierarchy.</source>
          <target state="translated">Se corrente <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto rappresenta un metodo ereditato (ovvero, il metodo corrente non fornisce la propria implementazione), il <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> metodo restituisce un <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta il metodo più basso nella gerarchia delle classi.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>For example, if <ph id="ph1">`Base.ToString`</ph> overrides <ph id="ph2">`Object.ToString`</ph>, and <ph id="ph3">`Derived.ToString`</ph> overrides <ph id="ph4">`Base.ToString`</ph>, calling the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method on a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph7">`Derived.ToString`</ph> returns a <ph id="ph8">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph9">`Object.ToString`</ph>.</source>
          <target state="translated">Ad esempio, se <ph id="ph1">`Base.ToString`</ph> esegue l'override <ph id="ph2">`Object.ToString`</ph>, e <ph id="ph3">`Derived.ToString`</ph> esegue l'override <ph id="ph4">`Base.ToString`</ph>, la chiamata di <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> metodo su un <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta <ph id="ph7">`Derived.ToString`</ph> restituisce un <ph id="ph8">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta <ph id="ph9">`Object.ToString`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is not present in any base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Se l'oggetto corrente <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto rappresenta un metodo che non è presente in qualsiasi classe di base, il <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> il metodo restituisce l'attuale <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method.</source>
          <target state="translated">È possibile determinare se il metodo corrente esegue l'override di un metodo in una classe base chiamando il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
          <target state="translated">Nell'esempio seguente viene implementato un <ph id="ph1">`IsOverride`</ph> metodo che esegue questa operazione.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>To call the <ph id="ph1">`GetBaseDefinition`</ph> method:</source>
          <target state="translated">Per chiamare il <ph id="ph1">`GetBaseDefinition`</ph> metodo:</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type (the class or structure) that contains the property.</source>
          <target state="translated">Ottenere un <ph id="ph1">&lt;xref:System.Type&gt;</ph> oggetto che rappresenta il tipo (la classe o struttura) che contiene la proprietà.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If you are working with an object (an instance of a type), you can call its <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method.</source>
          <target state="translated">Se si lavora con un oggetto (un'istanza di un tipo), è possibile chiamare il relativo <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Otherwise, you can use the C#  operator or the Visual Basic  operator, as the example illustrates.</source>
          <target state="translated">In caso contrario, è possibile utilizzare l'operatore in c# o l'operatore di Visual Basic, come illustra l'esempio.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Get a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method in which you're interested.</source>
          <target state="translated">Ottenere un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta il metodo in cui si è interessati.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can do this by getting an array of all methods from the <ph id="ph1">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> method and then iterating the elements in the array, or you can retrieve the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method directly by calling the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType&gt;</ph> method and specifying the method name.</source>
          <target state="translated">È possibile farlo tramite il recupero di una matrice di tutti i metodi dal <ph id="ph1">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> (metodo) e quindi si esegue l'iterazione gli elementi di matrice o è possibile recuperare il <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta il metodo chiamando direttamente il <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType&gt;</ph> metodo e specificando il nome del metodo.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method to get the value of the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the base method definition.</source>
          <target state="translated">Chiamare il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> metodo per ottenere il valore di <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta la definizione di metodo di base.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The following example demonstrates the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il comportamento del <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresentano gli argomenti di tipo di un metodo generico o i parametri di tipo della definizione di un metodo generico.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresentano gli argomenti di tipo di un metodo generico o i parametri di tipo della definizione di un metodo generica.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Returns an empty array if the current method is not a generic method.</source>
          <target state="translated">Restituisce una matrice vuota se il metodo corrente non è un metodo generico.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
          <target state="translated">Gli elementi della matrice restituita sono nell'ordine in cui compaiono nell'elenco dei parametri di tipo per il metodo generico.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
          <target state="translated">Se il metodo corrente è un metodo costruito chiuso (vale a dire il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> restituisce proprietà <ph id="ph2">`false`</ph>), la matrice restituita dal <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> metodo contiene i tipi che sono stati assegnati ai parametri di tipo generico del metodo generico definizione.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
          <target state="translated">Se il metodo corrente è una definizione di metodo generico, la matrice contiene i parametri di tipo.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
          <target state="translated">Se il metodo corrente è un metodo costruito aperto (ovvero, il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> restituisce proprietà <ph id="ph2">`true`</ph>) in tipi specifici assegnati ad alcuni parametri di tipo e il tipo di parametri di tipi generici di inclusione sono stati assegnati a altro tipo i parametri, la matrice contiene i tipi e tipo di parametri.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> proprietà per distinguerli.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Per una dimostrazione di questo scenario, vedere l'esempio di codice per il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>The following code example shows how to get the type arguments of a generic method and display them.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ottenere gli argomenti di tipo di un metodo generico e visualizzarli.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">In questo esempio fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>This method is not supported.</source>
          <target state="translated">Questo metodo non è supportato.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents a generic method definition from which the current method can be constructed.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> che rappresenta la definizione di un metodo generica da cui è possibile costruire il metodo corrente.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object representing a generic method definition from which the current method can be constructed.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> che rappresenta la definizione di un metodo generica da cui è possibile costruire il metodo corrente.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>A generic method definition is a template from which methods can be constructed.</source>
          <target state="translated">Una definizione di metodo generico è un modello da cui è possibile costruire i metodi.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For example, from the generic method definition <ph id="ph1">`T M&lt;T&gt;(T t)`</ph> (expressed in C# syntax; <ph id="ph2">`Function M(Of T)(ByVal tVal As T) As T`</ph> in Visual Basic) you can construct and invoke the method <ph id="ph3">`int M&lt;int&gt;(int t)`</ph> (<ph id="ph4">`Function M(Of Integer)(ByVal tVal As Integer) As Integer`</ph> in Visual Basic).</source>
          <target state="translated">Ad esempio, dalla definizione di metodo generico <ph id="ph1">`T M&lt;T&gt;(T t)`</ph> (espressi nella sintassi c#; <ph id="ph2">`Function M(Of T)(ByVal tVal As T) As T`</ph> in Visual Basic) è possibile creare e richiamare il metodo <ph id="ph3">`int M&lt;int&gt;(int t)`</ph> (<ph id="ph4">`Function M(Of Integer)(ByVal tVal As Integer) As Integer`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object representing this constructed method, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the generic method definition.</source>
          <target state="translated">Dato un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta questo metodo, costruito il <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> metodo restituisce la definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If two constructed methods are created from the same generic method definition, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for both methods.</source>
          <target state="translated">Se vengono creati due metodi costruiti dalla stessa definizione di metodo generico, la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> metodo restituisce lo stesso <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto per entrambi i metodi.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If you call <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that already represents a generic method definition, it returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Se si chiama <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> su un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> che già rappresenta una definizione di metodo generico, restituisce l'oggetto corrente <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</source>
          <target state="translated">Se una definizione di metodo generico contiene parametri generici del tipo dichiarante, esisterà una definizione di metodo generico specifiche di ogni tipo costruito.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For example, consider the following C#, Visual Basic, and C++ code:</source>
          <target state="translated">Ad esempio, si consideri il seguente codice c#, Visual Basic e C++:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the generic method <ph id="ph3">`M`</ph> returns <ph id="ph4">`B&lt;int, S&gt;`</ph>.</source>
          <target state="translated">Nel tipo costruito <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), il metodo generico <ph id="ph3">`M`</ph> restituisce <ph id="ph4">`B&lt;int, S&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the open type <ph id="ph1">`C&lt;T&gt;`</ph>, <ph id="ph2">`M`</ph> returns <ph id="ph3">`B&lt;T, S&gt;`</ph>.</source>
          <target state="translated">Nel tipo aperto <ph id="ph1">`C&lt;T&gt;`</ph>, <ph id="ph2">`M`</ph> restituisce <ph id="ph3">`B&lt;T, S&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents <ph id="ph4">`M`</ph>, so <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> can be called on both <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects.</source>
          <target state="translated">In entrambi i casi, il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethodDefinition%2A&gt;</ph> restituisce proprietà <ph id="ph2">`true`</ph> per il <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> che rappresenta <ph id="ph4">`M`</ph>, pertanto <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> può essere chiamata su entrambi <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetti.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the case of the constructed type, the result of calling <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> is a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can be invoked.</source>
          <target state="translated">Nel caso il tipo costruito, il risultato della chiamata <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> è un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> che può essere richiamato.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the case of the open type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> returned by <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> cannot be invoked.</source>
          <target state="translated">Nel caso del tipo aperto, il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> restituito da <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> non può essere richiamato.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>The following code example shows a class with a generic method and the code required to obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the method, bind the method to type arguments, and get the original generic type definition back from the bound method.</source>
          <target state="translated">Esempio di codice seguente viene illustrata una classe con un metodo generico e il codice necessario per ottenere un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> per il metodo, associare il metodo per gli argomenti di tipo e tornare alla definizione di tipo generico originale dal metodo associato.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">In questo esempio fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>The current method is not a generic method.</source>
          <target state="translated">Il metodo corrente non è un metodo generico.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.IsGenericMethod" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ciò significa che <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.IsGenericMethod" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>This method is not supported.</source>
          <target state="translated">Questo metodo non è supportato.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Restituisce il codice hash per l'istanza.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Codice hash di un intero con segno a 32 bit.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic method definition.</source>
          <target state="translated">Matrice di tipi con cui sostituire i parametri di tipo della definizione del metodo generica corrente.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object representing the resulting constructed method.</source>
          <target state="translated">Sostituisce con gli elementi di una matrice di tipi i parametri di tipo della definizione di metodo generica corrente e restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> che rappresenta il metodo costruito risultante.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents the constructed method formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic method definition.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> che rappresenta il metodo costruito ottenuto sostituendo gli elementi di <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> per i parametri di tipo della definizione di metodo generica corrente.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a particular constructed method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> metodo consente di scrivere codice per tipi specifici di assegnare ai parametri di tipo di una definizione di metodo generico, creando così un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta un determinato metodo costruito.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property of this <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object returns <ph id="ph3">`true`</ph>, you can use it to invoke the method or to create a delegate to invoke the method.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> proprietà di questo <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto restituisce <ph id="ph3">`true`</ph>, è possibile utilizzare per richiamare il metodo o per creare un delegato per richiamare il metodo.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Methods constructed with the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</source>
          <target state="translated">Metodi costruito con la <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> metodo può essere aperto, vale a dire, alcuni dei relativi argomenti di tipo possono essere parametri di tipo di inclusione di tipi generici.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>You might use such open constructed methods when you generate dynamic assemblies.</source>
          <target state="translated">È possibile utilizzare tali metodi costruiti aperti quando si generano assembly dinamici.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For example, consider the following C#, Visual Basic, and C++ code.</source>
          <target state="translated">Ad esempio, si consideri il seguente codice c#, Visual Basic e C++.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The method body of <ph id="ph1">`M`</ph> contains a call to method <ph id="ph2">`N`</ph>, specifying the type parameter of <ph id="ph3">`M`</ph> and the type <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Il corpo del metodo di <ph id="ph1">`M`</ph> contiene una chiamata al metodo <ph id="ph2">`N`</ph>, specificando il parametro di tipo <ph id="ph3">`M`</ph> e il tipo <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for method <ph id="ph3">`N&lt;V,int&gt;`</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> restituisce proprietà <ph id="ph2">`false`</ph> per il metodo <ph id="ph3">`N&lt;V,int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, so method <ph id="ph3">`N&lt;V,int&gt;`</ph> cannot be invoked.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> restituisce proprietà <ph id="ph2">`true`</ph>, in questo metodo <ph id="ph3">`N&lt;V,int&gt;`</ph> non può essere richiamato.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per condizioni specifiche per i metodi generici, vedere il <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Per un elenco delle condizioni invarianti per altri termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The following code example demonstrates the properties and methods of <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that support the examination of generic methods.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come le proprietà e metodi di <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> che supportano l'analisi di metodi generici.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The example does the following:</source>
          <target state="translated">L'esempio esegue le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Defines a class that has a generic method.</source>
          <target state="translated">Definisce una classe che ha un metodo generico.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Creates a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the generic method.</source>
          <target state="translated">Crea un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> che rappresenta il metodo generico.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Displays properties of the generic method definition.</source>
          <target state="translated">Visualizza le proprietà della definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Assigns type arguments to the type parameters of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, and invokes the resulting constructed generic method.</source>
          <target state="translated">Argomenti per i parametri di tipo del tipo assegna il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>e richiama il metodo generico costruito risultante.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Displays properties of the constructed generic method.</source>
          <target state="translated">Visualizza le proprietà del metodo generico costruito.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Retrieves the generic method definition from the constructed method and compares it to the original definition.</source>
          <target state="translated">Recupera la definizione di metodo generico dal metodo costruito e lo confronta con la definizione originale.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> does not represent a generic method definition.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> corrente non rappresenta una definizione di metodo generica,</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ciò significa che <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Qualsiasi elemento di <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is not the same as the number of type parameters of the current generic method definition.</source>
          <target state="translated">Il numero di elementi in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> non corrisponde al numero di parametri di tipo nella definizione del metodo generica corrente.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</source>
          <target state="translated">Uno degli elementi di <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> non soddisfa i vincoli specificati per il parametro di tipo corrispondente della definizione di metodo generica corrente.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>This method is not supported.</source>
          <target state="translated">Questo metodo non è supportato.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a method.</source>
          <target state="translated">Ottiene un valore <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> che indica che questo membro è un metodo.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a method.</source>
          <target state="translated">Valore <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> che indica che questo membro è un metodo.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Esegue l'override di questa proprietà <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects — for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> — the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType&gt;</ph> only when a given member is a method.</source>
          <target state="translated">Pertanto, quando si esamina un set di <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> oggetti, ad esempio, la matrice restituita dal <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> : il <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> restituisce proprietà <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType&gt;</ph> solo quando un membro specificato è un metodo.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>To get the <ph id="ph1">`MemberType`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">Per ottenere il <ph id="ph1">`MemberType`</ph> proprietà, ottenere innanzitutto la classe <ph id="ph2">`Type`</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
          <target state="translated">Dal <ph id="ph1">`Type`</ph>, ottenere il <ph id="ph2">`MethodInfo`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`MemberType`</ph>.</source>
          <target state="translated">Dal <ph id="ph1">`MethodInfo`</ph>, ottenere il <ph id="ph2">`MemberType`</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>The following example displays the type of the specified member.</source>
          <target state="translated">Nell'esempio seguente visualizza il tipo del membro specificato.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The first object to compare.</source>
          <target state="translated">Primo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The second object to compare.</source>
          <target state="translated">Secondo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica se due oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> sono uguali.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> è uguale a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The first object to compare.</source>
          <target state="translated">Primo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The second object to compare.</source>
          <target state="translated">Secondo oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica se due oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> non sono uguali.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> non è uguale a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> contenente informazioni sul tipo restituito dal metodo, ad esempio se il tipo restituito contiene modificatori personalizzati.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> contenente informazioni relative al tipo restituito.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>Compiler designers can use the <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> object returned by this property to discover whether custom modifiers, such as <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, have been applied to the return type.</source>
          <target state="translated">Finestre di progettazione del compilatore è possibile utilizzare il <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> oggetto restituito da questa proprietà per determinare se personalizzato modificatori, ad esempio <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, sono stati applicati al tipo restituito.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>This method is not implemented.</source>
          <target state="translated">Questo metodo non è implementato.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>Gets the return type of this method.</source>
          <target state="translated">Ottiene il tipo restituito di questo metodo.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>The return type of this method.</source>
          <target state="translated">Il tipo restituito di questo metodo.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>To get the return type property, first get the class <ph id="ph1">`Type`</ph>.</source>
          <target state="translated">Per ottenere la proprietà del tipo restituito, ottenere innanzitutto la classe <ph id="ph1">`Type`</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
          <target state="translated">Dal <ph id="ph1">`Type`</ph>, ottenere il <ph id="ph2">`MethodInfo`</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`ReturnType`</ph>.</source>
          <target state="translated">Dal <ph id="ph1">`MethodInfo`</ph>, ottenere il <ph id="ph2">`ReturnType`</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>The following example displays the return type of the specified method.</source>
          <target state="translated">Nell'esempio seguente viene visualizzato il tipo restituito del metodo specificato.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes">
          <source>Gets the custom attributes for the return type.</source>
          <target state="translated">Ottiene gli attributi personalizzati per il tipo restituito.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes">
          <source>An <ph id="ph1">&lt;see langword="ICustomAttributeProvider" /&gt;</ph> object representing the custom attributes for the return type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see langword="ICustomAttributeProvider" /&gt;</ph> che rappresenta gli attributi personalizzati per il tipo restituito.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matrice di nomi passata di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Conteggio dei nomi di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contesto delle impostazioni locali in cui interpretare i nomi.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType">
          <source>Provides access to the <ph id="ph1">&lt;see cref="M:System.Object.GetType" /&gt;</ph> method from COM.</source>
          <target state="translated">Fornisce l'accesso al metodo <ph id="ph1">&lt;see cref="M:System.Object.GetType" /&gt;</ph> da COM.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Informazioni sul tipo da restituire.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificatore delle impostazioni locali per le informazioni sul tipo.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can be used to get the type information for an interface.</source>
          <target state="translated">Recupera le informazioni sul tipo relative a un oggetto, che possono essere usate per ottenere informazioni sul tipo relative a un'interfaccia.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica il membro.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flag che descrivono il contesto della chiamata.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntatore alla posizione in cui deve essere archiviato il risultato.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntatore a una struttura contenente informazioni sull'eccezione.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Indice del primo argomento che contiene un errore.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::Invoke`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>