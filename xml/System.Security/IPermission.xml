<Type Name="IPermission" FullName="System.Security.IPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ab62c8d43e0ca696a66655b37755ebe3e68e56e6" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30499665" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IPermission : System.Security.ISecurityEncodable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IPermission implements class System.Security.ISecurityEncodable" />
  <TypeSignature Language="DocId" Value="T:System.Security.IPermission" />
  <TypeSignature Language="VB.NET" Value="Public Interface IPermission&#xA;Implements ISecurityEncodable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IPermission : System::Security::ISecurityEncodable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definisce metodi implementati da tipi di autorizzazioni.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le autorizzazioni in common language runtime sono oggetti che descrivono i set di operazioni che possono essere protette per le risorse specificate. Un oggetto di autorizzazione descrive le operazioni o accesso che è soggetto a controllo di sicurezza. non rappresenta un diritto di eseguire operazioni o di accesso. Le autorizzazioni sono utilizzate dal codice dell'applicazione e il sistema di sicurezza di .NET Framework nei modi seguenti.  
  
-   Codice richiede le autorizzazioni che necessarie per l'esecuzione.  
  
-   I criteri di sistema di sicurezza concedono le autorizzazioni al codice in modo che per l'esecuzione.  
  
-   Il codice richiede che il codice chiamante disponga di un'autorizzazione.  
  
-   Codice esegue l'override dello stack di sicurezza solo utilizzando assert/deny/autorizzazione.  
  
> [!NOTE]
>  Se si scrive una nuova autorizzazione, è necessario implementare questa interfaccia della classe.  
  
> [!IMPORTANT]
>  Un'autorizzazione può accedere da più thread. Quando si implementa questa interfaccia, è necessario garantire che il <xref:System.Security.IPermission.IsSubsetOf%2A>, <xref:System.Security.IPermission.Intersect%2A>, <xref:System.Security.IPermission.Union%2A>, e <xref:System.Security.IPermission.Copy%2A> implementazioni del metodo sono thread-safe.  
  
   
  
## Examples  
 In questo esempio viene illustrato come definire una classe di autorizzazioni per l'utilizzo con sicurezza dall'accesso di codice. Vengono implementate tutte le interfacce di autorizzazione necessaria.  
  
 [!code-cpp[Permission#1](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#1)]
 [!code-csharp[Permission#1](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#1)]
 [!code-vb[Permission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::IPermission ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea e restituisce una copia identica dell'autorizzazione corrente.</summary>
        <returns>Copia dell'autorizzazione corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia di un'autorizzazione rappresenta lo stesso accesso alle risorse dell'autorizzazione originale.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'implementazione di <xref:System.Security.IPermission.Copy%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.IPermission> classe.  
  
 [!code-cpp[Permission#4](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#4)]
 [!code-csharp[Permission#4](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#4)]
 [!code-vb[Permission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera un'eccezione <see cref="T:System.Security.SecurityException" /> in fase di esecuzione se non viene soddisfatto il requisito di sicurezza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene in genere utilizzato da librerie protette per garantire che i chiamanti dispongano dell'autorizzazione per accedere a una risorsa. Ad esempio, una classe di file in una libreria di classi protette chiama <xref:System.Security.CodeAccessPermission.Demand%2A> per gli oggetti necessari <xref:System.Security.Permissions.FileIOPermission> prima di eseguire un'operazione di file richiesta dal chiamante.  
  
 Sebbene la maggior parte delle classi che implementano questo metodo di interfaccia soddisfino i criteri di sicurezza mediante l'esecuzione di un percorso stack completo, un percorso stack non viene necessariamente eseguito. Un esempio di un'implementazione che non esegue un'analisi dello stack è <xref:System.Security.Permissions.PrincipalPermission.Demand%2A?displayProperty=nameWithType>.  
  
 Quando viene eseguita un'analisi dello stack, le autorizzazioni del codice che chiama questo metodo non vengono esaminate; il controllo inizia da parte del chiamante immediato del codice e continua fino allo stack. Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate. <xref:System.Security.CodeAccessPermission.Demand%2A> ha esito positivo solo se nessun <xref:System.Security.SecurityException> viene generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorizzazione da intersecare con quella corrente. Deve essere dello stesso tipo dell'autorizzazione corrente.</param>
        <summary>Crea e restituisce un'autorizzazione che rappresenta l'intersezione tra l'autorizzazione corrente e quella specificata.</summary>
        <returns>Nuova autorizzazione che rappresenta l'intersezione dell'autorizzazione corrente e di quella specificata. La nuova autorizzazione è <see langword="null" /> se l'intersezione è vuota.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'intersezione delle due autorizzazioni è un'autorizzazione che descrive il set di operazioni che hanno in comune. Solo una richiesta che supera entrambe le autorizzazioni originali passerà l'intersezione.  
  
 Le istruzioni seguenti devono essere true per tutte le implementazioni del <xref:System.Security.IPermission.Intersect%2A> metodo. `X` e `Y` rappresentano <xref:System.Security.IPermission> riferimenti agli oggetti che non sono `null`.  
  
-   `X`. Intersect (`X`) restituisce un valore pari a `X`.  
  
-   `X`. Intersect (`Y`) restituisce lo stesso valore di `Y`. Intersect (`X`).  
  
-   `X`. Intersect (`null`) restituisce `null`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'implementazione di <xref:System.Security.IPermission.Intersect%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.IPermission> classe.  
  
 [!code-cpp[Permission#2](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#2)]
 [!code-csharp[Permission#2](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#2)]
 [!code-vb[Permission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="target" /> non è <see langword="null" /> e non è un'istanza della stessa classe dell'autorizzazione corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorizzazione da testare per la relazione del subset. Questa autorizzazione deve essere dello stesso tipo di quella corrente.</param>
        <summary>Determina se l'autorizzazione corrente è un subset di quella specificata.</summary>
        <returns>
          <see langword="true" /> se l'autorizzazione corrente è un sottoinsieme dell'autorizzazione specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'autorizzazione corrente specifica un set di operazioni che è interamente contenuto l'autorizzazione specificata, l'autorizzazione corrente è un subset dell'autorizzazione specificata. Ad esempio, un'autorizzazione che rappresenta l'accesso a C:\example.txt è un subset di un'autorizzazione che rappresenta l'accesso in c:\\. Se questo metodo restituisce `true`, l'autorizzazione corrente non rappresenta un accesso alla risorsa protetta rispetto a quello dell'autorizzazione specificata.  
  
 Le istruzioni seguenti devono essere true per tutte le implementazioni del <xref:System.Security.IPermission.IsSubsetOf%2A> metodo. `X`, `Y`, e `Z` rappresentano <xref:System.Security.IPermission> gli oggetti che non `null`.  
  
-   `X`. IsSubsetOf (`X`) restituisce `true`.  
  
-   `X`. IsSubsetOf (`Y`) restituisce lo stesso valore di `Y`. IsSubsetOf (`X`) solo se `X` e `Y` rappresentano lo stesso set di autorizzazioni.  
  
-   Se `X`. IsSubsetOf (`Y`) e `Y`. IsSubsetOf (`Z`) restituiscono entrambi `true`, `X`. IsSubsetOf (`Z`) restituisce `true`.  
  
 Se `X` rappresenta un oggetto vuoto <xref:System.Security.IPermission> oggetto con uno stato di autorizzazione <xref:System.Security.Permissions.PermissionState.None> e `Y` rappresenta un <xref:System.Security.IPermission> oggetto `null`, `X`. IsSubsetOf (`Y`) restituisce `true`. Se `Z` è anche un'autorizzazione vuota, l'operazione di impostazione composta `X`. Union(Z). IsSubsetOf (y) restituisce inoltre `true` perché l'unione delle due autorizzazioni vuote è un'autorizzazione vuota.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'implementazione di <xref:System.Security.IPermission.IsSubsetOf%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.IPermission> classe.  
  
 [!code-cpp[Permission#3](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#3)]
 [!code-csharp[Permission#3](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#3)]
 [!code-vb[Permission#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="target" /> non è <see langword="null" /> ed è di un tipo diverso rispetto all'autorizzazione corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorizzazione da combinare con quella corrente. Deve essere dello stesso tipo dell'autorizzazione corrente.</param>
        <summary>Crea un'autorizzazione che rappresenta l'unione dell'autorizzazione corrente e di quella specificata.</summary>
        <returns>Nuova autorizzazione che rappresenta l'unione dell'autorizzazione corrente e di quella specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il risultato di una chiamata a <xref:System.Security.IPermission.Union%2A> è un'autorizzazione che rappresenta tutte le operazioni indicate sia dell'autorizzazione corrente e l'autorizzazione specificata. Qualsiasi richiesta che passa l'autorizzazione passa l'unione.  
  
 Le istruzioni seguenti devono essere true per tutte le implementazioni del <xref:System.Security.IPermission.Union%2A> metodo. `X` e `Y` rappresentano <xref:System.Security.IPermission> gli oggetti che non `null`.  
  
-   `X`. Union (`X`) restituisce un oggetto che ha lo stesso valore `X`.  
  
-   `X`. Union (`Y`) restituisce un oggetto che ha lo stesso valore dell'oggetto restituito da `Y`. Union (`X`).  
  
-   `X`. Union (`null`) restituisce un oggetto che ha lo stesso valore `X`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'implementazione di <xref:System.Security.IPermission.Union%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.IPermission> classe.  
  
 [!code-cpp[Permission#5](~/samples/snippets/cpp/VS_Snippets_CLR/Permission/cpp/Permission.cpp#5)]
 [!code-csharp[Permission#5](~/samples/snippets/csharp/VS_Snippets_CLR/Permission/CS/Permission.cs#5)]
 [!code-vb[Permission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Permission/vb/permission.vb#5)]  
  
-  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="target" /> non è <see langword="null" /> ed è di un tipo diverso rispetto all'autorizzazione corrente.</exception>
      </Docs>
    </Member>
  </Members>
</Type>