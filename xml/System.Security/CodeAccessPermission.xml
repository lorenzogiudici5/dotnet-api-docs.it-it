<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CodeAccessPermission.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b497a3cd20cb1d0ae8172ce6caf259ae001ddee0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b497a3cd20cb1d0ae8172ce6caf259ae001ddee0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.CodeAccessPermission">
          <source>Defines the underlying structure of all code access permissions.</source>
          <target state="translated">Definisce la struttura sottostante di tutte le autorizzazioni di accesso al codice.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</source>
          <target state="translated">Le autorizzazioni di accesso di codice utilizzano un percorso stack per assicurarsi che tutti i chiamanti del codice sono stata concessa un'autorizzazione.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>If a permission object is <ph id="ph1">`null`</ph>, it is handled the same as a permission object with the state <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se un oggetto di autorizzazione è <ph id="ph1">`null`</ph>, viene gestita come un oggetto di autorizzazione con lo stato <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Inheritors of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class must be granted full trust to function correctly as permissions extending the security infrastructure.</source>
          <target state="translated">Gli eredi di <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe deve essere concessa l'attendibilità totale per il corretto funzionamento delle autorizzazioni estendendo l'infrastruttura di sicurezza.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>To determine that the inheritors are fully trusted, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> issues an <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityAction.InheritanceDemand&gt;</ph> for <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence&gt;</ph><ph id="ph4"> = </ph><ph id="ph5">`true`</ph> and <ph id="ph6">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy&gt;</ph><ph id="ph7"> = </ph><ph id="ph8">`true`</ph>.</source>
          <target state="translated">Per determinare che gli eredi siano completamente attendibili, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> problemi un <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityAction.InheritanceDemand&gt;</ph> per <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence&gt;</ph> <ph id="ph4"> = </ph> <ph id="ph5">`true`</ph> e <ph id="ph6">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy&gt;</ph> <ph id="ph7"> = </ph> <ph id="ph8">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The following code example shows a permission derived from the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">L'esempio di codice seguente mostra un'autorizzazione che deriva dalla <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>for the ability of inheritors to provide evidence and view and modify policy.</source>
          <target state="translated">per consentire agli eredi di fornire l'evidenza e visualizzare e modificare i criteri.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>, you must also implement the <ph id="ph2">&lt;see cref="T:System.Security.Permissions.IUnrestrictedPermission" /&gt;</ph> interface.</source>
          <target state="translated">Quando si eredita da <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>, è necessario implementare anche il <ph id="ph2">&lt;see cref="T:System.Security.Permissions.IUnrestrictedPermission" /&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>The following <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> members must be overridden: <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Copy" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Security.CodeAccessPermission.ToXml" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /&gt;</ph>, and <ph id="ph7">&lt;see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /&gt;</ph>.</source>
          <target state="translated">Nell'esempio <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> necessario eseguire l'override di membri: <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Copy" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Security.CodeAccessPermission.ToXml" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /&gt;</ph>, e <ph id="ph7">&lt;see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>You must also define a constructor that takes a <ph id="ph1">&lt;see cref="T:System.Security.Permissions.PermissionState" /&gt;</ph> as its only parameter.</source>
          <target state="translated">È inoltre necessario definire un costruttore che accetta un <ph id="ph1">&lt;see cref="T:System.Security.Permissions.PermissionState" /&gt;</ph> solo come parametro.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.CodeAccessPermission">
          <source>You must apply the <ph id="ph1">&lt;see cref="T:System.SerializableAttribute" /&gt;</ph> attribute to a class that inherits from <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">È necessario applicare il <ph id="ph1">&lt;see cref="T:System.SerializableAttribute" /&gt;</ph> attributo a una classe che eredita da <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>This constructor is called to initialize state in the type whenever an instance of the derived class is created.</source>
          <target state="translated">Questo costruttore viene chiamato per inizializzare lo stato del tipo ogni volta che viene creata un'istanza della classe derivata.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.#ctor">
          <source>Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</source>
          <target state="translated">Sebbene in modo esplicito, è possibile chiamare questo costruttore nella dichiarazione del costruttore della classe derivata, questo non è in genere necessario; la maggior parte dei compilatori genererà automaticamente la chiamata.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">Dichiara che il codice chiamante può accedere alla risorsa protetta da una richiesta di autorizzazione tramite il codice che chiama il metodo, anche se ai chiamanti più in alto nello stack non è stata concessa l'autorizzazione per accedere alla risorsa.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Using <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> can create security issues.</source>
          <target state="translated">Se si utilizza <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> è possibile creare problemi di sicurezza.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Calling <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</source>
          <target state="translated">La chiamata <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> impedisce a un percorso stack originari inferiore nello stack di chiamate di procedere, lo stack di chiamate oltre il codice che chiama questo metodo.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</source>
          <target state="translated">Pertanto, anche se i chiamanti nello stack di chiamate non dispone di autorizzazioni necessarie per accedere a una risorsa, è possibile comunque accedere a tale tramite il codice che chiama questo metodo su dell'autorizzazione necessaria.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>An assertion is effective only if the code that calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> passes the security check for the permission that it is asserting.</source>
          <target state="translated">Un'asserzione è efficace solo se il codice che chiama <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> passa il controllo della sicurezza per l'autorizzazione che genera un'asserzione.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">La chiamata a <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> è efficace fino a quando il codice chiamante restituisce al chiamante.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">Un solo <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> può essere attivo su un frame.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">Un tentativo di chiamare <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> quando un oggetto attivo <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> sui risultati del frame è presente un <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Chiamare <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> per rimuovere un attivo <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>However, if code lower on the call stack calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Tuttavia, se il codice inferiore nello stack di chiamate chiama <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> per l'autorizzazione, un <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>This happens because the code that called <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> has not been granted the permission, even though it tried to <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> it.</source>
          <target state="translated">Ciò accade perché il codice che ha chiamato <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> non dispone dell'autorizzazione, anche se si è tentato di <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> è.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Because calling <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</source>
          <target state="translated">Poiché la chiamata <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> rimuove il requisito che tutto il codice nella catena di chiamate deve essere concessa l'autorizzazione per accedere alla risorsa specificata, può provocare problemi di sicurezza se usata in modo non corretto o inappropriato.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">Pertanto, devono essere utilizzata con estrema cautela.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>The calling code does not have <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</source>
          <target state="translated">Il codice chiamante non ha <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame.</source>
          <target state="translated">Esiste già un oggetto <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> attivo per il fotogramma corrente.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>for the ability to call <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>.</source>
          <target state="translated">Per poter chiamare <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Assert">
          <source>You cannot override this method.</source>
          <target state="translated">È possibile eseguire l'override di questo metodo.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>When implemented by a derived class, creates and returns an identical copy of the current permission object.</source>
          <target state="translated">Quando viene implementato da una classe derivata, crea e restituisce una copia identica dell'oggetto autorizzazioni corrente.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>A copy of the current permission object.</source>
          <target state="translated">Copia dell'oggetto autorizzazioni corrente.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>A copy of a permission object represents the same access to resources as the original permission object.</source>
          <target state="translated">Una copia di un oggetto di autorizzazione rappresenta lo stesso accesso alle risorse dell'oggetto di autorizzazione originale.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Copy%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un override del <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Copy%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Copy">
          <source>You must override this method in a derived class.</source>
          <target state="translated">È necessario eseguire l'override di questo metodo in una classe derivata.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>Forces a <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</source>
          <target state="translated">Forza un oggetto <ph id="ph1">&lt;see cref="T:System.Security.SecurityException" /&gt;</ph> in fase di esecuzione se tutti i chiamanti in posizioni superiori nello stack di chiamate non hanno l'autorizzazione specificata dall'istanza corrente.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">Questo metodo viene in genere utilizzato da librerie protette per garantire che i chiamanti dispongano dell'autorizzazione per accedere a una risorsa.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>For example, a file class in a secure class library calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for the necessary <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> before performing a file operation requested by the caller.</source>
          <target state="translated">Ad esempio, una classe di file in una libreria di classi protette chiama <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> per gli oggetti necessari <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> prima di eseguire un'operazione di file richiesta dal chiamante.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">Le autorizzazioni del codice che chiama questo metodo non vengono esaminate; il controllo inizia da parte del chiamante immediato del codice e continua fino allo stack.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> succeeds only if no <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> ha esito positivo solo se nessun <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> viene generato.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>A caller higher in the call stack does not have the permission specified by the current instance.</source>
          <target state="translated">Un chiamante in una posizione superiore nello stack di chiamate non ha l'autorizzazione specificata dall'istanza corrente.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>A caller higher in the call stack has called <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> on the current permission object.</source>
          <target state="translated">Un chiamante in una posizione superiore nello stack di chiamate ha chiamato <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> sull'oggetto autorizzazioni corrente.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Demand">
          <source>You cannot override this method.</source>
          <target state="translated">È possibile eseguire l'override di questo metodo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</source>
          <target state="translated">Impedisce ai chiamanti in posizione più elevata nello stack di chiamate di usare il codice che chiama questo metodo per accedere alla risorsa specificata dall'istanza corrente.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> metodo deve essere utilizzato solo per proteggere le risorse dall'accesso accidentale da codice completamente attendibile.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">Non da utilizzare per proteggere le risorse da un uso improprio intenzionale da codice non attendibile.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> for a permission and then calls method <ph id="ph3">`B`</ph>, method <ph id="ph4">`B`</ph> can overtly override the <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> by issuing an <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Ad esempio, se (metodo) <ph id="ph1">`A`</ph> problemi un <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> per un'autorizzazione e chiami il metodo <ph id="ph3">`B`</ph>, metodo <ph id="ph4">`B`</ph> chiaramente può eseguire l'override il <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> eseguendo un <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">Il metodo chiamato è sempre superiore dello stack.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> lower in the stack.</source>
          <target state="translated">Pertanto, se (metodo) <ph id="ph1">`B`</ph> tenta di accedere a una risorsa protetta, il sistema di sicurezza inizia a verificare le autorizzazioni, in quanto metodo <ph id="ph2">`B`</ph> è il chiamante immediato, e quindi percorre lo stack per verificare che sia presente alcun <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> o <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> inferiore nello stack.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> method.</source>
          <target state="translated">Metodo <ph id="ph1">`B`</ph>, che sta tentando di accedere alla risorsa, può arrestare l'analisi dello stack immediatamente utilizzando il <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>In that case, the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> placed on the stack by method <ph id="ph2">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">In tal caso, il <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> inseriti nello stack dal metodo <ph id="ph2">`A`</ph> (il metodo chiamante) non viene mai individuato.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">Questo metodo impedisce ai chiamanti più in alto nello stack di chiamate di accedere alla risorsa protetta tramite il codice che chiama questo metodo, anche se i chiamanti dispongono dell'autorizzazione per accedervi.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> from being used to access the resource protected by the denied permission.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> può limitare la responsabilità del programmatore o impedire problemi di sicurezza accidentale, in quanto impedisce che il metodo che chiama <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> venga utilizzato per accedere alla risorsa protetta dall'autorizzazione negata.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>If a method calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> on a permission, and if a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</source>
          <target state="translated">Se chiama un metodo <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> su un'autorizzazione e se un <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> per tale autorizzazione viene richiamato da un chiamante inferiore nello stack di chiamate, la verifica della sicurezza avrà esito negativo quando raggiunge il <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">La chiamata a <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> è efficace fino a quando il codice chiamante restituisce al chiamante.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">Un solo <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> può essere attivo su un frame.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">Un tentativo di chiamare <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> quando un oggetto attivo <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> sui risultati del frame è presente un <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</source>
          <target state="translated">Chiamare <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> per rimuovere un attivo <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame.</source>
          <target state="translated">Esiste già un oggetto <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> attivo per il fotogramma corrente.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Deny">
          <source>You cannot override this method.</source>
          <target state="translated">È possibile eseguire l'override di questo metodo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object to compare with the current <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> da confrontare con l'oggetto <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object is equal to the current <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>.</source>
          <target state="translated">Determina se l'oggetto <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> specificato è uguale all'oggetto <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object is equal to the current <ph id="ph3">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'oggetto specificato <ph id="ph2">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> è uguale all'oggetto <ph id="ph3">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> corrente; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Equals(System.Object)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The XML encoding to use to reconstruct the security object.</source>
          <target state="translated">Codifica XML da usare per ricostruire l'oggetto di sicurezza.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</source>
          <target state="translated">Quando ne viene eseguito l'override in una classe derivata, ricostruisce un oggetto di sicurezza con uno stato specificato da una codifica XML.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>Custom code that extends security objects needs to implement the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> methods to make the objects security-encodable.</source>
          <target state="translated">Codice personalizzato che estende gli oggetti di sicurezza deve implementare il <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> metodi per rendere gli oggetti codificabili.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un override del <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter does not contain the XML encoding for an instance of the same type as the current instance.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> non contiene la codifica XML per un'istanza dello stesso tipo di quella corrente.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>The version number of the <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> parameter is not supported.</source>
          <target state="translated">Il numero di versione del parametro <ph id="ph1">&lt;paramref name="elem" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">È necessario eseguire l'override di questo metodo in una classe derivata.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>Gets a hash code for the <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object that is suitable for use in hashing algorithms and data structures such as a hash table.</source>
          <target state="translated">Ottiene un codice hash per l'oggetto <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> adatto per l'uso in algoritmi di hash e in strutture di dati, come una tabella hash.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>A hash code for the current <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> object.</source>
          <target state="translated">Codice hash per l'oggetto <ph id="ph1">&lt;see cref="T:System.Security.CodeAccessPermission" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.GetHashCode">
          <source>The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> objects.</source>
          <target state="translated">Il codice hash per due istanze della stessa autorizzazione potrebbe essere diverso, pertanto è consigliabile non utilizzare un codice hash per confrontare due <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> oggetti.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>A permission to intersect with the current permission.</source>
          <target state="translated">Autorizzazione da intersecare con quella corrente.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Deve essere dello stesso tipo dell'autorizzazione corrente.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</source>
          <target state="translated">Se implementato da una classe derivata, crea e restituisce un'autorizzazione che rappresenta l'intersezione tra l'autorizzazione corrente e quella specificata.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>A new permission that represents the intersection of the current permission and the specified permission.</source>
          <target state="translated">Nuova autorizzazione che rappresenta l'intersezione dell'autorizzazione corrente e di quella specificata.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>This new permission is <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the intersection is empty.</source>
          <target state="translated">La nuova autorizzazione è <ph id="ph1">&lt;see langword="null" /&gt;</ph> se l'intersezione è vuota.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The intersection of two permissions is a permission that describes the set of operations they both describe in common.</source>
          <target state="translated">L'intersezione delle due autorizzazioni è un'autorizzazione che descrive il set di operazioni che hanno in comune.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>Only a demand that passes both original permissions will pass the intersection.</source>
          <target state="translated">Solo una richiesta che supera entrambe le autorizzazioni originali passerà l'intersezione.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Intersect%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un override del <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Intersect%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not an instance of the same class as the current permission.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="target" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e non è un'istanza della stessa classe dell'autorizzazione corrente.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">È necessario eseguire l'override di questo metodo in una classe derivata.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>A permission that is to be tested for the subset relationship.</source>
          <target state="translated">Autorizzazione da testare per la relazione del subset.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This permission must be of the same type as the current permission.</source>
          <target state="translated">Questa autorizzazione deve essere dello stesso tipo di quella corrente.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</source>
          <target state="translated">Quando implementato da una classe derivata, determina se l'autorizzazione corrente è un subset di quella specificata.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current permission is a subset of the specified permission; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'autorizzazione corrente è un sottoinsieme dell'autorizzazione specificata; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</source>
          <target state="translated">Se l'autorizzazione corrente specifica un set di operazioni che è interamente contenuto l'autorizzazione specificata, l'autorizzazione corrente è un subset dell'autorizzazione specificata.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:<ph id="ph1">\\</ph>.</source>
          <target state="translated">Ad esempio, un'autorizzazione che rappresenta l'accesso a C:\example.txt è un subset di un'autorizzazione che rappresenta l'accesso in c:<ph id="ph1">\\</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If this method returns <ph id="ph1">`true`</ph>, the current permission represents no more access to the protected resource than does the specified permission.</source>
          <target state="translated">Se questo metodo restituisce <ph id="ph1">`true`</ph>, l'autorizzazione corrente non rappresenta un accesso alla risorsa protetta rispetto a quello dell'autorizzazione specificata.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following statements are required to be <ph id="ph1">`true`</ph> for all overrides of the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">Le istruzioni seguenti devono essere <ph id="ph1">`true`</ph> per tutte le sostituzioni del <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>, <bpt id="p2">*</bpt>Y<ept id="p2">*</ept>, and <bpt id="p3">*</bpt>Z<ept id="p3">*</ept> represent custom code access permission objects that are not null references, <bpt id="p4">*</bpt>U<ept id="p4">*</ept> represents an unrestricted code access permission, and <bpt id="p5">*</bpt>N<ept id="p5">*</ept> represents an empty permission with a <ph id="ph1">&lt;xref:System.Security.Permissions.PermissionState&gt;</ph> of <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>, <bpt id="p2">*</bpt>Y<ept id="p2">*</ept>, e <bpt id="p3">*</bpt>Z<ept id="p3">*</ept> rappresentano oggetti di autorizzazione di accesso al codice personalizzato che non sono riferimenti null, <bpt id="p4">*</bpt>U<ept id="p4">*</ept> rappresenta un'autorizzazione di accesso di codice senza restrizioni, e <bpt id="p5">*</bpt>N<ept id="p5">*</ept> rappresenta un'autorizzazione vuota con un <ph id="ph1">&lt;xref:System.Security.Permissions.PermissionState&gt;</ph> di <ph id="ph2">&lt;xref:System.Security.Permissions.PermissionState.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) restituisce <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) returns the same value as <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>X<ept id="p4">*</ept>) if and only if <bpt id="p5">*</bpt>X<ept id="p5">*</ept> and <bpt id="p6">*</bpt>Y<ept id="p6">*</ept> represent the same set of permissions.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) restituisce lo stesso valore di <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>. IsSubsetOf (<bpt id="p4">*</bpt>X<ept id="p4">*</ept>) solo se <bpt id="p5">*</bpt>X<ept id="p5">*</ept> e <bpt id="p6">*</bpt>Y<ept id="p6">*</ept> rappresentano lo stesso set di autorizzazioni.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) and <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) both return <ph id="ph1">`true`</ph>, <bpt id="p5">*</bpt>X<ept id="p5">*</ept>.IsSubsetOf(<bpt id="p6">*</bpt>Z<ept id="p6">*</ept>) returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Se <bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>Y<ept id="p2">*</ept>) e <bpt id="p3">*</bpt>Y<ept id="p3">*</ept>. IsSubsetOf (<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) restituiscono entrambi <ph id="ph1">`true`</ph>, <bpt id="p5">*</bpt>X<ept id="p5">*</ept>. IsSubsetOf (<bpt id="p6">*</bpt>Z<ept id="p6">*</ept>) restituisce <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>U<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>U<ept id="p2">*</ept>) restituisce <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>X<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>N<ept id="p2">*</ept>) returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>X<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>N<ept id="p2">*</ept>) restituisce <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source><bpt id="p1">*</bpt>N<ept id="p1">*</ept>.IsSubsetOf(<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated"><bpt id="p1">*</bpt>N<ept id="p1">*</ept>. IsSubsetOf (<bpt id="p2">*</bpt>X<ept id="p2">*</ept>) restituisce <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>X<ept id="p1">*</ept> and <bpt id="p2">*</bpt>Y<ept id="p2">*</ept> represent custom code access permission objects that are null references, <bpt id="p3">*</bpt>X<ept id="p3">*</ept>.IsSubsetOf(<bpt id="p4">*</bpt>Y<ept id="p4">*</ept>) returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Se <bpt id="p1">*</bpt>X<ept id="p1">*</ept> e <bpt id="p2">*</bpt>Y<ept id="p2">*</ept> rappresentano oggetti di autorizzazione di accesso al codice personalizzato che non sono riferimenti null, <bpt id="p3">*</bpt>X<ept id="p3">*</ept>. IsSubsetOf (<bpt id="p4">*</bpt>Y<ept id="p4">*</ept>) restituisce <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>If <bpt id="p1">*</bpt>Z<ept id="p1">*</ept> is also null, the compound set operation <bpt id="p2">*</bpt>X<ept id="p2">*</ept>.Union(<bpt id="p3">*</bpt>Y<ept id="p3">*</ept>).IsSubsetOf(<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) also returns <ph id="ph1">`true`</ph> because the union of two null permissions is a null permission.</source>
          <target state="translated">Se <bpt id="p1">*</bpt>Z<ept id="p1">*</ept> è null, anche l'impostazione composta operazione <bpt id="p2">*</bpt>X<ept id="p2">*</ept>. Union (<bpt id="p3">*</bpt>Y<ept id="p3">*</ept>). IsSubsetOf (<bpt id="p4">*</bpt>Z<ept id="p4">*</ept>) restituisce inoltre <ph id="ph1">`true`</ph> perché l'unione di due autorizzazioni null è un'autorizzazione null.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un override del <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.IsSubsetOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="target" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and is not of the same type as the current permission.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="target" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> ed è di un tipo diverso rispetto all'autorizzazione corrente.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">È necessario eseguire l'override di questo metodo in una classe derivata.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</source>
          <target state="translated">Impedisce ai chiamanti in posizione più elevata nello stack di chiamate di usare il codice che chiama questo metodo per accedere a tutte le risorse eccetto quella specificata dall'istanza corrente.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> method should be used only to protect resources from accidental access by fully trusted code.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> metodo deve essere utilizzato solo per proteggere le risorse dall'accesso accidentale da codice completamente attendibile.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>It should not be used to protect resources from intentional misuse by untrusted code.</source>
          <target state="translated">Non da utilizzare per proteggere le risorse da un uso improprio intenzionale da codice non attendibile.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>For example, if method <ph id="ph1">`A`</ph> issues a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for a permission and then calls method <ph id="ph3">`B`</ph>, method <ph id="ph4">`B`</ph> can overtly override the <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> by issuing an <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</source>
          <target state="translated">Ad esempio, se (metodo) <ph id="ph1">`A`</ph> problemi un <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> per un'autorizzazione e chiami il metodo <ph id="ph3">`B`</ph>, metodo <ph id="ph4">`B`</ph> chiaramente può eseguire l'override il <ph id="ph5">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> eseguendo un <ph id="ph6">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The called method is always higher in the stack.</source>
          <target state="translated">Il metodo chiamato è sempre superiore dello stack.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Therefore, if method <ph id="ph1">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id="ph2">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> lower in the stack.</source>
          <target state="translated">Pertanto, se (metodo) <ph id="ph1">`B`</ph> tenta di accedere a una risorsa protetta, il sistema di sicurezza inizia a verificare le autorizzazioni, in quanto metodo <ph id="ph2">`B`</ph> è il chiamante immediato, e quindi percorre lo stack per verificare che sia presente alcun <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> o <ph id="ph4">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> inferiore nello stack.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Method <ph id="ph1">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> method.</source>
          <target state="translated">Metodo <ph id="ph1">`B`</ph>, che sta tentando di accedere alla risorsa, può arrestare l'analisi dello stack immediatamente utilizzando il <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>In that case, the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> placed on the stack by method <ph id="ph2">`A`</ph> (the calling method) is never discovered.</source>
          <target state="translated">In tal caso, il <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> inseriti nello stack dal metodo <ph id="ph2">`A`</ph> (il metodo chiamante) non viene mai individuato.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> è simile a <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, perché entrambi provocano l'analisi dello stack se avranno esito positivo.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The difference is that <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> specifies permissions that will cause the stack walk to fail, but <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">La differenza è che <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> specifica le autorizzazioni che provocano il percorso, di stack ma <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> specifica solo le autorizzazioni che non provocano il percorso di stack.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">Chiamare questo metodo per verificare che il codice può essere utilizzato per accedere solo le risorse specificate.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is effective until the calling code returns to its caller.</source>
          <target state="translated">La chiamata a <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> è efficace fino a quando il codice chiamante restituisce al chiamante.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Only one <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> can be active on a frame.</source>
          <target state="translated">Un solo <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> può essere attivo su un frame.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> when an active <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> exists on the frame results in a <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</source>
          <target state="translated">Un tentativo di chiamare <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> quando un oggetto attivo <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> sui risultati del frame è presente un <ph id="ph3">&lt;xref:System.Security.SecurityException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>Call <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> to remove an active <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">Chiamare <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> per rimuovere un attivo <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>However, if code lower on the call stack later calls <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">Tuttavia, se il codice inferiore nello stack di in un secondo momento chiama <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt;</ph> per l'autorizzazione, un <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>This is because the code that called <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> has not been granted the permission, even though it called <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for that permission.</source>
          <target state="translated">In questo modo il codice che ha chiamato <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> non dispone dell'autorizzazione, anche se chiamato <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> per tale autorizzazione.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>There is already an active <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">Esiste già un oggetto <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> attivo per il fotogramma corrente.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.PermitOnly">
          <source>You cannot override this method.</source>
          <target state="translated">È possibile eseguire l'override di questo metodo.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>Causes all previous overrides for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Tutti i precedenti override per il frame corrente vengono rimossi e non sono più attivi.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>If there are no overrides (<ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>) for the current frame, an <ph id="ph4">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">Se esistono override (<ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph>) per il frame corrente, un <ph id="ph4">&lt;xref:System.ExecutionEngineException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAll">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph>, or <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">Non esistono precedenti override <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> oppure <ph id="ph3">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> per il frame corrente.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Provoca la rimozione di qualsiasi <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> precedente per il frame corrente, annullandone la validità.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">Se è presente alcun <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;</ph> per il frame corrente, un <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertAssert">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> for the current frame.</source>
          <target state="translated">Non esistono metodi <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Assert" /&gt;</ph> precedenti per il frame corrente.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Provoca la rimozione di qualsiasi <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> precedente per il frame corrente, annullandone la validità.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">Se è presente alcun <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;</ph> per il frame corrente, un <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertDeny">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> for the current frame.</source>
          <target state="translated">Non esistono metodi <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.Deny" /&gt;</ph> precedenti per il frame corrente.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>Causes any previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame to be removed and no longer in effect.</source>
          <target state="translated">Provoca la rimozione di qualsiasi <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> precedente per il frame corrente, annullandone la validità.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>If there is no <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> for the current frame, an <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> is thrown.</source>
          <target state="translated">Se è presente alcun <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;</ph> per il frame corrente, un <ph id="ph2">&lt;xref:System.ExecutionEngineException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.RevertPermitOnly">
          <source>There is no previous <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> for the current frame.</source>
          <target state="translated">Non esistono metodi <ph id="ph1">&lt;see cref="M:System.Security.CodeAccessPermission.PermitOnly" /&gt;</ph> precedenti per il frame corrente.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>Creates and returns a string representation of the current permission object.</source>
          <target state="translated">Crea e restituisce una rappresentazione di stringa dell'oggetto autorizzazione corrente.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>A string representation of the current permission object.</source>
          <target state="translated">Rappresentazione di stringa dell'oggetto autorizzazione corrente.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToString">
          <source>This method is useful in debugging when you need to display the permission as a string.</source>
          <target state="translated">Questo metodo è utile per il debug quando è necessario visualizzare l'autorizzazione come stringa.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>When overridden in a derived class, creates an XML encoding of the security object and its current state.</source>
          <target state="translated">Quando sottoposto a override in una classe derivata, crea una codifica XML dell'oggetto di sicurezza e del relativo stato corrente.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>An XML encoding of the security object, including any state information.</source>
          <target state="translated">Codifica XML dell'oggetto di sicurezza, che include le eventuali informazioni sullo stato.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>Custom code that extends security objects needs to implement the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> methods to make the objects security-encodable.</source>
          <target state="translated">Codice personalizzato che estende gli oggetti di sicurezza deve implementare il <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt;</ph> metodi per rendere gli oggetti codificabili.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un override del <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.ToXml">
          <source>You must override this method in a derived class.</source>
          <target state="translated">È necessario eseguire l'override di questo metodo in una classe derivata.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>A permission to combine with the current permission.</source>
          <target state="translated">Autorizzazione da combinare con quella corrente.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>It must be of the same type as the current permission.</source>
          <target state="translated">Deve essere dello stesso tipo dell'autorizzazione corrente.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</source>
          <target state="translated">Quando sottoposto a override in una classe derivata, crea un'autorizzazione che rappresenta l'unione dell'autorizzazione corrente e di quella specificata.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>A new permission that represents the union of the current permission and the specified permission.</source>
          <target state="translated">Nuova autorizzazione che rappresenta l'unione dell'autorizzazione corrente e di quella specificata.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The result of a call to <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> is a permission that represents all the operations represented by both the current permission and the specified permission.</source>
          <target state="translated">Il risultato di una chiamata a <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> è un'autorizzazione che rappresenta tutte le operazioni indicate sia dell'autorizzazione corrente e l'autorizzazione specificata.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>Any demand that passes either permission passes their union.</source>
          <target state="translated">Qualsiasi richiesta che passa l'autorizzazione passa l'unione.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The following code example shows an override of the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un override del <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.Union%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> class.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>The <ph id="ph1">&lt;paramref name="other" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="other" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>This method is only supported at this level when passed <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questo metodo è supportato a questo livello solo se passato come <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>You must override this method in a derived class.</source>
          <target state="translated">È necessario eseguire l'override di questo metodo in una classe derivata.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)">
          <source>You should return a copy of the permission if the value of the <ph id="ph1">&lt;paramref name="other" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">È necessario restituire una copia dell'autorizzazione se il valore di <ph id="ph1">&lt;paramref name="other" /&gt;</ph> parametro <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>