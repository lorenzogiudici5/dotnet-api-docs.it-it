<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b497a3cd20cb1d0ae8172ce6caf259ae001ddee0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500855" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definisce la struttura sottostante di tutte le autorizzazioni di accesso al codice.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le autorizzazioni di accesso di codice utilizzano un percorso stack per assicurarsi che tutti i chiamanti del codice sono stata concessa un'autorizzazione. Se un oggetto di autorizzazione è `null`, viene gestita come un oggetto di autorizzazione con lo stato <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.  
  
 Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.  
  
 Gli eredi di <xref:System.Security.CodeAccessPermission> classe deve essere concessa l'attendibilità totale per il corretto funzionamento delle autorizzazioni estendendo l'infrastruttura di sicurezza. Per determinare che gli eredi siano completamente attendibili, <xref:System.Security.CodeAccessPermission> problemi un <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> per <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` e <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true`.  
  
   
  
## Examples  
 L'esempio di codice seguente mostra un'autorizzazione che deriva dalla <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per consentire agli eredi di fornire l'evidenza e visualizzare e modificare i criteri. Enumerazioni associate: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</permission>
    <block subset="none" type="overrides">
      <para>Quando si eredita da <see cref="T:System.Security.CodeAccessPermission" />, è necessario implementare anche il <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interfaccia.  
  
 Nell'esempio <see cref="T:System.Security.CodeAccessPermission" /> necessario eseguire l'override di membri: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, e <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.  
  
 È inoltre necessario definire un costruttore che accetta un <see cref="T:System.Security.Permissions.PermissionState" /> solo come parametro.  
  
 È necessario applicare il <see cref="T:System.SerializableAttribute" /> attributo a una classe che eredita da <see cref="T:System.Security.CodeAccessPermission" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.CodeAccessPermission" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene chiamato per inizializzare lo stato del tipo ogni volta che viene creata un'istanza della classe derivata. Sebbene in modo esplicito, è possibile chiamare questo costruttore nella dichiarazione del costruttore della classe derivata, questo non è in genere necessario; la maggior parte dei compilatori genererà automaticamente la chiamata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dichiara che il codice chiamante può accedere alla risorsa protetta da una richiesta di autorizzazione tramite il codice che chiama il metodo, anche se ai chiamanti più in alto nello stack non è stata concessa l'autorizzazione per accedere alla risorsa. Se si utilizza <see cref="M:System.Security.CodeAccessPermission.Assert" /> è possibile creare problemi di sicurezza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate. La chiamata <xref:System.Security.CodeAccessPermission.Assert%2A> impedisce a un percorso stack originari inferiore nello stack di chiamate di procedere, lo stack di chiamate oltre il codice che chiama questo metodo. Pertanto, anche se i chiamanti nello stack di chiamate non dispone di autorizzazioni necessarie per accedere a una risorsa, è possibile comunque accedere a tale tramite il codice che chiama questo metodo su dell'autorizzazione necessaria. Un'asserzione è efficace solo se il codice che chiama <xref:System.Security.CodeAccessPermission.Assert%2A> passa il controllo della sicurezza per l'autorizzazione che genera un'asserzione.  
  
 La chiamata a <xref:System.Security.CodeAccessPermission.Assert%2A> è efficace fino a quando il codice chiamante restituisce al chiamante. Un solo <xref:System.Security.CodeAccessPermission.Assert%2A> può essere attivo su un frame. Un tentativo di chiamare <xref:System.Security.CodeAccessPermission.Assert%2A> quando un oggetto attivo <xref:System.Security.CodeAccessPermission.Assert%2A> sui risultati del frame è presente un <xref:System.Security.SecurityException>. Chiamare <xref:System.Security.CodeAccessPermission.RevertAssert%2A> o <xref:System.Security.CodeAccessPermission.RevertAll%2A> per rimuovere un attivo <xref:System.Security.CodeAccessPermission.Assert%2A>.  
  
 <xref:System.Security.CodeAccessPermission.Assert%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà. Tuttavia, se il codice inferiore nello stack di chiamate chiama <xref:System.Security.CodeAccessPermission.Demand%2A> per l'autorizzazione, un <xref:System.Security.SecurityException> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <xref:System.Security.CodeAccessPermission.Assert%2A>. Ciò accade perché il codice che ha chiamato <xref:System.Security.CodeAccessPermission.Assert%2A> non dispone dell'autorizzazione, anche se si è tentato di <xref:System.Security.CodeAccessPermission.Assert%2A> è.  
  
> [!CAUTION]
>  Poiché la chiamata <xref:System.Security.CodeAccessPermission.Assert%2A> rimuove il requisito che tutto il codice nella catena di chiamate deve essere concessa l'autorizzazione per accedere alla risorsa specificata, può provocare problemi di sicurezza se usata in modo non corretto o inappropriato. Pertanto, devono essere utilizzata con estrema cautela.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il codice chiamante non ha <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.  
  
 oppure  
  
 Esiste già un oggetto <see cref="M:System.Security.CodeAccessPermission.Assert" /> attivo per il fotogramma corrente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter chiamare <see cref="M:System.Security.CodeAccessPermission.Assert" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></permission>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene implementato da una classe derivata, crea e restituisce una copia identica dell'oggetto autorizzazioni corrente.</summary>
        <returns>Copia dell'oggetto autorizzazioni corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia di un oggetto di autorizzazione rappresenta lo stesso accesso alle risorse dell'oggetto di autorizzazione originale.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.Copy%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Forza un oggetto <see cref="T:System.Security.SecurityException" /> in fase di esecuzione se tutti i chiamanti in posizioni superiori nello stack di chiamate non hanno l'autorizzazione specificata dall'istanza corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene in genere utilizzato da librerie protette per garantire che i chiamanti dispongano dell'autorizzazione per accedere a una risorsa. Ad esempio, una classe di file in una libreria di classi protette chiama <xref:System.Security.CodeAccessPermission.Demand%2A> per gli oggetti necessari <xref:System.Security.Permissions.FileIOPermission> prima di eseguire un'operazione di file richiesta dal chiamante.  
  
 Le autorizzazioni del codice che chiama questo metodo non vengono esaminate; il controllo inizia da parte del chiamante immediato del codice e continua fino allo stack. Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate. <xref:System.Security.CodeAccessPermission.Demand%2A> ha esito positivo solo se nessun <xref:System.Security.SecurityException> viene generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante in una posizione superiore nello stack di chiamate non ha l'autorizzazione specificata dall'istanza corrente.  
  
 oppure  
  
 Un chiamante in una posizione superiore nello stack di chiamate ha chiamato <see cref="M:System.Security.CodeAccessPermission.Deny" /> sull'oggetto autorizzazioni corrente.</exception>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Impedisce ai chiamanti in posizione più elevata nello stack di chiamate di usare il codice che chiama questo metodo per accedere alla risorsa specificata dall'istanza corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Security.CodeAccessPermission.Deny%2A> metodo deve essere utilizzato solo per proteggere le risorse dall'accesso accidentale da codice completamente attendibile. Non da utilizzare per proteggere le risorse da un uso improprio intenzionale da codice non attendibile. Ad esempio, se (metodo) `A` problemi un <xref:System.Security.CodeAccessPermission.Deny%2A> per un'autorizzazione e chiami il metodo `B`, metodo `B` chiaramente può eseguire l'override il <xref:System.Security.CodeAccessPermission.Deny%2A> eseguendo un <xref:System.Security.CodeAccessPermission.Assert%2A>. Il metodo chiamato è sempre superiore dello stack. Pertanto, se (metodo) `B` tenta di accedere a una risorsa protetta, il sistema di sicurezza inizia a verificare le autorizzazioni, in quanto metodo `B` è il chiamante immediato, e quindi percorre lo stack per verificare che sia presente alcun <xref:System.Security.CodeAccessPermission.Deny%2A> o <xref:System.Security.CodeAccessPermission.PermitOnly%2A> inferiore nello stack. Metodo `B`, che sta tentando di accedere alla risorsa, può arrestare l'analisi dello stack immediatamente utilizzando il <xref:System.Security.CodeAccessPermission.Assert%2A> metodo. In tal caso, il <xref:System.Security.CodeAccessPermission.Deny%2A> inseriti nello stack dal metodo `A` (il metodo chiamante) non viene mai individuato.  
  
 Questo metodo impedisce ai chiamanti più in alto nello stack di chiamate di accedere alla risorsa protetta tramite il codice che chiama questo metodo, anche se i chiamanti dispongono dell'autorizzazione per accedervi. Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.  
  
 <xref:System.Security.CodeAccessPermission.Deny%2A> può limitare la responsabilità del programmatore o impedire problemi di sicurezza accidentale, in quanto impedisce che il metodo che chiama <xref:System.Security.CodeAccessPermission.Deny%2A> venga utilizzato per accedere alla risorsa protetta dall'autorizzazione negata. Se chiama un metodo <xref:System.Security.CodeAccessPermission.Deny%2A> su un'autorizzazione e se un <xref:System.Security.CodeAccessPermission.Demand%2A> per tale autorizzazione viene richiamato da un chiamante inferiore nello stack di chiamate, la verifica della sicurezza avrà esito negativo quando raggiunge il <xref:System.Security.CodeAccessPermission.Deny%2A>.  
  
 La chiamata a <xref:System.Security.CodeAccessPermission.Deny%2A> è efficace fino a quando il codice chiamante restituisce al chiamante. Un solo <xref:System.Security.CodeAccessPermission.Deny%2A> può essere attivo su un frame. Un tentativo di chiamare <xref:System.Security.CodeAccessPermission.Deny%2A> quando un oggetto attivo <xref:System.Security.CodeAccessPermission.Deny%2A> sui risultati del frame è presente un <xref:System.Security.SecurityException>. Chiamare <xref:System.Security.CodeAccessPermission.RevertDeny%2A> o <xref:System.Security.CodeAccessPermission.RevertAll%2A> per rimuovere un attivo <xref:System.Security.CodeAccessPermission.Deny%2A>. <xref:System.Security.CodeAccessPermission.Deny%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Esiste già un oggetto <see cref="M:System.Security.CodeAccessPermission.Deny" /> attivo per il fotogramma corrente.</exception>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto <see cref="T:System.Security.CodeAccessPermission" /> da confrontare con l'oggetto <see cref="T:System.Security.CodeAccessPermission" /> corrente.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Security.CodeAccessPermission" /> specificato è uguale all'oggetto <see cref="T:System.Security.CodeAccessPermission" /> corrente.</summary>
        <returns>
          <see langword="true" /> se l'oggetto specificato <see cref="T:System.Security.CodeAccessPermission" /> è uguale all'oggetto <see cref="T:System.Security.CodeAccessPermission" /> corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.Object.Equals%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">Codifica XML da usare per ricostruire l'oggetto di sicurezza.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ricostruisce un oggetto di sicurezza con uno stato specificato da una codifica XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codice personalizzato che estende gli oggetti di sicurezza deve implementare il <xref:System.Security.CodeAccessPermission.ToXml%2A> e <xref:System.Security.CodeAccessPermission.FromXml%2A> metodi per rendere gli oggetti codificabili.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.FromXml%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="elem" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="elem" /> non contiene la codifica XML per un'istanza dello stesso tipo di quella corrente.  
  
 oppure  
  
 Il numero di versione del parametro <paramref name="elem" /> non è supportato.</exception>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un codice hash per l'oggetto <see cref="T:System.Security.CodeAccessPermission" /> adatto per l'uso in algoritmi di hash e in strutture di dati, come una tabella hash.</summary>
        <returns>Codice hash per l'oggetto <see cref="T:System.Security.CodeAccessPermission" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il codice hash per due istanze della stessa autorizzazione potrebbe essere diverso, pertanto è consigliabile non utilizzare un codice hash per confrontare due <xref:System.Security.CodeAccessPermission> oggetti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorizzazione da intersecare con quella corrente. Deve essere dello stesso tipo dell'autorizzazione corrente.</param>
        <summary>Se implementato da una classe derivata, crea e restituisce un'autorizzazione che rappresenta l'intersezione tra l'autorizzazione corrente e quella specificata.</summary>
        <returns>Nuova autorizzazione che rappresenta l'intersezione dell'autorizzazione corrente e di quella specificata. La nuova autorizzazione è <see langword="null" /> se l'intersezione è vuota.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'intersezione delle due autorizzazioni è un'autorizzazione che descrive il set di operazioni che hanno in comune. Solo una richiesta che supera entrambe le autorizzazioni originali passerà l'intersezione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.Intersect%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="target" /> non è <see langword="null" /> e non è un'istanza della stessa classe dell'autorizzazione corrente.</exception>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorizzazione da testare per la relazione del subset. Questa autorizzazione deve essere dello stesso tipo di quella corrente.</param>
        <summary>Quando implementato da una classe derivata, determina se l'autorizzazione corrente è un subset di quella specificata.</summary>
        <returns>
          <see langword="true" /> se l'autorizzazione corrente è un sottoinsieme dell'autorizzazione specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'autorizzazione corrente specifica un set di operazioni che è interamente contenuto l'autorizzazione specificata, l'autorizzazione corrente è un subset dell'autorizzazione specificata. Ad esempio, un'autorizzazione che rappresenta l'accesso a C:\example.txt è un subset di un'autorizzazione che rappresenta l'accesso in c:\\. Se questo metodo restituisce `true`, l'autorizzazione corrente non rappresenta un accesso alla risorsa protetta rispetto a quello dell'autorizzazione specificata.  
  
 Le istruzioni seguenti devono essere `true` per tutte le sostituzioni del <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> metodo. *X*, *Y*, e *Z* rappresentano oggetti di autorizzazione di accesso al codice personalizzato che non sono riferimenti null, *U* rappresenta un'autorizzazione di accesso di codice senza restrizioni, e *N* rappresenta un'autorizzazione vuota con un <xref:System.Security.Permissions.PermissionState> di <xref:System.Security.Permissions.PermissionState.None>.  
  
-   *X*. IsSubsetOf (*X*) restituisce `true`.  
  
-   *X*. IsSubsetOf (*Y*) restituisce lo stesso valore di *Y*. IsSubsetOf (*X*) solo se *X* e *Y* rappresentano lo stesso set di autorizzazioni.  
  
-   Se *X*. IsSubsetOf (*Y*) e *Y*. IsSubsetOf (*Z*) restituiscono entrambi `true`, *X*. IsSubsetOf (*Z*) restituisce `true`.  
  
-   *X*. IsSubsetOf (*U*) restituisce `true`.  
  
-   *X*. IsSubsetOf (*N*) restituisce `false`.  
  
-   *N*. IsSubsetOf (*X*) restituisce `true`.  
  
 Se *X* e *Y* rappresentano oggetti di autorizzazione di accesso al codice personalizzato che non sono riferimenti null, *X*. IsSubsetOf (*Y*) restituisce `true`. Se *Z* è null, anche l'impostazione composta operazione *X*. Union (*Y*). IsSubsetOf (*Z*) restituisce inoltre `true` perché l'unione di due autorizzazioni null è un'autorizzazione null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="target" /> non è <see langword="null" /> ed è di un tipo diverso rispetto all'autorizzazione corrente.</exception>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Impedisce ai chiamanti in posizione più elevata nello stack di chiamate di usare il codice che chiama questo metodo per accedere a tutte le risorse eccetto quella specificata dall'istanza corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Security.CodeAccessPermission.PermitOnly%2A> metodo deve essere utilizzato solo per proteggere le risorse dall'accesso accidentale da codice completamente attendibile. Non da utilizzare per proteggere le risorse da un uso improprio intenzionale da codice non attendibile. Ad esempio, se (metodo) `A` problemi un <xref:System.Security.CodeAccessPermission.PermitOnly%2A> per un'autorizzazione e chiami il metodo `B`, metodo `B` chiaramente può eseguire l'override il <xref:System.Security.CodeAccessPermission.PermitOnly%2A> eseguendo un <xref:System.Security.CodeAccessPermission.Assert%2A>. Il metodo chiamato è sempre superiore dello stack. Pertanto, se (metodo) `B` tenta di accedere a una risorsa protetta, il sistema di sicurezza inizia a verificare le autorizzazioni, in quanto metodo `B` è il chiamante immediato, e quindi percorre lo stack per verificare che sia presente alcun <xref:System.Security.CodeAccessPermission.Deny%2A> o <xref:System.Security.CodeAccessPermission.PermitOnly%2A> inferiore nello stack. Metodo `B`, che sta tentando di accedere alla risorsa, può arrestare l'analisi dello stack immediatamente utilizzando il <xref:System.Security.CodeAccessPermission.Assert%2A> metodo. In tal caso, il <xref:System.Security.CodeAccessPermission.PermitOnly%2A> inseriti nello stack dal metodo `A` (il metodo chiamante) non viene mai individuato.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> è simile a <xref:System.Security.CodeAccessPermission.Deny%2A>, perché entrambi provocano l'analisi dello stack se avranno esito positivo. La differenza è che <xref:System.Security.CodeAccessPermission.Deny%2A> specifica le autorizzazioni che provocano il percorso, di stack ma <xref:System.Security.CodeAccessPermission.PermitOnly%2A> specifica solo le autorizzazioni che non provocano il percorso di stack.  
  
 Chiamare questo metodo per verificare che il codice può essere utilizzato per accedere solo le risorse specificate. La chiamata a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> è efficace fino a quando il codice chiamante restituisce al chiamante. Un solo <xref:System.Security.CodeAccessPermission.PermitOnly%2A> può essere attivo su un frame. Un tentativo di chiamare <xref:System.Security.CodeAccessPermission.PermitOnly%2A> quando un oggetto attivo <xref:System.Security.CodeAccessPermission.PermitOnly%2A> sui risultati del frame è presente un <xref:System.Security.SecurityException>. Chiamare <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> o <xref:System.Security.CodeAccessPermission.RevertAll%2A> per rimuovere un attivo <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà. Tuttavia, se il codice inferiore nello stack di in un secondo momento chiama <xref:System.Security.CodeAccessPermission.Demand%2A> per l'autorizzazione, un <xref:System.Security.SecurityException> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <xref:System.Security.CodeAccessPermission.PermitOnly%2A>. In questo modo il codice che ha chiamato <xref:System.Security.CodeAccessPermission.PermitOnly%2A> non dispone dell'autorizzazione, anche se chiamato <xref:System.Security.CodeAccessPermission.PermitOnly%2A> per tale autorizzazione. Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Esiste già un oggetto <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> attivo per il fotogramma corrente.</exception>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tutti i precedenti override per il frame corrente vengono rimossi e non sono più attivi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esistono override (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, o <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) per il frame corrente, un <xref:System.ExecutionEngineException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non esistono precedenti override <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" /> oppure <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> per il frame corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoca la rimozione di qualsiasi <see cref="M:System.Security.CodeAccessPermission.Assert" /> precedente per il frame corrente, annullandone la validità.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente alcun <xref:System.Security.CodeAccessPermission.Assert%2A> per il frame corrente, un <xref:System.ExecutionEngineException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non esistono metodi <see cref="M:System.Security.CodeAccessPermission.Assert" /> precedenti per il frame corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoca la rimozione di qualsiasi <see cref="M:System.Security.CodeAccessPermission.Deny" /> precedente per il frame corrente, annullandone la validità.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente alcun <xref:System.Security.CodeAccessPermission.Deny%2A> per il frame corrente, un <xref:System.ExecutionEngineException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non esistono metodi <see cref="M:System.Security.CodeAccessPermission.Deny" /> precedenti per il frame corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoca la rimozione di qualsiasi <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> precedente per il frame corrente, annullandone la validità.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente alcun <xref:System.Security.CodeAccessPermission.PermitOnly%2A> per il frame corrente, un <xref:System.ExecutionEngineException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non esistono metodi <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> precedenti per il frame corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea e restituisce una rappresentazione di stringa dell'oggetto autorizzazione corrente.</summary>
        <returns>Rappresentazione di stringa dell'oggetto autorizzazione corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è utile per il debug quando è necessario visualizzare l'autorizzazione come stringa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, crea una codifica XML dell'oggetto di sicurezza e del relativo stato corrente.</summary>
        <returns>Codifica XML dell'oggetto di sicurezza, che include le eventuali informazioni sullo stato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codice personalizzato che estende gli oggetti di sicurezza deve implementare il <xref:System.Security.CodeAccessPermission.ToXml%2A> e <xref:System.Security.CodeAccessPermission.FromXml%2A> metodi per rendere gli oggetti codificabili.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.ToXml%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">Autorizzazione da combinare con quella corrente. Deve essere dello stesso tipo dell'autorizzazione corrente.</param>
        <summary>Quando sottoposto a override in una classe derivata, crea un'autorizzazione che rappresenta l'unione dell'autorizzazione corrente e di quella specificata.</summary>
        <returns>Nuova autorizzazione che rappresenta l'unione dell'autorizzazione corrente e di quella specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il risultato di una chiamata a <xref:System.Security.CodeAccessPermission.Union%2A> è un'autorizzazione che rappresenta tutte le operazioni indicate sia dell'autorizzazione corrente e l'autorizzazione specificata. Qualsiasi richiesta che passa l'autorizzazione passa l'unione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.Union%2A> metodo. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per la <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il parametro <paramref name="other" /> non è <see langword="null" />. Questo metodo è supportato a questo livello solo se passato come <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata. È necessario restituire una copia dell'autorizzazione se il valore di <paramref name="other" /> parametro <see langword="null" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>