<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ed301d6d9fb1098c38160cc31925699202ed1000" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52227300" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <TypeSignature Language="F#" Value="type CodeAccessPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definisce la struttura sottostante di tutte le autorizzazioni di accesso al codice.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le autorizzazioni di accesso di codice usano un percorso stack per assicurarsi che tutti i chiamanti del codice hanno ottenuti un'autorizzazione. Se è un oggetto permission `null`, viene gestito lo stesso come un oggetto di autorizzazione con lo stato <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.  
  
 Lo stack di chiamate in genere è rappresentato come cresce verso il basso, in modo che i metodi più elevati nello stack di chiamate chiamare metodi inferiore nello stack di chiamate.  
  
 Gli eredi di <xref:System.Security.CodeAccessPermission> classe deve essere concessa l'attendibilità per il corretto funzionamento delle autorizzazioni estendendo l'infrastruttura di sicurezza. Per determinare che gli eredi siano completamente attendibili <xref:System.Security.CodeAccessPermission> problemi di un' <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> per <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` e <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true`.  
  
   
  
## Examples  
 Esempio di codice seguente mostra un'autorizzazione che deriva dal <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per gli eredi per fornire l'evidenza e visualizzare e modificare i criteri di capacità. Enumerazioni associate: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</permission>
    <block subset="none" type="overrides">
      <para>Quando si eredita da <see cref="T:System.Security.CodeAccessPermission" />, è inoltre necessario implementare il <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interfaccia.  
  
Quanto segue <see cref="T:System.Security.CodeAccessPermission" /> devono eseguire l'override di membri: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, e <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.  
  
È anche necessario definire un costruttore che accetta un <see cref="T:System.Security.Permissions.PermissionState" /> come unico parametro.  
  
È necessario applicare il <see cref="T:System.SerializableAttribute" /> dell'attributo a una classe che eredita da <see cref="T:System.Security.CodeAccessPermission" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.CodeAccessPermission" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene chiamato per inizializzare lo stato del tipo ogni volta che viene creata un'istanza della classe derivata. Sebbene sia possibile chiamare in modo esplicito questo costruttore nella dichiarazione di costruttore del costruttore della classe derivata, questo non è in genere necessario; la maggior parte dei compilatori genera automaticamente la chiamata per l'utente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit&#xA;override this.Assert : unit -&gt; unit" Usage="codeAccessPermission.Assert " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dichiara che il codice chiamante può accedere alla risorsa protetta da una richiesta di autorizzazione tramite il codice che chiama il metodo, anche se ai chiamanti più in alto nello stack non è stata concessa l'autorizzazione per accedere alla risorsa. L'uso di <see cref="M:System.Security.CodeAccessPermission.Assert" /> può creare problemi di sicurezza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stack di chiamate in genere è rappresentato come cresce verso il basso, in modo che i metodi più elevati nello stack di chiamate chiamare metodi inferiore nello stack di chiamate. La chiamata a <xref:System.Security.CodeAccessPermission.Assert%2A> impedisce a un percorso stack proveniente inferiore nello stack di chiamate da proceda verso l'alto nello stack di chiamate oltre il codice che chiama questo metodo. Pertanto, anche se i chiamanti nello stack di chiamate non ha le autorizzazioni necessarie per accedere a una risorsa, essi possono ancora accedere tramite il codice che chiama questo metodo su dell'autorizzazione necessaria. Un'asserzione è efficace solo se il codice che chiama <xref:System.Security.CodeAccessPermission.Assert%2A> passa il controllo di sicurezza per l'autorizzazione che sta affermando.  
  
 La chiamata a <xref:System.Security.CodeAccessPermission.Assert%2A> è efficace fino a quando il codice chiamante viene restituito al chiamante. Un solo <xref:System.Security.CodeAccessPermission.Assert%2A> può essere attivo in un frame. Un tentativo di chiamare <xref:System.Security.CodeAccessPermission.Assert%2A> quando un oggetto attivo <xref:System.Security.CodeAccessPermission.Assert%2A> sui risultati del frame è presente un <xref:System.Security.SecurityException>. Chiamare <xref:System.Security.CodeAccessPermission.RevertAssert%2A> oppure <xref:System.Security.CodeAccessPermission.RevertAll%2A> per rimuovere un oggetto attivo <xref:System.Security.CodeAccessPermission.Assert%2A>.  
  
 <xref:System.Security.CodeAccessPermission.Assert%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà. Tuttavia, se viene chiamato codice inferiore nello stack di chiamate <xref:System.Security.CodeAccessPermission.Demand%2A> per l'autorizzazione, un <xref:System.Security.SecurityException> generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <xref:System.Security.CodeAccessPermission.Assert%2A>. Ciò accade perché il codice che ha chiamato <xref:System.Security.CodeAccessPermission.Assert%2A> non ha ottenuto l'autorizzazione, anche se l'App prova a <xref:System.Security.CodeAccessPermission.Assert%2A> è.  
  
> [!CAUTION]
>  Poiché la chiamata <xref:System.Security.CodeAccessPermission.Assert%2A> Elimina il requisito che tutto il codice nella catena di chiamate deve concedere l'autorizzazione per accedere alla risorsa specificata, può provocare problemi di protezione se usato in modo non corretto o non appropriato. Pertanto, deve essere utilizzata con grande attenzione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il codice chiamante non ha <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.  
  
oppure 
Esiste già un oggetto <see cref="M:System.Security.CodeAccessPermission.Assert" /> attivo per il fotogramma corrente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare <see cref="M:System.Security.CodeAccessPermission.Assert" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></permission>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md">Utilizzo del metodo Assert</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission" Usage="codeAccessPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando viene implementato da una classe derivata, crea e restituisce una copia identica dell'oggetto autorizzazioni corrente.</summary>
        <returns>Copia dell'oggetto autorizzazioni corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia di un oggetto di autorizzazione rappresenta lo stesso accesso alle risorse dell'oggetto di autorizzazione originale.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.Copy%2A> (metodo). Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="codeAccessPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Forza un oggetto <see cref="T:System.Security.SecurityException" /> in fase di esecuzione se tutti i chiamanti in posizioni superiori nello stack di chiamate non hanno l'autorizzazione specificata dall'istanza corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene in genere utilizzato da librerie protette per garantire che i chiamanti dispongano dell'autorizzazione per accedere a una risorsa. Ad esempio, chiama una classe di file in una libreria di classi protette <xref:System.Security.CodeAccessPermission.Demand%2A> per le necessarie <xref:System.Security.Permissions.FileIOPermission> prima di eseguire un'operazione di file richiesta dal chiamante.  
  
 Le autorizzazioni del codice che chiama questo metodo non vengono esaminate; la verifica viene avviata dal computer chiamante immediato del codice e procede verso l'alto. Lo stack di chiamate in genere è rappresentato come cresce verso il basso, in modo che i metodi più elevati nello stack di chiamate chiamare metodi inferiore nello stack di chiamate. <xref:System.Security.CodeAccessPermission.Demand%2A> ha esito positivo solo se nessun <xref:System.Security.SecurityException> viene generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante in una posizione superiore nello stack di chiamate non ha l'autorizzazione specificata dall'istanza corrente.  
  
oppure 
Un chiamante in una posizione superiore nello stack di chiamate ha chiamato <see cref="M:System.Security.CodeAccessPermission.Deny" /> sull'oggetto autorizzazioni corrente.</exception>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit&#xA;override this.Deny : unit -&gt; unit" Usage="codeAccessPermission.Deny " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Impedisce ai chiamanti in posizione più elevata nello stack di chiamate di usare il codice che chiama questo metodo per accedere alla risorsa specificata dall'istanza corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Security.CodeAccessPermission.Deny%2A> metodo deve essere utilizzato solo per proteggere le risorse dall'accesso accidentale da codice completamente attendibile. Consigliabile non usarla per proteggere le risorse da un uso improprio intenzionale da codice non attendibile. Ad esempio, se (metodo) `A` problemi un <xref:System.Security.CodeAccessPermission.Deny%2A> per un'autorizzazione e quindi chiami il metodo `B`, metodo `B` chiaramente può eseguire l'override il <xref:System.Security.CodeAccessPermission.Deny%2A> eseguendo un <xref:System.Security.CodeAccessPermission.Assert%2A>. Il metodo chiamato è sempre più elevato nello stack. Pertanto, se (metodo) `B` tenta di accedere a una risorsa protetta, il sistema di sicurezza inizia a verificare le autorizzazioni, in quanto il metodo `B` è il chiamante immediato e quindi percorre lo stack per assicurarsi che non esistano alcun <xref:System.Security.CodeAccessPermission.Deny%2A> o <xref:System.Security.CodeAccessPermission.PermitOnly%2A> inferiore nello stack. Metodo `B`, che sta tentando di accedere alla risorsa, può arrestare l'analisi dello stack immediatamente usando la <xref:System.Security.CodeAccessPermission.Assert%2A> (metodo). In tal caso, il <xref:System.Security.CodeAccessPermission.Deny%2A> posizionato sullo stack di dal metodo `A` (il metodo chiama) non è mai stato individuato.  
  
 Questo metodo impedisce ai chiamanti nello stack di chiamate di accedere alla risorsa protetta tramite il codice che chiama questo metodo, anche se i chiamanti dispongono dell'autorizzazione per accedervi. Lo stack di chiamate in genere è rappresentato come cresce verso il basso, in modo che i metodi più elevati nello stack di chiamate chiamare metodi inferiore nello stack di chiamate.  
  
 <xref:System.Security.CodeAccessPermission.Deny%2A> consentono di limitare le responsabilità del programmatore o di evitare problemi di sicurezza accidentali, perché consente di impedire il metodo che chiama <xref:System.Security.CodeAccessPermission.Deny%2A> vengano utilizzati per accedere alla risorsa protetta dall'autorizzazione negata. Se un metodo chiama <xref:System.Security.CodeAccessPermission.Deny%2A> su un'autorizzazione e, se un <xref:System.Security.CodeAccessPermission.Demand%2A> per tale autorizzazione viene richiamata da un chiamante inferiore nello stack di chiamate, la verifica della sicurezza avrà esito negativo quando raggiunge il <xref:System.Security.CodeAccessPermission.Deny%2A>.  
  
 La chiamata a <xref:System.Security.CodeAccessPermission.Deny%2A> è efficace fino a quando il codice chiamante viene restituito al chiamante. Un solo <xref:System.Security.CodeAccessPermission.Deny%2A> può essere attivo in un frame. Un tentativo di chiamare <xref:System.Security.CodeAccessPermission.Deny%2A> quando un oggetto attivo <xref:System.Security.CodeAccessPermission.Deny%2A> sui risultati del frame è presente un <xref:System.Security.SecurityException>. Chiamare <xref:System.Security.CodeAccessPermission.RevertDeny%2A> oppure <xref:System.Security.CodeAccessPermission.RevertAll%2A> per rimuovere un oggetto attivo <xref:System.Security.CodeAccessPermission.Deny%2A>. <xref:System.Security.CodeAccessPermission.Deny%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Esiste già un oggetto <see cref="M:System.Security.CodeAccessPermission.Deny" /> attivo per il fotogramma corrente.</exception>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="codeAccessPermission.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto <see cref="T:System.Security.CodeAccessPermission" /> da confrontare con l'oggetto <see cref="T:System.Security.CodeAccessPermission" /> corrente.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Security.CodeAccessPermission" /> specificato è uguale all'oggetto <see cref="T:System.Security.CodeAccessPermission" /> corrente.</summary>
        <returns>
          <see langword="true" /> se l'oggetto specificato <see cref="T:System.Security.CodeAccessPermission" /> è uguale all'oggetto <see cref="T:System.Security.CodeAccessPermission" /> corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.Object.Equals%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit" Usage="codeAccessPermission.FromXml elem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">Codifica XML da usare per ricostruire l'oggetto di sicurezza.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ricostruisce un oggetto di sicurezza con uno stato specificato da una codifica XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codice personalizzato che consente di estendere gli oggetti di sicurezza deve implementare il <xref:System.Security.CodeAccessPermission.ToXml%2A> e <xref:System.Security.CodeAccessPermission.FromXml%2A> metodi da rendere codificabili gli oggetti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.FromXml%2A> (metodo). Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="elem" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="elem" /> non contiene la codifica XML per un'istanza dello stesso tipo dell'istanza corrente.  
  
oppure 
Il numero di versione del parametro <paramref name="elem" /> non è supportato.</exception>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="codeAccessPermission.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un codice hash per l'oggetto <see cref="T:System.Security.CodeAccessPermission" /> adatto per l'uso in algoritmi di hash e in strutture di dati, come una tabella hash.</summary>
        <returns>Codice hash per l'oggetto <see cref="T:System.Security.CodeAccessPermission" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il codice hash per due istanze della stessa autorizzazione potrebbe essere diverso, quindi un codice hash non deve essere usato per confrontare due <xref:System.Security.CodeAccessPermission> oggetti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorizzazione da intersecare con quella corrente. Deve essere dello stesso tipo dell'autorizzazione corrente.</param>
        <summary>Se implementato da una classe derivata, crea e restituisce un'autorizzazione che rappresenta l'intersezione tra l'autorizzazione corrente e quella specificata.</summary>
        <returns>Nuova autorizzazione che rappresenta l'intersezione dell'autorizzazione corrente e di quella specificata. La nuova autorizzazione è <see langword="null" /> se l'intersezione è vuota.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'intersezione delle due autorizzazioni è un'autorizzazione che descrive il set di operazioni che hanno in comune. Solo una richiesta che supera entrambe le autorizzazioni originali passerà l'intersezione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.Intersect%2A> (metodo). Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="target" /> non è <see langword="null" /> e non è un'istanza della stessa classe dell'autorizzazione corrente.</exception>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="codeAccessPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorizzazione da testare per la relazione del subset. Questa autorizzazione deve essere dello stesso tipo di quella corrente.</param>
        <summary>Quando implementato da una classe derivata, determina se l'autorizzazione corrente è un subset di quella specificata.</summary>
        <returns>
          <see langword="true" /> se l'autorizzazione corrente è un subset di quella specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'autorizzazione corrente è un subset dell'autorizzazione specificata, se l'autorizzazione corrente specifica un set di operazioni che è completamente contenuto all'autorizzazione specificata. Ad esempio, un'autorizzazione che rappresenta l'accesso a C:\example.txt è un subset di un'autorizzazione che rappresenta l'accesso a c:\\. Se questo metodo restituisce `true`, l'autorizzazione corrente non rappresenta un accesso alla risorsa protetta rispetto all'autorizzazione specificata.  
  
 Le istruzioni seguenti devono essere `true` per tutte le sostituzioni del <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> (metodo). *X*, *Y*, e *Z* rappresentare oggetti di autorizzazione di accesso al codice personalizzato che non sono riferimenti null *U* rappresenta un'autorizzazione di accesso di codice senza restrizioni, e *N* rappresenta un'autorizzazione vuota con un <xref:System.Security.Permissions.PermissionState> di <xref:System.Security.Permissions.PermissionState.None>.  
  
-   *X*. IsSubsetOf (*X*) restituisce `true`.  
  
-   *X*. IsSubsetOf (*Y*) restituisce lo stesso valore di *Y*. IsSubsetOf (*X*) solo se *X* e *Y* rappresentano lo stesso set di autorizzazioni.  
  
-   Se *X*. IsSubsetOf (*Y*) e *Y*. IsSubsetOf (*Z*) restituiscono entrambi `true`, *X*. IsSubsetOf (*Z*) restituisce `true`.  
  
-   *X*. IsSubsetOf (*U*) restituisce `true`.  
  
-   *X*. IsSubsetOf (*N*) restituisce `false`.  
  
-   *N*. IsSubsetOf (*X*) restituisce `true`.  
  
 Se *X* e *Y* rappresentare oggetti di autorizzazione di accesso al codice personalizzato che non sono riferimenti null, *X*. IsSubsetOf (*Y*) restituisce `true`. Se *Z* è null, anche l'impostazione composta operazione *X*. Union (*Y*). IsSubsetOf (*Z*) restituisce inoltre `true` perché l'unione delle due autorizzazioni di null è un'autorizzazione null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> (metodo). Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="target" /> non è <see langword="null" /> e non è dello stesso tipo dell'autorizzazione corrente.</exception>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit&#xA;override this.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.PermitOnly " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Impedisce ai chiamanti in posizione più elevata nello stack di chiamate di usare il codice che chiama questo metodo per accedere a tutte le risorse eccetto quella specificata dall'istanza corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Security.CodeAccessPermission.PermitOnly%2A> metodo deve essere utilizzato solo per proteggere le risorse dall'accesso accidentale da codice completamente attendibile. Consigliabile non usarla per proteggere le risorse da un uso improprio intenzionale da codice non attendibile. Ad esempio, se (metodo) `A` problemi un <xref:System.Security.CodeAccessPermission.PermitOnly%2A> per un'autorizzazione e quindi chiami il metodo `B`, metodo `B` chiaramente può eseguire l'override il <xref:System.Security.CodeAccessPermission.PermitOnly%2A> eseguendo un <xref:System.Security.CodeAccessPermission.Assert%2A>. Il metodo chiamato è sempre più elevato nello stack. Pertanto, se (metodo) `B` tenta di accedere a una risorsa protetta, il sistema di sicurezza inizia a verificare le autorizzazioni, in quanto il metodo `B` è il chiamante immediato e quindi percorre lo stack per assicurarsi che non esistano alcun <xref:System.Security.CodeAccessPermission.Deny%2A> o <xref:System.Security.CodeAccessPermission.PermitOnly%2A> inferiore nello stack. Metodo `B`, che sta tentando di accedere alla risorsa, può arrestare l'analisi dello stack immediatamente usando la <xref:System.Security.CodeAccessPermission.Assert%2A> (metodo). In tal caso, il <xref:System.Security.CodeAccessPermission.PermitOnly%2A> posizionato sullo stack di dal metodo `A` (il metodo chiama) non è mai stato individuato.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> è simile a <xref:System.Security.CodeAccessPermission.Deny%2A>, in quanto entrambi provocano l'analisi dello stack esito negativo quando avrebbe potuto essere positivo. La differenza è che <xref:System.Security.CodeAccessPermission.Deny%2A> specifica le autorizzazioni che provocano il percorso stack vada a buon fine ma <xref:System.Security.CodeAccessPermission.PermitOnly%2A> specifica solo le autorizzazioni che non causano il percorso stack esito negativo.  
  
 Chiamare questo metodo per assicurarsi che il codice possa essere utilizzato per accedere solo alle risorse specificate. La chiamata a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> è efficace fino a quando il codice chiamante viene restituito al chiamante. Un solo <xref:System.Security.CodeAccessPermission.PermitOnly%2A> può essere attivo in un frame. Un tentativo di chiamare <xref:System.Security.CodeAccessPermission.PermitOnly%2A> quando un oggetto attivo <xref:System.Security.CodeAccessPermission.PermitOnly%2A> sui risultati del frame è presente un <xref:System.Security.SecurityException>. Chiamare <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> oppure <xref:System.Security.CodeAccessPermission.RevertAll%2A> per rimuovere un oggetto attivo <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.  
  
 <xref:System.Security.CodeAccessPermission.PermitOnly%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà. Tuttavia, se il codice inferiore nello stack in un secondo momento le chiamate <xref:System.Security.CodeAccessPermission.Demand%2A> per l'autorizzazione, un <xref:System.Security.SecurityException> generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <xref:System.Security.CodeAccessPermission.PermitOnly%2A>. Infatti, il codice che ha chiamato <xref:System.Security.CodeAccessPermission.PermitOnly%2A> non ha ottenuto l'autorizzazione, anche se chiamato <xref:System.Security.CodeAccessPermission.PermitOnly%2A> per tale autorizzazione. Lo stack di chiamate in genere è rappresentato come cresce verso il basso, in modo che i metodi più elevati nello stack di chiamate chiamare metodi inferiore nello stack di chiamate.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Esiste già un oggetto <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> attivo per il fotogramma corrente.</exception>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberSignature Language="F#" Value="static member RevertAll : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tutti i precedenti override per il frame corrente vengono rimossi e non sono più attivi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono disponibili override (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, o <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) per il frame corrente, un <xref:System.ExecutionEngineException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è presente alcun <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" /> o <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> precedente per il frame corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberSignature Language="F#" Value="static member RevertAssert : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAssert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Qualsiasi <see cref="M:System.Security.CodeAccessPermission.Assert" /> precedente per il frame corrente viene rimosso e non è più attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente alcun <xref:System.Security.CodeAccessPermission.Assert%2A> per il frame corrente, un <xref:System.ExecutionEngineException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è presente alcun oggetto <see cref="M:System.Security.CodeAccessPermission.Assert" /> precedente per il fotogramma corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberSignature Language="F#" Value="static member RevertDeny : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertDeny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Qualsiasi <see cref="M:System.Security.CodeAccessPermission.Deny" /> precedente per il frame corrente viene rimosso e non è più attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente alcun <xref:System.Security.CodeAccessPermission.Deny%2A> per il frame corrente, un <xref:System.ExecutionEngineException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è presente alcun oggetto <see cref="M:System.Security.CodeAccessPermission.Deny" /> precedente per il fotogramma corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberSignature Language="F#" Value="static member RevertPermitOnly : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertPermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Qualsiasi <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> precedente per il frame corrente viene rimosso e non è più attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente alcun <xref:System.Security.CodeAccessPermission.PermitOnly%2A> per il frame corrente, un <xref:System.ExecutionEngineException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è presente alcun oggetto <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> precedente per il fotogramma corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="codeAccessPermission.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea e restituisce una rappresentazione di stringa dell'oggetto autorizzazione corrente.</summary>
        <returns>Rappresentazione di stringa dell'oggetto autorizzazione corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è utile per eseguire il debug quando è necessario visualizzare l'autorizzazione sotto forma di stringa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement" Usage="codeAccessPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando sottoposto a override in una classe derivata, crea una codifica XML dell'oggetto di sicurezza e del relativo stato corrente.</summary>
        <returns>Codifica XML dell'oggetto di sicurezza, che include le eventuali informazioni sullo stato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codice personalizzato che consente di estendere gli oggetti di sicurezza deve implementare il <xref:System.Security.CodeAccessPermission.ToXml%2A> e <xref:System.Security.CodeAccessPermission.FromXml%2A> metodi da rendere codificabili gli oggetti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.ToXml%2A> (metodo). Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Union other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">Autorizzazione da combinare con quella corrente. Deve essere dello stesso tipo dell'autorizzazione corrente.</param>
        <summary>Quando sottoposto a override in una classe derivata, crea un'autorizzazione che rappresenta l'unione dell'autorizzazione corrente e di quella specificata.</summary>
        <returns>Nuova autorizzazione che rappresenta l'unione dell'autorizzazione corrente e di quella specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il risultato di una chiamata a <xref:System.Security.CodeAccessPermission.Union%2A> è un'autorizzazione che rappresenta tutte le operazioni indicate dall'autorizzazione corrente sia l'autorizzazione specificata. Qualsiasi richiesta che supera una di queste autorizzazioni passa l'unione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un override del <xref:System.Security.CodeAccessPermission.Union%2A> (metodo). Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Security.CodeAccessPermission> classe.  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il parametro <paramref name="other" /> non è <see langword="null" />. Questo metodo è supportato solo a questo livello quando viene passato <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>È necessario eseguire l'override di questo metodo in una classe derivata. È necessario restituire una copia dell'autorizzazione se il valore della <paramref name="other" /> parametro è <see langword="null" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>