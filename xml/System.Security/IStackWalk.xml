<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IStackWalk.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b37ff083eff27618aa07c0a744562f3f8a613708.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b37ff083eff27618aa07c0a744562f3f8a613708</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.IStackWalk">
          <source>Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</source>
          <target state="translated">Gestisce il percorso dello stack che determina se tutti i chiamanti nello stack di chiamate hanno le autorizzazioni necessarie per accedere a una risorsa protetta.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>Partially trusted code always presents a security risk.</source>
          <target state="translated">Codice parzialmente attendibile rappresenta sempre un rischio di sicurezza.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</source>
          <target state="translated">In alcuni casi, possono essere modificato per eseguire azioni per conto di codice dannoso che non dispone dell'autorizzazione per accedere a una risorsa.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>In this way, malicious code can achieve higher security access than it should be allowed.</source>
          <target state="translated">In questo modo, il codice dannoso può ottenere un accesso di sicurezza superiore a quello che dovrebbe essere consentito.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</source>
          <target state="translated">Common language runtime consente di proteggere il codice gestito da tali attacchi mediante l'esecuzione di un'analisi dello stack su tutte le chiamate.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>The stack walk requires that all code in the call stack has permission to access a protected resource.</source>
          <target state="translated">Il percorso dello stack è necessario che tutto il codice dello stack di chiamate dispone dell'autorizzazione per accedere a una risorsa protetta.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</source>
          <target state="translated">Poiché il codice che tenta l'attacco sarà sempre un punto nello stack di chiamate, in grado di superare le proprie autorizzazioni di sicurezza.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Assert">
          <source>Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">Dichiara che il codice chiamante può accedere alla ricorsa identificata dall'oggetto autorizzazioni corrente, anche se ai chiamanti più in alto nello stack non è stata concessa l'autorizzazione ad accedere alla risorsa.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Calling <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> stops the permission check on callers higher in the call stack.</source>
          <target state="translated">La chiamata <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> interrompe il controllo delle autorizzazioni su chiamanti nello stack di chiamate.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Therefore, even if these callers do not have the requisite permissions, they can still access resources.</source>
          <target state="translated">Pertanto, anche se ai chiamanti non dispone delle autorizzazioni necessarie, sarà comunque possibile accedere alle risorse.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>An assertion is effective only if the code that calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> passes the security check for the permission that it is asserting.</source>
          <target state="translated">Un'asserzione è efficace solo se il codice che chiama <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> passa il controllo della sicurezza per l'autorizzazione che genera un'asserzione.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>A call to <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> is effective until the calling code returns to its caller or until a subsequent call to <ph id="ph2">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> renders the previous assertion ineffective.</source>
          <target state="translated">Una chiamata a <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> è efficace fino a quando il codice chiamante restituisce al chiamante o fino a quando una chiamata successiva a <ph id="ph2">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> inefficace l'asserzione precedente.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Also, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> removes a pending <ph id="ph3">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>.</source>
          <target state="translated">Inoltre, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> rimuove un in sospeso <ph id="ph3">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>However, if code lower on the call stack calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>.</source>
          <target state="translated">Tuttavia, se il codice inferiore nello stack di chiamate chiama <ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> per l'autorizzazione, un <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <ph id="ph3">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>This happens because the code that called <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> has not been granted the permission, even though it tried to <ph id="ph2">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> it.</source>
          <target state="translated">Ciò accade perché il codice che ha chiamato <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> non dispone dell'autorizzazione, anche se si è tentato di <ph id="ph2">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> è.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Because calling <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</source>
          <target state="translated">Poiché la chiamata <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> rimuove il requisito che tutto il codice nella catena di chiamate deve essere concessa l'autorizzazione per accedere alla risorsa specificata, può provocare problemi di sicurezza se usata in modo non corretto o inappropriato.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">Pertanto, devono essere utilizzata con estrema cautela.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Assert">
          <source>The calling code does not have <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</source>
          <target state="translated">Il codice chiamante non ha <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Demand">
          <source>Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</source>
          <target state="translated">Determina in fase di esecuzione se tutti i chiamanti nello stack di chiamate hanno l'autorizzazione specificata dall'oggetto autorizzazioni corrente.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Demand">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">Questo metodo viene in genere utilizzato da librerie protette per garantire che i chiamanti dispongano dell'autorizzazione per accedere a una risorsa.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Demand">
          <source>For example, a file class in a secure class library calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> for the necessary <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> before performing a file operation requested by the caller.</source>
          <target state="translated">Ad esempio, una classe di file in una libreria di classi protette chiama <ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> per gli oggetti necessari <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> prima di eseguire un'operazione di file richiesta dal chiamante.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Demand">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">Le autorizzazioni del codice che chiama questo metodo non vengono esaminate; il controllo inizia da parte del chiamante immediato del codice e continua fino allo stack.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Demand">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> succeeds only if no <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> ha esito positivo solo se nessun <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> viene generato.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Demand">
          <source>A caller higher in the call stack does not have the permission specified by the current permission object.</source>
          <target state="translated">Un chiamante in una posizione superiore nello stack di chiamate non ha l'autorizzazione specificata dall'oggetto autorizzazioni corrente.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Demand">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Demand">
          <source>A caller in the call stack has called <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Deny" /&gt;</ph> on the current permission object.</source>
          <target state="translated">Un chiamante nello stack di chiamate ha chiamato il metodo <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Deny" /&gt;</ph> nell'oggetto autorizzazioni corrente.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Deny">
          <source>Causes every <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Demand" /&gt;</ph> for the current object that passes through the calling code to fail.</source>
          <target state="translated">Causa l'esito negativo di ogni oggetto <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Demand" /&gt;</ph> per l'oggetto corrente che passa attraverso il codice chiamante.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">Questo metodo impedisce ai chiamanti più in alto nello stack di chiamate di accedere alla risorsa protetta tramite il codice che chiama questo metodo, anche se i chiamanti dispongono dell'autorizzazione per accedervi.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <ph id="ph2">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> from being used to access the resource protected by the denied permission.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> può limitare la responsabilità del programmatore o impedire vulnerabilità della sicurezza accidentale, in quanto impedisce che il metodo che chiama <ph id="ph2">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> venga utilizzato per accedere alla risorsa protetta dall'autorizzazione negata.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source>If a method calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> on a permission, and if a <ph id="ph2">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <ph id="ph3">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>.</source>
          <target state="translated">Se chiama un metodo <ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> su un'autorizzazione e se un <ph id="ph2">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> per tale autorizzazione viene richiamato da un chiamante inferiore nello stack di chiamate, la verifica della sicurezza avrà esito negativo quando raggiunge il <ph id="ph3">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source>You cannot override this method.</source>
          <target state="translated">È possibile eseguire l'override di questo metodo.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>Causes every <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Demand" /&gt;</ph> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</source>
          <target state="translated">Determina l'annullamento di tutti i metodi <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Demand" /&gt;</ph> che attraversano il codice chiamante per tutti gli oggetti ad eccezione dell'oggetto corrente, anche se il codice nella parte superiore dello stack di chiamate dispone dell'autorizzazione necessaria per accedere ad altre risorse.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> è simile a <ph id="ph2">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>, perché entrambi provocano l'analisi dello stack se avranno esito positivo.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>The difference is that <ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> specifies permissions that will cause the stack walk to fail, but <ph id="ph2">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">La differenza è che <ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> specifica le autorizzazioni che provocano il percorso, di stack ma <ph id="ph2">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> specifica solo le autorizzazioni che non provocano il percorso di stack.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">Chiamare questo metodo per verificare che il codice può essere utilizzato per accedere solo le risorse specificate.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>However, if code lower on the call stack later calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">Tuttavia, se il codice inferiore nello stack di in un secondo momento chiama <ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> per l'autorizzazione, un <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <ph id="ph3">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>This is because the code that called <ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> has not been granted the permission, even though it called <ph id="ph2">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> for that permission.</source>
          <target state="translated">In questo modo il codice che ha chiamato <ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> non dispone dell'autorizzazione, anche se chiamato <ph id="ph2">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> per tale autorizzazione.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>