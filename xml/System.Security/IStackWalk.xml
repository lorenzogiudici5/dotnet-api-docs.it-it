<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b37ff083eff27618aa07c0a744562f3f8a613708" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30499165" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gestisce il percorso dello stack che determina se tutti i chiamanti nello stack di chiamate hanno le autorizzazioni necessarie per accedere a una risorsa protetta.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codice parzialmente attendibile rappresenta sempre un rischio di sicurezza. In alcuni casi, possono essere modificato per eseguire azioni per conto di codice dannoso che non dispone dell'autorizzazione per accedere a una risorsa. In questo modo, il codice dannoso può ottenere un accesso di sicurezza superiore a quello che dovrebbe essere consentito.  
  
 Common language runtime consente di proteggere il codice gestito da tali attacchi mediante l'esecuzione di un'analisi dello stack su tutte le chiamate. Il percorso dello stack è necessario che tutto il codice dello stack di chiamate dispone dell'autorizzazione per accedere a una risorsa protetta. Poiché il codice che tenta l'attacco sarà sempre un punto nello stack di chiamate, in grado di superare le proprie autorizzazioni di sicurezza.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dichiara che il codice chiamante può accedere alla ricorsa identificata dall'oggetto autorizzazioni corrente, anche se ai chiamanti più in alto nello stack non è stata concessa l'autorizzazione ad accedere alla risorsa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata <xref:System.Security.IStackWalk.Assert%2A> interrompe il controllo delle autorizzazioni su chiamanti nello stack di chiamate. Pertanto, anche se ai chiamanti non dispone delle autorizzazioni necessarie, sarà comunque possibile accedere alle risorse. Un'asserzione è efficace solo se il codice che chiama <xref:System.Security.IStackWalk.Assert%2A> passa il controllo della sicurezza per l'autorizzazione che genera un'asserzione.  
  
 Una chiamata a <xref:System.Security.IStackWalk.Assert%2A> è efficace fino a quando il codice chiamante restituisce al chiamante o fino a quando una chiamata successiva a <xref:System.Security.IStackWalk.Assert%2A> inefficace l'asserzione precedente. Inoltre, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> o <xref:System.Security.CodeAccessPermission.RevertAll%2A> rimuove un in sospeso <xref:System.Security.IStackWalk.Assert%2A>.  
  
 <xref:System.Security.IStackWalk.Assert%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà. Tuttavia, se il codice inferiore nello stack di chiamate chiama <xref:System.Security.IStackWalk.Demand%2A> per l'autorizzazione, un <xref:System.Security.SecurityException> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <xref:System.Security.IStackWalk.Assert%2A>. Ciò accade perché il codice che ha chiamato <xref:System.Security.IStackWalk.Assert%2A> non dispone dell'autorizzazione, anche se si è tentato di <xref:System.Security.IStackWalk.Assert%2A> è.  
  
> [!CAUTION]
>  Poiché la chiamata <xref:System.Security.IStackWalk.Assert%2A> rimuove il requisito che tutto il codice nella catena di chiamate deve essere concessa l'autorizzazione per accedere alla risorsa specificata, può provocare problemi di sicurezza se usata in modo non corretto o inappropriato. Pertanto, devono essere utilizzata con estrema cautela.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il codice chiamante non ha <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina in fase di esecuzione se tutti i chiamanti nello stack di chiamate hanno l'autorizzazione specificata dall'oggetto autorizzazioni corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene in genere utilizzato da librerie protette per garantire che i chiamanti dispongano dell'autorizzazione per accedere a una risorsa. Ad esempio, una classe di file in una libreria di classi protette chiama <xref:System.Security.IStackWalk.Demand%2A> per gli oggetti necessari <xref:System.Security.Permissions.FileIOPermission> prima di eseguire un'operazione di file richiesta dal chiamante.  
  
 Le autorizzazioni del codice che chiama questo metodo non vengono esaminate; il controllo inizia da parte del chiamante immediato del codice e continua fino allo stack. <xref:System.Security.IStackWalk.Demand%2A> ha esito positivo solo se nessun <xref:System.Security.SecurityException> viene generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante in una posizione superiore nello stack di chiamate non ha l'autorizzazione specificata dall'oggetto autorizzazioni corrente.  
  
 oppure  
  
 Un chiamante nello stack di chiamate ha chiamato il metodo <see cref="M:System.Security.IStackWalk.Deny" /> nell'oggetto autorizzazioni corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causa l'esito negativo di ogni oggetto <see cref="M:System.Security.IStackWalk.Demand" /> per l'oggetto corrente che passa attraverso il codice chiamante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo impedisce ai chiamanti più in alto nello stack di chiamate di accedere alla risorsa protetta tramite il codice che chiama questo metodo, anche se i chiamanti dispongono dell'autorizzazione per accedervi. Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.  
  
 <xref:System.Security.IStackWalk.Deny%2A> può limitare la responsabilità del programmatore o impedire vulnerabilità della sicurezza accidentale, in quanto impedisce che il metodo che chiama <xref:System.Security.IStackWalk.Deny%2A> venga utilizzato per accedere alla risorsa protetta dall'autorizzazione negata. Se chiama un metodo <xref:System.Security.IStackWalk.Deny%2A> su un'autorizzazione e se un <xref:System.Security.IStackWalk.Demand%2A> per tale autorizzazione viene richiamato da un chiamante inferiore nello stack di chiamate, la verifica della sicurezza avrà esito negativo quando raggiunge il <xref:System.Security.IStackWalk.Deny%2A>.  
  
 <xref:System.Security.IStackWalk.Deny%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina l'annullamento di tutti i metodi <see cref="M:System.Security.IStackWalk.Demand" /> che attraversano il codice chiamante per tutti gli oggetti ad eccezione dell'oggetto corrente, anche se il codice nella parte superiore dello stack di chiamate dispone dell'autorizzazione necessaria per accedere ad altre risorse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.IStackWalk.PermitOnly%2A> è simile a <xref:System.Security.IStackWalk.Deny%2A>, perché entrambi provocano l'analisi dello stack se avranno esito positivo. La differenza è che <xref:System.Security.IStackWalk.Deny%2A> specifica le autorizzazioni che provocano il percorso, di stack ma <xref:System.Security.IStackWalk.PermitOnly%2A> specifica solo le autorizzazioni che non provocano il percorso di stack. Chiamare questo metodo per verificare che il codice può essere utilizzato per accedere solo le risorse specificate.  
  
 <xref:System.Security.IStackWalk.PermitOnly%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà. Tuttavia, se il codice inferiore nello stack di in un secondo momento chiama <xref:System.Security.IStackWalk.Demand%2A> per l'autorizzazione, un <xref:System.Security.SecurityException> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <xref:System.Security.IStackWalk.PermitOnly%2A>. In questo modo il codice che ha chiamato <xref:System.Security.IStackWalk.PermitOnly%2A> non dispone dell'autorizzazione, anche se chiamato <xref:System.Security.IStackWalk.PermitOnly%2A> per tale autorizzazione. Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate a metodi chiamano metodi inferiore nello stack di chiamate.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>