<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50cee1b779f4bf3586b066ea45f3b7cac364420b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36623131" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codice parzialmente attendibile rappresenta sempre un rischio per la sicurezza. In alcuni casi, possono essere modificato per eseguire azioni per conto di codice dannoso che non dispone dell'autorizzazione per accedere a una risorsa. In questo modo, codice dannoso può ottenere un accesso di sicurezza superiore a quello che dovrebbe essere consentito.  
  
 Common language runtime consente di proteggere il codice gestito da tali attacchi mediante l'esecuzione di un percorso stack su tutte le chiamate. L'analisi dello stack, è necessario che tutto il codice nello stack di chiamate disponga delle autorizzazioni necessarie per accedere a una risorsa protetta. Poiché il codice che tenta l'attacco sarà sempre in un punto nello stack di chiamate, in grado di superare le proprie autorizzazioni di sicurezza.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata <xref:System.Security.IStackWalk.Assert%2A> interrompe il controllo delle autorizzazioni sui chiamanti più in alto nello stack di chiamate. Pertanto, anche se ai chiamanti non dispone delle autorizzazioni necessarie, può ancora accedere alle risorse. Un'asserzione è efficace solo se il codice che chiama <xref:System.Security.IStackWalk.Assert%2A> passa il controllo della sicurezza per l'autorizzazione che genera un'asserzione.  
  
 Una chiamata a <xref:System.Security.IStackWalk.Assert%2A> è efficace fino a quando il codice chiamante restituisce al chiamante o fino a una chiamata successiva a <xref:System.Security.IStackWalk.Assert%2A> inefficace l'asserzione precedente. Inoltre, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> oppure <xref:System.Security.CodeAccessPermission.RevertAll%2A> rimuove un'in sospeso <xref:System.Security.IStackWalk.Assert%2A>.  
  
 <xref:System.Security.IStackWalk.Assert%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà. Tuttavia, se il codice inferiore nello stack di chiamate chiama <xref:System.Security.IStackWalk.Demand%2A> per l'autorizzazione, un <xref:System.Security.SecurityException> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <xref:System.Security.IStackWalk.Assert%2A>. Ciò accade perché il codice che ha chiamato <xref:System.Security.IStackWalk.Assert%2A> non dispone dell'autorizzazione, anche se il tentativo di <xref:System.Security.IStackWalk.Assert%2A> è.  
  
> [!CAUTION]
>  Poiché la chiamata <xref:System.Security.IStackWalk.Assert%2A> rimuove il requisito che tutto il codice nella catena di chiamate deve essere concessa l'autorizzazione per accedere alla risorsa specificata, può provocare problemi di sicurezza se utilizzato in modo non corretto o non appropriata. Pertanto, devono essere utilizzata con estrema cautela.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene in genere utilizzato da librerie protette per garantire che i chiamanti dispongano dell'autorizzazione per accedere a una risorsa. Ad esempio, chiama una classe di file in una libreria di classi protette <xref:System.Security.IStackWalk.Demand%2A> per le necessarie <xref:System.Security.Permissions.FileIOPermission> prima di eseguire un'operazione di file richiesta dal chiamante.  
  
 Le autorizzazioni del codice che chiama questo metodo non vengono esaminate; la verifica inizia da parte del chiamante immediato del codice e continua nello stack. <xref:System.Security.IStackWalk.Demand%2A> ha esito positivo solo se nessun <xref:System.Security.SecurityException> viene generato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have the permission specified by the current permission object.  -or-  A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo impedisce ai chiamanti più in alto nello stack di chiamate di accesso alla risorsa protetta tramite il codice che chiama questo metodo, anche se i chiamanti dispongono dell'autorizzazione per accedervi. Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate chiamano metodi inferiore nello stack di chiamate.  
  
 <xref:System.Security.IStackWalk.Deny%2A> può limitare la responsabilità del programmatore o impedire vulnerabilità della sicurezza accidentale, in quanto impedisce che il metodo che chiama <xref:System.Security.IStackWalk.Deny%2A> vengano utilizzati per accedere alla risorsa protetta dall'autorizzazione negata. Se un metodo chiama <xref:System.Security.IStackWalk.Deny%2A> su un'autorizzazione e se un <xref:System.Security.IStackWalk.Demand%2A> per tale autorizzazione viene richiamata da un chiamante inferiore nello stack di chiamate, la verifica della sicurezza avrà esito negativo quando raggiunge il <xref:System.Security.IStackWalk.Deny%2A>.  
  
 <xref:System.Security.IStackWalk.Deny%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile eseguire l'override di questo metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.IStackWalk.PermitOnly%2A> è simile a <xref:System.Security.IStackWalk.Deny%2A>, in quanto entrambi provocano stack quando avranno esito positivo. La differenza consiste nel fatto che <xref:System.Security.IStackWalk.Deny%2A> specifica le autorizzazioni che faranno sì che il percorso stack avere esito negativo, ma <xref:System.Security.IStackWalk.PermitOnly%2A> specifica solo le autorizzazioni che non provocano l'analisi dello stack avere esito negativo. Chiamare questo metodo per verificare che il codice può essere utilizzato per accedere solo le risorse specificate.  
  
 <xref:System.Security.IStackWalk.PermitOnly%2A> viene ignorato per un'autorizzazione non concessa perché una richiesta di tale autorizzazione non riuscirà. Tuttavia, se il codice inferiore nello stack in un secondo momento chiama <xref:System.Security.IStackWalk.Demand%2A> per l'autorizzazione, un <xref:System.Security.SecurityException> viene generata quando il percorso stack raggiunge il codice che ha tentato di chiamare <xref:System.Security.IStackWalk.PermitOnly%2A>. Infatti, il codice che ha chiamato <xref:System.Security.IStackWalk.PermitOnly%2A> non è stata concessa l'autorizzazione, anche se chiamato <xref:System.Security.IStackWalk.PermitOnly%2A> per tale autorizzazione. Lo stack di chiamate viene rappresentato in genere come espansione verso il basso, in modo che più in alto nello stack di chiamate chiamano metodi inferiore nello stack di chiamate.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>