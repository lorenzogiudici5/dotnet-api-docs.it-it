<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df1ebcb619c0df47e18bd246379d554a3043d7ed" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37671054" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una cache di dati in memoria.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet>, ovvero una cache in memoria dei dati recuperati da un'origine dati, è un componente fondamentale dell'architettura ADO.NET. Il <xref:System.Data.DataSet> è costituito da una raccolta di <xref:System.Data.DataTable> gli oggetti che è possibile correlare reciprocamente con <xref:System.Data.DataRelation> oggetti. È inoltre possibile applicare l'integrità dei dati nel <xref:System.Data.DataSet> usando il <xref:System.Data.UniqueConstraint> e <xref:System.Data.ForeignKeyConstraint> oggetti. Per altre informazioni sull'utilizzo con <xref:System.Data.DataSet> oggetti, vedere [DataSet, DataTable e DataView](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 Considerando <xref:System.Data.DataTable> oggetti contengono i dati, il <xref:System.Data.DataRelationCollection> consente lo spostamento tra la gerarchia delle tabelle. Le tabelle sono contenute in un <xref:System.Data.DataTableCollection> accessibili tramite il <xref:System.Data.DataSet.Tables%2A> proprietà. Quando si accede a <xref:System.Data.DataTable> oggetti, si noti che sono prevedono la distinzione tra maiuscole e minuscole in modo condizionale. Ad esempio, se uno <xref:System.Data.DataTable> viene denominato "mydatatable" e un altro è denominato "Mydatatable", stringa utilizzata per cercare una delle tabelle verrà applicata la distinzione tra maiuscole e minuscole. Tuttavia, se presente "mydatatable" e "Mydatatable" non esiste, la stringa di ricerca viene considerata come maiuscole e minuscole. Per altre informazioni sull'utilizzo con <xref:System.Data.DataTable> oggetti, vedere [creazione di una DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Oggetto <xref:System.Data.DataSet> possono leggere e scrivere dati e dello schema come documenti XML. I dati e dello schema possono essere trasferiti tramite HTTP e usati da qualsiasi applicazione, in qualsiasi piattaforma che è abilitato per XML. È possibile salvare lo schema come schema XML con il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo e di schemi e i dati possono essere salvati utilizzando il <xref:System.Data.DataSet.WriteXml%2A> (metodo). Per leggere un documento XML che include lo schema sia dei dati, usare il <xref:System.Data.DataSet.ReadXml%2A> (metodo).  
  
 In una tipica implementazione a più livelli, i passaggi per la creazione e l'aggiornamento di un <xref:System.Data.DataSet>, e a sua volta, l'aggiornamento dei dati originali sono per:  
  
1.  Compilare e inserire ognuna <xref:System.Data.DataTable> in un <xref:System.Data.DataSet> con i dati da un'origine dati usando un <xref:System.Data.Common.DataAdapter>.  
  
2.  Modifica dei dati nei singoli <xref:System.Data.DataTable> oggetti per l'aggiunta, aggiornamento o eliminazione di <xref:System.Data.DataRow> oggetti.  
  
3.  Richiama il <xref:System.Data.DataSet.GetChanges%2A> per creare un secondo metodo <xref:System.Data.DataSet> che sono presenti solo le modifiche ai dati.  
  
4.  Chiamare il <xref:System.Data.Common.DataAdapter.Update%2A> metodo per il <xref:System.Data.Common.DataAdapter>, passando il secondo <xref:System.Data.DataSet> come argomento.  
  
5.  Richiama il <xref:System.Data.DataSet.Merge%2A> metodo di unire le modifiche dal secondo <xref:System.Data.DataSet> nella prima.  
  
6.  Richiama il <xref:System.Data.DataSet.AcceptChanges%2A> nella <xref:System.Data.DataSet>. In alternativa, richiamare <xref:System.Data.DataSet.RejectChanges%2A> per annullare le modifiche.  
  
> [!NOTE]
>  Il <xref:System.Data.DataSet> e <xref:System.Data.DataTable> oggetti ereditano da <xref:System.ComponentModel.MarshalByValueComponent>e supporta il <xref:System.Runtime.Serialization.ISerializable> interfaccia per la comunicazione remota. Si tratta degli unici oggetti ADO.NET che è possibile eseguire in remoto.  
  
> [!NOTE]
>  Le classi ereditate dal <xref:System.Data.DataSet> non vengono finalizzati dal garbage collector, perché il finalizzatore è stato soppresso <xref:System.Data.DataSet>. La classe derivata può chiamare il <xref:System.GC.ReRegisterForFinalize%2A> metodo nel costruttore per consentire alla classe di essere finalizzati dal garbage collector.  
  
   
  
## Examples  
 Nell'esempio seguente è costituito da diversi metodi che, combinato, creare e compilare un <xref:System.Data.DataSet> dal **Northwind** database.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è sicuro per le operazioni di lettura a thread multipli. È necessario sincronizzare qualsiasi operazione di scrittura.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione del <xref:System.Data.DataSet> costruttore non accetta parametri e crea un nome predefinito, "NewDataSet", per la nuova istanza.  
  
 Un nome per il <xref:System.Data.DataSet> è necessario per garantire che la rappresentazione XML del <xref:System.Data.DataSet> ha sempre un nome per l'elemento del documento, ossia l'elemento di livello più elevato in una definizione dello schema.  
  
   
  
## Examples  
 L'esempio seguente crea una nuova <xref:System.Data.DataSet>e aggiunge due <xref:System.Data.DataTable> oggetti ad esso.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">Nome di <see cref="T:System.Data.DataSet" />.</param>
        <summary>Inizializza una nuova istanza di una classe <see cref="T:System.Data.DataSet" /> con il nome specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nome per il <xref:System.Data.DataSet> è necessario per garantire che la rappresentazione XML del <xref:System.Data.DataSet> ha sempre un nome per l'elemento del documento, ovvero l'elemento di livello più elevato in una definizione dello schema.  
  
   
  
## Examples  
 L'esempio seguente crea una nuova <xref:System.Data.DataSet>, a cui due <xref:System.Data.DataTable> gli oggetti vengono aggiunti.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Dati necessari per serializzare o deserializzare un oggetto.</param>
        <param name="context">Origine e destinazione di un flusso serializzato specificato.</param>
        <summary>Inizializza una nuova istanza di una classe <see cref="T:System.Data.DataSet" /> avente le informazioni di serializzazione e il contesto specificati.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <param name="ConstructSchema">Valore Boolean.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esegue il commit di tutte le modifiche apportate a questo oggetto <see cref="T:System.Data.DataSet" /> dal momento in cui è stato caricato o dall'ultima chiamata al metodo <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sia la <xref:System.Data.DataRow> e <xref:System.Data.DataTable> classi hanno <xref:System.Data.DataSet.AcceptChanges%2A> metodi. La chiamata <xref:System.Data.DataTable.AcceptChanges%2A> nella <xref:System.Data.DataTable> cause di livello il <xref:System.Data.DataRow.AcceptChanges%2A> metodo per ogni <xref:System.Data.DataRow> da chiamare. Allo stesso modo, la chiamata <xref:System.Data.DataSet.AcceptChanges%2A> nella <xref:System.Data.DataSet> fa sì che <xref:System.Data.DataTable.AcceptChanges%2A> da chiamare in ogni tabella inclusa nel <xref:System.Data.DataSet>. In questo modo, si dispone di più livelli in corrispondenza del quale il metodo può essere richiamato. Chiama il <xref:System.Data.DataSet.AcceptChanges%2A> del <xref:System.Data.DataSet> consente di richiamare il metodo su tutti gli oggetti subordinati (ad esempio, tabelle e righe) con una sola chiamata.  
  
 Quando si chiama `AcceptChanges` nella `DataSet`, qualsiasi <xref:System.Data.DataRow> oggetti ancora in modalità di modifica vengono completate correttamente le modifiche apportate. Il <xref:System.Data.DataRow.RowState%2A> proprietà della ognuno <xref:System.Data.DataRow> anche viene modificato. `Added` e `Modified` righe diventare `Unchanged`, e `Deleted` vengono rimosse le righe.  
  
 Se il `DataSet` contiene <xref:System.Data.ForeignKeyConstraint> oggetti, richiamando il `AcceptChanges` metodo determina inoltre il <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> possano essere applicate.  
  
> [!NOTE]
>  `AcceptChanges` e `RejectChanges` si applicano solo a `DataRow` relative modifiche (vale a dire, Add, Remove, eliminazione e modifica). Non sono applicabili allo schema o modifiche strutturali.  
>   
>  La chiamata di AcceptChanges non consentirà di eseguire la replica di queste modifiche nell'origine dati se il DataSet è stato compilato utilizzando un DataAdapter. In tal caso, chiamare invece <xref:System.Data.Common.DataAdapter.Update%2A>. Visualizzare [l'aggiornamento di origini dati con DataAdapter](http://msdn.microsoft.com/library/33y2221y.aspx) per altre informazioni.  
  
   
  
## Examples  
 L'esempio seguente aggiunge un <xref:System.Data.DataRow> a un <xref:System.Data.DataTable> in un <xref:System.Data.DataSet>. Il <xref:System.Data.DataSet.AcceptChanges%2A> viene quindi chiamato il metodo sul <xref:System.Data.DataSet>, quali unarie a catena a tutti i <xref:System.Data.DataTable> gli oggetti in esso contenuti.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia l'inizializzazione di una <see cref="T:System.Data.DataSet" /> usata su un form o da un altro componente. L'inizializzazione avviene in fase di esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ambiente di progettazione di Visual Studio .NET Usa questo metodo per avviare l'inizializzazione di un componente che viene usato in un form o da un altro componente. Il <xref:System.Data.DataSet.EndInit%2A> metodo termina l'inizializzazione. Usando il <xref:System.Data.DataSet.BeginInit%2A> e <xref:System.Data.DataSet.EndInit%2A> metodi impedisce l'utilizzo prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se nei confronti tra stringhe all'interno di oggetti <see cref="T:System.Data.DataTable" /> viene applicata la distinzione tra maiuscole e minuscole.</summary>
        <value>
          <see langword="true" /> se per i confronti tra stringhe viene applicata la distinzione tra maiuscole e minuscole; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.CaseSensitive%2A> proprietà influisce sulla modalità di ordinamento, ricerca e operazioni di filtro vengono eseguite in ogni <xref:System.Data.DataTable> oggetto contenuto un <xref:System.Data.DataSet> quando si usa il <xref:System.Data.DataTable.Select%2A> (metodo).  
  
 Per impostazione predefinita, l'impostazione di <xref:System.Data.DataSet.CaseSensitive%2A> proprietà per un <xref:System.Data.DataSet> imposta inoltre il <xref:System.Data.DataTable.CaseSensitive%2A> proprietà della ognuno associati <xref:System.Data.DataTable> sullo stesso valore.  
  
   
  
## Examples  
 Nell'esempio seguente attiva o disattiva il <xref:System.Data.DataSet.CaseSensitive%2A> proprietà.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutti i dati dall'oggetto <see cref="T:System.Data.DataSet" /> rimuovendo tutte le righe in tutte le tabelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Data.DataSet> è associato a un <xref:System.Xml.XmlDataDocument>, la chiamata <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> oppure <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> genera il <xref:System.NotSupportedException>. Per evitare questa situazione, scorrere ogni tabella, rimuovendo una riga alla volta.  
  
   
  
## Examples  
 L'esempio seguente cancella i <xref:System.Data.DataSet> di tutte le righe in tutte le tabelle.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia la struttura dell'oggetto <see cref="T:System.Data.DataSet" />, inclusi tutti gli schemi, le relazioni e i vincoli dell'oggetto <see cref="T:System.Data.DataTable" />. Non vengono copiati i dati.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Data.DataSet" /> con lo stesso schema dell'oggetto <see cref="T:System.Data.DataSet" /> corrente, ma senza dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se queste classi sono state suddivise in sottoclassi, il clone sarà inoltre delle stesse sottoclassi.  
  
   
  
## Examples  
 L'esempio seguente crea un clone di un <xref:System.Data.DataSet> schema dell'oggetto.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia la struttura e i dati per questa classe <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Data.DataSet" /> con la stessa struttura (schemi, relazioni e vincoli della tabella) e gli stessi dati dell'oggetto <see cref="T:System.Data.DataSet" /> corrente.  
  
 <block subset="none" type="note"><para> Se queste classi sono state suddivise in sottoclassi, verrà eseguita anche una copia delle stesse sottoclassi.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataSet.Copy%2A> metodo per creare una copia dell'originale <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una classe <see cref="T:System.Data.DataTableReader" /> con un gruppo di risultati per la classe <see cref="T:System.Data.DataTable" />, nella stessa sequenza in cui le tabelle appaiono nell'insieme <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per garantire l'ordine dei set di risultati all'interno di restituito <xref:System.Data.DataTableReader>, se un <xref:System.Data.DataTable> all'interno di <xref:System.Data.DataSet> è vuoto, viene rappresentato da un risultato vuoto impostati nell'oggetto restituito `DataTableReader`.  
  
   
  
## Examples  
 Questo esempio, un'applicazione Console, vengono creati tre <xref:System.Data.DataTable> istanze e di aggiungere ciascuno a un <xref:System.Data.DataSet>. L'esempio chiama il <xref:System.Data.DataSet.CreateDataReader%2A> metodo e consente di visualizzare il contenuto dell'oggetto restituito <xref:System.Data.DataTableReader>. Si noti che imposta l'ordine del risultato nel `DataTableReader` è controllato dall'ordine del `DataTable` istanze passati come parametri.  
  
> [!NOTE]
>  Questo esempio illustra come usare una delle versioni di overload del `CreateDataReader`. Per altri esempi che potrebbero essere disponibili, vedere gli argomenti di overload singoli.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 L'esempio visualizza il codice seguente nella finestra della Console:  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una classe <see cref="T:System.Data.DataTableReader" /> con un gruppo di risultati per la classe <see cref="T:System.Data.DataTable" />, nella stessa sequenza in cui le tabelle appaiono nell'insieme <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <returns>Classe <see cref="T:System.Data.DataTableReader" /> contenente uno o più gruppi di risultati, che corrispondono alle istanze della classe <see cref="T:System.Data.DataTable" /> contenuta nella classe <see cref="T:System.Data.DataSet" /> di origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per garantire l'ordine dei set di risultati all'interno di restituito <xref:System.Data.DataTableReader>, se un <xref:System.Data.DataTable> all'interno di <xref:System.Data.DataSet> è vuoto, è rappresentato da un risultato vuoto impostati nell'oggetto restituito `DataTableReader`.  
  
   
  
## Examples  
 L'esempio seguente crea tre <xref:System.Data.DataTable> le istanze e aggiungere ciascuno a un <xref:System.Data.DataSet>. Nell'esempio viene quindi compilato passato `DataSet` a una routine che chiama il <xref:System.Data.DataSet.CreateDataReader%2A> metodo e prosegue per scorrere tutti i set di risultati contenuti all'interno di <xref:System.Data.DataTableReader>. L'esempio visualizza i risultati nella finestra della Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Matrice di DataTables che fornisce l'ordine dei gruppi di risultati da restituire nella classe <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Restituisce una classe <see cref="T:System.Data.DataTableReader" /> con un gruppo di risultati per la classe <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Classe <see cref="T:System.Data.DataTableReader" /> contenente uno o più gruppi di risultati, che corrispondono alle istanze della classe <see cref="T:System.Data.DataTable" /> contenuta nella classe <see cref="T:System.Data.DataSet" /> di origine. I gruppi di risultati restituiti sono nell'ordine specificato dal parametro <paramref name="dataTables" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per garantire che l'ordine del risultato set all'interno di restituito <xref:System.Data.DataTableReader>, se un <xref:System.Data.DataTable> all'interno di <xref:System.Data.DataSet> è vuoto, è rappresentato da un risultato vuoto impostati nell'oggetto restituito `DataTableReader`. Poiché questa versione di overload consente di specificare un elenco delle `DataTable` istanze come parametri, è possibile specificare l'ordine in cui i set di risultati vengono visualizzati all'interno di restituito `DataTableReader`.  
  
   
  
## Examples  
 Questo esempio, un'applicazione Console, vengono creati tre <xref:System.Data.DataTable> istanze e di aggiungere ciascuno a un <xref:System.Data.DataSet>. L'esempio chiama il <xref:System.Data.DataSet.CreateDataReader%2A> metodo e consente di visualizzare il contenuto dell'oggetto restituito <xref:System.Data.DataTableReader>. Si noti che imposta l'ordine del risultato nel `DataTableReader` è controllato dall'ordine del `DataTable` istanze passati come parametri. L'esempio visualizza i risultati nella finestra della Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome della classe <see cref="T:System.Data.DataSet" /> corrente.</summary>
        <value>Nome di <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una nuova <xref:System.Data.DataSet> con il determinato <xref:System.Data.DataSet.DataSetName%2A>.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una visualizzazione personalizzata dei dati contenuti nell'oggetto <see cref="T:System.Data.DataSet" /> per consentire di filtrare, eseguire ricerche ed esplorare mediante un oggetto <see cref="T:System.Data.DataViewManager" /> personalizzato.</summary>
        <value>Un oggetto <see cref="T:System.Data.DataViewManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataViewManager> restituiti dai <xref:System.Data.DataSet.DefaultViewManager%2A> proprietà consente di creare impostazioni personalizzate per ogni <xref:System.Data.DataTable> nel <xref:System.Data.DataSet>.  
  
 Quando ottengono una <xref:System.Data.DataView> da un <xref:System.Data.DataTable>, l'ordinamento, applicazione di filtri, e <xref:System.Data.DataViewRowState> configurati in base alle impostazioni nel <xref:System.Data.DataSet.DefaultViewManager%2A> proprietà.  
  
   
  
## Examples  
 L'esempio seguente ottiene il valore predefinito <xref:System.Data.DataViewManager> per un <xref:System.Data.DataSet>e aggiunge un <xref:System.Data.DataTable> per il <xref:System.Data.DataTableCollection>.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina la proprietà <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> per una classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere chiamato durante la deserializzazione di un oggetto tipizzato <xref:System.Data.DataSet> per determinare il <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Istanza <see cref="T:System.Xml.XmlReader" /> che viene passata durante la deserializzazione della classe <see cref="T:System.Data.DataSet" />.</param>
        <summary>Determina la proprietà <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> per una classe <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Enumerazione <see cref="T:System.Data.SchemaSerializationMode" /> che indica se le informazioni relative allo schema sono state omesse dal payload.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere chiamato durante la deserializzazione di un oggetto tipizzato <xref:System.Data.DataSet> per determinare il <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Classe <see cref="T:System.Runtime.Serialization.SerializationInfo" /> che viene richiamata insieme al metodo <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> del costruttore protetto della classe <see langword="DataSet" /> durante la deserializzazione in scenari remoti.</param>
        <param name="context">Classe <see cref="T:System.Runtime.Serialization.StreamingContext" /> che viene richiamata insieme al metodo <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> del costruttore protetto della classe <see langword="DataSet" /> durante la deserializzazione in scenari remoti.</param>
        <summary>Determina la proprietà <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> per una classe <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Enumerazione <see cref="T:System.Data.SchemaSerializationMode" /> che indica se le informazioni relative allo schema sono state omesse dal payload.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere chiamato durante la deserializzazione di un oggetto tipizzato <xref:System.Data.DataSet> per determinare il <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina l'inizializzazione di una classe <see cref="T:System.Data.DataSet" /> usata su un form o da un altro componente. L'inizializzazione avviene in fase di esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ambiente di progettazione di Visual Studio .NET Usa questo metodo per terminare l'inizializzazione di un componente che viene usato in un form o da un altro componente. Il <xref:System.Data.DataSet.BeginInit%2A> metodo avvia l'inizializzazione. Usando il <xref:System.Data.DataSet.BeginInit%2A> e <xref:System.Data.DataSet.EndInit%2A> metodi impedisce l'utilizzo prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se vengono seguite le regole sui vincoli quando si esegue un'operazione di aggiornamento.</summary>
        <value>
          <see langword="true" /> se le regole sono attivate; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I vincoli sono impostati nel <xref:System.Data.DataTable> livello (<xref:System.Data.DataTable.Constraints%2A> proprietà). Per altre informazioni sulla creazione di vincoli, vedere [vincoli DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Data.DataSet> con una tabella, una colonna, cinque righe e uno <xref:System.Data.UniqueConstraint>. Il <xref:System.Data.DataSet.EnforceConstraints%2A> è impostata su `false` e i valori di ogni riga vengono impostati sullo stesso valore. Quando il <xref:System.Data.DataSet.EnforceConstraints%2A> proprietà viene reimpostata `true`, un <xref:System.Data.ConstraintException> viene generato.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Non è possibile attivare uno o più vincoli.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di informazioni utente personalizzate associate all'oggetto <see langword="DataSet" />.</summary>
        <value>Insieme <see cref="T:System.Data.PropertyCollection" /> contenente tutte le informazioni utente personalizzate.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.ExtendedProperties%2A> proprietà consente di archiviare informazioni personalizzate con il `DataSet`. Ad esempio, è possibile archiviare un tempo quando i dati devono essere aggiornati.  
  
 Le proprietà estese devono essere di tipo <xref:System.String> se si vuole che siano resi persistenti quando le <xref:System.Data.DataSet> viene scritto come XML.  
  
   
  
## Examples  
 L'esempio seguente aggiunge una proprietà personalizzata per il <xref:System.Data.PropertyCollection> restituito dal <xref:System.Data.DataColumn.ExtendedProperties%2A> proprietà. Nel secondo esempio viene recuperata la proprietà personalizzata.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene una copia dell'oggetto <see cref="T:System.Data.DataSet" /> contenente tutte le modifiche apportate sin dall'ultimo caricamento o dall'ultima chiamata a <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una copia della classe <see cref="T:System.Data.DataSet" /> contenente tutte le modifiche apportate a essa dal momento in cui è stata caricata o dall'ultima chiamata al metodo <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <returns>Copia delle modifiche da <see cref="T:System.Data.DataSet" /> su cui è possibile eseguire azioni e che successivamente può essere nuovamente unita tramite <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Se non vengono trovate righe modificate, il metodo restituisce <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo <xref:System.Data.DataSet> che contiene una copia di tutte le righe nell'originale <xref:System.Data.DataSet> che con modifiche in sospeso. I vincoli di relazione possono causare altre righe non modificate da aggiungere al nuovo <xref:System.Data.DataSet> se tali righe contengono chiavi primarie corrispondenti alle chiavi esterne in righe modificate. Il metodo restituisce `null` se non sono presenti righe nell'originale <xref:System.Data.DataSet> che con modifiche in sospeso.  
  
   
  
## Examples  
 L'esempio seguente crea una semplice <xref:System.Data.DataSet> con una tabella, due colonne e dieci righe. Due valori vengono modificati, e viene aggiunta una riga. Viene creato un subset dei dati modificati utilizzando il <xref:System.Data.DataSet.GetChanges%2A> (metodo). Dopo la risoluzione degli errori, viene aggiunta una nuova colonna al sottoinsieme, modifica dello schema. Quando la <xref:System.Data.DataSet.Merge%2A> metodo viene chiamato con il `missingSchemaAction` impostata su `MissingSchemaAction.Add`, la nuova colonna verrà aggiunta all'istanza originale <xref:System.Data.DataSet> schema dell'oggetto.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Uno dei valori di <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Ottiene una copia della classe <see cref="T:System.Data.DataSet" /> contenente tutte le modifiche apportate a essa dal momento in cui è stata caricata o dall'ultima chiamata al metodo <see cref="M:System.Data.DataSet.AcceptChanges" />, filtrata dall'enumerazione <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Copia filtrata della classe <see cref="T:System.Data.DataSet" /> su cui è possibile eseguire azioni e che successivamente può essere unita di nuovo all'originale utilizzando il metodo <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Se non viene trovata alcuna riga dell'oggetto <see cref="T:System.Data.DataRowState" /> desiderato, questo metodo restituirà <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.GetChanges%2A> metodo viene utilizzato per produrre una seconda <xref:System.Data.DataSet> oggetto che contiene solo le modifiche apportate all'originale. Usare il `rowStates` argomento per specificare il tipo di modifiche deve includere il nuovo oggetto.  
  
 Questo valore restituito copia è progettata per essere nuovamente unita all'oggetto originale <xref:System.Data.DataSet>. I vincoli di relazione possono causare le righe padre contrassegnate `Unchanged` da includere. Se nessuna riga dell'oggetto desiderato <xref:System.Data.DataRowState> vengono rilevati, il <xref:System.Data.DataSet.GetChanges%2A> restituzione del metodo `null`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataSet.GetChanges%2A> per creare un secondo metodo <xref:System.Data.DataSet> oggetto, che viene quindi usato per aggiornare un'origine dati.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Set di schemi specificato.</param>
        <summary>Ottiene una copia di <see cref="T:System.Xml.Schema.XmlSchemaSet" /> per il DataSet.</summary>
        <returns>Una copia di <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente i dati serializzati associati all'eccezione <see cref="T:System.Data.DataSet" />.</param>
        <param name="context">Contesto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato all'eccezione <see cref="T:System.Data.DataSet" />.</param>
        <summary>Popola un oggetto di informazioni di serializzazione con i dati necessari per serializzare l'istanza di <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="info" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un'istanza di <see cref="T:System.Xml.Schema.XmlSchema" /> serializzabile.</summary>
        <returns>Istanza di <see cref="T:System.Xml.Schema.XmlSchema" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Istanza di <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Contesto di flusso.</param>
        <summary>Deserializza i dati della tabella dal flusso binario o XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce la rappresentazione XML dei dati memorizzati nell'oggetto <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Stringa che costituisce una rappresentazione dei dati memorizzati nell'oggetto <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo è identica alla chiamata <xref:System.Data.DataSet.WriteXml%2A> con <xref:System.Data.XmlWriteMode> impostato su <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A> Restituisce XML sotto forma di stringa e pertanto richiede un overhead maggiore rispetto a <xref:System.Data.DataSet.WriteXml%2A> scrivere XML in un file.  
  
 Se si compila un <xref:System.Data.DataSet> tramite inferenza dello schema e serializzare usando XML o per servizi Web, l'ordinamento delle colonne può cambiare.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Data.DataSet> e <xref:System.Data.DataTable>, aggiunge dati di esempio e quindi Visualizza i dati in formato XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 In questo esempio viene illustrato come scrivere i dati in un file XML da un DataSet e leggere tali dati nel DataSet di XML. In questo esempio verrà creato un dataset con due tabelle. Utilizzare due modalità per esportare un set di dati nei file XML (WriteXml e GetXml) e utilizzare due modalità (ReadXml e InferXmlSchema) per includere un set di dati dal file XML.  
  
 Prima di compilare ed eseguire l'esempio, è necessario creare quattro file XML nella directory dell'esempio. Creare innanzitutto ElementsWithAttributes.xml:  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 Creare quindi ElementsWithChildElementsxml.xml:  
  
```  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Creare ora ElementsWithOnlyAttributes.xml:  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 Creare infine RepeatingElements.xml:  
  
```  
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Ora è possibile compilare ed eseguire il codice sorgente.  [Come Store dei dati del set di dati in File XML](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) contiene progetti Visual Basic e c# per questo esempio.  
  
```  
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce lo schema XML per la rappresentazione XML dei dati memorizzati nell'oggetto <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Stringa che rappresenta lo schema XML per la rappresentazione XML dei dati memorizzati nell'oggetto <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo è identica alla chiamata al metodo <xref:System.Data.DataSet.WriteXmlSchema%2A>, ad eccezione del fatto che viene scritto solo lo schema principale.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> Restituisce XML sotto forma di stringa e pertanto richiede un overhead maggiore rispetto a <xref:System.Data.DataSet.WriteXmlSchema%2A> scrivere XML in un file.  
  
 Se si compila un <xref:System.Data.DataSet> tramite inferenza dello schema e serializzare usando XML o per servizi Web, l'ordinamento delle colonne può cambiare.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Data.DataSet> e <xref:System.Data.DataTable>e quindi Visualizza lo schema in formato XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Data.DataSet" /> presenta delle modifiche, quali righe nuove, eliminate o modificate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Data.DataSet" /> presenta delle modifiche, quali righe nuove, eliminate o modificate.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Data.DataSet" /> presenta delle modifiche; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataSet.GetChanges%2A> per creare un secondo metodo <xref:System.Data.DataSet> oggetto che viene quindi usato per aggiornare un'origine dati.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Uno dei valori di <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Data.DataSet" /> presenta delle modifiche, quali righe nuove, eliminate o modificate, filtrate in base all'oggetto <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Data.DataSet" /> presenta delle modifiche; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esaminare i <xref:System.Data.DataSet.HasChanges%2A> proprietà del `DataSet` prima di richiamare il <xref:System.Data.DataSet.GetChanges%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataSet.GetChanges%2A> per creare un secondo metodo <xref:System.Data.DataSet> oggetto, che viene quindi usato per aggiornare un'origine dati.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se sono presenti errori in uno degli oggetti <see cref="T:System.Data.DataTable" /> all'interno di questo oggetto <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see langword="true" /> se nelle tabelle è presente un errore; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciascuna <xref:System.Data.DataTable> in un <xref:System.Data.DataSet> ha anche un <xref:System.Data.DataTable.HasErrors%2A> proprietà. Usare la `HasErrors` proprietà del `DataSet` prima, per determinare se una tabella dispone di errori, prima di controllare i singoli <xref:System.Data.DataTable> oggetti. Se un `DataTable` presenta errori, il <xref:System.Data.DataTable.GetErrors%2A> metodo restituisce una matrice di <xref:System.Data.DataRow> gli oggetti che contiene gli errori.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataSet.HasErrors%2A> proprietà per determinare se un <xref:System.Data.DataSet> oggetto contiene errori. In questo caso, gli errori di ciascun <xref:System.Data.DataRow> in ogni <xref:System.Data.DataTable> vengono stampati.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Viene applicato lo schema XML all'oggetto <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto <see langword="Stream" /> da cui leggere lo schema.</param>
        <param name="nsArray">Matrice di stringhe dell'Uniform Resource Identifier (URI) dello spazio dei nomi da escludere dall'inferenza dello schema.</param>
        <summary>Lo schema XML dalla classe <see cref="T:System.IO.Stream" /> specificata viene applicato alla classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">Oggetto <see langword="TextReader" /> da cui leggere lo schema.</param>
        <param name="nsArray">Matrice di stringhe dell'Uniform Resource Identifier (URI) dello spazio dei nomi da escludere dall'inferenza dello schema.</param>
        <summary>Lo schema XML dalla classe <see cref="T:System.IO.TextReader" /> specificata viene applicato alla classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file, incluso il percorso, da cui leggere lo schema.</param>
        <param name="nsArray">Matrice di stringhe dell'Uniform Resource Identifier (URI) dello spazio dei nomi da escludere dall'inferenza dello schema.</param>
        <summary>Lo schema XML dal file specificato viene applicato all'oggetto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">La classe <see cref="T:System.Security.Permissions.FileIOPermission" /> non è impostata su <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per la lettura e scrittura di file. Enumerazione associata: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">Oggetto <see langword="XMLReader" /> da cui leggere lo schema.</param>
        <param name="nsArray">Matrice di stringhe dell'Uniform Resource Identifier (URI) dello spazio dei nomi da escludere dall'inferenza dello schema.</param>
        <summary>Lo schema XML dalla classe <see cref="T:System.Xml.XmlReader" /> specificata viene applicato alla classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica dopo l'inizializzazione dell'oggetto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deserializza tutti i dati delle tabelle del DataSet dal flusso binario o XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <summary>Esamina il formato della rappresentazione serializzata di <see langword="DataSet" />.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> specificato è un <see langword="DataSet" /> serializzato in formato binario; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro supporta l'infrastruttura .NET Framework e non è possibile usarlo direttamente dal codice.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la classe <see cref="T:System.Data.DataSet" /> è inizializzata.</summary>
        <value>
          <see langword="true" /> per indicare che il componente ha completato l'inizializzazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Restituisce lo stato del <xref:System.Data.DataSet> mentre si è che viene costruito, ad esempio da Visual Studio. Il <xref:System.Data.DataSet.BeginInit%2A> lo imposta su metodo `false` e <xref:System.Data.DataSet.EndInit%2A> metodo lo imposta su `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riempie una classe <see cref="T:System.Data.DataSet" /> con valori di un'origine dati utilizzando l'interfaccia <see cref="T:System.Data.IDataReader" /> fornita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.Load%2A> metodo fornisce una tecnica per riempire un singolo <xref:System.Data.DataTable> i dati, recuperati da un <xref:System.Data.IDataReader> istanza. Questo metodo offre la stessa funzionalità, ma consente di caricare più set di risultati da un' `IDataReader` in più tabelle all'interno di un `DataSet`.  
  
 Se `DataSet` contiene già righe, i dati in arrivo dall'origine dati vengono uniti alle righe esistenti.  
  
 Il `Load` metodo può essere utilizzato in diversi scenari comuni, tutti incentrati sul recupero di dati da un'origine dati specificata e aggiungendolo al contenitore di dati corrente (in questo caso, un `DataSet`). Questi scenari descrivono l'utilizzo standard per un `DataSet`, che descrive l'aggiornamento e comportamento di tipo merge.  
  
 Oggetto `DataSet` Sincronizza o aggiorna un'origine dati primaria. Il `DataSet` tiene traccia delle modifiche, consentendo la sincronizzazione con l'origine dati primaria. Inoltre, un `DataSet` può accettare dati incrementali da uno o più origini dati del database secondario. Il `DataSet` non è responsabile del rilevamento delle modifiche per consentire la sincronizzazione con l'origine dati secondaria.  
  
 Considerate queste due origini di dati ipotetica, un utente è probabilmente, deve essere uno dei comportamenti seguenti:  
  
-   Inizializzare `DataSet` da un'origine dati primaria. In questo scenario, l'utente desidera inizializzare un oggetto vuoto `DataSet` con i valori dell'origine dati primaria. Contenuto di uno o più di DataTable viene modificato. In un secondo momento si intende propagare le modifiche all'origine dati primaria.  
  
-   Mantenere le modifiche e sincronizzare nuovamente dall'origine dati primaria. In questo scenario, l'utente desidera eseguire la `DataSet` riempito nello scenario precedente ed eseguire una sincronizzazione incrementale con l'origine dati primaria, mantenendo le modifiche apportate il `DataSet`.  
  
-   Da origini di dati secondari di feed di dati incrementali. In questo scenario, l'utente vuole unire le modifiche da una o più origini di dati secondari e propagare le modifiche all'origine dati primaria.  
  
 Il `Load` metodo rende tutti questi scenari possibili. Questo metodo consente di specificare un parametro di opzione di caricamento, che indica come le righe già in un <xref:System.Data.DataTable> associ le righe in fase di caricamento. La tabella seguente descrive le tre opzioni di caricamento fornite dal <xref:System.Data.LoadOption> enumerazione. In ogni caso, la descrizione indica il comportamento quando la chiave primaria di una riga nei dati in ingresso corrisponde alla chiave primaria di una riga esistente.  
  
|Opzione di caricamento|Descrizione|  
|-----------------|-----------------|  
|`PreserveChanges` (impostazione predefinita)|Aggiorna la versione originale della riga con il valore di riga in arrivo.|  
|`OverwriteChanges`|Aggiorna le versioni correnti e originali della riga con il valore di riga in arrivo.|  
|`Upsert`|Aggiorna la versione corrente della riga con il valore di riga in arrivo.|  
  
 In generale, il `PreserveChanges` e `OverwriteChanges` le opzioni sono destinate agli scenari in cui l'utente dovrà sincronizzare la `DataSet` e le relative modifiche con l'origine dati primaria. Il `Upsert` opzione facilita le modifiche di aggregazione provenienti da uno o più origini di dati secondari.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Interfaccia <see cref="T:System.Data.IDataReader" /> che fornisce uno o più gruppi di risultati.</param>
        <param name="loadOption">Valore dall'enumerazione <see cref="T:System.Data.LoadOption" />, che indica come vengono combinate le righe già presenti nelle istanze della classe <see cref="T:System.Data.DataTable" />, all'interno della classe <see cref="T:System.Data.DataSet" />, con le righe in entrata che condividono la stessa chiave primaria.</param>
        <param name="tables">Matrice di istanze della classe <see cref="T:System.Data.DataTable" /> da cui il metodo <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> recupera informazioni relative al nome e allo spazio dei nomi. Ognuna di queste tabelle deve essere un membro della classe <see cref="T:System.Data.DataTableCollection" /> contenuta da questa classe <see cref="T:System.Data.DataSet" />.</param>
        <summary>Riempie una classe <see cref="T:System.Data.DataSet" /> con valori da un'origine dati, utilizzando l'interfaccia <see cref="T:System.Data.IDataReader" /> fornita, tramite una matrice di istanze della classe <see cref="T:System.Data.DataTable" />, per fornire informazioni relative allo schema e allo spazio dei nomi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.Load%2A> metodo fornisce una tecnica per riempire un singolo <xref:System.Data.DataTable> i dati, recuperati da un <xref:System.Data.IDataReader> istanza. Questo metodo offre la stessa funzionalità, ma consente di caricare più set di risultati da un' <xref:System.Data.IDataReader> in più tabelle all'interno di un <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  L'operazione di caricamento avrà esito negativo con un <xref:System.InvalidOperationException> se una qualsiasi delle colonne di dati di origine in ingresso `reader` sono colonne calcolate.  
  
 Il `loadOption` parametro consente di specificare come si desidera che i dati importati per interagire con i dati esistenti e può essere uno dei valori di <xref:System.Data.LoadOption> enumerazione. Vedere la documentazione per il <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> metodo per altre informazioni sull'uso di questo parametro.  
  
 Il `tables` parametro consente di specificare una matrice di <xref:System.Data.DataTable> istanze, che indica l'ordine delle tabelle corrispondenti a ogni gruppo di risultati caricato dal lettore. Il <xref:System.Data.DataSet.Load%2A> metodo compila ogni fornito <xref:System.Data.DataTable> istanza con i dati da un singolo set di risultati da lettore dati di origine. Dopo ogni set di risultati, il <xref:System.Data.DataSet.Load%2A> metodo passa al risultato successivo impostato all'interno del lettore, fino a quando non sono presenti set di risultati non è più.  
  
 Lo schema di risoluzione nome per questo metodo è analoga a quella seguita dal <xref:System.Data.Common.DbDataAdapter.Fill%2A> metodo di <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Data.DataSet>, aggiunge due <xref:System.Data.DataTable> alle istanze di <xref:System.Data.DataSet>e poi riempie il <xref:System.Data.DataSet> usando il <xref:System.Data.DataSet.Load%2A> metodo, il recupero dei dati da un <xref:System.Data.DataTableReader> contenente due set di risultati. Infine, l'esempio visualizza il contenuto delle tabelle nella finestra della console.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Interfaccia <see cref="T:System.Data.IDataReader" /> che fornisce uno o più gruppi di risultati.</param>
        <param name="loadOption">Valore dall'enumerazione <see cref="T:System.Data.LoadOption" />, che indica come vengono combinate le righe già presenti nelle istanze della classe <see cref="T:System.Data.DataTable" />, all'interno della classe <see langword="DataSet" />, con le righe in entrata che condividono la stessa chiave primaria.</param>
        <param name="tables">Matrice di stringhe da cui il metodo <see langword="Load" /> recupera le informazioni relative ai nomi delle tabelle.</param>
        <summary>Riempie una classe <see cref="T:System.Data.DataSet" /> con valori da un'origine dati, utilizzando l'interfaccia <see cref="T:System.Data.IDataReader" /> fornita e una matrice di stringhe, per rendere disponibili i nomi delle tabelle all'interno della classe <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.Load%2A> metodo fornisce una tecnica per riempire un singolo <xref:System.Data.DataTable> i dati, recuperati da un <xref:System.Data.IDataReader> istanza. Questo metodo offre la stessa funzionalità, ma consente di caricare più set di risultati da un' `IDataReader` in più tabelle all'interno di un `DataSet`.  
  
> [!NOTE]
>  L'operazione di caricamento avrà esito negativo con un <xref:System.InvalidOperationException> se una qualsiasi delle colonne di dati di origine in ingresso `reader` sono colonne calcolate.  
  
 Il `loadOption` parametro consente di specificare come si desidera che i dati importati per interagire con i dati esistenti e può essere uno dei valori di <xref:System.Data.LoadOption> enumerazione. Vedere la documentazione per il <xref:System.Data.DataTable.Load%2A> metodo per altre informazioni sull'uso di questo parametro.  
  
 Il `tables` parametro consente di specificare una matrice di nomi di tabella, che indica l'ordine delle tabelle corrispondenti a ogni gruppo di risultati caricato dal lettore. Il `Load` metodo tenta di trovare una tabella all'interno di `DataSet` che corrisponde a quello trovato nella matrice di nomi di tabella, in ordine. Se viene trovata una corrispondenza nella tabella, tale tabella viene caricata con il contenuto del set di risultati corrente. Se nessuna tabella corrispondente viene trovata, viene creata una tabella usando il nome specificato nella matrice di nomi di tabella e il nuovo schema della tabella viene dedotto dal set di risultati. Dopo ogni set di risultati, il `Load` metodo passa al risultato successivo impostato all'interno del lettore, fino a quando non sono presenti set di risultati non è più.  
  
 Lo spazio dei nomi predefinito associato `DataSet`, se presente, vengono associati a ogni appena creati `DataTable`. Lo schema di risoluzione nome per questo metodo è analoga a quella seguita dal <xref:System.Data.Common.DbDataAdapter.Fill%2A> metodo di <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 L'esempio di applicazione Console seguente prima di tutto crea tabelle e carica i dati da un lettore in un <xref:System.Data.DataSet>, usando il `Load` (metodo). L'esempio aggiunge quindi le tabelle da un <xref:System.Data.DataSet> e tenta di compilare le tabelle con dati provenienti da un <xref:System.Data.DataTableReader>. In questo esempio, perché i parametri passati per il `Load` metodo indicare un nome di tabella che non esiste, il `Load` metodo crea una nuova tabella in modo che corrisponda al nome passato come parametro. Una volta caricati i dati, l'esempio visualizza il contenuto di tutte le relative tabelle nella finestra della Console.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Interfaccia <see cref="T:System.Data.IDataReader" /> che fornisce uno o più gruppi di risultati.</param>
        <param name="loadOption">Valore dall'enumerazione <see cref="T:System.Data.LoadOption" />, che indica come vengono combinate le righe già presenti nelle istanze della classe <see cref="T:System.Data.DataTable" />, all'interno della classe <see cref="T:System.Data.DataSet" />, con le righe in entrata che condividono la stessa chiave primaria.</param>
        <param name="errorHandler">Delegato <see cref="T:System.Data.FillErrorEventHandler" /> da chiamare quando si verifica un errore durante il caricamento dei dati.</param>
        <param name="tables">Matrice di istanze della classe <see cref="T:System.Data.DataTable" /> da cui il metodo <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> recupera informazioni relative al nome e allo spazio dei nomi.</param>
        <summary>Riempie una classe <see cref="T:System.Data.DataSet" /> con valori da un'origine dati, utilizzando l'interfaccia <see cref="T:System.Data.IDataReader" /> fornita, tramite una matrice di istanze della classe <see cref="T:System.Data.DataTable" />, per fornire informazioni relative allo schema e allo spazio dei nomi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.Load%2A> metodo fornisce una tecnica per riempire un singolo <xref:System.Data.DataTable> i dati, recuperati da un <xref:System.Data.IDataReader> istanza. Questo metodo offre la stessa funzionalità, ma consente di caricare più set di risultati da un' <xref:System.Data.IDataReader> in più tabelle all'interno di un <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  L'operazione di caricamento avrà esito negativo con un <xref:System.InvalidOperationException> se una qualsiasi delle colonne di dati di origine in ingresso `reader` sono colonne calcolate.  
  
 Il `loadOption` parametro consente di specificare come si desidera che i dati importati per interagire con i dati esistenti e può essere uno dei valori di <xref:System.Data.LoadOption> enumerazione. Vedere la documentazione per il <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> metodo per altre informazioni sull'uso di questo parametro.  
  
 Il `errorHandler` parametro è un <xref:System.Data.FillErrorEventHandler> delegato che fa riferimento a una routine che viene chiamata quando si verifica un errore durante il caricamento dei dati. Il <xref:System.Data.FillErrorEventArgs> parametro passato alla procedura fornisce le proprietà che consentono di recuperare le informazioni sull'errore che si sono verificati, la riga corrente di dati, e il <xref:System.Data.DataTable> riempito. Con questo meccanismo di delegato, anziché un semplice blocco try/catch, consente di determinare l'errore, gestire la situazione e continuare l'elaborazione se lo si desidera. Il <xref:System.Data.FillErrorEventArgs> parametro fornisce un <xref:System.Data.FillErrorEventArgs.Continue%2A> proprietà: impostare questa proprietà su `true` a indicare che è stata gestita l'errore e desideri continuare l'elaborazione; impostare la proprietà su `false` per indicare che si desidera interrompere l'elaborazione. Tenere presente che l'impostazione della proprietà su `false` fa sì che il codice che ha attivato il problema prima di generare un'eccezione.  
  
 Il `tables` parametro consente di specificare una matrice di <xref:System.Data.DataTable> istanze, che indica l'ordine delle tabelle corrispondenti a ogni gruppo di risultati caricato dal lettore. Il <xref:System.Data.DataSet.Load%2A> metodo compila ogni fornito <xref:System.Data.DataTable> istanza con i dati da un singolo set di risultati da lettore dati di origine. Dopo ogni set di risultati, il <xref:System.Data.DataSet.Load%2A> metodo passa al risultato successivo impostato all'interno del lettore, fino a quando non sono presenti set di risultati non è più.  
  
 Lo schema di risoluzione nome per questo metodo è analoga a quella seguita dal <xref:System.Data.Common.DbDataAdapter.Fill%2A> metodo di <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 L'esempio seguente aggiunge una tabella a un <xref:System.Data.DataSet>e quindi prova a usare il <xref:System.Data.DataSet.Load%2A> per caricare dati da un <xref:System.Data.DataTableReader> contenente uno schema incompatibile. Invece di intercettare l'errore, questo esempio viene usato un <xref:System.Data.FillErrorEventHandler> delegato da analizzare e gestire l'errore. L'output viene visualizzato nella finestra della console.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le informazioni sulle impostazioni locali utilizzate per confrontare stringhe all'interno della tabella.</summary>
        <value>Oggetto <see cref="T:System.Globalization.CultureInfo" /> che contiene i dati sulle impostazioni locali del computer dell'utente. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Locale%2A> proprietà specifica le impostazioni locali per cui l'ordinamento viene applicata.  
  
 Per impostazione predefinita, l'impostazione di <xref:System.Data.DataSet.Locale%2A> per un <xref:System.Data.DataSet> imposta inoltre il <xref:System.Data.DataSet.Locale%2A> per ogni <xref:System.Data.DataTable> oggetto in cui `DataSet` sullo stesso valore.  
  
> [!NOTE]
>  Nelle colonne che contengono espressioni, il <xref:System.StringComparison.InvariantCulture> viene usato. Il <xref:System.StringComparison.CurrentCulture> viene ignorato.  
  
   
  
## Examples  
 L'esempio seguente ottiene i <xref:System.Globalization.CultureInfo> per un <xref:System.Data.DataSet> e viene stampato il <xref:System.Globalization.CultureInfo.DisplayName%2A> e <xref:System.Globalization.CultureInfo.EnglishName%2A> proprietà.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unisce un oggetto <see cref="T:System.Data.DataSet" />, <see cref="T:System.Data.DataTable" /> o una matrice di oggetti <see cref="T:System.Data.DataRow" /> nell'oggetto <see langword="DataSet" /> o <see langword="DataTable" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">Matrice di oggetti <see langword="DataRow" /> che saranno uniti nell'oggetto <see langword="DataSet" />.</param>
        <summary>Unisce una matrice di oggetti <see cref="T:System.Data.DataRow" /> nell'oggetto <see cref="T:System.Data.DataSet" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Merge%2A> metodo viene usato per unire due <xref:System.Data.DataSet> gli oggetti che contengono schemi molto simili. Un'unione nell'indice è in genere usato in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataSet>. In questo modo l'applicazione client avere un oggetto aggiornato <xref:System.Data.DataSet> con i dati più recenti dall'origine dati.  
  
 Il <xref:System.Data.DataSet.Merge%2A> viene chiamato in genere alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistente <xref:System.Data.DataSet>.  
  
 In un'applicazione client, è comune disporre di un unico pulsante che l'utente può scegliere che raccoglie i dati modificati e la convalida prima di inviarlo a un componente di livello intermedio. In questo scenario il <xref:System.Data.DataSet.GetChanges%2A> metodo viene richiamato prima di tutto. Questo metodo restituisce un secondo <xref:System.Data.DataSet> ottimizzato per la convalida e l'unione. Questa seconda <xref:System.Data.DataSet> oggetto contiene solo le <xref:System.Data.DataTable> e <xref:System.Data.DataRow> oggetti che sono stati modificati, causando un sottoinsieme dell'oggetto originale <xref:System.Data.DataSet>. Questo subset è generalmente più piccole e di conseguenza in modo più efficiente passato a un componente di livello intermedio. Il componente di livello intermedio aggiorna quindi l'origine dati originale con le modifiche mediante le stored procedure. Il livello intermedio può quindi inviare un nuovo oggetto <xref:System.Data.DataSet> che include dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale), oppure che venga inviato nuovamente il subset con eventuali modifiche apportate a esso dall'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primari univoca, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataSet> può essere nuovamente uniti in originale dell'applicazione client <xref:System.Data.DataSet> con il <xref:System.Data.DataSet.Merge%2A> (metodo).  
  
 Quando la <xref:System.Data.DataSet.Merge%2A> metodo viene chiamato, gli schemi dei due <xref:System.Data.DataSet> gli oggetti confrontati perché è possibile che gli schemi sia stati modificati. Ad esempio, in uno scenario business-to-business, potrebbero sono state aggiunte nuove colonne in un XML schema da un processo automatizzato. Se l'origine <xref:System.Data.DataSet> contiene gli elementi dello schema (aggiunto <xref:System.Data.DataColumn> oggetti) che non sono presenti nel database di destinazione, è possono aggiungere gli elementi dello schema di destinazione impostando le `missingSchemaAction` argomento `MissingSchemaAction.Add`. In tal caso, l'oggetto unito <xref:System.Data.DataSet> contiene lo schema e aggiunti dati.  
  
 Dopo aver unito gli schemi, i dati vengono uniti.  
  
 Durante il merge di una nuova origine <xref:System.Data.DataSet> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> pari a `Unchanged`, `Modified`, o `Deleted` corrispondono alle righe di destinazione con gli stessi valori di chiave primari. Origine le righe con un <xref:System.Data.DataRowState> pari a `Added` corrispondono alle nuove righe di destinazione con gli stessi valori di chiave primari come le nuove righe di origine.  
  
 Durante un'operazione di unione, i vincoli sono disabilitati. Se tutti i vincoli non è possibile abilitare la fine di un'unione nell'indice, un <xref:System.Data.ConstraintException> viene generato e i dati uniti viene mantenuti anche se i vincoli sono disabilitati. In questo caso, il <xref:System.Data.DataSet.EnforceConstraints%2A> è impostata su `false`, e tutte le righe che non sono validi vengono segnalate come errori. È necessario risolvere gli errori prima di provare a reimpostare il <xref:System.Data.DataSet.EnforceConstraints%2A> proprietà `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">Oggetto <see langword="DataSet" /> di cui verranno uniti i dati e lo schema.</param>
        <summary>Unisce una classe <see cref="T:System.Data.DataSet" /> specificata e il relativo schema nella classe <see langword="DataSet" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Merge%2A> metodo viene usato per unire due <xref:System.Data.DataSet> gli oggetti che contengono schemi molto simili. Un'unione nell'indice è in genere usato in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataSet>. In questo modo l'applicazione client avere un oggetto aggiornato <xref:System.Data.DataSet> con i dati più recenti dall'origine dati.  
  
 Il <xref:System.Data.DataSet.Merge%2A> viene chiamato in genere alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistente <xref:System.Data.DataSet>.  
  
 In un'applicazione client, è comune disporre di un unico pulsante che l'utente può scegliere che raccoglie i dati modificati e la convalida prima di inviarlo a un componente di livello intermedio. In questo scenario il <xref:System.Data.DataSet.GetChanges%2A> metodo viene richiamato prima di tutto. Questo metodo restituisce un secondo <xref:System.Data.DataSet> ottimizzato per la convalida e l'unione. Questa seconda <xref:System.Data.DataSet> oggetto contiene solo le <xref:System.Data.DataTable> e <xref:System.Data.DataRow> oggetti che sono stati modificati, causando un sottoinsieme dell'oggetto originale <xref:System.Data.DataSet>. Questo subset è generalmente di dimensioni ridotte e pertanto più efficiente passare a un componente di livello intermedio. Il componente di livello intermedio aggiorna quindi l'origine dati originale con le modifiche mediante le stored procedure. Il livello intermedio può quindi inviare un nuovo oggetto <xref:System.Data.DataSet> che include dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale), oppure che venga inviato nuovamente il subset con eventuali modifiche apportate a esso dall'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primari univoca, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataSet> può essere nuovamente uniti in originale dell'applicazione client <xref:System.Data.DataSet> con il <xref:System.Data.DataSet.Merge%2A> (metodo).  
  
 Quando la <xref:System.Data.DataSet.Merge%2A> metodo viene chiamato, gli schemi dei due <xref:System.Data.DataSet> gli oggetti confrontati perché è possibile che gli schemi sia stati modificati. Ad esempio, in uno scenario business-to-business, potrebbero sono state aggiunte nuove colonne in un XML schema da un processo automatizzato. Se l'origine <xref:System.Data.DataSet> contiene gli elementi dello schema (aggiunto <xref:System.Data.DataColumn> oggetti) che non sono presenti nel database di destinazione, è possono aggiungere gli elementi dello schema di destinazione impostando le `missingSchemaAction` argomento `MissingSchemaAction.Add`. In tal caso, l'oggetto unito <xref:System.Data.DataSet> contiene lo schema e aggiunti dati.  
  
 Dopo aver unito gli schemi, i dati vengono uniti.  
  
 Durante il merge di una nuova origine <xref:System.Data.DataSet> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> pari a `Unchanged`, `Modified`, o `Deleted` corrispondono alle righe di destinazione con gli stessi valori di chiave primari. Origine le righe con un `DataRowState` pari a `Added` corrispondono alle nuove righe di destinazione con gli stessi valori di chiave primari come le nuove righe di origine.  
  
 Durante un'operazione di unione, i vincoli sono disabilitati. Se tutti i vincoli non è possibile abilitare la fine di unione, un <xref:System.Data.ConstraintException> viene generato e i dati uniti viene mantenuti anche se i vincoli sono disabilitati. In questo caso, il <xref:System.Data.DataSet.EnforceConstraints%2A> è impostata su `false`, e tutte le righe che non sono validi vengono segnalate come errori. È necessario risolvere gli errori prima di provare a reimpostare il <xref:System.Data.DataSet.EnforceConstraints%2A> proprietà `true`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataSet.GetChanges%2A>, aggiornamento, e <xref:System.Data.DataSet.Merge%2A> metodi su un <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Non è possibile attivare uno o più vincoli.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="dataSet" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Oggetto <see cref="T:System.Data.DataTable" /> di cui verranno uniti i dati e lo schema.</param>
        <summary>Unisce una classe <see cref="T:System.Data.DataTable" /> specificata e il relativo schema nella classe <see cref="T:System.Data.DataSet" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Merge%2A> metodo viene usato per unire due <xref:System.Data.DataSet> gli oggetti che contengono schemi molto simili. Un'unione nell'indice è in genere usato in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataSet>. In questo modo l'applicazione client avere un oggetto aggiornato <xref:System.Data.DataSet> con i dati più recenti dall'origine dati.  
  
 Il <xref:System.Data.DataSet.Merge%2A> viene chiamato in genere alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistente <xref:System.Data.DataSet>.  
  
 In un'applicazione client, è comune disporre di un unico pulsante che l'utente può scegliere che raccoglie i dati modificati e la convalida prima di inviarlo a un componente di livello intermedio. In questo scenario il <xref:System.Data.DataSet.GetChanges%2A> metodo viene richiamato prima di tutto. Questo metodo restituisce un secondo <xref:System.Data.DataSet> ottimizzato per la convalida e l'unione. Questa seconda <xref:System.Data.DataSet> oggetto contiene solo le <xref:System.Data.DataTable> e <xref:System.Data.DataRow> oggetti che sono stati modificati, causando un sottoinsieme dell'oggetto originale <xref:System.Data.DataSet>. Questo subset è generalmente di dimensioni ridotte e pertanto più efficiente passare a un componente di livello intermedio. Il componente di livello intermedio aggiorna quindi l'origine dati originale con le modifiche mediante le stored procedure. Il livello intermedio può quindi inviare un nuovo oggetto <xref:System.Data.DataSet> che include dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale), oppure che venga inviato nuovamente il subset con eventuali modifiche apportate a esso dall'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primari univoca, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataSet> può essere nuovamente uniti in originale dell'applicazione client <xref:System.Data.DataSet> con il <xref:System.Data.DataSet.Merge%2A> (metodo).  
  
 Quando la <xref:System.Data.DataSet.Merge%2A> metodo viene chiamato, gli schemi dei due <xref:System.Data.DataSet> gli oggetti confrontati perché è possibile che gli schemi sia stati modificati. Ad esempio, in uno scenario business-to-business, potrebbero sono state aggiunte nuove colonne in un XML schema da un processo automatizzato. Se l'origine <xref:System.Data.DataSet> contiene gli elementi dello schema (aggiunto <xref:System.Data.DataColumn> oggetti) che non sono presenti nel database di destinazione, è possono aggiungere gli elementi dello schema di destinazione impostando le `missingSchemaAction` argomento `MissingSchemaAction.Add`. In tal caso, l'oggetto unito <xref:System.Data.DataSet> contiene lo schema e aggiunti dati.  
  
 Dopo aver unito gli schemi, i dati vengono uniti.  
  
 Durante il merge di una nuova origine <xref:System.Data.DataSet> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> pari a `Unchanged`, `Modified`, o `Deleted` corrispondono alle righe di destinazione con gli stessi valori di chiave primari. Origine le righe con un `DataRowState` pari a `Added` corrispondono alle nuove righe di destinazione con gli stessi valori di chiave primari come le nuove righe di origine.  
  
 Durante un'operazione di unione, i vincoli sono disabilitati. Se tutti i vincoli non è possibile abilitare la fine di unione, un <xref:System.Data.ConstraintException> viene generato e i dati uniti viene mantenuti anche se i vincoli sono disabilitati. In questo caso, il <xref:System.Data.DataSet.EnforceConstraints%2A> è impostata su `false`, e tutte le righe che non sono validi vengono segnalate come errori. È necessario risolvere gli errori prima di provare a reimpostare il <xref:System.Data.DataSet.EnforceConstraints%2A> proprietà `true`.  
  
   
  
## Examples  
 L'esempio seguente crea una semplice <xref:System.Data.DataSet> con una tabella, due colonne e dieci righe. Un secondo <xref:System.Data.DataTable> creato che è identico al primo. Due righe vengono aggiunte alla seconda tabella, che viene quindi unita le <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="table" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">Oggetto <see langword="DataSet" /> di cui verranno uniti i dati e lo schema.</param>
        <param name="preserveChanges">
          <see langword="true" /> per conservare le modifiche apportate all'oggetto <see langword="DataSet" /> corrente; in caso contrario, <see langword="false" />.</param>
        <summary>Unisce un oggetto <see cref="T:System.Data.DataSet" /> specificato e il relativo schema nell'oggetto <see langword="DataSet" /> corrente, mantenendo o ignorando eventuali modifiche apportate a <see langword="DataSet" /> secondo l'argomento definito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Merge%2A> metodo viene usato per unire due <xref:System.Data.DataSet> gli oggetti che contengono schemi molto simili. Un'unione nell'indice è in genere usato in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataSet>. In questo modo l'applicazione client avere un oggetto aggiornato <xref:System.Data.DataSet> con i dati più recenti dall'origine dati.  
  
 Il <xref:System.Data.DataSet.Merge%2A> viene chiamato in genere alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistente <xref:System.Data.DataSet>.  
  
 In un'applicazione client, è comune disporre di un unico pulsante che l'utente può scegliere che raccoglie i dati modificati e la convalida prima di inviarlo a un componente di livello intermedio. In questo scenario il <xref:System.Data.DataSet.GetChanges%2A> metodo viene richiamato prima di tutto. Questo metodo restituisce un secondo <xref:System.Data.DataSet> ottimizzato per la convalida e l'unione. Questa seconda <xref:System.Data.DataSet> oggetto contiene solo le <xref:System.Data.DataTable> e <xref:System.Data.DataRow> oggetti che sono stati modificati, causando un sottoinsieme dell'oggetto originale <xref:System.Data.DataSet>. Questo subset è generalmente di dimensioni ridotte e pertanto più efficiente passare a un componente di livello intermedio. Il componente di livello intermedio aggiorna quindi l'origine dati originale con le modifiche mediante le stored procedure. Il livello intermedio può quindi inviare un nuovo oggetto <xref:System.Data.DataSet> che include dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale), oppure che venga inviato nuovamente il subset con eventuali modifiche apportate a esso dall'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primari univoca, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataSet> può essere nuovamente uniti in originale dell'applicazione client <xref:System.Data.DataSet> con il <xref:System.Data.DataSet.Merge%2A> (metodo).  
  
 Quando la <xref:System.Data.DataSet.Merge%2A> metodo viene chiamato, gli schemi dei due <xref:System.Data.DataSet> gli oggetti confrontati perché è possibile che gli schemi sia stati modificati. Ad esempio, in uno scenario business-to-business, potrebbero sono state aggiunte nuove colonne in un XML schema da un processo automatizzato. Se l'origine <xref:System.Data.DataSet> contiene gli elementi dello schema (aggiunto <xref:System.Data.DataColumn> oggetti) che non sono presenti nel database di destinazione, è possono aggiungere gli elementi dello schema di destinazione impostando le `missingSchemaAction` argomento `MissingSchemaAction.Add`. In tal caso, l'oggetto unito <xref:System.Data.DataSet> contiene lo schema e aggiunti dati.  
  
 Dopo aver unito gli schemi, i dati vengono uniti.  
  
 Durante il merge di una nuova origine <xref:System.Data.DataSet> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> pari a `Unchanged`, `Modified`, o `Deleted` corrispondono alle righe di destinazione con gli stessi valori di chiave primari. Origine le righe con un `DataRowState` pari a `Added` corrispondono alle nuove righe di destinazione con gli stessi valori di chiave primari come le nuove righe di origine.  
  
 Durante un'operazione di unione, i vincoli sono disabilitati. Se tutti i vincoli non è possibile abilitare la fine di unione, un <xref:System.Data.ConstraintException> viene generato e i dati uniti viene mantenuti anche se i vincoli sono disabilitati. In questo caso, il <xref:System.Data.DataSet.EnforceConstraints%2A> è impostata su `false`, e tutte le righe che non sono validi vengono segnalate come errori. È necessario risolvere gli errori prima di provare a reimpostare il <xref:System.Data.DataSet.EnforceConstraints%2A> proprietà `true`.  
  
   
  
## Examples  
 L'esempio seguente crea una semplice <xref:System.Data.DataSet> con una tabella, due colonne e dieci righe. Dopo aver aggiunto le dieci righe, due valori vengono modificati, e viene aggiunta una riga. Viene creato un subset dei dati modificati utilizzando il <xref:System.Data.DataSet.GetChanges%2A> (metodo). Dopo la risoluzione degli errori, i dati del sottoinsieme viene uniti originale <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">Matrice di oggetti <see cref="T:System.Data.DataRow" /> che saranno uniti nell'oggetto <see langword="DataSet" />.</param>
        <param name="preserveChanges">
          <see langword="true" /> per conservare le modifiche apportate all'oggetto <see langword="DataSet" />; in caso contrario, <see langword="false" />.</param>
        <param name="missingSchemaAction">Uno dei valori di <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Unisce una matrice di oggetti <see cref="T:System.Data.DataRow" /> nell'oggetto <see cref="T:System.Data.DataSet" /> corrente, mantenendo o ignorando eventuali modifiche apportate a <see langword="DataSet" /> e gestendo uno schema incompatibile secondo gli argomenti definiti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Merge%2A> metodo viene usato per unire due <xref:System.Data.DataSet> gli oggetti che contengono schemi molto simili. Un'unione nell'indice è in genere usato in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataSet>. In questo modo l'applicazione client avere un oggetto aggiornato <xref:System.Data.DataSet> con i dati più recenti dall'origine dati.  
  
 Il <xref:System.Data.DataSet.Merge%2A> viene chiamato in genere alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistente <xref:System.Data.DataSet>.  
  
 In un'applicazione client, è comune disporre di un unico pulsante che l'utente può scegliere che raccoglie i dati modificati e la convalida prima di inviarlo a un componente di livello intermedio. In questo scenario il <xref:System.Data.DataSet.GetChanges%2A> metodo viene richiamato prima di tutto. Questo metodo restituisce un secondo <xref:System.Data.DataSet> ottimizzato per la convalida e l'unione. Questa seconda <xref:System.Data.DataSet> oggetto contiene solo le <xref:System.Data.DataTable> e <xref:System.Data.DataRow> oggetti che sono stati modificati, causando un sottoinsieme dell'oggetto originale <xref:System.Data.DataSet>. Questo subset è generalmente di dimensioni ridotte e pertanto più efficiente passare a un componente di livello intermedio. Il componente di livello intermedio aggiorna quindi l'origine dati originale con le modifiche mediante le stored procedure. Il livello intermedio può quindi inviare un nuovo oggetto <xref:System.Data.DataSet> che include dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale), oppure che venga inviato nuovamente il subset con eventuali modifiche apportate a esso dall'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primari univoca, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataSet> può essere nuovamente uniti in originale dell'applicazione client <xref:System.Data.DataSet> con il <xref:System.Data.DataSet.Merge%2A> (metodo).  
  
 Per semplificare la descrizione del <xref:System.Data.DataSet.Merge%2A> metodo, utilizziamo "target" per indicare che l'oggetto corrente <xref:System.Data.DataSet>e "source" per indicare il secondo (parametro) <xref:System.Data.DataSet>. La destinazione <xref:System.Data.DataSet> è così chiamati perché è l'oggetto su cui si verifica un'azione (unione). La seconda <xref:System.Data.DataSet> viene chiamato una "origine" perché le informazioni in esso contenute non cambiano, ma vengono unite in corrente <xref:System.Data.DataSet>.  
  
 Quando la <xref:System.Data.DataSet.Merge%2A> metodo viene chiamato, gli schemi dei due <xref:System.Data.DataSet> gli oggetti confrontati perché è possibile che gli schemi sia stati modificati. Ad esempio, in uno scenario business-to-business, potrebbero sono state aggiunte nuove colonne in un XML schema da un processo automatizzato. Se l'origine <xref:System.Data.DataSet> contiene gli elementi dello schema (aggiunto <xref:System.Data.DataColumn> oggetti) che non sono presenti nel database di destinazione, è possono aggiungere gli elementi dello schema di destinazione impostando le `missingSchemaAction` argomento `MissingSchemaAction.Add`. In tal caso, l'oggetto unito <xref:System.Data.DataSet> contiene lo schema e aggiunti dati.  
  
 Dopo aver unito gli schemi, i dati vengono uniti.  
  
 Durante il merge di una nuova origine <xref:System.Data.DataSet> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> pari a `Unchanged`, `Modified`, o `Deleted` corrispondono alle righe di destinazione con gli stessi valori di chiave primari. Origine le righe con un `DataRowState` pari a `Added` corrispondono alle nuove righe di destinazione con gli stessi valori di chiave primari come le nuove righe di origine.  
  
 Durante un'operazione di unione, i vincoli sono disabilitati. Se tutti i vincoli non è possibile abilitare la fine di unione, un <xref:System.Data.ConstraintException> viene generato e i dati uniti viene mantenuti anche se i vincoli sono disabilitati. In questo caso, il <xref:System.Data.DataSet.EnforceConstraints%2A> è impostata su `false`, e tutte le righe che non sono validi vengono segnalate come errori. È necessario risolvere gli errori prima di provare a reimpostare il <xref:System.Data.DataSet.EnforceConstraints%2A> proprietà `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">Oggetto <see langword="DataSet" /> di cui verranno uniti i dati e lo schema.</param>
        <param name="preserveChanges">
          <see langword="true" /> per conservare le modifiche apportate all'oggetto <see langword="DataSet" /> corrente; in caso contrario, <see langword="false" />.</param>
        <param name="missingSchemaAction">Uno dei valori di <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Unisce un oggetto <see cref="T:System.Data.DataSet" /> specificato e il relativo schema nell'oggetto <see langword="DataSet" /> corrente, mantenendo o ignorando eventuali modifiche apportate all'oggetto <see langword="DataSet" /> corrente e gestendo uno schema incompatibile secondo gli argomenti definiti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Merge%2A> metodo viene usato per unire due <xref:System.Data.DataSet> gli oggetti che contengono schemi molto simili. Un'unione nell'indice è in genere usato in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataSet>. In questo modo l'applicazione client avere un oggetto aggiornato <xref:System.Data.DataSet> con i dati più recenti dall'origine dati.  
  
 Il <xref:System.Data.DataSet.Merge%2A> viene chiamato in genere alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistente <xref:System.Data.DataSet>.  
  
 In un'applicazione client, è comune disporre di un unico pulsante che l'utente può scegliere che raccoglie i dati modificati e la convalida prima di inviarlo a un componente di livello intermedio. In questo scenario il <xref:System.Data.DataSet.GetChanges%2A> metodo viene richiamato prima di tutto. Questo metodo restituisce un secondo <xref:System.Data.DataSet> ottimizzato per la convalida e l'unione. Questa seconda <xref:System.Data.DataSet> oggetto contiene solo le <xref:System.Data.DataTable> e <xref:System.Data.DataRow> oggetti che sono stati modificati, causando un sottoinsieme dell'oggetto originale <xref:System.Data.DataSet>. Questo subset è generalmente di dimensioni ridotte e pertanto più efficiente passare a un componente di livello intermedio. Il componente di livello intermedio aggiorna quindi l'origine dati originale con le modifiche mediante le stored procedure. Il livello intermedio può quindi inviare un nuovo oggetto <xref:System.Data.DataSet> che include dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale), oppure che venga inviato nuovamente il subset con eventuali modifiche apportate a esso dall'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primari univoca, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataSet> può essere nuovamente uniti in originale dell'applicazione client <xref:System.Data.DataSet> con il <xref:System.Data.DataSet.Merge%2A> (metodo).  
  
 Per semplificare la descrizione del <xref:System.Data.DataSet.Merge%2A> metodo, utilizziamo "target" per indicare che l'oggetto corrente <xref:System.Data.DataSet>e "source" per indicare il secondo (parametro) <xref:System.Data.DataSet>. La destinazione <xref:System.Data.DataSet> è così chiamati perché è l'oggetto su cui si verifica un'azione (unione). La seconda <xref:System.Data.DataSet> viene chiamato una "origine" perché le informazioni in esso contenute non cambiano, ma vengono unite in corrente <xref:System.Data.DataSet>.  
  
 Quando la <xref:System.Data.DataSet.Merge%2A> metodo viene chiamato, gli schemi dei due <xref:System.Data.DataSet> gli oggetti confrontati perché è possibile che gli schemi sia stati modificati. Ad esempio, in uno scenario business-to-business, potrebbero sono state aggiunte nuove colonne in un XML schema da un processo automatizzato. Se l'origine <xref:System.Data.DataSet> contiene gli elementi dello schema (aggiunto <xref:System.Data.DataColumn> oggetti) che non sono presenti nel database di destinazione, è possono aggiungere gli elementi dello schema di destinazione impostando le `missingSchemaAction` argomento `MissingSchemaAction.Add`. In tal caso, l'oggetto unito <xref:System.Data.DataSet> contiene lo schema e aggiunti dati.  
  
 Dopo aver unito gli schemi, i dati vengono uniti.  
  
 Durante il merge di una nuova origine <xref:System.Data.DataSet> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> pari a `Unchanged`, `Modified`, o `Deleted` corrispondono alle righe di destinazione con gli stessi valori di chiave primari. Origine le righe con un `DataRowState` pari a `Added` corrispondono alle nuove righe di destinazione con gli stessi valori di chiave primari come le nuove righe di origine.  
  
 Durante un'operazione di unione, i vincoli sono disabilitati. Se tutti i vincoli non è possibile abilitare la fine di unione, un <xref:System.Data.ConstraintException> viene generato e i dati uniti viene mantenuti anche se i vincoli sono disabilitati. In questo caso, il <xref:System.Data.DataSet.EnforceConstraints%2A> è impostata su `false`, e tutte le righe che non sono validi vengono segnalate come errori. È necessario risolvere gli errori prima di provare a reimpostare il <xref:System.Data.DataSet.EnforceConstraints%2A> proprietà `true`.  
  
   
  
## Examples  
 L'esempio seguente crea una semplice <xref:System.Data.DataSet> con una tabella, due colonne e dieci righe. Due valori vengono modificati, e viene aggiunta una riga. Viene creato un subset dei dati modificati utilizzando il <xref:System.Data.DataSet.GetChanges%2A> (metodo). Dopo la risoluzione degli errori, viene aggiunta una nuova colonna al sottoinsieme, modifica dello schema. Quando la <xref:System.Data.DataSet.Merge%2A> metodo viene chiamato con il `missingSchemaAction` impostata su `MissingSchemaAction.Add`, la nuova colonna verrà aggiunta all'istanza originale <xref:System.Data.DataSet> schema dell'oggetto.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="dataSet" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">Oggetto <see langword="DataTable" /> di cui verranno uniti i dati e lo schema.</param>
        <param name="preserveChanges">Uno dei valori di <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <param name="missingSchemaAction">
          <see langword="true" /> per conservare le modifiche apportate all'oggetto <see langword="DataSet" />; in caso contrario, <see langword="false" />.</param>
        <summary>Unisce un oggetto <see cref="T:System.Data.DataTable" /> specificato e il relativo schema nell'oggetto <see langword="DataSet" /> corrente, mantenendo o ignorando eventuali modifiche apportate all'oggetto <see langword="DataSet" /> e gestendo uno schema incompatibile secondo gli argomenti definiti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Merge%2A> metodo viene usato per unire due <xref:System.Data.DataSet> gli oggetti che contengono schemi molto simili. Un'unione nell'indice è in genere usato in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataSet>. In questo modo l'applicazione client avere un oggetto aggiornato <xref:System.Data.DataSet> con i dati più recenti dall'origine dati.  
  
 Il <xref:System.Data.DataSet.Merge%2A> viene chiamato in genere alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistente <xref:System.Data.DataSet>.  
  
 Applicazione client è comune disporre di un unico pulsante che l'utente può scegliere che raccoglie i dati modificati e la convalida prima di inviarlo a un componente di livello intermedio. In questo scenario il <xref:System.Data.DataSet.GetChanges%2A> metodo viene richiamato prima di tutto. Questo metodo restituisce un secondo <xref:System.Data.DataSet> ottimizzato per la convalida e l'unione. Questa seconda <xref:System.Data.DataSet> oggetto contiene solo le <xref:System.Data.DataTable> e <xref:System.Data.DataRow> oggetti che sono stati modificati, causando un sottoinsieme dell'oggetto originale <xref:System.Data.DataSet>. Questo subset è generalmente di dimensioni ridotte e pertanto più efficiente passare a un componente di livello intermedio. Il componente di livello intermedio aggiorna quindi l'origine dati originale con le modifiche mediante le stored procedure. Il livello intermedio può quindi inviare un nuovo oggetto <xref:System.Data.DataSet> che include dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale), oppure che venga inviato nuovamente il subset con eventuali modifiche apportate a esso dall'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primari univoca, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataSet> può essere nuovamente uniti in originale dell'applicazione client <xref:System.Data.DataSet> con il <xref:System.Data.DataSet.Merge%2A> (metodo).  
  
 Quando la <xref:System.Data.DataSet.Merge%2A> metodo viene chiamato, gli schemi dei due <xref:System.Data.DataSet> gli oggetti confrontati perché è possibile che gli schemi sia stati modificati. Ad esempio, in uno scenario business-to-business, potrebbero sono state aggiunte nuove colonne in un XML schema da un processo automatizzato. Se l'origine <xref:System.Data.DataSet> contiene gli elementi dello schema (aggiunto <xref:System.Data.DataColumn> oggetti) che non sono presenti nel database di destinazione, è possono aggiungere gli elementi dello schema di destinazione impostando le `missingSchemaAction` argomento `MissingSchemaAction.Add`. In tal caso, l'oggetto unito <xref:System.Data.DataSet> contiene lo schema e aggiunti dati.  
  
 Dopo aver unito gli schemi, i dati vengono uniti.  
  
 Durante il merge di una nuova origine <xref:System.Data.DataSet> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> pari a `Unchanged`, `Modified`, o `Deleted` corrispondono alle righe di destinazione con gli stessi valori di chiave primari. Origine le righe con un `DataRowState` pari a `Added` corrispondono alle nuove righe di destinazione con gli stessi valori di chiave primari come le nuove righe di origine.  
  
 Durante un'operazione di unione, i vincoli sono disabilitati. Se tutti i vincoli non è possibile abilitare la fine di unione, un <xref:System.Data.ConstraintException> viene generato e i dati uniti viene mantenuti anche se i vincoli sono disabilitati. In questo caso, il <xref:System.Data.DataSet.EnforceConstraints%2A> è impostata su `false`, e tutte le righe che non sono validi vengono segnalate come errori. È necessario risolvere gli errori prima di provare a reimpostare il <xref:System.Data.DataSet.EnforceConstraints%2A> proprietà `true`.  
  
   
  
## Examples  
 L'esempio seguente crea una semplice <xref:System.Data.DataSet> con una tabella, due colonne e dieci righe. Un secondo <xref:System.Data.DataTable> viene creato che è quasi identico al primo ad eccezione del fatto che un nuovo `DataColumn` viene aggiunta alla tabella. Due righe vengono aggiunte alla seconda tabella, che viene quindi unita il <xref:System.Data.DataSet> con il `preserveChanges` argomento impostato su `false`e il `missingSchemaAction` argomento impostato su `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="dataSet" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando due oggetti <see cref="T:System.Data.DataRow" /> di origine e di destinazione presentano la stessa chiave primaria e la proprietà <see cref="P:System.Data.DataSet.EnforceConstraints" /> è impostata su true.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni sulla gestione degli eventi, vedere [NIB: utilizzo di eventi](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Data.DataSet.MergeFailed> evento.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo spazio dei nomi della classe <see cref="T:System.Data.DataSet" />.</summary>
        <value>Spazio dei nomi di <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Namespace%2A> proprietà viene usata durante la lettura e scrittura di un file XML del documento nel <xref:System.Data.DataSet> usando la <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, o <xref:System.Data.DataSet.WriteXmlSchema%2A> metodi.  
  
 Lo spazio dei nomi di un documento XML viene usato per definire l'ambito di attributi XML e gli elementi durante la lettura in un <xref:System.Data.DataSet>. Ad esempio, se un <xref:System.Data.DataSet> contiene uno schema che è stato letto da un documento con lo spazio dei nomi "azienda" e viene effettuato un tentativo di leggere i dati solo da un documento con uno spazio dei nomi diversi, tutti i dati che non corrispondano allo schema esistente viene ignorati.  
  
   
  
## Examples  
 L'esempio seguente imposta la <xref:System.Data.DataSet.Prefix%2A> prima di chiamare il <xref:System.Data.DataSet.ReadXml%2A> (metodo).  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nello spazio dei nomi sono già disponibili dati.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Oggetto <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> in una classe derivata, accertarsi di chiamare la classe di base <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> (metodo).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">Classe <see cref="T:System.Data.DataRelation" /> che viene rimossa.</param>
        <summary>Viene generato quando si rimuove un oggetto <see cref="T:System.Data.DataRelation" /> da un oggetto <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere sottoposto a override dalle sottoclassi per limitare le tabelle da rimuovere  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Classe <see cref="T:System.Data.DataTable" /> che viene rimossa.</param>
        <summary>Viene generato quando si rimuove un oggetto <see cref="T:System.Data.DataTable" /> da un oggetto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere sottoposto a override dalle sottoclassi per limitare le tabelle non verrà rimossa.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata una classe derivata dal <xref:System.Data.DataSet> con il <xref:System.Data.DataSet.OnRemoveTable%2A> metodo sottoposto a override.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un prefisso XML che rappresenta l'alias dello spazio dei nomi della classe <see cref="T:System.Data.DataSet" />.</summary>
        <value>Prefisso XML per lo spazio dei nomi della classe <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.Prefix%2A> proprietà viene utilizzata in un documento XML per identificare gli elementi appartenenti allo spazio dei nomi di <xref:System.Data.DataSet> oggetto (come impostato dal <xref:System.Data.DataSet.Namespace%2A> proprietà).  
  
   
  
## Examples  
 L'esempio seguente imposta la <xref:System.Data.DataSet.Prefix%2A> prima di chiamare il <xref:System.Data.DataSet.ReadXml%2A> (metodo).  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà che sta per essere modificata.</param>
        <summary>Invia una notifica nella quale è indicato che la proprietà dell'oggetto <see cref="T:System.Data.DataSet" /> specificato sta per essere modificata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge i dati e lo schema XML nell'oggetto <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto derivato da <see cref="T:System.IO.Stream" />.</param>
        <summary>Legge i dati e lo schema XML nella classe <see cref="T:System.Data.DataSet" /> utilizzando la classe <see cref="T:System.IO.Stream" /> specificata.</summary>
        <returns>Modalità <see cref="T:System.Data.XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o sia i dati dello schema in un <xref:System.Data.DataSet> da un documento XML, mentre il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo legge solo lo schema. Per leggere i dati e dello schema, usare uno dei `ReadXML` overload che include le `mode` parametro e impostarne il valore su `ReadSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere i dati XML, oppure lo schema e i dati dal `DataSet`, usare il `WriteXml` (metodo). Per scrivere solo lo schema, usare il `WriteXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati) viene generata un'eccezione.  
  
 Se si specifica alcuno schema inline, la struttura relazionale viene esteso tramite inferenza, in base alle esigenze, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML al relativo valore corrispondente `DataColumn` o `DataTable` quando vengono sottoposti a escape i caratteri XML validi, ad esempio ("_") nel XML serializzato. Il `DataSet` esegue solo l'escape di caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nei nomi di elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
 Se lo Schema XML per un <xref:System.Data.DataSet> include `targetNamespace`, i dati non possono essere letti e che vengano generate eccezioni quando si chiama <xref:System.Data.DataSet.ReadXml%2A> per caricare il <xref:System.Data.DataSet> con XML che contiene gli elementi senza spazio dei nomi validi. Per leggere gli elementi non qualificati, impostare `elementFormDefault` uguale a "qualified" nello Schema XML, come illustrato nell'esempio seguente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> specificando `XmlReadMode.ReadSchema`. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
   
  
## Examples  
 L'esempio seguente crea innanzitutto un semplice <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, due colonne e dieci righe. Il <xref:System.Data.DataSet> dello schema e i dati vengono scritti su disco richiamando il <xref:System.Data.DataSet.WriteXml%2A> (metodo). Una seconda <xref:System.Data.DataSet> viene creato e <xref:System.Data.DataSet.ReadXml%2A> metodo viene utilizzato per compilarlo con schemi e dati.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Oggetto <see langword="TextReader" /> da cui leggere schema e dati.</param>
        <summary>Legge i dati e lo schema XML nella classe <see cref="T:System.Data.DataSet" /> utilizzando la classe <see cref="T:System.IO.TextReader" /> specificata.</summary>
        <returns>Modalità <see cref="T:System.Data.XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o sia i dati dello schema in un <xref:System.Data.DataSet> da un documento XML, mentre il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo legge solo lo schema. Per leggere i dati e dello schema, usare uno dei `ReadXML` overload che include le `mode` parametro e impostarne il valore su `ReadSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere i dati XML, oppure lo schema e i dati dal `DataSet`, usare il `WriteXml` (metodo). Per scrivere solo lo schema, usare il `WriteXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati) viene generata un'eccezione.  
  
 Se si specifica alcuno schema inline, la struttura relazionale viene esteso tramite inferenza, in base alle esigenze, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML al relativo valore corrispondente `DataColumn` o `DataTable` quando vengono sottoposti a escape i caratteri XML validi, ad esempio ("_") nel XML serializzato. Il `DataSet` esegue solo l'escape di caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nei nomi di elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
 Se lo Schema XML per un <xref:System.Data.DataSet> include `targetNamespace`, i dati non possono essere letti e che vengano generate eccezioni quando si chiama <xref:System.Data.DataSet.ReadXml%2A> per caricare il <xref:System.Data.DataSet> con XML che contiene gli elementi senza spazio dei nomi validi. Per leggere gli elementi non qualificati, impostare `elementFormDefault` uguale a "qualified" nello Schema XML come illustrato nell'esempio seguente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Le classi che ereditano dal <xref:System.IO.TextReader> classe includono i <xref:System.IO.StreamReader> e <xref:System.IO.StringReader> classi.  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> specificando `XmlReadMode.ReadSchema`. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
   
  
## Examples  
 L'esempio seguente crea innanzitutto un semplice <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, due colonne e dieci righe. Il <xref:System.Data.DataSet> dello schema e i dati vengono scritti su disco richiamando il <xref:System.Data.DataSet.WriteXml%2A> (metodo). Una seconda <xref:System.Data.DataSet> viene creato e <xref:System.Data.DataSet.ReadXml%2A> metodo viene utilizzato per compilarlo con schemi e dati.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file, incluso il percorso, da cui eseguire la lettura.</param>
        <summary>Legge i dati e lo schema XML nell'oggetto <see cref="T:System.Data.DataSet" /> utilizzando il file specificato.</summary>
        <returns>Modalità <see langword="XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o sia i dati dello schema in un <xref:System.Data.DataSet> da un documento XML, mentre il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo legge solo lo schema. Per leggere i dati e dello schema, usare uno dei `ReadXML` overload che include le `mode` parametro e impostarne il valore su `ReadSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere i dati XML, oppure lo schema e i dati dal `DataSet`, usare il `WriteXml` (metodo). Per scrivere solo lo schema, usare il `WriteXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati) viene generata un'eccezione.  
  
 Se si specifica alcuno schema inline, la struttura relazionale viene esteso tramite inferenza, in base alle esigenze, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML al relativo valore corrispondente `DataColumn` o `DataTable` quando vengono sottoposti a escape i caratteri XML validi, ad esempio ("_") nel XML serializzato. Il `DataSet` esegue solo l'escape di caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nei nomi di elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
 Se lo Schema XML per un <xref:System.Data.DataSet> include un `targetNamespace`, i dati non possono essere letti e che vengano generate eccezioni quando si chiama <xref:System.Data.DataSet.ReadXml%2A> per caricare il <xref:System.Data.DataSet> con XML che contiene gli elementi senza spazio dei nomi validi. Per leggere gli elementi non qualificati, impostare `elementFormDefault` uguale a "qualified" nello Schema XML come illustrato nell'esempio seguente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> specificando `XmlReadMode.ReadSchema`. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
   
  
## Examples  
 L'esempio seguente crea innanzitutto un semplice <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, due colonne e dieci righe. Il <xref:System.Data.DataSet> dello schema e i dati vengono scritti su disco richiamando il <xref:System.Data.DataSet.WriteXml%2A> (metodo). Una seconda <xref:System.Data.DataSet> viene creato e <xref:System.Data.DataSet.ReadXml%2A> metodo viene utilizzato per compilarlo con schemi e dati.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">La classe <see cref="T:System.Security.Permissions.FileIOPermission" /> non è impostata su <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazione associata: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Classe <see cref="T:System.Xml.XmlReader" /> da cui eseguire la lettura.</param>
        <summary>Legge i dati e lo schema XML nella classe <see cref="T:System.Data.DataSet" /> utilizzando la classe <see cref="T:System.Xml.XmlReader" /> specificata.</summary>
        <returns>Modalità <see langword="XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o sia i dati dello schema in un <xref:System.Data.DataSet> da un documento XML, mentre il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo legge solo lo schema. Per leggere i dati e dello schema, usare uno dei `ReadXML` overload che include le `mode` parametro e impostarne il valore su `ReadSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere i dati XML, oppure lo schema e i dati dal `DataSet`, usare il `WriteXml` (metodo). Per scrivere solo lo schema, usare il `WriteXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati) viene generata un'eccezione.  
  
 Se si specifica alcuno schema inline, la struttura relazionale viene esteso tramite inferenza, in base alle esigenze, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML al relativo valore corrispondente `DataColumn` o `DataTable` quando vengono sottoposti a escape i caratteri XML validi, ad esempio ("_") nel XML serializzato. Il `DataSet` esegue solo l'escape di caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nei nomi di elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
 Se lo Schema XML per un <xref:System.Data.DataSet> include un `targetNamespace`, i dati non possono essere letti e che vengano generate eccezioni quando si chiama <xref:System.Data.DataSet.ReadXml%2A> per caricare il <xref:System.Data.DataSet> con XML che contiene gli elementi senza spazio dei nomi validi. Per leggere gli elementi non qualificati, impostare `elementFormDefault` uguale a "qualified" nello Schema XML come illustrato nell'esempio seguente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> eredita da <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> specificando `XmlReadMode.ReadSchema`. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
   
  
## Examples  
 L'esempio seguente crea innanzitutto un semplice <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, due colonne e dieci righe. Il <xref:System.Data.DataSet> dello schema e i dati vengono scritti su disco richiamando il <xref:System.Data.DataSet.WriteXml%2A> (metodo). Una seconda <xref:System.Data.DataSet> viene creato e <xref:System.Data.DataSet.ReadXml%2A> metodo viene utilizzato per compilarlo con schemi e dati.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">Classe <see cref="T:System.IO.Stream" /> da cui eseguire la lettura.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Legge i dati e lo schema XML nella classe <see cref="T:System.Data.DataSet" /> utilizzando la classe <see cref="T:System.IO.Stream" /> e l'enumerazione <see cref="T:System.Data.XmlReadMode" /> specificate.</summary>
        <returns>Modalità <see langword="XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o sia i dati dello schema in un <xref:System.Data.DataSet> da un documento XML, mentre il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo legge solo lo schema. Per leggere i dati e dello schema, usare uno dei `ReadXML` overload che include le `mode` parametro e impostarne il valore su `ReadSchema`.  
  
 Lo stesso vale per il <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere i dati XML, oppure lo schema e i dati dal `DataSet`, usare il `WriteXml` (metodo). Per scrivere solo lo schema, usare il `WriteXmlSchema` (metodo).  
  
> [!NOTE]
>  Quando si usa <xref:System.Data.DataSet.ReadXml%2A> e si imposta <xref:System.Data.XmlReadMode> al `Diffgram`, il contenuto della destinazione `DataSet` originale e `DataSet` possono variare a causa delle modalità di generazione ed elaborazione diffgram. Per altre informazioni sui DiffGram, vedere [DiffGram](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati) viene generata un'eccezione.  
  
 Se si specifica alcuno schema inline, la struttura relazionale viene esteso tramite inferenza, in base alle esigenze, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML al relativo valore corrispondente `DataColumn` o `DataTable` quando vengono sottoposti a escape i caratteri XML validi, ad esempio ("_") nel XML serializzato. Il `DataSet` esegue solo l'escape di caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nei nomi di elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
 Se lo Schema XML per un <xref:System.Data.DataSet> include `targetNamespace`, i dati non possono essere letti e che vengano generate eccezioni quando si chiama <xref:System.Data.DataSet.ReadXml%2A> per caricare il <xref:System.Data.DataSet> con XML che contiene gli elementi senza spazio dei nomi validi. Per leggere gli elementi non qualificati, impostare `elementFormDefault` uguale a "qualified" nello Schema XML come illustrato nell'esempio seguente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> specificando `XmlReadMode.ReadSchema`. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Classe <see cref="T:System.IO.TextReader" /> da cui eseguire la lettura.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Legge i dati e lo schema XML nella classe <see cref="T:System.Data.DataSet" /> utilizzando la classe <see cref="T:System.IO.TextReader" /> e l'enumerazione <see cref="T:System.Data.XmlReadMode" /> specificate.</summary>
        <returns>Modalità <see langword="XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o sia i dati dello schema in un <xref:System.Data.DataSet> da un documento XML, mentre il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo legge solo lo schema. Per leggere i dati e dello schema, usare uno dei `ReadXML` overload che include le `mode` parametro e impostarne il valore su `ReadSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere i dati XML, oppure lo schema e i dati dal `DataSet`, usare il `WriteXml` (metodo). Per scrivere solo lo schema, usare il `WriteXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati) viene generata un'eccezione.  
  
 Se si specifica alcuno schema inline, la struttura relazionale viene esteso tramite inferenza, in base alle esigenze, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML al relativo valore corrispondente `DataColumn` o `DataTable` quando vengono sottoposti a escape i caratteri XML validi, ad esempio ("_") nel XML serializzato. Il `DataSet` esegue solo l'escape di caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nei nomi di elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
 Se lo Schema XML per un <xref:System.Data.DataSet> include `targetNamespace`, i dati non possono essere letti e che vengano generate eccezioni quando si chiama <xref:System.Data.DataSet.ReadXml%2A> per caricare il <xref:System.Data.DataSet> con XML che contiene gli elementi senza spazio dei nomi validi. Per leggere gli elementi non qualificati, impostare `elementFormDefault` uguale a "qualified" nello Schema XML come illustrato nell'esempio seguente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> specificando `XmlReadMode.ReadSchema`. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file, incluso il percorso, da cui eseguire la lettura.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Legge i dati e lo schema XML nell'oggetto <see cref="T:System.Data.DataSet" /> utilizzando il file e l'oggetto <see cref="T:System.Data.XmlReadMode" /> specificati.</summary>
        <returns>Modalità <see langword="XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o sia i dati dello schema in un <xref:System.Data.DataSet> da un documento XML, mentre il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo legge solo lo schema. Per leggere i dati e dello schema, usare uno dei `ReadXML` overload che include le `mode` parametro e impostarne il valore su `ReadSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere i dati XML, oppure lo schema e i dati dal `DataSet`, usare il `WriteXml` (metodo). Per scrivere solo lo schema, usare il `WriteXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati) viene generata un'eccezione.  
  
 Se si specifica alcuno schema inline, la struttura relazionale viene esteso tramite inferenza, in base alle esigenze, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML al relativo valore corrispondente `DataColumn` o `DataTable` quando vengono sottoposti a escape i caratteri XML validi, ad esempio ("_") nel XML serializzato. Il `DataSet` esegue solo l'escape di caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nei nomi di elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
 Se lo Schema XML per un <xref:System.Data.DataSet> include un `targetNamespace`, i dati non possono essere letti e che vengano generate eccezioni quando si chiama <xref:System.Data.DataSet.ReadXml%2A> per caricare il <xref:System.Data.DataSet> con XML che contiene gli elementi senza spazio dei nomi validi. Per leggere gli elementi non qualificati, impostare `elementFormDefault` uguale a "qualified" nello Schema XML come illustrato nell'esempio seguente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> specificando `XmlReadMode.ReadSchema`. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">La classe <see cref="T:System.Security.Permissions.FileIOPermission" /> non è impostata su <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazione associata: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Classe <see cref="T:System.Xml.XmlReader" /> da cui eseguire la lettura.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Legge i dati e lo schema XML nella classe <see cref="T:System.Data.DataSet" /> utilizzando la classe <see cref="T:System.Xml.XmlReader" /> e l'enumerazione <see cref="T:System.Data.XmlReadMode" /> specificate.</summary>
        <returns>Modalità <see langword="XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataSet.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o sia i dati dello schema in un <xref:System.Data.DataSet> da un documento XML, mentre il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo legge solo lo schema. Per leggere i dati e dello schema, usare uno dei `ReadXML` overload che include le `mode` parametro e impostarne il valore su `ReadSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.WriteXml%2A> e <xref:System.Data.DataSet.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere i dati XML, oppure lo schema e i dati dal `DataSet`, usare il `WriteXml` (metodo). Per scrivere solo lo schema, usare il `WriteXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati) viene generata un'eccezione.  
  
 Se si specifica alcuno schema inline, la struttura relazionale viene esteso tramite inferenza, in base alle esigenze, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML al relativo valore corrispondente `DataColumn` o `DataTable` quando vengono sottoposti a escape i caratteri XML validi, ad esempio ("_") nel XML serializzato. Il `DataSet` esegue solo l'escape di caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nei nomi di elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
 Se lo Schema XML per un <xref:System.Data.DataSet> include un `targetNamespace`, i dati non possono essere letti e che vengano generate eccezioni quando si chiama <xref:System.Data.DataSet.ReadXml%2A> per caricare il <xref:System.Data.DataSet> con XML che contiene gli elementi senza spazio dei nomi validi. Per leggere gli elementi non qualificati, impostare `elementFormDefault` uguale a "qualified" nello Schema XML come illustrato nell'esempio seguente.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXml%2A> specificando `XmlReadMode.ReadSchema`. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge un XML Schema in <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Classe <see cref="T:System.IO.Stream" /> da cui eseguire la lettura.</param>
        <summary>Legge lo schema XML dalla classe <see cref="T:System.IO.Stream" /> specificata nella classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo per creare lo schema per un <xref:System.Data.DataSet>. Lo schema include le definizioni di tabella, relazioni e vincoli. Per scrivere uno schema a un documento XML, usare il <xref:System.Data.DataSet.WriteXmlSchema%2A> (metodo).  
  
 Lo schema XML viene scritto usando lo standard XSD.  
  
> [!NOTE]
>  Il danneggiamento dei dati può verificarsi se il DataType e i tipi xs: Type non corrispondono. Non verrà generata alcuna eccezione.  
  
 Il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo in genere viene richiamato prima di richiamare il <xref:System.Data.DataSet.ReadXml%2A> metodo utilizzato per riempire il <xref:System.Data.DataSet>.  
  
 Le classi che derivano dal <xref:System.IO.Stream> classe includono <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, e <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXmlSchema%2A>. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.IO.FileStream> dell'oggetto per leggere uno schema XML e richiama il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo con l'oggetto.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Classe <see cref="T:System.IO.TextReader" /> da cui eseguire la lettura.</param>
        <summary>Legge lo schema XML dalla classe <see cref="T:System.IO.TextReader" /> specificata nella classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo per creare lo schema per un <xref:System.Data.DataSet>. Lo schema include le definizioni di tabella, relazioni e vincoli. Per scrivere uno schema a un documento XML, usare il <xref:System.Data.DataSet.WriteXmlSchema%2A> (metodo).  
  
 Lo schema XML viene scritto usando lo standard XSD.  
  
> [!NOTE]
>  Il danneggiamento dei dati può verificarsi se il DataType e i tipi xs: Type non corrispondono. Non verrà generata alcuna eccezione.  
  
 Il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo in genere viene richiamato prima di richiamare il <xref:System.Data.DataSet.ReadXml%2A> metodo utilizzato per riempire il <xref:System.Data.DataSet>.  
  
 Le classi che ereditano dal <xref:System.IO.TextReader> classe includono i <xref:System.IO.StreamReader> e <xref:System.IO.StringReader> classi.  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXmlSchema%2A>. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.IO.StreamReader> per leggere uno schema dell'oggetto e richiama il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo con l'oggetto.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file, incluso il percorso, da cui eseguire la lettura.</param>
        <summary>Legge lo schema XML dal file specificato nell'oggetto <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo per creare lo schema per un <xref:System.Data.DataSet>. Lo schema include le definizioni di tabella, relazioni e vincoli. Per scrivere uno schema a un documento XML, usare il <xref:System.Data.DataSet.WriteXmlSchema%2A> (metodo).  
  
 Lo schema XML viene scritto usando lo standard XSD.  
  
> [!NOTE]
>  Il danneggiamento dei dati può verificarsi se il DataType e i tipi xs: Type non corrispondono. Non verrà generata alcuna eccezione.  
  
 Il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo in genere viene richiamato prima di richiamare il <xref:System.Data.DataSet.ReadXml%2A> metodo utilizzato per riempire il <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Se lo schema per l'oggetto <xref:System.Data.DataSet> contiene elementi con lo stesso nome, ma di tipo diverso, nello stesso spazio dei nomi, quando si tenta di leggere lo schema nell'oggetto <xref:System.Data.DataSet> con il metodo <xref:System.Data.DataSet.ReadXmlSchema%2A> verrà generata un'eccezione. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">La classe <see cref="T:System.Security.Permissions.FileIOPermission" /> non è impostata su <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazione associata: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Classe <see cref="T:System.Xml.XmlReader" /> da cui eseguire la lettura.</param>
        <summary>Legge lo schema XML dalla classe <see cref="T:System.Xml.XmlReader" /> specificata nella classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo per creare lo schema per un <xref:System.Data.DataSet>. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto usando lo standard XSD.  
  
> [!NOTE]
>  Il danneggiamento dei dati può verificarsi se il DataType e i tipi xs: Type non corrispondono. Non verrà generata alcuna eccezione.  
  
 Il <xref:System.Data.DataSet.ReadXmlSchema%2A> metodo in genere viene richiamato prima di richiamare il <xref:System.Data.DataSet.ReadXml%2A> metodo utilizzato per riempire il <xref:System.Data.DataSet>.  
  
 Il <xref:System.Xml.XmlReader?displayProperty=nameWithType> classe è astratta. Una classe che eredita dal `XmlReader` è il <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> classe.  
  
> [!NOTE]
>  Se lo schema per il <xref:System.Data.DataSet> contiene gli elementi con lo stesso nome ma con tipo diverso, nello stesso spazio dei nomi, viene generata un'eccezione quando si prova a leggere lo schema nel <xref:System.Data.DataSet> con <xref:System.Data.DataSet.ReadXmlSchema%2A>. Questa eccezione non viene eseguito se si usa .NET Framework versione 1.0.  
  
   
  
## Examples  
 L'esempio seguente crea una nuova <xref:System.Data.DataSet> e <xref:System.IO.FileStream?displayProperty=nameWithType> oggetto. Il <xref:System.IO.FileStream> oggetto, creato con un percorso di file e nome file, viene usato per creare un' <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> che viene passato come argomento per il <xref:System.Data.DataSet.ReadXmlSchema%2A> (metodo).  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lettore XML specificato.</param>
        <summary>Ignora gli attributi e restituisce un DataSet vuoto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla tutte le modifiche apportate all'oggetto <see cref="T:System.Data.DataSet" /> dal momento in cui è stato creato o sin dall'ultima chiamata al metodo <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Richiamare il <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> per chiamare il <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> metodo su tutti <xref:System.Data.DataTable> gli oggetti contenuti il <xref:System.Data.DataSet>.  
  
 <xref:System.Data.DataRow> gli oggetti contenuti il <xref:System.Data.DataSet> è possibile portare in modalità di modifica richiamando il <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> (metodo). Dopo aver richiamato il <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> metodo, le modifiche possono essere rifiutate chiamando il <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> nel <xref:System.Data.DataTable> a cui il <xref:System.Data.DataRow> appartengono gli oggetti.  
  
 Quando il <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> viene chiamato il metodo, tutte le righe ancora in modalità di modifica annullate le modifiche apportate. Le nuove righe vengono rimosse. Righe modificate ed eliminate tornano al relativo stato originale (`DataRowState.Unchanged`).  
  
 Oggetti acceptchange e Rejectchange si applicano solo ai <xref:System.Data.DataRow> le modifiche correlate (vale a dire `Add`, `Remove`, `Delete`, e `Modify`). Non sono applicabili allo schema o modifiche strutturali.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata una classe derivata dal <xref:System.Data.DataSet> classe. Il <xref:System.Data.DataSet.RejectChanges%2A> evento viene richiamato dall'interno di una funzione.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottenere l'insieme di relazioni che collegano le tabelle e consentono la navigazione dalle tabelle padre a quelle figlio.</summary>
        <value>Classe <see cref="T:System.Data.DataRelationCollection" /> che contiene una raccolta di oggetti <see cref="T:System.Data.DataRelation" />. Se non esiste alcun oggetto <see cref="T:System.Data.DataRelation" /> viene restituito un insieme vuoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente visualizza il nome della colonna di tutte le tabelle figlio tramite la <xref:System.Data.DataSet.Relations%2A> proprietà.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un'enumerazione <see cref="T:System.Data.SerializationFormat" /> per la classe <see cref="T:System.Data.DataSet" /> utilizzata durante i servizi remoti.</summary>
        <value>Un oggetto <see cref="T:System.Data.SerializationFormat" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutte le tabelle e rimuove tutte le relazioni, vincoli stranieri e tabelle da <see cref="T:System.Data.DataSet" />. Per ripristinare lo stato originale dell'oggetto <see cref="M:System.Data.DataSet.Reset" />, è necessario eseguire l'override del metodo <see cref="T:System.Data.DataSet" /> mediante le sottoclassi.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un'enumerazione <see cref="T:System.Data.SchemaSerializationMode" /> per una classe <see cref="T:System.Data.DataSet" />.</summary>
        <value>Ottiene o imposta un'enumerazione <see cref="T:System.Data.SchemaSerializationMode" /> per una classe <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Data.DataSet> serializza i dati dello schema e istanza per impostazione predefinita nei servizi Web e scenari remoti. Impostando il <xref:System.Data.DataSet.SchemaSerializationMode%2A> proprietà di una classe tipizzata `DataSet` a <xref:System.Data.SchemaSerializationMode.ExcludeSchema> fa sì che le informazioni sullo schema da escludere dal payload della serializzazione.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> è supportato solo per un oggetto tipizzato `DataSet`. Per una classe non tipizzata `DataSet` questa proprietà può essere impostata solo su <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> deve essere usato solo nei casi in cui le informazioni sullo schema dell'oggetto sottostante digitate `DataTables`, `DataRelations` e `Constraints` non è stato modificato. Se le modifiche di schema, tutte le informazioni devono essere serializzate con <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> è supportato nella versione 2.0 di .NET Framework o versione successiva.  
  
 Quando <xref:System.Data.SchemaSerializationMode.ExcludeSchema> è impostato, solo le proprietà di runtime di livello superiore presente nel <xref:System.Data.DataSet> vengono serializzati. Inoltre, essi vengono serializzate solo se si verificano può essere diverso dai valori predefiniti. Nessuna delle `Tables`, `Relations` o `Constraints` vengono serializzati. Includono le proprietà di runtime serializzati <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, e <xref:System.Data.DataSet.CaseSensitive%2A>. Queste proprietà vengono serializzate per assicurarsi che venga mantenuto l'integrità dei dati di runtime complessiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un valore che indica se la proprietà <see cref="P:System.Data.DataSet.Relations" /> deve essere resa persistente.</summary>
        <returns>
          <see langword="true" /> se il valore della proprietà è stato modificato rispetto all'impostazione predefinita; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere Usa questo metodo se si crea una finestra di progettazione per il <xref:System.Data.DataSet>, o la creazione di controllo personalizzato che includa il <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Gli esempi seguenti mostrano una classe derivata dal <xref:System.Data.DataSet> classe. Il <xref:System.Data.DataSet.Reset%2A> e <xref:System.Data.DataSet.ShouldSerializeRelations%2A> metodi vengono richiamati all'interno delle funzioni nella classe derivata.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un valore che indica se la proprietà <see cref="P:System.Data.DataSet.Tables" /> deve essere resa persistente.</summary>
        <returns>
          <see langword="true" /> se il valore della proprietà è stato modificato rispetto all'impostazione predefinita; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è in genere usare solo se si crea una finestra di progettazione per il <xref:System.Data.DataSet>, o la creazione di controllo personalizzato che includa il <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata una classe derivata dal <xref:System.Data.DataSet> classe. Il <xref:System.Data.DataSet.ShouldSerializeTables%2A> metodo viene chiamato da all'interno delle funzioni nella classe derivata.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto <see cref="T:System.ComponentModel.ISite" /> per l'oggetto <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> per l'oggetto <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Associano i siti di una <xref:System.ComponentModel.Component> a un <xref:System.ComponentModel.Container> e abilitare la comunicazione tra di essi, nonché forniscono un modo per il contenitore gestire i relativi componenti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>Per una descrizione di questo membro, vedere <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataSet> a un'interfaccia <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Per una descrizione di questo membro, vedere <see cref="M:System.ComponentModel.IListSource.GetList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataSet> a un'interfaccia <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Per una descrizione di questo membro, vedere <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataSet> a un'interfaccia <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Oggetto <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataSet> a un'interfaccia <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataSet> a un'interfaccia <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di tabelle contenuto nell'oggetto <see cref="T:System.Data.DataSet" />.</summary>
        <value>Classe <see cref="T:System.Data.DataTableCollection" /> contenuta da questa classe <see cref="T:System.Data.DataSet" />. Se non esiste alcun oggetto <see cref="T:System.Data.DataTable" /> viene restituito un insieme vuoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per aggiungere tabelle alla raccolta, usare <xref:System.Data.DataTableCollection.Add%2A> metodo di <xref:System.Data.DataTableCollection>. Per rimuovere tabelle, usare il <xref:System.Data.DataTableCollection.Remove%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente restituisce il <xref:System.Data.DataSet> dell'oggetto <xref:System.Data.DataTableCollection>e visualizza le colonne e righe in ogni tabella.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive i dati XML e, facoltativamente, lo schema dall'oggetto <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto <see cref="T:System.IO.Stream" /> utilizzato per scrivere in un file.</param>
        <summary>Scrive i dati correnti per la classe <see cref="T:System.Data.DataSet" /> utilizzando la classe <see cref="T:System.IO.Stream" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `WriteXml` metodo fornisce un modo per scrivere solo i dati o sia i dati dello schema da un <xref:System.Data.DataSet> in un documento XML, mentre il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, usare uno degli overload che include il `mode` parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e i dati nel `DataSet`, usare il `ReadXml` (metodo). Per leggere solo lo schema, usare il `ReadXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.IO.FileStream?displayProperty=nameWithType> oggetto. L'oggetto viene quindi usato con il <xref:System.Data.DataSet.WriteXml%2A> metodo per scrivere un documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> con cui eseguire operazioni di scrittura.</param>
        <summary>Scrive i dati correnti per la classe <see cref="T:System.Data.DataSet" /> utilizzando la classe <see cref="T:System.IO.TextWriter" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `WriteXml` metodo fornisce un modo per scrivere solo i dati o sia i dati dello schema da un <xref:System.Data.DataSet> in un documento XML, mentre il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, usare uno degli overload che include il `mode` parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e i dati nel `DataSet`, usare il `ReadXml` (metodo). Per leggere solo lo schema, usare il `ReadXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file, incluso il percorso, in cui scrivere.</param>
        <summary>Scrive i dati correnti per l'oggetto <see cref="T:System.Data.DataSet" /> nel file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `WriteXml` metodo fornisce un modo per scrivere solo i dati o sia i dati dello schema da un <xref:System.Data.DataSet> in un documento XML, mentre il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, usare uno degli overload che include il `mode` parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e i dati nel `DataSet`, usare il `ReadXml` (metodo). Per leggere solo lo schema, usare il `ReadXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">La classe <see cref="T:System.Security.Permissions.FileIOPermission" /> non è impostata su <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazione associata: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Xml.XmlWriter" /> con cui scrivere.</param>
        <summary>Scrive i dati correnti per l'oggetto <see cref="T:System.Data.DataSet" /> nell'oggetto <see cref="T:System.Xml.XmlWriter" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `WriteXml` metodo fornisce un modo per scrivere solo i dati o sia i dati dello schema da un <xref:System.Data.DataSet> in un documento XML, mentre il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, usare uno degli overload che include il `mode` parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e i dati nel `DataSet`, usare il `ReadXml` (metodo). Per leggere solo lo schema, usare il `ReadXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto <see cref="T:System.IO.Stream" /> utilizzato per scrivere in un file.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataSet" /> utilizzando l'oggetto <see cref="T:System.IO.Stream" /> e l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificati. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `WriteXml` metodo fornisce un modo per scrivere solo i dati o sia i dati dello schema da un <xref:System.Data.DataSet> in un documento XML, mentre il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere lo schema sia i dati, impostare il `mode` parametro per `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e i dati nel `DataSet`, usare il `ReadXml` (metodo). Per leggere solo lo schema, usare il `ReadXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" />utilizzato per scrivere il documento.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataSet" /> utilizzando l'oggetto <see cref="T:System.IO.TextWriter" /> e l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificati. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `WriteXml` metodo fornisce un modo per scrivere solo i dati o sia i dati dello schema da un <xref:System.Data.DataSet> in un documento XML, mentre il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere lo schema sia i dati, impostare il `mode` parametro per `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e i dati nel `DataSet`, usare il `ReadXml` (metodo). Per leggere solo lo schema, usare il `ReadXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L'esempio seguente crea innanzitutto un semplice <xref:System.Data.DataSet> con uno <xref:System.Data.DataTable>, due colonne e dieci righe. Il <xref:System.Data.DataSet> dello schema e i dati vengono scritti su disco richiamando il <xref:System.Data.DataSet.WriteXml%2A> (metodo). Una seconda <xref:System.Data.DataSet> viene creato e <xref:System.Data.DataSet.ReadXml%2A> metodo viene utilizzato per compilarlo con schemi e dati.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file, incluso il percorso, in cui scrivere.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataSet" /> nel file specificato utilizzando l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificato. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `WriteXml` metodo fornisce un modo per scrivere solo i dati o sia i dati dello schema da un <xref:System.Data.DataSet> in un documento XML, mentre il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere lo schema sia i dati, impostare il `mode` parametro per `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e i dati nel `DataSet`, usare il `ReadXml` (metodo). Per leggere solo lo schema, usare il `ReadXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataSet.WriteXml%2A> metodo per scrivere un documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">La classe <see cref="T:System.Security.Permissions.FileIOPermission" /> non è impostata su <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazione associata: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Xml.XmlWriter" /> con cui scrivere.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataSet" /> utilizzando l'oggetto <see cref="T:System.Xml.XmlWriter" /> e l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificati. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `WriteXml` metodo fornisce un modo per scrivere solo i dati o sia i dati dello schema da un <xref:System.Data.DataSet> in un documento XML, mentre il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere lo schema sia i dati, impostare il `mode` parametro per `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataSet.ReadXml%2A> e <xref:System.Data.DataSet.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e i dati nel `DataSet`, usare il `ReadXml` (metodo). Per leggere solo lo schema, usare il `ReadXmlSchema` (metodo).  
  
> [!NOTE]
>  Un' <xref:System.InvalidOperationException> viene generata se un tipo di colonna nel `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.IO.FileStream?displayProperty=nameWithType> che consente di creare un nuovo oggetto <xref:System.Xml.XmlTextWriter>. Il <xref:System.Xml.XmlTextWriter> oggetto viene usato con il <xref:System.Data.DataSet.WriteXml%2A> metodo per scrivere un documento XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive la struttura dell'oggetto <see cref="T:System.Data.DataSet" /> come schema XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto <see cref="T:System.IO.Stream" /> utilizzato per scrivere in un file.</param>
        <summary>Scrive la struttura <see cref="T:System.Data.DataSet" /> come schema XML nell'oggetto <see cref="T:System.IO.Stream" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataSet> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli. Per scrivere uno schema a un documento XML, usare il <xref:System.Data.DataSet.WriteXmlSchema%2A> (metodo).  
  
 Lo schema XML viene scritto usando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, usare il <xref:System.Data.DataSet.WriteXml%2A> (metodo).  
  
 Le classi che derivano dal <xref:System.IO.Stream> classe includono <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, e <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.IO.FileStream> oggetto che viene passato il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo per scrivere lo schema sul disco.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> con cui eseguire operazioni di scrittura.</param>
        <summary>Scrive la struttura <see cref="T:System.Data.DataSet" /> come schema XML nell'oggetto <see cref="T:System.IO.TextWriter" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataSet> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli. Per scrivere uno schema a un documento XML, usare il <xref:System.Data.DataSet.WriteXmlSchema%2A> (metodo).  
  
 Lo schema XML viene scritto usando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, usare il <xref:System.Data.DataSet.WriteXml%2A> (metodo).  
  
 Le classi derivate dal <xref:System.IO.TextWriter?displayProperty=nameWithType> classe includono i <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, e <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Text.StringBuilder?displayProperty=nameWithType> oggetto a cui viene usato per creare un nuovo <xref:System.IO.StringWriter?displayProperty=nameWithType>. Il <xref:System.IO.StringWriter> viene passato per il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo e la stringa risultante viene stampato nella finestra della console.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file, incluso il percorso, in cui scrivere.</param>
        <summary>Scrive la struttura dell'oggetto <see cref="T:System.Data.DataSet" /> come schema XML in un file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataSet> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli. Per scrivere uno schema a un documento XML, usare il <xref:System.Data.DataSet.WriteXmlSchema%2A> (metodo).  
  
 Lo schema XML viene scritto usando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, usare il <xref:System.Data.DataSet.WriteXml%2A> (metodo).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">La classe <see cref="T:System.Security.Permissions.FileIOPermission" /> non è impostata su <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura e scrittura di file. Enumerazione associata: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> in cui scrivere.</param>
        <summary>Scrive la struttura dell'oggetto <see cref="T:System.Data.DataSet" /> come schema XML in un oggetto <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataSet> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli. Per scrivere uno schema a un documento XML, usare il <xref:System.Data.DataSet.WriteXmlSchema%2A> (metodo).  
  
 Lo schema XML viene scritto usando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, usare il <xref:System.Data.DataSet.WriteXml%2A> (metodo).  
  
 Una classe che eredita dal <xref:System.Xml.XmlWriter?displayProperty=nameWithType> classe è il <xref:System.Xml.XmlTextWriter> classe.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.IO.FileStream?displayProperty=nameWithType> oggetto con il percorso specificato. Il <xref:System.IO.FileStream> oggetto viene usato per creare un <xref:System.Xml.XmlTextWriter> oggetto. Il <xref:System.Data.DataSet.WriteXmlSchema%2A> metodo viene quindi richiamato con il <xref:System.Xml.XmlTextWriter> oggetto da scrivere lo schema sul disco.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto <see cref="T:System.IO.Stream" /> in cui scrivere.</param>
        <param name="multipleTargetConverter">Delegato utilizzato per convertire <see cref="T:System.Type" /> in stringa.</param>
        <summary>Scrive la struttura <see cref="T:System.Data.DataSet" /> come schema XML nell'oggetto <see cref="T:System.IO.Stream" /> specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> in cui scrivere.</param>
        <param name="multipleTargetConverter">Delegato utilizzato per convertire <see cref="T:System.Type" /> in stringa.</param>
        <summary>Scrive la struttura di <see cref="T:System.Data.DataSet" /> come XML Schema nell'oggetto <see cref="T:System.IO.TextWriter" /> specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file in cui scrivere.</param>
        <param name="multipleTargetConverter">Delegato utilizzato per convertire <see cref="T:System.Type" /> in stringa.</param>
        <summary>Scrive la struttura dell'oggetto <see cref="T:System.Data.DataSet" /> come schema XML in un file.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Xml.XmlWriter" /> in cui scrivere.</param>
        <param name="multipleTargetConverter">Delegato utilizzato per convertire <see cref="T:System.Type" /> in stringa.</param>
        <summary>Scrive la struttura di <see cref="T:System.Data.DataSet" /> come XML Schema nell'oggetto <see cref="T:System.Xml.XmlWriter" /> specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>