<Type Name="IDataAdapter" FullName="System.Data.IDataAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="19bc999689e2cb5af52a69b1ab28024ad5ede488" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36678228" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDataAdapter" />
  <TypeSignature Language="DocId" Value="T:System.Data.IDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDataAdapter" />
  <TypeSignature Language="F#" Value="type IDataAdapter = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Consente a un oggetto di implementare un oggetto DataAdapter e rappresenta un insieme di metodi e proprietà correlate ad azioni di mapping utilizzate per riempire e aggiornare <see cref="T:System.Data.DataSet" /> e aggiornare un'origine dati.  
  
 Le istanze di <see cref="T:System.Data.IDbDataAdapter" /> sono per le origini dati che sono o sembrano database relazionali con comandi testuali (come Transact-SQL), mentre le istanze di <see cref="T:System.Data.IDataAdapter" /> possono usare qualsiasi tipo di origine dati.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.IDataAdapter> interfaccia consente a una classe che eredita implementare una classe di DataAdapter, che rappresenta il ponte tra un'origine dati e un <xref:System.Data.DataSet>. Per ulteriori informazioni sulle classi di DataAdapter, vedere [popolamento di un set di dati da un oggetto DataAdapter](~/docs/framework/data/adonet/populating-a-dataset-from-a-dataadapter.md).  
  
 Un'applicazione non crea un'istanza di <xref:System.Data.IDataAdapter> interfaccia direttamente, ma implementa un'istanza di una classe che eredita <xref:System.Data.IDataAdapter>.  
  
 Le classi che ereditano <xref:System.Data.IDataAdapter> deve implementare i membri ereditati e in genere definiscono membri aggiuntivi per aggiungere funzionalità specifiche del provider. Ad esempio, il <xref:System.Data.IDataAdapter> interfaccia definisce un <xref:System.Data.IDataAdapter.Fill%2A> metodo che accetta un <xref:System.Data.DataSet> come parametro. A sua volta, il <xref:System.Data.OleDb.OleDbDataAdapter> classe eredita le <xref:System.Data.Common.DbDataAdapter.Fill%2A> (metodo) e definisce anche altri due overload del <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> metodo che accetta un oggetto Recordset ADO come parametro.  
  
   
  
## Examples  
 L'esempio seguente usa le classi derivate <xref:System.Data.SqlClient.SqlCommand>, <xref:System.Data.SqlClient.SqlDataAdapter>, e <xref:System.Data.SqlClient.SqlConnection>, per selezionare i record da un database. Il riempimento <xref:System.Data.DataSet> viene quindi restituito. A tale scopo, viene passato un oggetto inizializzato <xref:System.Data.DataSet>, una stringa di connessione e una stringa di query che rappresenta un'istruzione Transact-SQL SELECT.  
  
 [!code-csharp[Classic WebData SqlDataAdapter Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlDataAdapter Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlDataAdapter Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlDataAdapter Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Per promuovere la coerenza fra i provider di dati .NET Framework, assegnare un nome alla classe che eredita il form <paramref name="Prv" /> DataAdapter dove <paramref name="Prv" /> è il prefisso uniforme assegnato a tutte le classi in uno specifico spazio dei nomi del provider di dati .NET Framework. Ad esempio, <paramref name="Sql" /> è il prefisso del <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> classe il <see langword="System.Data.SqlClient" /> dello spazio dei nomi.  Quando si eredita dal <see cref="T:System.Data.IDataAdapter" /> interfaccia, è necessario implementare i seguenti costruttori: <list type="table"><listheader><term> elemento </term><description> descrizione </description></listheader><item><term> PrvDataAdapter() </term><description> Inizializza una nuova istanza della classe PrvDataAdapter.  </description></item><item><term> PrvDataAdapter (PrvCommand selectCommand) </term><description> Inizializza una nuova istanza della classe PrvDataAdapter utilizzando l'istruzione SQL SELECT specificato.  </description></item><item><term> PrvDataAdapter (selectCommandText stringa, stringa selectConnectionString) </term><description> Inizializza una nuova istanza della classe PrvDataAdapter utilizzando un'istruzione SQL SELECT e una stringa di connessione.  </description></item><item><term> PrvDataAdapter (stringa selectCommandText, PrvConnection selectConnection) </term><description> Inizializza una nuova istanza della classe PrvDataAdapter utilizzando un'istruzione SQL SELECT e un oggetto PrvConnection.  </description></item></list></para>
    </block>
  </Docs>
  <Members>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="abstract member Fill : System.Data.DataSet -&gt; int" Usage="iDataAdapter.Fill dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">Oggetto <see cref="T:System.Data.DataSet" /> in cui inserire i record e, se necessario, lo schema.</param>
        <summary>Aggiunge o aggiorna righe nell'oggetto <see cref="T:System.Data.DataSet" /> affinché corrispondano a quelle presenti nell'origine dati utilizzando il nome dell'oggetto <see cref="T:System.Data.DataSet" /> e crea un oggetto <see cref="T:System.Data.DataTable" /> denominato "Table".</summary>
        <returns>Numero di righe aggiunte o aggiornate correttamente nell'oggetto <see cref="T:System.Data.DataSet" />. Non sono incluse righe modificate da istruzioni che non restituiscono righe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataAdapter.Fill%2A> Recupera le righe dall'origine dati utilizzando l'istruzione SELECT specificata da un oggetto associato <xref:System.Data.IDbDataAdapter.SelectCommand%2A> proprietà. L'oggetto connessione associato con l'istruzione SELECT deve essere valido, ma non devono essere aperte. Se la connessione viene chiusa prima <xref:System.Data.IDataAdapter.Fill%2A> viene chiamato, verrà aperta per recuperare i dati, quindi chiusa. Se la connessione è aperta prima <xref:System.Data.IDataAdapter.Fill%2A> viene chiamato, rimane aperto.  
  
 Il <xref:System.Data.IDataAdapter.Fill%2A> operazione quindi le righe aggiunte alla destinazione <xref:System.Data.DataTable> gli oggetti di <xref:System.Data.DataSet>, creando il <xref:System.Data.DataTable> oggetti se non esistano già. Quando si crea <xref:System.Data.DataTable> oggetti, il <xref:System.Data.IDataAdapter.Fill%2A> vengono in genere creati solo i metadati dei nomi di colonna. Tuttavia, se il <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> è impostata su `AddWithKey`, vengono creati anche le chiavi primarie appropriate e vincoli.  
  
 Se `SelectCommand` restituisce i risultati di un OUTER JOIN, mediante `DataAdapter` non viene impostato un valore di <xref:System.Data.DataTable.PrimaryKey%2A> per l'oggetto <xref:System.Data.DataTable> risultante. È necessario definire in modo esplicito la chiave primaria per garantire che le righe duplicate vengano risolte correttamente. Per altre informazioni, vedere [definizione di chiavi primarie](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
 Se il <xref:System.Data.IDataAdapter> rileva colonne duplicate durante la compilazione di un <xref:System.Data.DataTable>, genera nomi per le colonne successive, tramite il criterio "columnname1", "columnname2", "columnname3" e così via. Se i dati in ingresso contengano colonne senza nome, e vengono inseriti nel <xref:System.Data.DataSet> in base al criterio "Column1", "Column2" e così via. Quando più set di risultati vengono aggiunti i <xref:System.Data.DataSet>, ogni set di risultati viene inserito in una tabella separata. Set di risultati aggiuntivi sono denominati aggiungendo i valori integrali al nome della tabella specificato (ad esempio, "Table", "Table1", "Table2" e così via). Le applicazioni devono prestare attenzione quando si utilizzano nomi di colonne e tabelle per assicurarsi che non si verifichino conflitti con questi modelli di denominazione.  
  
 Quando l'istruzione SELECT che consente di popolare il <xref:System.Data.DataSet> restituisce più risultati, ad esempio un'istruzione SQL batch, se uno dei risultati contiene un errore, tutti i risultati successivi vengono ignorati e non aggiunti al <xref:System.Data.DataSet>.  
  
 È possibile usare il <xref:System.Data.IDataAdapter.Fill%2A> metodo più volte nella stessa <xref:System.Data.DataTable>. Se esiste una chiave primaria, le righe in ingresso vengono unite con le righe corrispondenti che esistono già. Se non esiste alcuna chiave primaria, le righe in ingresso vengono accodate al <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Quando si gestiscono istruzioni SQL batch che restituiscono più risultati, l'implementazione di <xref:System.Data.IDataAdapter.Fill%2A> e <xref:System.Data.IDataAdapter.FillSchema%2A> per dati .NET Framework provider recupera le informazioni sullo schema per il primo risultato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberSignature Language="F#" Value="abstract member FillSchema : System.Data.DataSet * System.Data.SchemaType -&gt; System.Data.DataTable[]" Usage="iDataAdapter.FillSchema (dataSet, schemaType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet">Oggetto <see cref="T:System.Data.DataSet" /> in cui inserire lo schema dall'origine dati.</param>
        <param name="schemaType">Uno dei valori di <see cref="T:System.Data.SchemaType" />.</param>
        <summary>Aggiunge un oggetto <see cref="T:System.Data.DataTable" /> denominato "Table" all'oggetto <see cref="T:System.Data.DataSet" /> specificato e configura lo schema perché corrisponda a quello presente nell'origine dati basato sull'oggetto <see cref="T:System.Data.SchemaType" /> specificato.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Data.DataTable" /> che contiene informazioni di schema restituite dall'origine dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.IDataAdapter.FillSchema%2A> che consente di recuperare lo schema dall'origine dati mediante il <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. L'oggetto connessione associato il <xref:System.Data.IDbDataAdapter.SelectCommand%2A> deve essere valido, ma non deve essere aperto. Se la connessione viene chiusa prima <xref:System.Data.IDataAdapter.FillSchema%2A> viene chiamato, verrà aperta per recuperare i dati, quindi chiusa. Se la connessione è aperta prima <xref:System.Data.IDataAdapter.FillSchema%2A> viene chiamato, rimane aperto.  
  
 Un <xref:System.Data.IDataAdapter.FillSchema%2A> operazione viene aggiunta una <xref:System.Data.DataTable> alla destinazione <xref:System.Data.DataSet>. Aggiunge quindi le colonne per la <xref:System.Data.DataColumnCollection> del <xref:System.Data.DataTable> e configura gli elementi seguenti <xref:System.Data.DataColumn> proprietà, se sono presenti nell'origine dati:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. È necessario impostare <xref:System.Data.DataColumn.AutoIncrementStep%2A> e <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separatamente.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.IDataAdapter.FillSchema%2A> Configura inoltre la <xref:System.Data.DataTable.PrimaryKey%2A> e <xref:System.Data.DataTable.Constraints%2A> proprietà secondo le regole seguenti:  
  
-   Se vengono restituite uno o più colonne chiave primaria per il <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, verranno utilizzate come colonne chiave primaria per il <xref:System.Data.DataTable>.  
  
-   Se non vengono restituite le colonne di chiavi primarie sono colonne univoche, le colonne univoche vengono utilizzate come chiave primaria se tutte le colonne univoche sono non nullable. Se una delle colonne sono nullable, un <xref:System.Data.UniqueConstraint> viene aggiunto per il <xref:System.Data.ConstraintCollection>, ma la <xref:System.Data.DataTable.PrimaryKey%2A> non è impostata.  
  
-   Se vengono restituite sia colonne chiave primaria che colonne univoche, le colonne chiave primaria vengono utilizzate come colonne chiave primaria per la <xref:System.Data.DataTable>.  
  
 Si noti che le chiavi primarie e i vincoli unique vengono aggiunti i <xref:System.Data.ConstraintCollection> in base alle regole precedenti, ma altri vincoli non vengono aggiunti i tipi.  
  
 Se il cluster univoco indice è definito in una o più colonne in una tabella di SQL Server e il vincolo di chiave primaria è definito in un set diverso di colonne, quindi verranno restituiti i nomi delle colonne nell'indice cluster. Per restituire il nome o i nomi delle colonne chiave primaria, utilizzare un hint per la query con l'istruzione SELECT che specifica il nome dell'indice di chiave primaria. Per ulteriori informazioni su come specificare hint per la query, vedere [hint per la Query (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Se il <xref:System.Data.IDataAdapter> rileva colonne duplicate durante la compilazione di un <xref:System.Data.DataTable>, genera nomi per le colonne successive, tramite il criterio "columnname1", "columnname2", "columnname3" e così via. Se i dati in ingresso contengano colonne senza nome, e vengono inseriti nel <xref:System.Data.DataSet> in base al criterio "Column1", "Column2" e così via. Quando più set di risultati vengono aggiunti i <xref:System.Data.DataSet>, ogni set di risultati viene inserito in una tabella separata. Set di risultati aggiuntivi sono denominati aggiungendo i valori integrali al nome della tabella specificato (ad esempio, "Table", "Table1", "Table2" e così via). Le applicazioni devono prestare attenzione quando si utilizzano nomi di colonne e tabelle per assicurarsi che non si verifichino conflitti con questi modelli di denominazione.  
  
 <xref:System.Data.IDataAdapter.FillSchema%2A> non restituisce alcuna riga. Usare la <xref:System.Data.IDataAdapter.Fill%2A> metodo per aggiungere righe a un <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetFillParameters : unit -&gt; System.Data.IDataParameter[]" Usage="iDataAdapter.GetFillParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene i parametri impostati dall'utente durante l'esecuzione di un'istruzione SQL SELECT.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Data.IDataParameter" /> che contiene i parametri impostati dall'utente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
```  
private static void GetParameters(String connectiongString) {  
           using (SqlConnection conn = new SqlConnection(connectiongString)) {  
              String queryString = "Select [CourseID],[Title],[Credits] from [MySchool].[dbo].[Course] where [Year]=@Year and [Credit]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MissingMappingAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingMappingAction MissingMappingAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingMappingAction MissingMappingAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.MissingMappingAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingMappingAction As MissingMappingAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingMappingAction MissingMappingAction { System::Data::MissingMappingAction get(); void set(System::Data::MissingMappingAction value); };" />
      <MemberSignature Language="F#" Value="member this.MissingMappingAction : System.Data.MissingMappingAction with get, set" Usage="System.Data.IDataAdapter.MissingMappingAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MissingMappingAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica o specifica se colonne o tabelle di origine non mappate vengono passate con i rispettivi nomi di origine per l'applicazione di filtri o per la generazione di un errore.</summary>
        <value>Uno dei valori di <see cref="T:System.Data.MissingMappingAction" />. Il valore predefinito è <see langword="Passthrough" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.IDataAdapter.TableMappings%2A> proprietà fornisce il mapping master tra i record restituiti e <xref:System.Data.DataSet>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore impostato non è uno dei valori di <see cref="T:System.Data.MissingMappingAction" />.</exception>
        <altmember cref="P:System.Data.IDataAdapter.MissingSchemaAction" />
      </Docs>
    </Member>
    <Member MemberName="MissingSchemaAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingSchemaAction MissingSchemaAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingSchemaAction MissingSchemaAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.MissingSchemaAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingSchemaAction As MissingSchemaAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingSchemaAction MissingSchemaAction { System::Data::MissingSchemaAction get(); void set(System::Data::MissingSchemaAction value); };" />
      <MemberSignature Language="F#" Value="member this.MissingSchemaAction : System.Data.MissingSchemaAction with get, set" Usage="System.Data.IDataAdapter.MissingSchemaAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MissingSchemaAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica o specifica se le tabelle, le colonne e le rispettive relazioni di origine mancanti verranno aggiunte allo schema dataset, verranno ignorate o causeranno la generazione di un errore.</summary>
        <value>Uno dei valori di <see cref="T:System.Data.MissingSchemaAction" />. Il valore predefinito è <see langword="Add" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Il valore impostato non è uno dei valori di <see cref="T:System.Data.MissingSchemaAction" />.</exception>
        <altmember cref="P:System.Data.Common.DataAdapter.MissingMappingAction" />
      </Docs>
    </Member>
    <Member MemberName="TableMappings">
      <MemberSignature Language="C#" Value="public System.Data.ITableMappingCollection TableMappings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ITableMappingCollection TableMappings" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.TableMappings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TableMappings As ITableMappingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ITableMappingCollection ^ TableMappings { System::Data::ITableMappingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TableMappings : System.Data.ITableMappingCollection" Usage="System.Data.IDataAdapter.TableMappings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.ITableMappingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica come viene eseguito il mapping tra una tabella di origine e una tabella dataset.</summary>
        <value>Insieme che fornisce il mapping principale tra i record restituiti e l'oggetto <see cref="T:System.Data.DataSet" />. Il valore predefinito è una raccolta vuota.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.IDataAdapter> utilizza solo i mapping per la tabella di origine denominata "Table". Selezionare tutti, istruzioni INSERT, DELETE e UPDATE che restituiscono dati devono eseguire l'operazione usando denominazione delle colonne coerente. I nomi delle colonne restituite nei record devono essere univoci, in caso contrario, le colonne con nomi duplicati sovrascrivere i dati precedenti. In <xref:System.Data.IDataAdapter.Update%2A>, solo la tabella mappata alla tabella di origine denominata "Table" avrà le relative modifiche risolte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="abstract member Update : System.Data.DataSet -&gt; int" Usage="iDataAdapter.Update dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">L'oggetto <see cref="T:System.Data.DataSet" /> utilizzato per aggiornare l'origine dati.</param>
        <summary>Chiama le corrispondenti istruzioni INSERT, UPDATE o DELETE per ciascuna riga inserita, aggiornata o eliminata nell'oggetto <see cref="T:System.Data.DataSet" /> specificato da un oggetto <see cref="T:System.Data.DataTable" /> denominato "Table".</summary>
        <returns>Numero di righe aggiornate correttamente dall'oggetto <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un'applicazione chiama il <xref:System.Data.IDataAdapter.Update%2A> metodo, il <xref:System.Data.IDataAdapter> esamina la <xref:System.Data.DataRow.RowState%2A> proprietà ed esegue le istruzioni INSERT, UPDATE o DELETE richieste in modo iterativo per ogni riga, in base all'ordine degli indici configurati nel <xref:System.Data.DataSet>. Ad esempio <xref:System.Data.IDataAdapter.Update%2A> potrebbe eseguire un'istruzione DELETE, seguita da un'istruzione INSERT e quindi un'altra istruzione DELETE, a causa di ordinamento delle righe nel <xref:System.Data.DataTable>.  
  
 Tenere presente che queste istruzioni non vengono eseguite come processo batch; ogni riga viene aggiornata singolarmente. Un'applicazione può chiamare il <xref:System.Data.DataSet.GetChanges%2A> metodo se è necessario controllare la sequenza di tipi di istruzione (ad esempio, gli inserimenti prima degli aggiornamenti). Per altre informazioni, vedere [l'aggiornamento di origini dati con DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Se le istruzioni INSERT, UPDATE o DELETE non sono state specificate, il <xref:System.Data.Common.DataAdapter.Update%2A> metodo genera un'eccezione. Tuttavia, è possibile creare una <xref:System.Data.SqlClient.SqlCommandBuilder> oppure <xref:System.Data.OleDb.OleDbCommandBuilder> oggetto per generare automaticamente le istruzioni SQL per tabella singola aggiornamenti se si imposta la `SelectCommand` proprietà di un provider di dati .NET Framework. Quindi, le istruzioni SQL aggiuntive che non si imposta vengono generate da CommandBuilder. Questa logica per la generazione richiede informazioni della colonna chiave è presente nel <xref:System.Data.DataSet>. Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 Il <xref:System.Data.Common.DataAdapter.Update%2A> che consente di recuperare le righe dalla tabella elencata nel primo mapping prima di eseguire un aggiornamento. Il <xref:System.Data.Common.DataAdapter.Update%2A> quindi aggiorna la riga utilizzando il valore della <xref:System.Data.IDbCommand.UpdatedRowSource%2A> proprietà. Tutte le eventuali righe restituite vengono ignorate.  
  
 Dopo che tutti i dati viene caricati nuovamente il <xref:System.Data.DataSet>, il <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> evento viene generato, consentendo all'utente di controllare il riconciliato <xref:System.Data.DataSet> riga e le eventuali parametri di output restituiti dal comando. Dopo una riga viene aggiornata correttamente, vengono accettate le modifiche di tale riga.  
  
 Quando si utilizza <xref:System.Data.IDataAdapter.Update%2A>, l'ordine di esecuzione è il seguente:  
  
1.  I valori di <xref:System.Data.DataRow> vengono spostati i valori dei parametri.  
  
2.  Viene generato l'evento <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>.  
  
3.  Viene eseguito il comando.  
  
4.  Se il comando è impostato su `FirstReturnedRecord`, quindi il primo risultato restituito verrà inserito <xref:System.Data.DataRow>.  
  
5.  Se sono presenti parametri di output, e vengono inseriti nel <xref:System.Data.DataRow>.  
  
6.  Viene generato l'evento <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>.  
  
7.  Chiamata del metodo <xref:System.Data.DataRow.AcceptChanges%2A>.  
  
 Ogni comando associato il <xref:System.Data.IDataAdapter> ha in genere una raccolta di parametri associata. I parametri sono mappati alla riga corrente tramite il `SourceColumn` e `SourceVersion` proprietà di un provider di dati .NET Framework `Parameter` classe. `SourceColumn` fa riferimento a un <xref:System.Data.DataTable> colonna che il <xref:System.Data.IDataAdapter> riferimenti per ottenere i valori dei parametri della riga corrente.  
  
 `SourceColumn` si riferisce al nome della colonna non mappata prima i mapping delle tabelle sono stati applicati. Se `SourceColumn` fa riferimento a una colonna inesistente, l'azione eseguita dipende da uno dei seguenti <xref:System.Data.MissingMappingAction> valori.  
  
|Valore di enumerazione|Azione eseguita|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Utilizzare i nomi delle colonne di origine e nomi di tabella il <xref:System.Data.DataSet> se è presente alcun mapping.|  
|`MissingMappingAction.Ignore`|Oggetto <xref:System.SystemException> viene generato. Quando i mapping sono impostati in modo esplicito, la mancanza di mapping per un parametro di input è in genere dovuto a un errore.|  
|`MissingMappingAction.Error`|Oggetto <xref:System.SystemException> viene generato.|  
  
 Il `SourceColumn` proprietà viene utilizzata anche per il mapping del valore per l'output o i parametri di input/output del `DataSet`. Se fa riferimento a una colonna inesistente, viene generata un'eccezione.  
  
 Il `SourceVersion` proprietà di un provider di dati .NET Framework `Parameter` classe determina se utilizzare il `Original`, `Current`, o `Proposed` versione del valore della colonna. Questa funzionalità viene spesso utilizzata per includere i valori originali nella clausola WHERE di un'istruzione UPDATE per verificare la presenza di eventuali violazioni alla concorrenza ottimistica.  
  
> [!NOTE]
>  Se si verifica un errore durante l'aggiornamento di una riga, viene generata un'eccezione e l'esecuzione dell'aggiornamento non è più disponibile. Per continuare l'operazione di aggiornamento senza generare eccezioni quando viene rilevato un errore, impostare il <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> proprietà da `true` prima di chiamare <xref:System.Data.Common.DbDataAdapter.Update%2A>. È anche possibile rispondere agli errori in base per ogni riga all'interno di `RowUpdated` dell'evento di un oggetto DataAdapter. Per continuare l'operazione di aggiornamento senza generare un'eccezione all'interno di `RowUpdated` set di eventi, il <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> proprietà del <xref:System.Data.Common.RowUpdatedEventArgs> a <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 L'esempio seguente usa la classe derivata <xref:System.Data.OleDb.OleDbDataAdapter>, a <xref:System.Data.Common.DataAdapter.Update%2A> l'origine dati. Questo esempio si presuppone che sia stato creato un <xref:System.Data.OleDb.OleDbDataAdapter> e un <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DBConcurrencyException">Un tentativo di esecuzione di un'istruzione INSERT, UPDATE o DELETE non ha avuto effetto su alcun record.</exception>
      </Docs>
    </Member>
  </Members>
</Type>