<Type Name="IDataAdapter" FullName="System.Data.IDataAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4877f267408f77d2e2104534ad5ebe7e397b5b13" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30399385" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDataAdapter" />
  <TypeSignature Language="DocId" Value="T:System.Data.IDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDataAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Consente a un oggetto di implementare un oggetto DataAdapter e rappresenta un insieme di metodi e proprietà correlate ad azioni di mapping utilizzate per riempire e aggiornare <see cref="T:System.Data.DataSet" /> e aggiornare un'origine dati.  
  
 Le istanze di <see cref="T:System.Data.IDbDataAdapter" /> sono per le origini dati che sono o sembrano database relazionali con comandi testuali (come Transact-SQL), mentre le istanze di <see cref="T:System.Data.IDataAdapter" /> possono usare qualsiasi tipo di origine dati.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.IDataAdapter> interfaccia consente a una classe che eredita di implementare una classe di DataAdapter, che rappresenta il ponte tra un'origine dati e un <xref:System.Data.DataSet>. Per ulteriori informazioni sulle classi DataAdapter, vedere [popolamento di un set di dati da un oggetto DataAdapter](~/docs/framework/data/adonet/populating-a-dataset-from-a-dataadapter.md).  
  
 Un'applicazione crea un'istanza di <xref:System.Data.IDataAdapter> interfaccia direttamente, ma implementa un'istanza di una classe che eredita <xref:System.Data.IDataAdapter>.  
  
 Le classi che ereditano <xref:System.Data.IDataAdapter> deve implementare i membri ereditati e in genere definiscono ulteriori membri per l'aggiunta di funzionalità specifiche del provider. Ad esempio, il <xref:System.Data.IDataAdapter> interfaccia definisce un <xref:System.Data.IDataAdapter.Fill%2A> metodo che accetta un <xref:System.Data.DataSet> come parametro. A sua volta, il <xref:System.Data.OleDb.OleDbDataAdapter> classe eredita il <xref:System.Data.Common.DbDataAdapter.Fill%2A> (metodo) e definisce anche altri due overload di <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> metodo che accetta un oggetto Recordset ADO come parametro.  
  
   
  
## Examples  
 L'esempio seguente usa le classi derivate, <xref:System.Data.SqlClient.SqlCommand>, <xref:System.Data.SqlClient.SqlDataAdapter>, e <xref:System.Data.SqlClient.SqlConnection>, per selezionare i record da un database. Il riempimento <xref:System.Data.DataSet> viene quindi restituito. A tale scopo, viene passato un oggetto inizializzato <xref:System.Data.DataSet>, una stringa di connessione e una stringa di query che rappresenta un'istruzione Transact-SQL SELECT.  
  
 [!code-csharp[Classic WebData SqlDataAdapter Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlDataAdapter Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlDataAdapter Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlDataAdapter Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Per promuovere la coerenza fra i provider di dati .NET Framework, assegnare un nome alla classe che eredita il form <paramref name="Prv" /> DataAdapter dove <paramref name="Prv" /> è il prefisso uniforme assegnato a tutte le classi in uno specifico spazio dei nomi provider di dati .NET Framework. Ad esempio, <paramref name="Sql" /> è il prefisso del <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> classe il <see langword="System.Data.SqlClient" /> dello spazio dei nomi.  
  
 Quando si eredita dal <see cref="T:System.Data.IDataAdapter" /> interfaccia, è necessario implementare i seguenti costruttori:  
  
 <list type="table"><listheader><term> Elemento  
  
 </term><description> Descrizione  
  
 </description></listheader><item><term> PrvDataAdapter()  
  
 </term><description> Inizializza una nuova istanza della classe PrvDataAdapter.  
  
 </description></item><item><term> PrvDataAdapter (PrvCommand selectCommand)  
  
 </term><description> Inizializza una nuova istanza della classe PrvDataAdapter utilizzando l'istruzione SQL SELECT specificata.  
  
 </description></item><item><term> PrvDataAdapter (selectCommandText stringa, stringa selectConnectionString)  
  
 </term><description> Inizializza una nuova istanza della classe PrvDataAdapter utilizzando un'istruzione SQL SELECT e una stringa di connessione.  
  
 </description></item><item><term> PrvDataAdapter (stringa selectCommandText, PrvConnection selectConnection)  
  
 </term><description> Inizializza una nuova istanza della classe PrvDataAdapter utilizzando un'istruzione SQL SELECT e un oggetto PrvConnection.  
  
 </description></item></list></para>
    </block>
  </Docs>
  <Members>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">Oggetto <see cref="T:System.Data.DataSet" /> in cui inserire i record e, se necessario, lo schema.</param>
        <summary>Aggiunge o aggiorna righe nell'oggetto <see cref="T:System.Data.DataSet" /> affinché corrispondano a quelle presenti nell'origine dati utilizzando il nome dell'oggetto <see cref="T:System.Data.DataSet" /> e crea un oggetto <see cref="T:System.Data.DataTable" /> denominato "Table".</summary>
        <returns>Numero di righe aggiunte o aggiornate correttamente nell'oggetto <see cref="T:System.Data.DataSet" />. Non sono incluse righe modificate da istruzioni che non restituiscono righe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataAdapter.Fill%2A> Recupera le righe dall'origine dati utilizzando l'istruzione SELECT specificata da un oggetto associato <xref:System.Data.IDbDataAdapter.SelectCommand%2A> proprietà. L'oggetto connessione associato con l'istruzione SELECT deve essere valido, ma non devono essere aperte. Se la connessione viene chiusa prima <xref:System.Data.IDataAdapter.Fill%2A> viene chiamato, verrà aperta per recuperare i dati, quindi chiusa. Se la connessione è aperta prima <xref:System.Data.IDataAdapter.Fill%2A> viene chiamato, rimane aperto.  
  
 Il <xref:System.Data.IDataAdapter.Fill%2A> aggiunge quindi le righe di destinazione <xref:System.Data.DataTable> gli oggetti di <xref:System.Data.DataSet>, creando il <xref:System.Data.DataTable> oggetti se non sono già presenti. Quando si creano <xref:System.Data.DataTable> oggetti, il <xref:System.Data.IDataAdapter.Fill%2A> vengono in genere creati solo i metadati dei nomi di colonna. Tuttavia, se il <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> è impostata su `AddWithKey`, chiavi primarie appropriate e i vincoli vengono creati.  
  
 Se `SelectCommand` restituisce i risultati di un OUTER JOIN, mediante `DataAdapter` non viene impostato un valore di <xref:System.Data.DataTable.PrimaryKey%2A> per l'oggetto <xref:System.Data.DataTable> risultante. È necessario definire in modo esplicito la chiave primaria per garantire che le righe duplicate vengano risolte correttamente. Per ulteriori informazioni, vedere [la definizione di chiavi primarie](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
 Se il <xref:System.Data.IDataAdapter> rileva colonne duplicate durante la compilazione di un <xref:System.Data.DataTable>, genera nomi per le colonne successive, tramite il criterio "columnname1", "columnname2", "columnname3" e così via. Se i dati in ingresso contengano colonne senza nome, e vengono inseriti nel <xref:System.Data.DataSet> secondo il criterio "Column1", "Column2" e così via. Quando più set di risultati vengono aggiunti per il <xref:System.Data.DataSet>, ogni set di risultati viene inserito in una tabella separata. Set di risultati aggiuntivi sono denominati aggiungendo i valori integrali per il nome della tabella specificato (ad esempio, "Table", "Table1", "Table2" e così via). Le applicazioni devono prestare attenzione quando si utilizzano nomi di colonna e di tabella per assicurarsi che non si verifichino conflitti con questi modelli di denominazione.  
  
 Quando l'istruzione SELECT che viene utilizzato per popolare il <xref:System.Data.DataSet> restituisce più risultati, ad esempio un'istruzione SQL batch, se uno dei risultati contiene un errore, tutti i risultati successivi vengono ignorati e non aggiunti al <xref:System.Data.DataSet>.  
  
 È possibile utilizzare il <xref:System.Data.IDataAdapter.Fill%2A> metodo più volte sullo stesso <xref:System.Data.DataTable>. Se esiste una chiave primaria, le righe in ingresso vengono unite con le righe corrispondenti che esistono già. Se è presente alcuna chiave primaria, le righe in ingresso vengono aggiunti per il <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Quando si gestiscono istruzioni SQL batch che restituiscono più risultati, l'implementazione di <xref:System.Data.IDataAdapter.Fill%2A> e <xref:System.Data.IDataAdapter.FillSchema%2A> per i dati di .NET Framework provider recupera le informazioni sullo schema solo per il primo risultato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet">Oggetto <see cref="T:System.Data.DataSet" /> in cui inserire lo schema dall'origine dati.</param>
        <param name="schemaType">Uno dei valori di <see cref="T:System.Data.SchemaType" />.</param>
        <summary>Aggiunge un oggetto <see cref="T:System.Data.DataTable" /> denominato "Table" all'oggetto <see cref="T:System.Data.DataSet" /> specificato e configura lo schema perché corrisponda a quello presente nell'origine dati basato sull'oggetto <see cref="T:System.Data.SchemaType" /> specificato.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Data.DataTable" /> che contiene informazioni di schema restituite dall'origine dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.IDataAdapter.FillSchema%2A> che consente di recuperare lo schema dell'origine dati utilizzando il <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. L'oggetto connessione associato il <xref:System.Data.IDbDataAdapter.SelectCommand%2A> deve essere valido, ma non deve essere aperto. Se la connessione viene chiusa prima <xref:System.Data.IDataAdapter.FillSchema%2A> viene chiamato, verrà aperta per recuperare i dati, quindi chiusa. Se la connessione è aperta prima <xref:System.Data.IDataAdapter.FillSchema%2A> viene chiamato, rimane aperto.  
  
 Oggetto <xref:System.Data.IDataAdapter.FillSchema%2A> consente di aggiungere un <xref:System.Data.DataTable> alla destinazione <xref:System.Data.DataSet>. Aggiunge quindi le colonne per la <xref:System.Data.DataColumnCollection> del <xref:System.Data.DataTable> e configura gli elementi seguenti <xref:System.Data.DataColumn> proprietà, se sono presenti nell'origine dati:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. È necessario impostare <xref:System.Data.DataColumn.AutoIncrementStep%2A> e <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separatamente.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.IDataAdapter.FillSchema%2A> Configura inoltre la <xref:System.Data.DataTable.PrimaryKey%2A> e <xref:System.Data.DataTable.Constraints%2A> proprietà secondo le regole seguenti:  
  
-   Se vengono restituite uno o più colonne chiave primaria per la <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, verranno utilizzate come colonne chiave primaria per la <xref:System.Data.DataTable>.  
  
-   Se viene restituita alcuna colonna di chiave primaria, ma sono colonne univoche, le colonne univoche vengono utilizzate come chiave primaria se tutte le colonne univoche sono non nullable. Se una o più colonne ammettono valori null, un <xref:System.Data.UniqueConstraint> viene aggiunto per il <xref:System.Data.ConstraintCollection>, ma la <xref:System.Data.DataTable.PrimaryKey%2A> non è impostata.  
  
-   Se vengono restituite sia colonne chiave primaria che colonne univoche, le colonne chiave primaria vengono utilizzate come colonne chiave primaria per la <xref:System.Data.DataTable>.  
  
 Si noti che le chiavi primarie e i vincoli unique vengono aggiunti il <xref:System.Data.ConstraintCollection> in base alle regole precedenti, ma altri vincoli non vengono aggiunti i tipi.  
  
 Se il cluster univoco viene definito l'indice in una colonna o colonne in una tabella di SQL Server e il vincolo di chiave primaria è definito in un set diverso di colonne, quindi verranno restituiti i nomi delle colonne nell'indice cluster. Per restituire il nome o i nomi delle colonne chiave primaria, utilizzare un hint per la query con l'istruzione SELECT che specifica il nome dell'indice di chiave primaria. Per ulteriori informazioni su come specificare hint per la query, vedere [Hint per la Query (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Se il <xref:System.Data.IDataAdapter> rileva colonne duplicate durante la compilazione di un <xref:System.Data.DataTable>, genera nomi per le colonne successive, tramite il criterio "columnname1", "columnname2", "columnname3" e così via. Se i dati in ingresso contengano colonne senza nome, e vengono inseriti nel <xref:System.Data.DataSet> secondo il criterio "Column1", "Column2" e così via. Quando più set di risultati vengono aggiunti per il <xref:System.Data.DataSet>, ogni set di risultati viene inserito in una tabella separata. Set di risultati aggiuntivi sono denominati aggiungendo i valori integrali per il nome della tabella specificato (ad esempio, "Table", "Table1", "Table2" e così via). Le applicazioni devono prestare attenzione quando si utilizzano nomi di colonna e di tabella per assicurarsi che non si verifichino conflitti con questi modelli di denominazione.  
  
 <xref:System.Data.IDataAdapter.FillSchema%2A> non restituisce alcuna riga. Utilizzare il <xref:System.Data.IDataAdapter.Fill%2A> metodo per aggiungere righe a un <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene i parametri impostati dall'utente durante l'esecuzione di un'istruzione SQL SELECT.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Data.IDataParameter" /> che contiene i parametri impostati dall'utente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
```  
private static void GetParameters(String connectiongString) {  
           using (SqlConnection conn = new SqlConnection(connectiongString)) {  
              String queryString = "Select [CourseID],[Title],[Credits] from [MySchool].[dbo].[Course] where [Year]=@Year and [Credits]>=@Credits";   
              SqlParameter year = new SqlParameter("@Year", 2012);   
              SqlParameter credits = new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits");   
              credits.Value = 4; SqlCommand command = new SqlCommand(queryString, conn);   
              command.Parameters.Add(year);   
              command.Parameters.Add(credits);   
              IDbDataAdapter mySchool = new SqlDataAdapter(command);   
              IDataParameter[] parameters = mySchool.GetFillParameters();  
              Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", "ParameterName", "SourceColumn", "Direction", "DbType", "Value");   
              foreach (IDataParameter parameter in parameters) {   
                 Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", parameter.ParameterName, parameter.SourceColumn, parameter.Direction, parameter.DbType, parameter.Value);   
              }  
           }  
        }  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MissingMappingAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingMappingAction MissingMappingAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingMappingAction MissingMappingAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.MissingMappingAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingMappingAction As MissingMappingAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingMappingAction MissingMappingAction { System::Data::MissingMappingAction get(); void set(System::Data::MissingMappingAction value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MissingMappingAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica o specifica se colonne o tabelle di origine non mappate vengono passate con i rispettivi nomi di origine per l'applicazione di filtri o per la generazione di un errore.</summary>
        <value>Uno dei valori di <see cref="T:System.Data.MissingMappingAction" />. Il valore predefinito è <see langword="Passthrough" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.IDataAdapter.TableMappings%2A> proprietà fornisce il mapping master tra i record restituiti e <xref:System.Data.DataSet>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore impostato non è uno dei valori di <see cref="T:System.Data.MissingMappingAction" />.</exception>
        <altmember cref="P:System.Data.IDataAdapter.MissingSchemaAction" />
      </Docs>
    </Member>
    <Member MemberName="MissingSchemaAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingSchemaAction MissingSchemaAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingSchemaAction MissingSchemaAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.MissingSchemaAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingSchemaAction As MissingSchemaAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingSchemaAction MissingSchemaAction { System::Data::MissingSchemaAction get(); void set(System::Data::MissingSchemaAction value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MissingSchemaAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica o specifica se le tabelle, le colonne e le rispettive relazioni di origine mancanti verranno aggiunte allo schema dataset, verranno ignorate o causeranno la generazione di un errore.</summary>
        <value>Uno dei valori di <see cref="T:System.Data.MissingSchemaAction" />. Il valore predefinito è <see langword="Add" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Il valore impostato non è uno dei valori di <see cref="T:System.Data.MissingSchemaAction" />.</exception>
        <altmember cref="P:System.Data.Common.DataAdapter.MissingMappingAction" />
      </Docs>
    </Member>
    <Member MemberName="TableMappings">
      <MemberSignature Language="C#" Value="public System.Data.ITableMappingCollection TableMappings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ITableMappingCollection TableMappings" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.TableMappings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TableMappings As ITableMappingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ITableMappingCollection ^ TableMappings { System::Data::ITableMappingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.ITableMappingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica come viene eseguito il mapping tra una tabella di origine e una tabella dataset.</summary>
        <value>Insieme che fornisce il mapping principale tra i record restituiti e l'oggetto <see cref="T:System.Data.DataSet" />. Il valore predefinito è una raccolta vuota.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.IDataAdapter> utilizza solo i mapping per la tabella di origine denominata "Table". Selezionare tutti, istruzioni INSERT, DELETE e UPDATE restituzione di dati devono eseguire l'operazione usando denominazione delle colonne uniforme. I nomi di colonna restituiti nei record devono essere univoci, in caso contrario le colonne con nomi duplicati sovrascrivere i dati precedenti. In <xref:System.Data.IDataAdapter.Update%2A>, solo la tabella mappata alla tabella di origine denominata "Table" avrà le relative modifiche risolte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">L'oggetto <see cref="T:System.Data.DataSet" /> utilizzato per aggiornare l'origine dati.</param>
        <summary>Chiama le corrispondenti istruzioni INSERT, UPDATE o DELETE per ciascuna riga inserita, aggiornata o eliminata nell'oggetto <see cref="T:System.Data.DataSet" /> specificato da un oggetto <see cref="T:System.Data.DataTable" /> denominato "Table".</summary>
        <returns>Numero di righe aggiornate correttamente dall'oggetto <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un'applicazione chiama il <xref:System.Data.IDataAdapter.Update%2A> (metodo), il <xref:System.Data.IDataAdapter> esamina il <xref:System.Data.DataRow.RowState%2A> , proprietà ed esegue le istruzioni INSERT, UPDATE o DELETE necessarie in modo iterativo per ogni riga, in base all'ordine degli indici configurati nel <xref:System.Data.DataSet>. Ad esempio, <xref:System.Data.IDataAdapter.Update%2A> potrebbe eseguire un'istruzione DELETE, seguita da un'istruzione INSERT e quindi un'altra istruzione DELETE, a causa di ordinamento delle righe di <xref:System.Data.DataTable>.  
  
 Tenere presente che queste istruzioni non vengono eseguite come un processo batch. ogni riga viene aggiornata singolarmente. Un'applicazione può chiamare il <xref:System.Data.DataSet.GetChanges%2A> (metodo), è necessario controllare la sequenza di tipi di istruzione (ad esempio, gli inserimenti prima degli aggiornamenti). Per ulteriori informazioni, vedere [l'aggiornamento di origini dati con DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Se le istruzioni INSERT, UPDATE o DELETE non sono state specificate, il <xref:System.Data.Common.DataAdapter.Update%2A> metodo genera un'eccezione. Tuttavia, è possibile creare un <xref:System.Data.SqlClient.SqlCommandBuilder> o <xref:System.Data.OleDb.OleDbCommandBuilder> oggetto per generare automaticamente le istruzioni SQL per gli aggiornamenti a tabella singola, se si imposta la `SelectCommand` proprietà di un provider di dati .NET Framework. Le istruzioni SQL aggiuntive che non si imposta, quindi vengono generate da CommandBuilder. Questa logica di generazione richiede informazioni della colonna chiave deve essere presente nel <xref:System.Data.DataSet>. Per ulteriori informazioni vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 Il <xref:System.Data.Common.DataAdapter.Update%2A> che consente di recuperare le righe dalla tabella elencata nel primo mapping prima di eseguire un aggiornamento. Il <xref:System.Data.Common.DataAdapter.Update%2A> quindi aggiorna la riga utilizzando il valore della <xref:System.Data.IDbCommand.UpdatedRowSource%2A> proprietà. Tutte le eventuali righe restituite vengono ignorate.  
  
 Dopo che tutti i dati vengono caricati nuovamente il <xref:System.Data.DataSet>, il <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> evento viene generato, consentendo all'utente di controllare il riconciliato <xref:System.Data.DataSet> riga e le eventuali parametri di output restituiti dal comando. Dopo una riga viene aggiornata correttamente, vengono accettate le modifiche di tale riga.  
  
 Quando si utilizza <xref:System.Data.IDataAdapter.Update%2A>, l'ordine di esecuzione è il seguente:  
  
1.  I valori di <xref:System.Data.DataRow> vengono spostati i valori dei parametri.  
  
2.  Viene generato l'evento <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>.  
  
3.  Esegue il comando.  
  
4.  Se il comando è impostato su `FirstReturnedRecord`, quindi il primo risultato restituito verrà inserito <xref:System.Data.DataRow>.  
  
5.  Se sono presenti parametri di output, e vengono inseriti nel <xref:System.Data.DataRow>.  
  
6.  Viene generato l'evento <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>.  
  
7.  Chiamata del metodo <xref:System.Data.DataRow.AcceptChanges%2A>.  
  
 Ogni comando associato il <xref:System.Data.IDataAdapter> in genere è una raccolta di parametri associata. I parametri sono mappati alla riga corrente tramite il `SourceColumn` e `SourceVersion` le proprietà di un provider di dati .NET Framework `Parameter` classe. `SourceColumn` fa riferimento a un <xref:System.Data.DataTable> colonna che il <xref:System.Data.IDataAdapter> riferimenti per ottenere i valori dei parametri per la riga corrente.  
  
 `SourceColumn` fa riferimento al nome della colonna non mappata prima i mapping delle tabelle sono stati applicati. Se `SourceColumn` fa riferimento a una colonna inesistente, l'azione eseguita dipende da uno dei seguenti <xref:System.Data.MissingMappingAction> valori.  
  
|Valore di enumerazione|Azione eseguita|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Utilizzare i nomi di tabella in e i nomi di colonna di origine di <xref:System.Data.DataSet> se è presente alcun mapping.|  
|`MissingMappingAction.Ignore`|Oggetto <xref:System.SystemException> viene generato. Quando i mapping vengono impostati in modo esplicito, la mancanza di mapping per un parametro di input è in genere causato da un errore.|  
|`MissingMappingAction.Error`|Oggetto <xref:System.SystemException> viene generato.|  
  
 Il `SourceColumn` proprietà viene utilizzata anche per il mapping del valore per l'output o i parametri di input/output del `DataSet`. Se fa riferimento a una colonna inesistente, viene generata un'eccezione.  
  
 Il `SourceVersion` proprietà di un provider di dati .NET Framework `Parameter` classe determina se utilizzare il `Original`, `Current`, o `Proposed` versione del valore della colonna. Questa funzionalità viene spesso utilizzata per includere i valori originali nella clausola WHERE di un'istruzione UPDATE per verificare la presenza di eventuali violazioni alla concorrenza ottimistica.  
  
> [!NOTE]
>  Se si verifica un errore durante l'aggiornamento di una riga, viene generata un'eccezione e l'esecuzione dell'aggiornamento non è più disponibile. Per continuare l'operazione di aggiornamento senza generare eccezioni quando viene rilevato un errore, impostare il <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> proprietà `true` prima di chiamare <xref:System.Data.Common.DbDataAdapter.Update%2A>. È anche possibile rispondere agli errori in una riga all'interno di `RowUpdated` evento di un oggetto DataAdapter. Per continuare l'operazione di aggiornamento senza generare un'eccezione all'interno di `RowUpdated` set di eventi, il <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> proprietà del <xref:System.Data.Common.RowUpdatedEventArgs> a <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la classe derivata, <xref:System.Data.OleDb.OleDbDataAdapter>a <xref:System.Data.Common.DataAdapter.Update%2A> l'origine dati. Questo esempio si presuppone che sia stato creato un <xref:System.Data.OleDb.OleDbDataAdapter> e <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DBConcurrencyException">Un tentativo di esecuzione di un'istruzione INSERT, UPDATE o DELETE non ha avuto effetto su alcun record.</exception>
      </Docs>
    </Member>
  </Members>
</Type>