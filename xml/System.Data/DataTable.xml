<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ae2d2ca49781b6fbea2101bb4f63426c09bee1b1" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33685190" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una tabella di dati in memoria.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable> è un oggetto centrale nella libreria di ADO.NET. Altri oggetti che utilizzano il <xref:System.Data.DataTable> includono il <xref:System.Data.DataSet> e <xref:System.Data.DataView>.  
  
 Quando si accede a <xref:System.Data.DataTable> oggetti, si noti che sono prevedono la distinzione tra maiuscole e minuscole in modo condizionale. Ad esempio, se un <xref:System.Data.DataTable> viene denominato "mydatatable" e un altro denominato "Mydatatable", stringa utilizzata per cercare una delle tabelle verrà applicata la distinzione tra maiuscole e minuscole. Tuttavia, se presente "mydatatable" e non "Mydatatable", la stringa di ricerca viene considerata tra maiuscole e minuscole. Oggetto <xref:System.Data.DataSet> può contenere due <xref:System.Data.DataTable> gli oggetti che hanno lo stesso <xref:System.Data.DataTable.TableName%2A> valore della proprietà ma diversi <xref:System.Data.DataTable.Namespace%2A> i valori delle proprietà. Per ulteriori informazioni sull'utilizzo di <xref:System.Data.DataTable> degli oggetti, vedere [creazione di un oggetto DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Se si sta creando un <xref:System.Data.DataTable> a livello di codice, è necessario definire lo schema aggiungendo <xref:System.Data.DataColumn> oggetti per il <xref:System.Data.DataColumnCollection> (tramite la <xref:System.Data.DataTable.Columns%2A> proprietà). Per ulteriori informazioni sull'aggiunta di <xref:System.Data.DataColumn> degli oggetti, vedere [aggiunta di colonne a un oggetto DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).  
  
 Per aggiungere righe a un <xref:System.Data.DataTable>, è necessario utilizzare innanzitutto la <xref:System.Data.DataTable.NewRow%2A> per restituire un nuovo <xref:System.Data.DataRow> oggetto. Il <xref:System.Data.DataTable.NewRow%2A> il metodo restituisce una riga con lo schema del <xref:System.Data.DataTable>, come definito nella tabella <xref:System.Data.DataColumnCollection>. Il numero massimo di righe che un <xref:System.Data.DataTable> possibile archivio è 16.777.216. Per ulteriori informazioni, vedere [aggiunta di dati a un oggetto DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).  
  
 Il <xref:System.Data.DataTable> contiene inoltre un insieme di <xref:System.Data.Constraint> gli oggetti che possono essere utilizzati per garantire l'integrità dei dati. Per ulteriori informazioni, vedere [vincoli DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
 Esistono molti <xref:System.Data.DataTable> gli eventi che possono essere usati per determinare quando vengono apportate modifiche a una tabella. Tali attributi includono <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting> e <xref:System.Data.DataTable.RowDeleted>. Per ulteriori informazioni sugli eventi che può essere utilizzato con un <xref:System.Data.DataTable>, vedere [gestione di eventi DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
 Quando un'istanza di <xref:System.Data.DataTable> viene creato, alcuni della lettura/scrittura sono impostate sui valori iniziali. Per un elenco di questi valori, vedere il <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> argomento costruttore.  
  
> [!NOTE]
>  Il <xref:System.Data.DataSet> e <xref:System.Data.DataTable> oggetti ereditano <xref:System.ComponentModel.MarshalByValueComponent>e supportano il <xref:System.Runtime.Serialization.ISerializable> interfaccia per la comunicazione remota di .NET Framework. Si tratta degli unici oggetti ADO.NET che è possibile utilizzare per la comunicazione remota di .NET Framework.  
  
   
  
## Examples  
 L'esempio seguente crea due <xref:System.Data.DataTable> oggetti e una <xref:System.Data.DataRelation> e aggiunge i nuovi oggetti per un <xref:System.Data.DataSet>. Le tabelle vengono quindi visualizzate in un <xref:System.Windows.Forms.DataGridView> controllo.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 In questo esempio viene illustrato come creare manualmente un oggetto DataTable tramite definizioni di schema specifiche:  
  
-   Creare più DataTable e definire le colonne iniziali.  
  
-   Creare i vincoli della tabella.  
  
-   Inserire i valori e visualizzare le tabelle.  
  
-   Creare colonne di espressioni e visualizzare le tabelle.  
  
 Progetti c# e Visual Basic con questo esempio di codice sono reperibile in [esempi di codice per sviluppatori](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è sicuro per le operazioni di lettura con multithreading. È necessario sincronizzare le operazioni di scrittura.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.DataTable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.DataTable" /> senza argomenti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore imposta i valori iniziali per tutte le proprietà del <xref:System.Data.DataTable> oggetto. Nella tabella seguente mostra le proprietà e valori predefiniti. Quando un'istanza di <xref:System.Data.DataTable> viene creato, le seguenti proprietà vengono impostate sui valori iniziali di lettura/scrittura.  
  
|Proprietà|Valore predefinito|  
|--------------|-------------------|  
|**CaseSensitive**|Uguale all'elemento padre <xref:System.Data.DataSet>, se appartiene a uno. In caso contrario, `false`.|  
|**DisplayExpression**|una stringa vuota ("")|  
|**Impostazioni locali**|Uguale all'elemento padre <xref:System.Data.DataSet> dell'oggetto <xref:System.Globalization.CultureInfo> (restituito dal <xref:System.Data.DataSet.Locale%2A> proprietà); se non esiste alcun padre, il valore predefinito è il sistema corrente <xref:System.Globalization.CultureInfo>.|  
|**MinimumCapacity**|50 righe.|  
  
 È possibile modificare il valore per una di queste proprietà tramite una chiamata distinta per la proprietà.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Data.DataTable> con <xref:System.Data.DataColumn> e <xref:System.Data.DataRow>e lo visualizza in un <xref:System.Windows.Forms.DataGridView> controllo.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Nome da assegnare alla tabella. Se <c>tableName</c> è impostato su <see langword="null" /> o su una stringa vuota, viene assegnato un nome predefinito nel momento in cui viene aggiunto a <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.DataTable" /> con il nome della tabella specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Data.DataTable> e lo visualizza in un <xref:System.Windows.Forms.DataGridView> controllo.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Dati necessari per serializzare o deserializzare un oggetto.</param>
        <param name="context">Origine e destinazione di un flusso serializzato specificato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.DataTable" /> con gli oggetti <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione del <xref:System.Data.DataTable> è necessario per costruttore <xref:System.Runtime.Serialization.ISerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Nome da assegnare alla tabella. Se <c>tableName</c> è impostato su <see langword="null" /> o su una stringa vuota, viene assegnato un nome predefinito nel momento in cui viene aggiunto a <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">Spazio dei nomi della rappresentazione XML dei dati memorizzati nella classe <see langword="DataTable" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.DataTable" /> con il nome della tabella e lo spazio dei nomi specificati.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convalida tutte le modifiche apportate a questa tabella sin dall'ultima chiamata al metodo <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Data.DataTable.AcceptChanges%2A> viene chiamato, ogni <xref:System.Data.DataRow> oggetto ancora in modalità di modifica termina correttamente le relative modifiche. Il <xref:System.Data.DataRowState> cambia anche: tutti `Added` e `Modified` righe diventare `Unchanged`, e `Deleted` le righe vengono rimosse.  
  
 Il <xref:System.Data.DataTable.AcceptChanges%2A> viene in genere chiamato su un <xref:System.Data.DataTable> dopo aver tentato di aggiornare il <xref:System.Data.DataSet> utilizzando il <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente ogni tabella per gli errori di test. Se è possono risolvere gli errori della tabella (passando a una funzione non definita), <xref:System.Data.DataTable.AcceptChanges%2A> chiamato; in caso contrario, <xref:System.Data.DataTable.RejectChanges%2A> viene chiamato.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia l'inizializzazione di una <see cref="T:System.Data.DataTable" /> usata su un form o da un altro componente. L'inizializzazione avviene in fase di esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ambiente di progettazione di Visual Studio .NET utilizza questo metodo per avviare l'inizializzazione di un componente utilizzato in un form o da un altro componente. Il <xref:System.Data.DataTable.EndInit%2A> metodo termina l'inizializzazione. Utilizzo di <xref:System.Data.DataTable.BeginInit%2A> e <xref:System.Data.DataTable.EndInit%2A> metodi impedisce che venga utilizzato prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disattiva le notifiche, la manutenzione degli indici e i vincoli durante il caricamento dei dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Data.DataTable.BeginLoadData%2A> in combinazione con <xref:System.Data.DataTable.LoadDataRow%2A> e <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se i confronti tra stringhe all'interno della tabella prendono in considerazione la distinzione tra maiuscole e minuscole.</summary>
        <value>
          <see langword="true" /> se per il confronto viene applicata la distinzione tra maiuscole e minuscole; in caso contrario, <see langword="false" />. Il valore predefinito viene impostato sulla proprietà <see cref="T:System.Data.DataSet" /> dell'oggetto <see cref="P:System.Data.DataSet.CaseSensitive" /> padre oppure su <see langword="false" /> se l'oggetto <see cref="T:System.Data.DataTable" /> è stato creato indipendentemente da un oggetto <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.CaseSensitive%2A> proprietà ha effetto su confronti tra stringhe nell'ordinamento, ricerca e filtro.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Data.DataTable.Select%2A> metodo due volte su un <xref:System.Data.DataTable>. La prima volta, il <xref:System.Data.DataTable.CaseSensitive%2A> è impostata su `false`, il secondo, su `true`.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di relazioni figlio per l'oggetto <see cref="T:System.Data.DataTable" />.</summary>
        <value>Una classe <see cref="T:System.Data.DataRelationCollection" /> che contiene le relazioni figlio della tabella. Se non esiste alcun oggetto <see cref="T:System.Data.DataRelation" /> viene restituito un insieme vuoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Data.DataRelation> definisce la relazione tra due tabelle. In genere, due tabelle sono collegate tramite un unico campo che contiene gli stessi dati. Ad esempio, una tabella che contiene i dati degli indirizzi potrebbe essere un singolo campo contenente i codici che rappresentano i paesi/aree geografiche. Una seconda tabella che contiene i dati di paese/area geografica avrà un unico campo che contiene il codice che identifica il paese/regione ed è il codice che viene inserito il campo corrispondente nella prima tabella. Oggetto <xref:System.Data.DataRelation>, quindi contiene almeno quattro tipi di informazioni: (1) il nome della prima tabella, (2) il nome della colonna nella prima tabella, (3) il nome della seconda tabella e (4) il nome della colonna nella seconda tabella.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataTable.ChildRelations%2A> proprietà da restituire ogni elemento figlio <xref:System.Data.DataRelation> in un <xref:System.Data.DataTable>. Ogni relazione viene quindi utilizzata come argomento in di <xref:System.Data.DataRow.GetChildRows%2A> metodo il <xref:System.Data.DataRow> per restituire una matrice di righe. Viene quindi stampato il valore di ogni colonna nella riga.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutti i dati dell'oggetto <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutte le righe in tutte le tabelle vengono rimossi. Se la tabella include le eventuali relazioni figlio che fa sì che le righe figlio di essere isolati (orfani), viene generata un'eccezione.  
  
 Se il <xref:System.Data.DataSet> è associato a un <xref:System.Xml.XmlDataDocument>, la chiamata <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> o <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> genera il <xref:System.NotSupportedException>. Per evitare questa situazione, scorrere ogni tabella rimuovendo una riga alla volta. Quando si utilizza <xref:System.Data.DataTable.NewRow%2A> per creare nuove righe, le righe devono essere elaborate prima di chiamare <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente cancella la tabella di tutti i dati.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Duplica la struttura dell'oggetto <see cref="T:System.Data.DataTable" />, tra cui tutti gli schemi e i vincoli dell'oggetto <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Data.DataTable" /> con lo stesso schema dell'oggetto <see cref="T:System.Data.DataTable" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se queste classi sono state derivate, il clone sarà inoltre delle stesse classi derivate.  
  
 Il clone crea un nuovo <xref:System.Data.DataTable> con la stessa struttura del <xref:System.Data.DataTable> originale, ma non copia alcun dato (il nuovo <xref:System.Data.DataTable> non conterrà alcun `DataRows`). Per copiare sia la struttura che i dati in un nuovo <xref:System.Data.DataTable> utilizzare <xref:System.Data.DataTable.Copy%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiornare la struttura e i vincoli della tabella di destinazione dopo avere eseguito DataTable.Clone. La classe ClonedDataTable restituirà una tabella di destinazione e include tutti gli eventi di aggiornamento. Dopo il clone, le modifiche apportate alla struttura nella tabella di origine non verranno riflesse nella tabella di destinazione. In particolare, in questo esempio vengono illustrate le seguenti operazioni:  
  
-   Aggiornare le modifiche delle colonne nella tabella di origine.  
  
-   Aggiornare le modifiche di UniqueConstraint nella tabella di origine.  
  
-   Aggiornare le modifiche di ForeignKeyConstraint nella tabella di origine.  
  
 Progetti c# e Visual Basic con questo esempio di codice sono reperibile in [esempi di codice per sviluppatori](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 In questo esempio viene illustrato come modificare i dati in un oggetto DataTable e aggiornare l'origine dati.  
  
 In primo luogo, creare un database:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 È ora possibile compilare ed eseguire l'esempio. [Come modificare dati in DataTable e aggiornamento dell'origine dati](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) con progetti di Visual Basic e c# di questo esempio.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato una volta modificato il valore per l'oggetto <see cref="T:System.Data.DataColumn" /> specificato in un oggetto <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere [gestione di eventi DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando è in corso la modifica di un valore per l'oggetto <see cref="T:System.Data.DataColumn" /> specificato in un oggetto <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere [gestione di eventi DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di colonne che appartengono a questa tabella.</summary>
        <value>Classe <see cref="T:System.Data.DataColumnCollection" /> che contiene l'insieme di oggetti <see cref="T:System.Data.DataColumn" /> per la tabella. Se non esiste alcun oggetto <see cref="T:System.Data.DataColumn" /> viene restituito un insieme vuoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataColumnCollection> determina lo schema di una tabella definendo il tipo di dati di ogni colonna.  
  
   
  
## Examples  
 Nell'esempio seguente viene stampato il valore di ogni riga in una tabella mediante la <xref:System.Data.DataTable.Columns%2A> proprietà.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Espressione da calcolare.</param>
        <param name="filter">Filtro per limitare le righe di valutazione nell'espressione.</param>
        <summary>Calcola l'espressione specificata sulle righe correnti che soddisfano i criteri di filtro.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> impostato sul risultato del calcolo. Se l'espressione restituisce Null, il valore restituito sarà <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `expression` parametro richiede una funzione di aggregazione. Ad esempio, il seguente è un'espressione di persona:  
  
 `Count(Quantity)`  
  
 Ma non è l'espressione:  
  
 `Sum (Quantity * UnitPrice)`  
  
 Se è necessario eseguire un'operazione su due o più colonne, è necessario creare un <xref:System.Data.DataColumn>, impostare il relativo <xref:System.Data.DataColumn.Expression%2A> proprietà a un'espressione appropriata e utilizzare un'espressione di aggregazione per la colonna risulta. In questo caso, dato un <xref:System.Data.DataColumn> con il nome "totale" e <xref:System.Data.DataColumn.Expression%2A> impostata a questo:  
  
 `"Quantity * UnitPrice"`  
  
 L'argomento dell'espressione per il <xref:System.Data.DataTable.Compute%2A> metodo lo sarebbe quindi:  
  
 `Sum(total)`  
  
 Il secondo parametro, `filter`, determina le righe vengono utilizzate nell'espressione. Ad esempio, se la tabella contiene una colonna Data denominata "colDate", è possibile limitare le righe con l'espressione seguente:  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 Per le regole sulla creazione di espressioni per entrambi i parametri, vedere il <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente vengono sommati i valori di una colonna denominata "Total", per il venditore il cui numero di identificazione è cinque.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di vincoli mantenuti da questa tabella.</summary>
        <value>Classe <see cref="T:System.Data.ConstraintCollection" /> che contiene l'insieme di oggetti <see cref="T:System.Data.Constraint" /> per la tabella. Se non esiste alcun oggetto <see cref="T:System.Data.Constraint" /> viene restituito un insieme vuoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Data.ForeignKeyConstraint> limita l'azione eseguita quando un valore in una colonna (o le colonne) viene eliminato o aggiornato. Tale vincolo deve essere usato con colonne chiave primaria. In una relazione padre/figlio tra due tabelle, l'eliminazione di un valore dalla tabella padre può influenzare le righe figlio in uno dei modi seguenti.  
  
-   L'elemento figlio è anche possibile di righe eliminate (un'operazione di propagazione).  
  
-   I valori della colonna figlio (o delle colonne) possono essere impostati su valori null.  
  
-   I valori predefiniti, è possono impostare i valori della colonna figlio (o delle colonne).  
  
-   Può essere generata un'eccezione.  
  
 Oggetto <xref:System.Data.UniqueConstraint> diventa attiva durante il tentativo di impostare un valore di una chiave primaria su un valore non univoco.  
  
   
  
## Examples  
 L'esempio seguente aggiunge un <xref:System.Data.ForeignKeyConstraint> per la raccolta di vincoli.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia la struttura e i dati per questa classe <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Data.DataTable" /> con la stessa struttura (schemi, relazioni e vincoli della tabella) e gli stessi dati dell'oggetto <see cref="T:System.Data.DataTable" /> corrente.  
  
 Se queste classi sono state derivate, anche la copia apparterrà alle stesse classi derivate.  
  
 <see cref="M:System.Data.DataTable.Copy" /> crea un nuovo oggetto <see cref="T:System.Data.DataTable" /> con la stessa struttura e gli stessi dati dell'oggetto <see cref="T:System.Data.DataTable" /> originale. Per copiare la struttura in un nuovo oggetto <see cref="T:System.Data.DataTable" />, ma non i dati, utilizzare il metodo <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataTable.Copy%2A> metodo per creare una copia dell'originale <xref:System.Data.DataTable>. Il nome dello spazio dei nomi non verrà conservato se viene ereditato da un padre <xref:System.Data.DataTable> o <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una classe <see cref="T:System.Data.DataTableReader" /> corrispondente ai dati all'interno di questa classe <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Classe <see cref="T:System.Data.DataTableReader" /> che contiene un gruppo di risultati, corrispondenti all'istanza <see cref="T:System.Data.DataTable" /> di origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'applicazione console seguente viene creata un'istanza di <xref:System.Data.DataTable>. Nell'esempio viene quindi passata la <xref:System.Data.DataTable> a una routine che chiama il <xref:System.Data.DataTable.CreateDataReader%2A> metodo, scorre i risultati contenuti all'interno di <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 Nell'esempio viene visualizzato il seguente output nella finestra della console:  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una nuova istanza di <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nuova espressione.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la classe <see cref="T:System.Data.DataSet" /> a cui la tabella appartiene.</summary>
        <value>Classe <see cref="T:System.Data.DataSet" /> a cui la tabella appartiene.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un controllo è associato a dati per un <xref:System.Data.DataTable>, e la tabella appartiene a un <xref:System.Data.DataSet>, è possibile ottenere il <xref:System.Data.DataSet> tramite questa proprietà.  
  
   
  
## Examples  
 L'esempio seguente restituisce l'elemento padre <xref:System.Data.DataSet> di una tabella specificata tramite la <xref:System.Data.DataTable.DataSet%2A> proprietà.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una visualizzazione personalizzata della tabella che può comprendere una visualizzazione filtrata o la posizione del cursore.</summary>
        <value>Oggetto <see cref="T:System.Data.DataView" /> associato all'oggetto <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.DefaultView%2A> proprietà restituisce un <xref:System.Data.DataView> è possibile utilizzare per l'ordinamento, filtro e ricerca un <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Nell'esempio seguente imposta una proprietà del <xref:System.Data.DataTable> dell'oggetto <xref:System.Data.DataView> tramite il <xref:System.Data.DataTable.DefaultView%2A> proprietà. Nell'esempio viene inoltre illustrata l'associazione di un <xref:System.Windows.Forms.DataGridView> il controllo a un <xref:System.Data.DataTable> denominato "Suppliers" che include una colonna denominata "CompanyName".  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'espressione che restituisce un valore utilizzato per rappresentare questa tabella nell'interfaccia utente. La proprietà <see langword="DisplayExpression" /> consente di visualizzare il nome di questa tabella in un'interfaccia utente.</summary>
        <value>Stringa di visualizzazione.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina l'inizializzazione di una classe <see cref="T:System.Data.DataTable" /> usata su un form o da un altro componente. L'inizializzazione avviene in fase di esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ambiente di progettazione di Visual Studio .NET utilizza questo metodo per terminare l'inizializzazione di un componente utilizzato in un form o da un altro componente. Il <xref:System.Data.DataTable.BeginInit%2A> metodo avvia l'inizializzazione. Utilizzo di <xref:System.Data.DataTable.BeginInit%2A> e <xref:System.Data.DataTable.EndInit%2A> metodi impedisce che venga utilizzato prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attiva le notifiche, la manutenzione degli indici e i vincoli dopo il caricamento dei dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Data.DataTable.EndLoadData%2A> in combinazione con <xref:System.Data.DataTable.LoadDataRow%2A> e <xref:System.Data.DataTable.BeginLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di informazioni utente personalizzate.</summary>
        <value>Insieme <see cref="T:System.Data.PropertyCollection" /> che contiene informazioni utente personalizzate.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.ExtendedProperties%2A> per aggiungere informazioni personalizzate a un <xref:System.Data.DataTable>. Aggiungere le informazioni con il `Add` metodo. Recuperare le informazioni con il `Item` metodo.  
  
 Proprietà estese devono essere di tipo <xref:System.String>. Le proprietà che non sono di tipo stringa non sono persistenti quando il <xref:System.Data.DataTable> è scritto in formato XML.  
  
   
  
## Examples  
 L'esempio seguente aggiunge un valore di timestamp di <xref:System.Data.DataTable> tramite il <xref:System.Data.DataTable.ExtendedProperties%2A> proprietà.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controlla se l'inizializzazione è in corso. L'inizializzazione avviene in fase di esecuzione.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene una copia dell'oggetto <see cref="T:System.Data.DataTable" /> contenente tutte le modifiche apportate sin dall'ultimo caricamento o dall'ultima chiamata a <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una copia della classe <see cref="T:System.Data.DataTable" /> contenente tutte le modifiche apportate a essa dal momento in cui è stata caricata o dall'ultima chiamata al metodo <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <returns>Copia delle modifiche di questo oggetto <see cref="T:System.Data.DataTable" /> , oppure <see langword="null" /> se non vengono rilevate modifiche.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un nuovo <xref:System.Data.DataSet> contenente una copia di tutte le righe nell'originale <xref:System.Data.DataSet> che con modifiche in sospeso. Vincoli della relazione possono comportare ulteriori righe invariate da aggiungere al nuovo <xref:System.Data.DataSet> se tali righe contengono chiavi primarie corrispondenti a chiavi esterne in righe modificate. Il metodo restituisce `null` (`Nothing` in Visual Basic) se non sono presenti righe nell'originale <xref:System.Data.DataSet> con le modifiche in sospeso.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Uno dei valori di <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Ottiene una copia della classe <see cref="T:System.Data.DataTable" /> contenente tutte le modifiche apportate a essa dal momento in cui è stata caricata o dall'ultima chiamata al metodo <see cref="M:System.Data.DataTable.AcceptChanges" />, filtrata dall'enumerazione <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Copia filtrata della classe <see cref="T:System.Data.DataTable" /> su cui è possibile eseguire azioni e che successivamente può essere unita di nuovo nella classe <see cref="T:System.Data.DataTable" /> utilizzando il metodo <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Se non viene trovata alcuna riga dell'oggetto <see cref="T:System.Data.DataRowState" /> desiderato, questo metodo restituirà <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.GetChanges%2A> metodo viene utilizzato per produrre un secondo <xref:System.Data.DataTable> oggetto che contiene solo le modifiche apportate all'originale. Utilizzare il `rowStates` argomento per specificare il tipo di modifiche deve includere il nuovo oggetto.  
  
 I vincoli di relazione possono impedire le righe padre unchanged da includere.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Istanza di <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</param>
        <summary>Questo metodo restituisce un'istanza <see cref="T:System.Xml.Schema.XmlSchemaSet" /> contenente il linguaggio WDSL (Web Services Description Language) che descrive la classe <see cref="T:System.Data.DataTable" /> per i servizi Web.</summary>
        <returns>Istanza di <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una matrice di oggetti <see cref="T:System.Data.DataRow" /> che contengono errori.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Data.DataRow" /> che contengono errori.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Restituisce l'elenco degli oggetti <xref:System.Data.DataRow> con <xref:System.Data.DataRow.RowError%2A> impostato. Ad esempio, possono verificarsi errori quando si chiama <xref:System.Data.Common.DataAdapter.Update%2A> con <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> impostato su **true**. Non richiamare <xref:System.Data.DataTable.AcceptChanges%2A> in <xref:System.Data.DataTable> fino a quando non vengono risolti tutti gli errori e viene nuovamente inviato <xref:System.Data.DataSet> per l'aggiornamento.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataTable.GetErrors%2A> per restituire una matrice di <xref:System.Data.DataRow> gli oggetti che contengono errori.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente i dati serializzati associati alla classe <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> che contiene l'origine e la destinazione del flusso serializzato associato all'istanza della classe <see cref="T:System.Data.DataTable" />.</param>
        <summary>Popola un oggetto di informazioni di serializzazione con i dati necessari per serializzare l'istanza di <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> è un riferimento null (in Visual Basic <see langword="Nothing" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il tipo della riga.</summary>
        <returns>Restituisce il tipo di <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Oggetto <see cref="T:System.Xml.Schema.XmlSchema" /> che descrive la rappresentazione XML dell'oggetto prodotto dal metodo <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> e usato dal metodo <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se sono presenti errori nelle righe delle tabelle dell'oggetto <see cref="T:System.Data.DataSet" /> al quale la tabella appartiene.</summary>
        <value>
          <see langword="true" /> se sono presenti errori; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mentre si utilizza un set di dati contenuti in un <xref:System.Data.DataTable>, è possibile contrassegnare ogni modifica di un errore se la modifica provochi errori di convalida. È possibile contrassegnare un'intera <xref:System.Data.DataRow> con un messaggio di errore mediante il <xref:System.Data.DataRow.RowError%2A> proprietà. È inoltre possibile impostare gli errori in ogni colonna della riga con il <xref:System.Data.DataRow.SetColumnError%2A> metodo.  
  
 Prima di aggiornare un'origine dati con un <xref:System.Data.DataSet>, è consigliabile richiamare il <xref:System.Data.DataSet.GetChanges%2A> metodo sull'oggetto destinazione <xref:System.Data.DataSet>. Il metodo genera un <xref:System.Data.DataSet> che contiene solo le modifiche apportate all'oggetto originale. Prima di inviare il <xref:System.Data.DataSet> all'origine dati per l'aggiornamento, controllare il <xref:System.Data.DataTable.HasErrors%2A> della proprietà di ogni tabella per vedere se sono stati associati errori alle righe o colonne delle righe.  
  
 Dopo la riconciliazione ogni errore, cancellare gli errori con il <xref:System.Data.DataRow.ClearErrors%2A> metodo il `DataRow`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataTable.HasErrors%2A> proprietà per controllare se una tabella contiene errori.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">Oggetto <see cref="T:System.Data.DataRow" /> da importare.</param>
        <summary>Copia un oggetto <see cref="T:System.Data.DataRow" /> in un oggetto <see cref="T:System.Data.DataTable" />, conservando sia le impostazioni delle proprietà sia i valori originali e correnti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata <xref:System.Data.DataTable.NewRow%2A> aggiunge una riga alla tabella utilizzando lo schema della tabella esistente, ma con i valori predefiniti per la riga e imposta il <xref:System.Data.DataRowState> a `Detached`. La chiamata <xref:System.Data.DataTable.ImportRow%2A> mantiene esistente <xref:System.Data.DataRowState> con altri valori nella riga. Se il `DataRow` che viene passato come parametro è in uno stato scollegato, viene ignorata e viene generata alcuna eccezione.  
  
 La nuova riga verrà aggiunta alla fine della tabella di dati.  
  
 Se la nuova riga viola un vincolo non verranno aggiunti alla tabella di dati.  
  
 È possibile ottenere l'indice della nuova riga con DataTable.Rows.Find e DataTable.Rows.IndexOf. Per altre informazioni, vedere <xref:System.Data.DataRowCollection> e <xref:System.Data.DataTable.Rows%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica dopo l'inizializzazione dell'oggetto <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.Data.DataTable.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la classe <see cref="T:System.Data.DataTable" /> è inizializzata.</summary>
        <value>
          <see langword="true" /> per indicare che il componente ha completato l'inizializzazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Restituisce lo stato di <xref:System.Data.DataTable> mentre viene costruita, ad esempio da Visual Studio. Il <xref:System.Data.DataTable.BeginInit%2A> metodo lo imposta su `false` e <xref:System.Data.DataTable.EndInit%2A> metodo lo imposta su `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riempie una classe <see cref="T:System.Data.DataTable" /> con valori di un'origine dati utilizzando l'interfaccia <see cref="T:System.Data.IDataReader" /> fornita. Se <see langword="DataTable" /> contiene già righe, i dati in arrivo dall'origine dati vengono uniti alle righe esistenti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Load` metodo può essere utilizzato in diversi scenari comuni, tutti incentrati sull'ottenimento di dati da un'origine dati specificata e aggiungendolo al contenitore di dati corrente (in questo caso, un `DataTable`). Gli scenari seguenti indicano l'utilizzo standard per un `DataTable`, che descrive l'aggiornamento e comportamento di tipo merge.  
  
 Oggetto `DataTable` Sincronizza o aggiorna con un'origine dati primaria. Il `DataTable` tiene traccia delle modifiche, consentendo la sincronizzazione con l'origine dati primaria. Inoltre, un `DataTable` può accettare dati incrementali da una o più origini di dati secondari. Il `DataTable` non è responsabile del rilevamento delle modifiche per consentire la sincronizzazione con l'origine dati secondaria.  
  
 Dato queste due origini dati ipotetiche, un utente è probabilmente, deve essere uno dei comportamenti seguenti:  
  
-   Inizializzare `DataTable` da un'origine dati primaria. In questo scenario, l'utente desidera inizializzare un oggetto vuoto `DataTable` con i valori dell'origine dati primaria. In un secondo momento si intende propagare le modifiche all'origine dati primaria.  
  
-   Mantenere le modifiche e sincronizzare nuovamente dall'origine dati primaria. In questo scenario, l'utente desidera eseguire il `DataTable` riempita nello scenario precedente ed eseguire una sincronizzazione incrementale con l'origine dati primaria, mantenendo le modifiche apportate il `DataTable`.  
  
-   Feed di dati incrementali da origini di dati secondari. In questo scenario, l'utente desidera unire le modifiche da una o più origini di dati secondari e propagare le modifiche all'origine dati primaria.  
  
 Il `Load` metodo rende possibili tutti questi scenari. Tutti tranne uno degli overload di questo metodo consente di specificare un parametro di opzione di caricamento, che indica come le righe già in un <xref:System.Data.DataTable> combinare con le righe in fase di caricamento. (L'overload che non consente di specificare il comportamento Usa l'opzione di caricamento predefinito). Nella tabella seguente vengono descritte le tre opzioni di caricamento fornite dal <xref:System.Data.LoadOption> enumerazione. In ogni caso, la descrizione indica il comportamento quando la chiave primaria di una riga nei dati in ingresso corrisponde alla chiave primaria di una riga esistente.  
  
|Opzione di caricamento|Descrizione|  
|-----------------|-----------------|  
|`PreserveChanges` (impostazione predefinita)|Aggiorna la versione originale della riga con il valore della riga in arrivo.|  
|`OverwriteChanges`|Aggiorna le versioni correnti e originali della riga con il valore della riga in arrivo.|  
|`Upsert`|Aggiorna la versione corrente della riga con il valore della riga in arrivo.|  
  
 In generale, il `PreserveChanges` e `OverwriteChanges` opzioni sono indicate per scenari in cui l'utente deve sincronizzare il `DataSet` e le relative modifiche con l'origine dati primaria. Il `Upsert` opzione semplifica le modifiche di aggregazione da una o più origini di dati secondari.  
  
   
  
## Examples  
 L'esempio seguente illustra alcuni dei problemi correlati alla chiamata di <xref:System.Data.DataTable.Load%2A> metodo. Innanzitutto, nell'esempio si concentra problemi relativi allo schema, tra cui deduzione di uno schema dall'interfaccia caricata <xref:System.Data.IDataReader>, quindi la gestione di schemi incompatibili e gli schemi con colonne mancanti o aggiuntive. L'esempio quindi illustra problemi di dati, inclusa la gestione delle diverse opzioni di caricamento.  
  
> [!NOTE]
>  In questo esempio viene illustrato come utilizzare una delle versioni di overload di `Load`. Per altri esempi che potrebbero essere disponibili, vedere gli argomenti di overload singoli.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Interfaccia <see cref="T:System.Data.IDataReader" /> che fornisce un gruppo di risultati.</param>
        <summary>Riempie una classe <see cref="T:System.Data.DataTable" /> con valori di un'origine dati utilizzando l'interfaccia <see cref="T:System.Data.IDataReader" /> fornita. Se <see cref="T:System.Data.DataTable" /> contiene già righe, i dati in arrivo dall'origine dati vengono uniti alle righe esistenti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.Load%2A> metodo utilizza il primo set di risultati da caricato <xref:System.Data.IDataReader>e dopo il completamento, imposta la posizione del lettore al set di risultati successivo, se presente. Quando la conversione dei dati, il `Load` metodo utilizza le stesse regole di conversione di <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> metodo.  
  
 Il <xref:System.Data.DataTable.Load%2A> metodo necessario prendere in considerazione tre problemi specifici durante il caricamento dei dati da un <xref:System.Data.IDataReader> istanza: operazioni di eventi, dati e schema. Quando si lavora con lo schema, il <xref:System.Data.DataTable.Load%2A> metodo potrebbe incontrare condizioni, come descritto nella tabella seguente. Le operazioni di schema si verificano per tutti i set di risultati importati, anche quelli che non contengono dati.  
  
|Condizione|Comportamento|  
|---------------|--------------|  
|Il <xref:System.Data.DataTable> dispone di alcuno schema.|Il <xref:System.Data.DataTable.Load%2A> metodo deduce lo schema basato su set di risultati dal importato <xref:System.Data.IDataReader>.|  
|Il <xref:System.Data.DataTable> ha uno schema, ma non è compatibile con lo schema caricato.|Il <xref:System.Data.DataTable.Load%2A> metodo genera un'eccezione corrispondente all'errore specifico che si verifica quando si tenta di caricare i dati nello schema non compatibile.|  
|Gli schemi sono compatibili, ma lo schema di set di risultati caricato contiene colonne che non esistono nel <xref:System.Data.DataTable>.|Il <xref:System.Data.DataTable.Load%2A> metodo aggiunge le colonne in più `DataTable`di schema. Il metodo genera un'eccezione se corrispondenti colonne di <xref:System.Data.DataTable> e il set di risultati caricato non sono compatibili valore. Inoltre, il metodo recupera le informazioni sul vincolo dal set di risultati per tutte le colonne aggiunte. Ad eccezione del caso di un vincolo Primary Key, le informazioni di questo vincolo viene utilizzate solo se l'oggetto corrente <xref:System.Data.DataTable> non contiene tutte le colonne all'inizio dell'operazione di caricamento.|  
|Gli schemi sono compatibili, ma lo schema di set di risultati caricato contiene colonne di un numero inferiore rispetto a quello di `DataTable`.|Se una colonna mancante dispone di un valore predefinito o il tipo di dati della colonna è nullable, il <xref:System.Data.DataTable.Load%2A> metodo consente di righe da aggiungere, sostituendo il valore predefinito o `null` valore per la colonna mancante. Se nessun valore predefinito o `null` può essere utilizzato, il `Load` metodo genera un'eccezione. Se non è stato fornito alcun valore predefinito, il `Load` metodo utilizza il `null` al valore predefinito implicito.|  
  
 Prima di considerare il comportamento del `Load` metodo in termini di operazioni sui dati, tenere presente che ogni riga all'interno di un <xref:System.Data.DataTable> mantiene sia il valore corrente e il valore originale per ogni colonna. Questi valori può essere equivalenti o potrebbe essere diversi se i dati nella riga sono stati modificati dopo il riempimento di `DataTable`.  Per ulteriori informazioni, vedere [stati delle righe e le versioni di riga](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Questa versione di `Load` metodo tenta di mantenere i valori correnti in ogni riga, lasciando intatto il valore originale. (Se si desidera un controllo più preciso il comportamento dei dati in arrivo, vedere <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) Se la riga esistente e la riga in arrivo contengono valori di chiave primaria corrispondenti, la riga viene elaborata utilizzando il relativo valore di stato di riga corrente, in caso contrario viene considerato come una nuova riga.  
  
 In termini di operazioni di eventi, il <xref:System.Data.DataTable.RowChanging> evento si verifica prima di ogni riga viene modificato e <xref:System.Data.DataTable.RowChanged> evento si verifica dopo ogni riga è stata modificata. In ogni caso, il <xref:System.Data.DataRowChangeEventArgs.Action%2A> proprietà del <xref:System.Data.DataRowChangeEventArgs> istanza passata al gestore dell'evento contiene informazioni sulla specifica azione associata all'evento. Valore di questa azione dipende dallo stato della riga prima dell'operazione di caricamento. In ogni caso, si verificano entrambi gli eventi e l'azione è lo stesso per ogni. L'azione può essere applicato per la versione corrente o originale di ogni riga, o entrambi, a seconda dello stato di riga corrente.  
  
 Nella tabella seguente viene visualizzato il comportamento per la `Load` metodo. La riga finale (denominata "(non presente)") viene descritto il comportamento per le righe in ingresso non corrisponde ad alcuna riga esistente. Ogni cella in questa tabella viene descritto il valore corrente e originale per un campo all'interno di una riga, insieme al <xref:System.Data.DataRowState> per il valore dopo il `Load` completamento del metodo. In questo caso, il metodo non consente di indicare l'opzione di caricamento e utilizza il valore predefinito `PreserveChanges`.  
  
|DataRowState esistente|I valori dopo `Load` metodo e azione evento|  
|---------------------------|--------------------------------------------------|  
|Aggiunto|Corrente = \<esistente ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<modificato ><br /><br /> RowAction = ChangeOriginal|  
|Modificato|Corrente = \<esistente ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<modificato ><br /><br /> RowAction = ChangeOriginal|  
|Eliminato|Corrente = \<non disponibile ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<eliminato ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(Non presente)|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 I valori in un <xref:System.Data.DataColumn> può essere vincolato, ad esempio tramite l'utilizzo di proprietà <xref:System.Data.DataColumn.ReadOnly%2A> e <xref:System.Data.DataColumn.AutoIncrement%2A>. Il `Load` metodo gestisce tali colonne in modo che sia coerente con il comportamento definito dalle proprietà della colonna. Il vincolo in sola lettura in un <xref:System.Data.DataColumn> è applicabile solo per le modifiche apportate in memoria. Il `Load` metodo sovrascrive i valori della colonna di sola lettura, se necessario.  
  
 Per determinare la versione del campo di chiave primaria da utilizzare per confrontare la riga corrente con una riga in ingresso, il `Load` metodo utilizza la versione originale del valore della chiave primaria, all'interno di una riga, se presente. In caso contrario, il `Load` metodo utilizza la versione corrente del campo di chiave primaria.  
  
   
  
## Examples  
 L'esempio seguente illustra alcuni dei problemi correlati alla chiamata di <xref:System.Data.DataTable.Load%2A> metodo. Innanzitutto, nell'esempio si concentra problemi relativi allo schema, tra cui deduzione di uno schema dall'interfaccia caricata <xref:System.Data.IDataReader>, quindi la gestione di schemi incompatibili e gli schemi con colonne mancanti o aggiuntive. Nell'esempio viene quindi chiamato il `Load` (metodo), la visualizzazione dei dati prima e dopo l'operazione di caricamento.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">Interfaccia <see cref="T:System.Data.IDataReader" /> che fornisce uno o più gruppi di risultati.</param>
        <param name="loadOption">Valore dall'enumerazione della classe <see cref="T:System.Data.LoadOption" />, che indica come vengono combinate le righe già presenti nella classe <see cref="T:System.Data.DataTable" /> con le righe in entrata che condividono la stessa chiave primaria.</param>
        <summary>Riempie una classe <see cref="T:System.Data.DataTable" /> con valori di un'origine dati utilizzando l'interfaccia <see cref="T:System.Data.IDataReader" /> fornita. Se <see langword="DataTable" /> contiene già righe, i dati in arrivo dall'origine dati vengono uniti alle righe esistenti, in base al valore del parametro <paramref name="loadOption" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Load` metodo utilizza il primo set di risultati da caricato <xref:System.Data.IDataReader>e dopo il completamento, imposta la posizione del lettore al set di risultati successivo, se presente. Quando la conversione dei dati, il `Load` metodo utilizza le stesse regole di conversione di <xref:System.Data.Common.DbDataAdapter.Fill%2A> metodo.  
  
 Il `Load` metodo necessario prendere in considerazione tre problemi specifici durante il caricamento dei dati da un <xref:System.Data.IDataReader> istanza: operazioni di eventi, dati e schema. Quando si lavora con lo schema, il `Load` metodo potrebbe incontrare condizioni, come descritto nella tabella seguente. Le operazioni di schema si verificano per tutti i set di risultati importati, anche quelli che non contengono dati.  
  
|Condizione|Comportamento|  
|---------------|--------------|  
|Il <xref:System.Data.DataTable> dispone di alcuno schema.|Il `Load` metodo deduce lo schema basato su set di risultati dal importato <xref:System.Data.IDataReader>.|  
|Il <xref:System.Data.DataTable> ha uno schema, ma non è compatibile con lo schema caricato.|Il `Load` metodo genera un'eccezione corrispondente all'errore specifico che si verifica quando si tenta di caricare i dati nello schema non compatibile.|  
|Gli schemi sono compatibili, ma lo schema di set di risultati caricato contiene colonne che non esistono nel `DataTable`.|Il `Load` metodo aggiunge le colonne in più `DataTable`di schema. Il metodo genera un'eccezione se corrispondenti colonne di <xref:System.Data.DataTable> e il set di risultati caricato non sono compatibili valore. Inoltre, il metodo recupera le informazioni sul vincolo dal set di risultati per tutte le colonne aggiunte. Ad eccezione del caso di un vincolo Primary Key, le informazioni di questo vincolo viene utilizzate solo se l'oggetto corrente <xref:System.Data.DataTable> non contiene tutte le colonne all'inizio dell'operazione di caricamento.|  
|Gli schemi sono compatibili, ma lo schema di set di risultati caricato contiene colonne di un numero inferiore rispetto a quello di `DataTable`.|Se una colonna mancante dispone di un valore predefinito o il tipo di dati della colonna è nullable, il `Load` metodo consente di righe da aggiungere, sostituendo il valore predefinito o null per la colonna mancante. Se non può essere utilizzato alcun valore predefinito o null, il `Load` metodo genera un'eccezione. Se non è stato fornito alcun valore predefinito, il `Load` metodo utilizza il valore null come valore predefinito implicito.|  
  
 Prima di considerare il comportamento del `Load` metodo in termini di operazioni sui dati, tenere presente che ogni riga all'interno di un <xref:System.Data.DataTable> mantiene sia il valore corrente e il valore originale per ogni colonna. Questi valori può essere equivalenti o potrebbe essere diversi se i dati nella riga sono stati modificati dopo il riempimento di `DataTable`. Vedere [stati delle righe e le versioni di riga](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) per ulteriori informazioni.  
  
 In questa chiamata al metodo, l'oggetto specificata <xref:System.Data.LoadOption> parametro influenza l'elaborazione dei dati in arrivo. Come il metodo Load deve gestire le righe di caricamento che hanno la stessa chiave primaria delle righe esistenti? È necessario modificare i valori correnti, i valori originali o entrambi? Questi problemi e altro ancora, sono controllato dal `loadOption` parametro.  
  
 Se la riga esistente e la riga in arrivo contengono valori di chiave primaria corrispondenti, la riga viene elaborata utilizzando il relativo valore di stato di riga corrente, in caso contrario viene considerato come una nuova riga.  
  
 In termini di operazioni di eventi, il <xref:System.Data.DataTable.RowChanging> evento si verifica prima di ogni riga viene modificato e <xref:System.Data.DataTable.RowChanged> evento si verifica dopo ogni riga è stata modificata. In ogni caso, il <xref:System.Data.DataRowChangeEventArgs.Action%2A> proprietà del <xref:System.Data.DataRowChangeEventArgs> istanza passata al gestore dell'evento contiene informazioni sulla specifica azione associata all'evento. Valore di questa azione varia a seconda dello stato della riga prima dell'operazione di caricamento. In ogni caso, si verificano entrambi gli eventi e l'azione è lo stesso per ogni. L'azione può essere applicato per la versione corrente o originale di ogni riga, o entrambi, a seconda dello stato di riga corrente.  
  
 Nella tabella seguente viene visualizzato il comportamento del metodo Load quando viene chiamato con ogni il `LoadOption` valori e Mostra come i valori di interagiscono con lo stato di riga per riga in fase di caricamento. La riga finale (denominata "(non presente)") viene descritto il comportamento per le righe in ingresso non corrisponde ad alcuna riga esistente. Ogni cella in questa tabella viene descritto il valore corrente e originale per un campo all'interno di una riga, insieme al <xref:System.Data.DataRowState> per il valore dopo il `Load` completamento del metodo.  
  
|DataRowState esistente|Upsert|OverwriteChanges|PreserveChanges (comportamento predefinito)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Aggiunto|Corrente = \<in arrivo ><br /><br /> Originale = -\<non disponibile ><br /><br /> Stato = \<aggiunto ><br /><br /> RowAction = modifica|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<esistente ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<modificato ><br /><br /> RowAction = ChangeOriginal|  
|Modificato|Corrente = \<in arrivo ><br /><br /> Originale = \<esistente ><br /><br /> Stato = \<modificato ><br /><br /> RowAction = modifica|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<esistente ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<modificato ><br /><br /> RowAction =ChangeOriginal|  
eliminazione|(Il metodo load non non interessano eliminato righe)<br /><br /> Corrente =--<br /><br /> Originale = \<esistente ><br /><br /> Stato = \<eliminato ><br /><br /> (Nuova riga viene aggiunto con le caratteristiche seguenti)<br /><br /> Corrente = \<in arrivo ><br /><br /> Originale = \<non disponibile ><br /><br /> Stato = \<aggiunto ><br /><br /> RowAction = aggiungere|Annullare l'eliminazione e<br /><br /> Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<non disponibile ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<eliminato ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Corrente = \<in arrivo ><br /><br /> Originale = \<esistente ><br /><br /> Se il nuovo valore è uguale al valore esistente quindi<br /><br /> Stato = \<invariato ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Stato = \<modificato ><br /><br /> RowAction = modifica|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Non è presente)|Corrente = \<in arrivo ><br /><br /> Originale = \<non disponibile ><br /><br /> Stato = \<aggiunto ><br /><br /> RowAction = aggiungere|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 I valori in un <xref:System.Data.DataColumn> può essere vincolato, ad esempio tramite l'utilizzo di proprietà <xref:System.Data.DataColumn.ReadOnly%2A> e <xref:System.Data.DataColumn.AutoIncrement%2A>. Il `Load` metodo gestisce tali colonne in modo che sia coerente con il comportamento definito dalle proprietà della colonna. Il vincolo in sola lettura in un <xref:System.Data.DataColumn> è applicabile solo per le modifiche apportate in memoria. Il `Load` metodo sovrascrive i valori della colonna di sola lettura, se necessario.  
  
 Se si specificano le opzioni OverwriteChanges o PreserveChanges quando si chiama il `Load` (metodo), quindi il presupposto è che i dati in ingresso proviene dal `DataTable`dell'origine dati primaria e DataTable tiene traccia delle modifiche e in grado di propagare le modifiche all'origine dati. Se si seleziona l'opzione Upsert, si presuppone che i dati provenienti da uno di un'origine dati secondaria, ad esempio i dati forniti da un componente di livello intermedio, ad esempio è stato modificato da un utente. In questo caso, il presupposto è che si desidera aggregare i dati da uno o più origini dati nel `DataTable`per poi propagare ad esempio i dati all'origine dati primaria. Il <xref:System.Data.LoadOption> parametro viene utilizzato per determinare la versione specifica della riga che deve essere utilizzato per il confronto della chiave primario. Nella tabella seguente fornisce i dettagli.  
  
|Opzione di caricamento|Versione DataRow utilizzato per il confronto della chiave primario|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Versione originale, se presente, la versione corrente in caso contrario|  
|`PreserveChanges`|Versione originale, se presente, la versione corrente in caso contrario|  
|`Upsert`|La versione corrente, se presente, la versione originale in caso contrario|  
  
   
  
## Examples  
 L'esempio seguente illustra alcuni dei problemi correlati alla chiamata di <xref:System.Data.DataTable.Load%2A> metodo. Innanzitutto, nell'esempio si concentra problemi relativi allo schema, tra cui deduzione di uno schema dall'interfaccia caricata <xref:System.Data.IDataReader>, quindi la gestione di schemi incompatibili e gli schemi con colonne mancanti o aggiuntive. L'esempio quindi illustra problemi di dati, inclusa la gestione delle diverse opzioni di caricamento.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">Interfaccia <see cref="T:System.Data.IDataReader" /> che fornisce un gruppo di risultati.</param>
        <param name="loadOption">Valore dall'enumerazione della classe <see cref="T:System.Data.LoadOption" />, che indica come vengono combinate le righe già presenti nella classe <see cref="T:System.Data.DataTable" /> con le righe in entrata che condividono la stessa chiave primaria.</param>
        <param name="errorHandler">Delegato <see cref="T:System.Data.FillErrorEventHandler" /> da chiamare quando si verifica un errore durante il caricamento dei dati.</param>
        <summary>Riempie una classe <see cref="T:System.Data.DataTable" /> con valori di un'origine dati utilizzando l'interfaccia <see cref="T:System.Data.IDataReader" /> fornita, tramite un delegato di gestione degli errori.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Load` metodo utilizza il primo set di risultati da caricato <xref:System.Data.IDataReader>e dopo il completamento, imposta la posizione del lettore al set di risultati successivo, se presente. Quando la conversione dei dati, il `Load` metodo utilizza le stesse regole di conversione di <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> metodo.  
  
 Il `Load` metodo necessario prendere in considerazione tre problemi specifici durante il caricamento dei dati da un <xref:System.Data.IDataReader> istanza: operazioni di eventi, dati e schema. Quando si lavora con lo schema, il `Load` metodo potrebbe incontrare condizioni, come descritto nella tabella seguente. Le operazioni di schema si verificano per tutti i set di risultati importati, anche quelli che non contengono dati.  
  
|Condizione|Comportamento|  
|---------------|--------------|  
|Il <xref:System.Data.DataTable> dispone di alcuno schema.|Il `Load` metodo deduce lo schema basato su set di risultati dal importato <xref:System.Data.IDataReader>.|  
|Il <xref:System.Data.DataTable> ha uno schema, ma non è compatibile con lo schema caricato.|Il `Load` metodo genera un'eccezione corrispondente all'errore specifico che si verifica quando si tenta di caricare i dati nello schema non compatibile.|  
|Gli schemi sono compatibili, ma lo schema di set di risultati caricato contiene colonne che non esistono nel `DataTable`.|Il `Load` metodo aggiunge le colonne aggiuntive per `DataTable`di schema. Il metodo genera un'eccezione se corrispondenti colonne di <xref:System.Data.DataTable> e il set di risultati caricato non sono compatibili valore. Inoltre, il metodo recupera le informazioni sul vincolo dal set di risultati per tutte le colonne aggiunte. Ad eccezione del caso di un vincolo Primary Key, le informazioni di questo vincolo viene utilizzate solo se l'oggetto corrente <xref:System.Data.DataTable> non contiene tutte le colonne all'inizio dell'operazione di caricamento.|  
|Gli schemi sono compatibili, ma lo schema di set di risultati caricato contiene colonne di un numero inferiore rispetto a quello di `DataTable`.|Se una colonna mancante dispone di un valore predefinito o il tipo di dati della colonna è nullable, il `Load` metodo consente di righe da aggiungere, sostituendo il valore predefinito o null per la colonna mancante. Se non può essere utilizzato alcun valore predefinito o null, il `Load` metodo genera un'eccezione. Se non è stato fornito alcun valore predefinito, il `Load` metodo utilizza il valore null come valore predefinito implicito.|  
  
 Prima di considerare il comportamento del `Load` metodo in termini di operazioni sui dati, tenere presente che ogni riga all'interno di un <xref:System.Data.DataTable> mantiene sia il valore corrente e il valore originale per ogni colonna. Questi valori può essere equivalenti o potrebbe essere diversi se i dati nella riga sono stati modificati dopo il riempimento di `DataTable`. Vedere [stati delle righe e le versioni di riga](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) per ulteriori informazioni.  
  
 In questa chiamata al metodo, l'oggetto specificata <xref:System.Data.LoadOption> parametro influenza l'elaborazione dei dati in arrivo. Come il metodo Load deve gestire le righe di caricamento che hanno la stessa chiave primaria delle righe esistenti? È necessario modificare i valori correnti, i valori originali o entrambi? Questi problemi e altro ancora, sono controllato dal `loadOption` parametro.  
  
 Se la riga esistente e la riga in arrivo contengono valori di chiave primaria corrispondenti, la riga viene elaborata utilizzando il relativo valore di stato di riga corrente, in caso contrario viene considerato come una nuova riga.  
  
 In termini di operazioni di eventi, il <xref:System.Data.DataTable.RowChanging> evento si verifica prima di ogni riga viene modificato e <xref:System.Data.DataTable.RowChanged> evento si verifica dopo ogni riga è stata modificata. In ogni caso, il <xref:System.Data.DataRowChangeEventArgs.Action%2A> proprietà del <xref:System.Data.DataRowChangeEventArgs> istanza passata al gestore dell'evento contiene informazioni sulla specifica azione associata all'evento. Valore di questa azione varia a seconda dello stato della riga prima dell'operazione di caricamento. In ogni caso, si verificano entrambi gli eventi e l'azione è lo stesso per ogni. L'azione può essere applicato per la versione corrente o originale di ogni riga, o entrambi, a seconda dello stato di riga corrente.  
  
 Nella tabella seguente viene visualizzato il comportamento del metodo Load quando viene chiamato con ogni il `LoadOption` valori e Mostra come i valori di interagiscono con lo stato di riga per riga in fase di caricamento. La riga finale (denominata "(non presente)") viene descritto il comportamento per le righe in ingresso non corrisponde ad alcuna riga esistente. Ogni cella in questa tabella viene descritto il valore corrente e originale per un campo all'interno di una riga, insieme al <xref:System.Data.DataRowState> per il valore dopo il `Load` completamento del metodo.  
  
|DataRowState esistente|Upsert|OverwriteChanges|PreserveChanges (comportamento predefinito)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Aggiunto|Corrente = \<in arrivo ><br /><br /> Originale = -\<non disponibile ><br /><br /> Stato = \<aggiunto ><br /><br /> RowAction = modifica|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<esistente ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<modificato ><br /><br /> RowAction = ChangeOriginal|  
|Modificato|Corrente = \<in arrivo ><br /><br /> Originale = \<esistente ><br /><br /> Stato = \<modificato ><br /><br /> RowAction = modifica|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<esistente ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<modificato ><br /><br /> RowAction =ChangeOriginal|  
eliminazione|(Il metodo load non non interessano eliminato righe)<br /><br /> Corrente =--<br /><br /> Originale = \<esistente ><br /><br /> Stato = \<eliminato ><br /><br /> (Nuova riga viene aggiunto con le caratteristiche seguenti)<br /><br /> Corrente = \<in arrivo ><br /><br /> Originale = \<non disponibile ><br /><br /> Stato = \<aggiunto ><br /><br /> RowAction = aggiungere|Annullare l'eliminazione e<br /><br /> Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<non disponibile ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<eliminato ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Corrente = \<in arrivo ><br /><br /> Originale = \<esistente ><br /><br /> Se il nuovo valore è uguale al valore esistente quindi<br /><br /> Stato = \<invariato ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Stato = \<modificato ><br /><br /> RowAction = modifica|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Non è presente)|Corrente = \<in arrivo ><br /><br /> Originale = \<non disponibile ><br /><br /> Stato = \<aggiunto ><br /><br /> RowAction = aggiungere|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|Corrente = \<in arrivo ><br /><br /> Originale = \<in arrivo ><br /><br /> Stato = \<invariato ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 I valori in un <xref:System.Data.DataColumn> può essere vincolato, ad esempio tramite l'utilizzo di proprietà <xref:System.Data.DataColumn.ReadOnly%2A> e <xref:System.Data.DataColumn.AutoIncrement%2A>. Il `Load` metodo gestisce tali colonne in modo che sia coerente con il comportamento definito dalle proprietà della colonna. Il vincolo in sola lettura in un <xref:System.Data.DataColumn> è applicabile solo per le modifiche apportate in memoria. Il `Load` metodo sovrascrive i valori della colonna di sola lettura, se necessario.  
  
 Se si specificano le opzioni OverwriteChanges o PreserveChanges quando si chiama il `Load` (metodo), quindi il presupposto è che i dati in ingresso proviene dal `DataTable`dell'origine dati primaria e DataTable tiene traccia delle modifiche e in grado di propagare le modifiche all'origine dati. Se si seleziona l'opzione Upsert, si presuppone che i dati provenienti da uno di un'origine dati secondaria, ad esempio i dati forniti da un componente di livello intermedio, ad esempio è stato modificato da un utente. In questo caso, il presupposto è che si desidera aggregare i dati da uno o più origini dati nel `DataTable`per poi propagare ad esempio i dati all'origine dati primaria. Il <xref:System.Data.LoadOption> parametro viene utilizzato per determinare la versione specifica della riga che deve essere utilizzato per il confronto della chiave primario. Nella tabella seguente fornisce i dettagli.  
  
|Opzione di caricamento|Versione DataRow utilizzato per il confronto della chiave primario|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Versione originale, se presente, la versione corrente in caso contrario|  
|`PreserveChanges`|Versione originale, se presente, la versione corrente in caso contrario|  
|`Upsert`|La versione corrente, se presente, la versione originale in caso contrario|  
  
 Il `errorHandler` parametro è un <xref:System.Data.FillErrorEventHandler> delegato che fa riferimento a una routine che viene chiamata quando si verifica un errore durante il caricamento di dati. Il <xref:System.Data.FillErrorEventArgs> parametro passato alla procedura fornisce le proprietà che consentono di recuperare informazioni sull'errore che si sono verificati, la riga corrente di dati, e <xref:System.Data.DataTable> riempito. Tramite questo meccanismo di delegato, anziché un semplice blocco try/catch, consente di determinare l'errore, gestire la situazione e continuare l'elaborazione se lo si desidera. Il <xref:System.Data.FillErrorEventArgs> parametro fornisce un <xref:System.Data.FillErrorEventArgs.Continue%2A> proprietà: impostare questa proprietà su `true` per indicare che è stato gestito l'errore e continuare l'elaborazione. Impostare la proprietà su `false` per indicare che si desidera interrompere l'elaborazione. Tenere presente che l'impostazione della proprietà su `false` , il codice che ha generato il problema di generare un'eccezione.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rileva e aggiorna una riga specifica. Se non viene trovata una riga corrispondente, viene creata una nuova riga utilizzando i valori dati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">Matrice di valori utilizzati per creare la nuova riga.</param>
        <param name="fAcceptChanges">
          <see langword="true" /> per accettare le modifiche apportate; in caso contrario, <see langword="false" />.</param>
        <summary>Rileva e aggiorna una riga specifica. Se non viene trovata una riga corrispondente, viene creata una nuova riga utilizzando i valori dati.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.LoadDataRow%2A> metodo accetta una matrice di valori e trova i valori corrispondenti nelle colonne chiave primarie.  
  
 Se una colonna contiene un valore predefinito, passare un valore null nella matrice per impostare il valore predefinito per tale colonna. Analogamente, se dispone di una colonna relativa <xref:System.Data.DataColumn.AutoIncrement%2A> proprietà è impostata su true, passare un valore null nella matrice per impostare il valore generato automaticamente per la riga.  
  
 Se il `fAcceptChanges` parametro `true` o non è specificato, vengono aggiunti i nuovi dati e quindi <xref:System.Data.DataTable.AcceptChanges%2A> viene chiamato per accettare tutte le modifiche nel <xref:System.Data.DataTable>; se l'argomento è `false`, aggiunta di righe contrassegnate come inserimenti e le modifiche ai le righe esistenti sono contrassegnate come le modifiche.  
  
 Eccezioni possono verificarsi anche durante un <xref:System.Data.DataTable.ColumnChanging> o <xref:System.Data.DataTable.RowChanging> evento. Se si verifica un'eccezione, la riga non viene aggiunta alla tabella.  
  
 Utilizzare <xref:System.Data.DataTable.LoadDataRow%2A> in combinazione con <xref:System.Data.DataTable.BeginLoadData%2A> e <xref:System.Data.DataTable.EndLoadData%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataTable.LoadDataRow%2A> metodo nel tentativo di trovare una riga. Se non viene trovata alcuna riga, i valori vengono utilizzati per creare una nuova riga.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matrice è maggiore del numero di colonne nella tabella.</exception>
        <exception cref="T:System.InvalidCastException">Un valore non corrisponde al rispettivo tipo di colonna.</exception>
        <exception cref="T:System.Data.ConstraintException">L'aggiunta della riga invalida un vincolo.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Tentativo di immissione di un valore null in una colonna in cui la proprietà <see cref="P:System.Data.DataColumn.AllowDBNull" /> è impostata su false.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">Matrice di valori utilizzati per creare la nuova riga.</param>
        <param name="loadOption">Utilizzato per stabilire la modalità in cui i valori della matrice vengono applicati ai valori corrispondenti in una riga esistente.</param>
        <summary>Rileva e aggiorna una riga specifica. Se non viene trovata una riga corrispondente, viene creata una nuova riga utilizzando i valori dati.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.LoadDataRow%2A> metodo accetta una matrice di valori e trova i valori corrispondenti nelle colonne chiave primarie.  
  
 Se una colonna contiene un valore predefinito, passare un valore null nella matrice per impostare il valore predefinito per tale colonna. Analogamente, se dispone di una colonna relativa <xref:System.Data.DataColumn.AutoIncrement%2A> proprietà è impostata su true, passare un valore null nella matrice per impostare il valore generato automaticamente per la riga.  
  
 Il valore di `loadOption` parametro viene utilizzato per determinare come vengono applicati i valori nella matrice in una riga esistente. Ad esempio, se `loadOption` è impostato su `OverwriteChanges`, `Original` e `Current` i valori di ogni colonna vengono sostituiti con i valori della riga in arrivo e `RowState` è impostata su `Unchanged`.  
  
 Eccezioni possono verificarsi anche durante un <xref:System.Data.DataTable.ColumnChanging> o <xref:System.Data.DataTable.RowChanging> evento. Se si verifica un'eccezione, la riga non viene aggiunta alla tabella.  
  
 Utilizzare <xref:System.Data.DataTable.LoadDataRow%2A> in combinazione con <xref:System.Data.DataTable.BeginLoadData%2A> e <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le informazioni sulle impostazioni locali utilizzate per confrontare stringhe all'interno della tabella.</summary>
        <value>Oggetto <see cref="T:System.Globalization.CultureInfo" /> che contiene i dati sulle impostazioni locali del computer dell'utente. Il valore predefinito è rappresentato dall'oggetto <see cref="T:System.Data.DataSet" /> del <see cref="T:System.Globalization.CultureInfo" /> (restituito dalla proprietà <see cref="P:System.Data.DataSet.Locale" />) a cui appartiene l'oggetto <see cref="T:System.Data.DataTable" />; se la tabella non appartiene a un oggetto <see cref="T:System.Data.DataSet" />, il valore predefinito sarà rappresentato dall'oggetto <see cref="T:System.Globalization.CultureInfo" /> del sistema corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Globalization.CultureInfo> rappresenta le preferenze di software di determinate impostazioni cultura o community.  
  
 Quando viene utilizzato per confronti tra stringhe, il <xref:System.Globalization.CultureInfo> influisce sul filtro e ordinamento, sui confronti.  
  
> [!NOTE]
>  Nelle colonne che contengono espressioni, il <xref:System.StringComparison.InvariantCulture> viene utilizzato. Il <xref:System.StringComparison.CurrentCulture> viene ignorato.  
  
   
  
## Examples  
 L'esempio seguente imposta il <xref:System.Globalization.CultureInfo> tramite il <xref:System.Data.DataTable.Locale%2A> e viene stampato il nome di lingua ISO.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unire la classe <see cref="T:System.Data.DataTable" /> specificata alla classe <see cref="T:System.Data.DataTable" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Merge` metodo viene utilizzato per unire due <xref:System.Data.DataTable> gli oggetti che contengono schemi molto simili. Un'unione è in genere utilizzata in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataTable>. In questo modo l'applicazione client per un aggiornamento <xref:System.Data.DataTable> con i dati più recenti dall'origine dati.  
  
 L'operazione di unione prende in considerazione solo la tabella originale e la tabella da unire. Tabelle figlio non sono interessate o inclusa. Se la tabella contiene una o più tabelle figlio, definite come parte di una relazione, è necessario unire singolarmente ogni tabella figlio.  
  
   
  
## Examples  
 L'applicazione console seguente viene illustrato il comportamento del `missingSchemaAction` parametro del <xref:System.Data.DataTable.Merge%2A> metodo. Questo esempio crea due versioni della stessa tabella, la modifica dello schema per la seconda versione. Il codice tenta quindi di unire la seconda tabella al primo oggetto.  
  
> [!NOTE]
>  In questo esempio viene illustrato come utilizzare una delle versioni di overload di tipo Merge. Per altri esempi che potrebbero essere disponibili, vedere gli argomenti di overload singoli.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Classe <see cref="T:System.Data.DataTable" /> da unire alla classe <see cref="T:System.Data.DataTable" /> corrente.</param>
        <summary>Unire la classe <see cref="T:System.Data.DataTable" /> specificata alla classe <see cref="T:System.Data.DataTable" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo di tipo Merge viene utilizzato per unire due <xref:System.Data.DataTable> gli oggetti che contengono schemi molto simili. Un'unione è in genere utilizzata in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataTable>. In questo modo l'applicazione client per un aggiornamento <xref:System.Data.DataTable> con i dati più recenti dall'origine dati.  
  
 L'operazione di unione prende in considerazione solo la tabella originale e la tabella da unire. Tabelle figlio non sono interessate o inclusa. Se la tabella contiene una o più tabelle figlio, definite come parte di una relazione, è necessario unire singolarmente ogni tabella figlio.  
  
 Il `Merge` viene in genere chiamato alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistenti <xref:System.Data.DataTable>.  
  
 Quando si esegue un'operazione di unione, le modifiche apportate ai dati esistenti prima dell'unione vengono conservate per impostazione predefinita durante l'operazione di unione. Gli sviluppatori possono modificare questo comportamento chiamando uno degli altri due overload di questo metodo e specificando un valore false per il `preserveChanges` parametro.  
  
 In un'applicazione client, è previsto un singolo pulsante che l'utente può fare clic per raccogliere i dati modificati e convalidarli prima di inviarlo a un componente di livello intermedio. In questo scenario, il <xref:System.Data.DataTable.GetChanges%2A> metodo viene richiamato prima. Questo metodo restituisce un secondo <xref:System.Data.DataTable> con ottimizzazione per la convalida e l'unione. Questo secondo <xref:System.Data.DataTable> oggetto contiene solo il <xref:System.Data.DataRow> gli oggetti che sono stati modificati, rappresenta un sottoinsieme dell'originale <xref:System.Data.DataTable>. Questo subset è in genere più piccoli e di conseguenza in modo più efficiente passato nuovamente al componente di livello intermedio. Il componente di livello intermedio quindi aggiorna l'origine dei dati con le modifiche mediante le stored procedure. Il livello intermedio possa quindi inviare un nuovo oggetto <xref:System.Data.DataTable> che include i dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale) oppure può inviare nuovamente il subset con eventuali modifiche apportate all'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primaria univoci, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataTable> possono essere reinseriti nell'originale dell'applicazione client <xref:System.Data.DataTable> con il <xref:System.Data.DataTable.Merge%2A> metodo.  
  
 Quando si uniscono una nuova origine <xref:System.Data.DataTable> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> valore `Unchanged`, `Modified`, o `Deleted`, corrisponde a righe di destinazione con gli stessi valori di chiave primari. Le righe di origine un <xref:System.Data.DataRowState> valore `Added` corrispondenti alle nuove righe di destinazione con gli stessi valori di chiave primari delle nuove righe di origine.  
  
   
  
## Examples  
 La seguente applicazione console crea un semplice <xref:System.Data.DataTable> e aggiunge i dati alla tabella. Nell'esempio viene quindi creata una copia della tabella, l'aggiunta di righe per la copia. Infine, viene chiamato il <xref:System.Data.DataTable.Merge%2A> metodo per unire i dati nella seconda tabella con i dati nella prima tabella.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">Classe <see langword="DataTable" /> da unire alla classe <see langword="DataTable" /> corrente.</param>
        <param name="preserveChanges">
          <see langword="true" /> per mantenere le modifiche apportate all'elemento <see langword="DataTable" /> corrente; in caso contrario, <see langword="false" />.<see langword="" /></param>
        <summary>Unire la classe <see cref="T:System.Data.DataTable" /> specificata alla classe <see langword="DataTable" /> corrente, indicando se conservare le modifiche nella classe <see langword="DataTable" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo di tipo Merge viene utilizzato per unire due <xref:System.Data.DataTable> gli oggetti che contengono schemi molto simili. Un'unione è in genere utilizzata in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataTable>. In questo modo l'applicazione client per un aggiornamento <xref:System.Data.DataTable> con i dati più recenti dall'origine dati.  
  
 L'operazione di unione prende in considerazione solo la tabella originale e la tabella da unire. Tabelle figlio non sono interessate o inclusa. Se la tabella contiene una o più tabelle figlio, definite come parte di una relazione, è necessario unire singolarmente ogni tabella figlio.  
  
 Il `Merge` viene in genere chiamato alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistenti <xref:System.Data.DataTable>.  
  
 Quando si esegue un'operazione di unione, le modifiche apportate ai dati esistenti prima dell'unione vengono mantenute durante l'operazione di unione, a meno che lo sviluppatore specifica false per il `preserveChanges` parametro. Se il `preserveChanges` parametro è impostato su `true`, i valori in ingresso non sovrascrivono i valori esistenti nella versione di riga corrente della riga esistente. Se il `preserveChanges` parametro è impostato su `false`, i valori in ingresso di sovrascrivere i valori esistenti nella versione di riga corrente della riga esistente. Per ulteriori informazioni sulle versioni delle righe, vedere [stati delle righe e le versioni di riga](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 In un'applicazione client, è previsto un singolo pulsante che l'utente può fare clic per raccogliere i dati modificati e convalidarli prima di inviarlo a un componente di livello intermedio. In questo scenario, il <xref:System.Data.DataTable.GetChanges%2A> metodo viene richiamato prima. Questo metodo restituisce un secondo <xref:System.Data.DataTable> con ottimizzazione per la convalida e l'unione. Questo secondo <xref:System.Data.DataTable> oggetto contiene solo il <xref:System.Data.DataTable> e <xref:System.Data.DataRow> gli oggetti che sono stati modificati, rappresenta un sottoinsieme dell'originale <xref:System.Data.DataTable>. Questo subset è generalmente di dimensioni ridotte e, pertanto questo subset è più efficiente passare a un componente di livello intermedio. Il componente di livello intermedio quindi aggiorna l'origine dei dati con le modifiche mediante le stored procedure. Il livello intermedio possa quindi inviare un nuovo oggetto <xref:System.Data.DataTable> che include i dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale) oppure può inviare nuovamente il subset con eventuali modifiche apportate all'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primaria univoci, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataTable> possono essere reinseriti nell'originale dell'applicazione client <xref:System.Data.DataTable> con il <xref:System.Data.DataTable.Merge%2A> metodo.  
  
 Quando si uniscono una nuova origine <xref:System.Data.DataTable> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> valore `Unchanged`, `Modified`, o `Deleted` corrispondenti alle righe di destinazione con gli stessi valori di chiave primari. Le righe di origine un <xref:System.Data.DataRowState> valore `Added` corrispondenti alle nuove righe di destinazione con gli stessi valori di chiave primari delle nuove righe di origine.  
  
   
  
## Examples  
 La seguente applicazione console crea un <xref:System.Data.DataTable> contenente le righe, vengono modificati alcuni dati in tali righe e tenta di unire dati da un altro <xref:System.Data.DataTable>. Nell'esempio vengono illustrati i diversi comportamenti di `preserveChanges` parametro.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">Classe <see cref="T:System.Data.DataTable" /> da unire alla classe <see cref="T:System.Data.DataTable" /> corrente.</param>
        <param name="preserveChanges">
          <see langword="true" /> per conservare le modifiche apportate all'oggetto <see cref="T:System.Data.DataTable" /> corrente; in caso contrario, <see langword="false" />.</param>
        <param name="missingSchemaAction">Uno dei valori di <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Unire la classe <see cref="T:System.Data.DataTable" /> specificata alla classe <see langword="DataTable" /> corrente, indicando se conservare le modifiche e come gestire lo schema mancante nella classe <see langword="DataTable" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Merge` metodo viene utilizzato per unire due <xref:System.Data.DataTable> gli oggetti che contengono schemi molto simili. Un'unione è in genere utilizzata in un'applicazione client per incorporare le modifiche più recenti da un'origine dati in un oggetto esistente <xref:System.Data.DataTable>. In questo modo l'applicazione client per un aggiornamento <xref:System.Data.DataTable> con i dati più recenti dall'origine dati.  
  
 L'operazione di unione prende in considerazione solo la tabella originale e la tabella da unire. Tabelle figlio non sono interessate o inclusa. Se la tabella contiene una o più tabelle figlio, definite come parte di una relazione, è necessario unire singolarmente ogni tabella figlio.  
  
 Il `Merge` viene in genere chiamato alla fine di una serie di procedure che comportano la convalida delle modifiche, la risoluzione degli errori, aggiornare l'origine dati con le modifiche e infine l'aggiornamento esistenti <xref:System.Data.DataTable>.  
  
 Quando si esegue un'operazione di unione, le modifiche apportate ai dati esistenti prima dell'unione vengono mantenute durante l'operazione di unione, a meno che lo sviluppatore specifica false per il `preserveChanges` parametro. Se il `preserveChanges` parametro è impostato su `true`, i valori in ingresso non sovrascrivono i valori esistenti nella versione di riga corrente della riga esistente. Se il `preserveChanges` parametro è impostato su `false`, i valori in ingresso di sovrascrivere i valori esistenti nella versione di riga corrente della riga esistente. Per ulteriori informazioni sulle versioni delle righe, vedere [stati delle righe e le versioni di riga](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 In un'applicazione client, è previsto un singolo pulsante che l'utente può fare clic per raccogliere i dati modificati e convalidarli prima di inviarlo a un componente di livello intermedio. In questo scenario, il <xref:System.Data.DataTable.GetChanges%2A> metodo viene richiamato prima. Questo metodo restituisce un secondo <xref:System.Data.DataTable> con ottimizzazione per la convalida e l'unione. Questo secondo <xref:System.Data.DataTable> oggetto contiene solo il <xref:System.Data.DataTable> e <xref:System.Data.DataRow> gli oggetti che sono stati modificati, rappresenta un sottoinsieme dell'originale <xref:System.Data.DataTable>. Questo subset è generalmente di dimensioni ridotte e, pertanto questo subset è più efficiente passare a un componente di livello intermedio. Il componente di livello intermedio quindi aggiorna l'origine dei dati con le modifiche mediante le stored procedure. Il livello intermedio possa quindi inviare un nuovo oggetto <xref:System.Data.DataTable> che include i dati originali e i dati più recenti dall'origine dati (per eseguire nuovamente la query originale) oppure può inviare nuovamente il subset con eventuali modifiche apportate all'origine dati. (Ad esempio, se l'origine dati crea automaticamente i valori di chiave primaria univoci, questi valori possono essere propagati all'applicazione client.) In entrambi i casi, l'oggetto restituito <xref:System.Data.DataTable> possono essere reinseriti nell'originale dell'applicazione client <xref:System.Data.DataTable> con il <xref:System.Data.DataTable.Merge%2A> metodo.  
  
 Quando il <xref:System.Data.DataTable.Merge%2A> metodo viene chiamato, gli schemi dei due <xref:System.Data.DataTable> vengono confrontati gli oggetti, poiché è possibile che gli schemi sia stati modificati. Ad esempio, in uno scenario business-to-business, potrebbero sono state aggiunte nuove colonne a uno schema XML da un processo automatizzato. Se l'origine <xref:System.Data.DataTable> contiene gli elementi dello schema (aggiunto <xref:System.Data.DataColumn> oggetti) che non sono presenti nel database di destinazione, è possono aggiungere gli elementi dello schema di destinazione impostando il `missingSchemaAction` argomento `MissingSchemaAction.Add`. In questo caso, l'oggetto unito <xref:System.Data.DataTable> contiene lo schema e aggiunti dati.  
  
 Dopo l'unione di schemi, i dati vengono uniti.  
  
 Quando si uniscono una nuova origine <xref:System.Data.DataTable> nella destinazione, qualsiasi origine righe con un <xref:System.Data.DataRowState> valore `Unchanged`, `Modified`, o `Deleted` corrispondenti alle righe di destinazione con gli stessi valori di chiave primari. Le righe di origine un <xref:System.Data.DataRowState> valore `Added` corrispondenti alle nuove righe di destinazione con gli stessi valori di chiave primari delle nuove righe di origine.  
  
   
  
## Examples  
 L'applicazione console seguente viene illustrato il comportamento del `missingSchemaAction` parametro del <xref:System.Data.DataTable.Merge%2A> metodo. Questo esempio crea due versioni della stessa tabella, la modifica dello schema per la seconda versione. Il codice tenta quindi di unire la seconda tabella al primo oggetto.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione iniziale di questa tabella.</summary>
        <value>Dimensione iniziale delle righe di questa tabella. Il valore predefinito è 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.MinimumCapacity%2A> consente al sistema di creare un set appropriato delle risorse prima del recupero dei dati. In una situazione quando le prestazioni sono critiche, impostazione di questa proprietà può ottimizzare le prestazioni.  
  
   
  
## Examples  
 L'esempio seguente imposta il <xref:System.Data.DataTable.MinimumCapacity%2A> di un <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo spazio dei nomi per la rappresentazione XML dei dati memorizzati nella classe <see cref="T:System.Data.DataTable" />.</summary>
        <value>Spazio dei nomi di <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Data.DataRow" /> con lo stesso schema della tabella.</summary>
        <returns>Oggetto <see cref="T:System.Data.DataRow" /> con lo stesso schema dell'oggetto <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario utilizzare il <xref:System.Data.DataTable.NewRow%2A> metodo per creare nuovi <xref:System.Data.DataRow> oggetti con lo stesso schema di <xref:System.Data.DataTable>. Dopo aver creato un <xref:System.Data.DataRow>, è possibile aggiungerlo al <xref:System.Data.DataRowCollection>, tramite il <xref:System.Data.DataTable> dell'oggetto <xref:System.Data.DataTable.Rows%2A> proprietà. Quando si utilizza <xref:System.Data.DataTable.NewRow%2A> per creare nuove righe, le righe devono essere aggiunti o eliminate dalla tabella di dati prima di chiamare <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Data.DataTable>, aggiunge due <xref:System.Data.DataColumn> oggetti determinano lo schema della tabella, vengono creati diversi nuovi <xref:System.Data.DataRow> degli oggetti mediante il <xref:System.Data.DataTable.NewRow%2A> metodo. Quelli <xref:System.Data.DataRow> gli oggetti vengono quindi aggiunti al <xref:System.Data.DataRowCollection> utilizzando il <xref:System.Data.DataRowCollection.Add%2A> metodo.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">Valore <see cref="T:System.Int32" /> che descrive le dimensioni della matrice.</param>
        <summary>Restituisce una matrice di <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Nuova matrice.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Un oggetto <see cref="T:System.Data.DataRowBuilder" />.</param>
        <summary>Crea una nuova riga da una riga esistente.</summary>
        <returns>Classe <see cref="T:System.Data.DataRow" /> derivata.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Data.DataColumnChangeEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Data.DataTable.ColumnChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Data.DataColumnChangeEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Data.DataTable.ColumnChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Oggetto <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">Classe <see cref="T:System.Data.DataColumn" /> che viene rimossa.</param>
        <summary>Notifica all'oggetto <see cref="T:System.Data.DataTable" /> che è in corso l'eliminazione di un oggetto <see cref="T:System.Data.DataColumn" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Data.DataRowChangeEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Data.DataTable.RowChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Data.DataRowChangeEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Data.DataTable.RowChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Data.DataRowChangeEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Data.DataTable.RowDeleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Data.DataRowChangeEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Data.DataTable.RowDeleting" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> metodo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Data.DataTableClearEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Data.DataTable.TableCleared" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Genera il <xref:System.Data.DataTable.TableCleared> evento, viene generato immediatamente dopo che tutte le righe sono state cancellate ma prima che il <xref:System.Data.DataTable.Clear%2A> metodo restituisce il controllo al chiamante.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Data.DataTableClearEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Data.DataTable.TableClearing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Genera il <xref:System.Data.DataTable.TableClearing> evento, viene generato prima dell'elaborazione del <xref:System.Data.DataTable.Clear%2A> inizia l'operazione.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Data.DataTableNewRowEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Data.DataTable.TableNewRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Genera il <xref:System.Data.DataTable.TableNewRow> evento, che viene attivato dopo un nuovo <xref:System.Data.DataRow> è stato creato utilizzando <xref:System.Data.DataTable.NewRow%2A>.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di relazioni padre dell'oggetto <see cref="T:System.Data.DataTable" />.</summary>
        <value>Classe <see cref="T:System.Data.DataRelationCollection" /> che contiene le relazioni padre della tabella. Se non esiste alcun oggetto <see cref="T:System.Data.DataRelation" /> viene restituito un insieme vuoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa il <xref:System.Data.DataTable.ParentRelations%2A> proprietà per restituire ogni elemento padre <xref:System.Data.DataRelation> in un <xref:System.Data.DataTable>. Ogni relazione viene quindi utilizzata come argomento in di <xref:System.Data.DataRow.GetParentRows%2A> metodo il <xref:System.Data.DataRow> per restituire una matrice di righe. Viene quindi stampato il valore di ogni colonna nella riga.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo spazio dei nomi per la rappresentazione XML dei dati memorizzati nella classe <see cref="T:System.Data.DataTable" />.</summary>
        <value>Prefisso dell'oggetto <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una matrice di colonne che agiscono da chiavi primarie della tabella di dati.</summary>
        <value>Matrice di oggetti <see cref="T:System.Data.DataColumn" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiave primaria di una tabella deve essere univoca per identificare il record nella tabella. È inoltre possibile disporre di una tabella con una chiave primaria costituita da due o più colonne. Questo errore si verifica quando una singola colonna non può contenere valori univoci sufficienti. Ad esempio, una chiave primaria con due colonne può essere costituito da una colonna "FirstName" e "Cognome". Poiché le chiavi primarie possono essere composto da più di una colonna, il <xref:System.Data.DataTable.PrimaryKey%2A> proprietà è costituito da una matrice di <xref:System.Data.DataColumn> oggetti.  
  
   
  
## Examples  
 Nel primo esempio viene illustrato come restituire le colonne chiave primaria per una <xref:System.Data.DataTable> visualizzati in un `DataGrid`. Nel secondo esempio viene illustrato come impostare le colonne chiave primaria per una <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">La chiave è una chiave esterna.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge i dati e lo schema XML nell'oggetto <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o dati e schema in un <xref:System.Data.DataTable> da un documento XML, mentre il <xref:System.Data.DataTable.ReadXmlSchema%2A> metodo legge solo lo schema. Per leggere i dati e schema, utilizzare uno del `ReadXML` overload che includono il `XmlReadMode` parametro e impostarne il valore su `ReadSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere dati XML, oppure lo schema e dati dal `DataTable`, utilizzare il `WriteXml` metodo. Per scrivere solo lo schema, utilizzare il `WriteXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Oggetto derivato dalla classe <see cref="T:System.IO.Stream" />.</param>
        <summary>Legge i dati e lo schema XML nella classe <see cref="T:System.Data.DataTable" /> utilizzando la classe <see cref="T:System.IO.Stream" /> specificata.</summary>
        <returns>Modalità <see cref="T:System.Data.XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Data.DataTable> e relativi discendenti vengono caricati con i dati dall'oggetto fornito <xref:System.IO.Stream>. Il comportamento di questo metodo è identico a quello del <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> (metodo), tranne che in questo caso, i dati vengono caricati solo per la tabella corrente e dei relativi discendenti.  
  
 Il <xref:System.Data.DataTable.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o dati e schema in un <xref:System.Data.DataTable> da un documento XML, mentre il <xref:System.Data.DataTable.ReadXmlSchema%2A> metodo legge solo lo schema.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere dati XML, oppure lo schema e dati dal `DataTable`, utilizzare il `WriteXml` metodo. Per scrivere solo lo schema, utilizzare il `WriteXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati), viene generata un'eccezione.  
  
 Se viene specificato alcuno schema di in linea, la struttura relazionale viene esteso tramite inferenza, se necessario, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML di corrispondente `DataColumn` o `DataTable` caratteri XML validi come ("_") quando vengono sottoposti a escape nel XML serializzato. Il `DataSet` delle sequenze di escape solo caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nel nome dell'elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Data.DataTable> contenente due colonne e righe di dieci. Nell'esempio viene scritto il <xref:System.Data.DataTable> schema e i dati in un flusso di memoria, richiamando il <xref:System.Data.DataTable.WriteXml%2A> metodo. Nell'esempio viene creato un secondo <xref:System.Data.DataTable> e chiama il <xref:System.Data.DataTable.ReadXml%2A> metodo per riempirla con schema e dati.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Oggetto <see cref="T:System.IO.TextReader" /> che verrà utilizzato per leggere i dati.</param>
        <summary>Legge i dati e lo schema XML nella classe <see cref="T:System.Data.DataTable" /> utilizzando la classe <see cref="T:System.IO.TextReader" /> specificata.</summary>
        <returns>Modalità <see cref="T:System.Data.XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Data.DataTable> e relativi discendenti vengono caricati con i dati dall'oggetto fornito <xref:System.IO.TextReader>. Il comportamento di questo metodo è identico a quello del <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> (metodo), tranne che in questo caso, i dati vengono caricati solo per la tabella corrente e dei relativi discendenti.  
  
 Il <xref:System.Data.DataTable.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o dati e schema in un <xref:System.Data.DataTable> da un documento XML, mentre il <xref:System.Data.DataTable.ReadXmlSchema%2A> metodo legge solo lo schema.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere dati XML, oppure lo schema e dati dal `DataTable`, utilizzare il `WriteXml` metodo. Per scrivere solo lo schema, utilizzare il `WriteXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati), viene generata un'eccezione.  
  
 Se viene specificato alcuno schema di in linea, la struttura relazionale viene esteso tramite inferenza, se necessario, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML di corrispondente `DataColumn` o `DataTable` caratteri XML validi come ("_") quando vengono sottoposti a escape nel XML serializzato. Il `DataSet` delle sequenze di escape solo caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nel nome dell'elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Data.DataTable> contenente due colonne e righe di dieci. Nell'esempio viene scritto il <xref:System.Data.DataTable> schema e i dati in un flusso di memoria, richiamando il <xref:System.Data.DataTable.WriteXml%2A> metodo. Nell'esempio viene creato un secondo <xref:System.Data.DataTable> e chiama il <xref:System.Data.DataTable.ReadXml%2A> metodo per riempirla con schema e dati.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file dal quale leggere i dati.</param>
        <summary>Legge i dati e lo schema XML nella classe <see cref="T:System.Data.DataTable" /> dal file specificato.</summary>
        <returns>Modalità <see cref="T:System.Data.XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Data.DataTable> e relativi discendenti vengono caricati con i dati nel file denominato nella classe fornita <xref:System.String>. Il comportamento di questo metodo è identico a quello del <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> (metodo), tranne che in questo caso, i dati vengono caricati solo per la tabella corrente e dei relativi discendenti.  
  
 Il <xref:System.Data.DataTable.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o dati e schema in un <xref:System.Data.DataTable> da un documento XML, mentre il <xref:System.Data.DataTable.ReadXmlSchema%2A> metodo legge solo lo schema.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere dati XML, oppure lo schema e dati dal `DataTable`, utilizzare il `WriteXml` metodo. Per scrivere solo lo schema, utilizzare il `WriteXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati), viene generata un'eccezione.  
  
 Se viene specificato alcuno schema di in linea, la struttura relazionale viene esteso tramite inferenza, se necessario, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML di corrispondente `DataColumn` o `DataTable` caratteri XML validi come ("_") quando vengono sottoposti a escape nel XML serializzato. Il `DataSet` delle sequenze di escape solo caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nel nome dell'elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Data.DataTable> contenente due colonne e righe di dieci. Nell'esempio viene scritto il <xref:System.Data.DataTable> schema e i dati su disco. Nell'esempio viene creato un secondo <xref:System.Data.DataTable> e chiama il <xref:System.Data.DataTable.ReadXml%2A> metodo per riempirla con schema e dati.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Oggetto <see cref="T:System.Xml.XmlReader" /> che verrà utilizzato per leggere i dati.</param>
        <summary>Legge i dati e lo schema XML nell'oggetto <see cref="T:System.Data.DataTable" /> utilizzando l'oggetto <see cref="T:System.Xml.XmlReader" /> specificato.</summary>
        <returns>Modalità <see cref="T:System.Data.XmlReadMode" /> utilizzata per leggere i dati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Data.DataTable> e relativi discendenti vengono caricati con i dati nel file denominato nella classe fornita <xref:System.Xml.XmlReader>. Il comportamento di questo metodo è identico a quello del <xref:System.Data.DataTable.ReadXml%2A> (metodo), tranne che in questo caso, i dati vengono caricati solo per la tabella corrente e dei relativi discendenti.  
  
 Il <xref:System.Data.DataTable.ReadXml%2A> metodo fornisce un modo per leggere solo i dati o dati e schema in un <xref:System.Data.DataTable> da un documento XML, mentre il <xref:System.Data.DataTable.ReadXmlSchema%2A> metodo legge solo lo schema.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.WriteXml%2A> e <xref:System.Data.DataTable.WriteXmlSchema%2A> metodi, rispettivamente. Per scrivere dati XML, oppure lo schema e dati dal `DataTable`, utilizzare il `WriteXml` metodo. Per scrivere solo lo schema, utilizzare il `WriteXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Se viene specificato uno schema inline, lo schema inline viene utilizzato per estendere la struttura relazionale esistente prima di caricare i dati. Se sono presenti conflitti (ad esempio, la stessa colonna nella stessa tabella definita con diversi tipi di dati), viene generata un'eccezione.  
  
 Se viene specificato alcuno schema di in linea, la struttura relazionale viene esteso tramite inferenza, se necessario, in base alla struttura del documento XML. Se lo schema non può essere esteso tramite inferenza per esporre tutti i dati, viene generata un'eccezione.  
  
> [!NOTE]
>  Il `DataSet` non associa un elemento XML di corrispondente `DataColumn` o `DataTable` caratteri XML validi come ("_") quando vengono sottoposti a escape nel XML serializzato. Il `DataSet` delle sequenze di escape solo caratteri XML non validi nei nomi degli elementi XML e pertanto può utilizzare solo lo stesso. Quando vengono sottoposti a escape caratteri validi nel nome dell'elemento XML, l'elemento viene ignorato durante l'elaborazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Data.DataTable> contenente due colonne e righe di dieci. Nell'esempio viene scritto il <xref:System.Data.DataTable> schemi e dati a un <xref:System.Xml.XmlReader>. Nell'esempio viene creato un secondo <xref:System.Data.DataTable> e chiama il <xref:System.Data.DataTable.ReadXml%2A> metodo per riempirla con schema e dati dal <xref:System.Xml.XmlReader> istanza.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge un XML Schema in <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il `ReadXmlSchema` metodo per creare lo schema per un <xref:System.Data.DataTable>. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Per scrivere uno schema di un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo.  
  
 Lo schema XML viene interpretato in base XSD standard.  
  
 Il `ReadXmlSchema` metodo in genere viene richiamato prima di richiamare il <xref:System.Data.DataTable.ReadXml%2A> metodo utilizzato per riempire il <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flusso utilizzato per leggere lo schema.</param>
        <summary>Legge uno schema XML nella classe <see cref="T:System.Data.DataTable" />, utilizzando il flusso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.ReadXmlSchema%2A> metodo per creare lo schema per un <xref:System.Data.DataTable>. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Per scrivere uno schema di un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo.  
  
 Lo schema XML viene interpretato in base XSD standard.  
  
 Il danneggiamento dei dati può verificarsi se il DataType e i tipi xs: Type non corrispondono. Verrà generata alcuna eccezione.  
  
 Il `ReadXmlSchema` metodo in genere viene richiamato prima di richiamare il <xref:System.Data.DataTable.ReadXml%2A> metodo utilizzato per riempire il <xref:System.Data.DataTable>.  
  
 Per creare una relazione annidata utilizzando lo schema XML, usare elementi nidificati impliciti. È anche possibile configurare la relazione annidata per l'utilizzo di nomi di colonna espliciti. Gli elementi devono essere nidificati in modo implicito in ordine per il corrispondente DataTable deve far parte di una relazione annidata.  
  
   
  
## Examples  
 La seguente applicazione console crea un nuovo <xref:System.Data.DataTable>e scrive lo schema per la tabella a un <xref:System.IO.MemoryStream>. Quindi, nell'esempio viene creato un nuovo <xref:System.Data.DataTable> e legge lo schema dallo schema XML salvato.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Classe <see cref="T:System.IO.TextReader" /> utilizzata per leggere le informazioni dello schema.</param>
        <summary>Legge uno schema XML nella classe <see cref="T:System.Data.DataTable" />, utilizzando la classe <see cref="T:System.IO.TextReader" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.ReadXmlSchema%2A> metodo per creare lo schema per un <xref:System.Data.DataTable>. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Per scrivere uno schema di un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo.  
  
 Lo schema XML viene interpretato in base XSD standard.  
  
 Il danneggiamento dei dati può verificarsi se il DataType e i tipi xs: Type non corrispondono. Verrà generata alcuna eccezione.  
  
 Il `ReadXmlSchema` metodo in genere viene richiamato prima di richiamare il <xref:System.Data.DataTable.ReadXml%2A> metodo utilizzato per riempire il <xref:System.Data.DataTable>.  
  
 Per creare una relazione annidata utilizzando lo schema XML, usare elementi nidificati impliciti. È anche possibile riconfigurare la relazione annidata per l'utilizzo di nomi di colonna espliciti. Gli elementi devono essere nidificati in modo implicito in ordine per il corrispondente DataTable deve far parte di una relazione annidata.  
  
   
  
## Examples  
 La seguente applicazione console crea un nuovo <xref:System.Data.DataTable>e scrive lo schema per la tabella a un <xref:System.IO.MemoryStream>. Quindi, nell'esempio viene creato un nuovo <xref:System.Data.DataTable> e viene letto lo schema dallo schema XML salvato, utilizzando un <xref:System.IO.StreamReader> (che eredita da <xref:System.IO.TextReader>) come origine.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file dal quale leggere le informazioni dello schema.</param>
        <summary>Legge uno schema XML nella classe <see cref="T:System.Data.DataTable" /> dal file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.ReadXmlSchema%2A> metodo per creare lo schema per un <xref:System.Data.DataTable>. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Per scrivere uno schema di un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo.  
  
 Lo schema XML viene interpretato in base XSD standard.  
  
 Il danneggiamento dei dati può verificarsi se il DataType e i tipi xs: Type non corrispondono. Verrà generata alcuna eccezione.  
  
 Il `ReadXmlSchema` metodo in genere viene richiamato prima di richiamare il <xref:System.Data.DataTable.ReadXml%2A> metodo utilizzato per riempire il `DataTable`.  
  
 Per creare una relazione annidata utilizzando lo schema XML, usare elementi nidificati impliciti. È anche possibile riconfigurare la relazione annidata per l'utilizzo di nomi di colonna espliciti. Gli elementi devono essere nidificati in modo implicito in ordine per il corrispondente DataTable deve far parte di una relazione annidata.  
  
   
  
## Examples  
 La seguente applicazione console crea un nuovo <xref:System.Data.DataTable>e scrive lo schema per la tabella in un file. Quindi, nell'esempio viene creato un nuovo <xref:System.Data.DataTable> e viene letto lo schema dallo schema XML salvato, utilizzando il file come origine.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Classe <see cref="T:System.Xml.XmlReader" /> utilizzata per leggere le informazioni dello schema.</param>
        <summary>Legge uno schema XML nella classe <see cref="T:System.Data.DataTable" />, utilizzando la classe <see cref="T:System.Xml.XmlReader" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.ReadXmlSchema%2A> metodo per creare lo schema per un <xref:System.Data.DataTable>. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Per scrivere uno schema di un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo.  
  
 Lo schema XML viene interpretato in base XSD standard.  
  
 Il danneggiamento dei dati può verificarsi se il DataType e i tipi xs: Type non corrispondono. Verrà generata alcuna eccezione.  
  
 Il `ReadXmlSchema` metodo in genere viene richiamato prima di richiamare il <xref:System.Data.DataTable.ReadXml%2A> metodo utilizzato per riempire il <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Per creare una relazione annidata utilizzando lo schema XML consiste nel disporre di elementi nidificati impliciti. Inoltre, la relazione nidificata potrebbe essere nuovamente cablata, utilizzare nomi di colonna espliciti. È obbligatoria, gli elementi devono essere annidato in modo implicito per DataTable corrispondente deve far parte di una relazione annidata.  
  
   
  
## Examples  
 La seguente applicazione console crea un nuovo <xref:System.Data.DataTable>e scrive lo schema per la tabella a un <xref:System.IO.MemoryStream>. Quindi, nell'esempio viene creato un nuovo <xref:System.Data.DataTable> e viene letto lo schema dallo schema XML salvato, utilizzando un <xref:System.Xml.XmlTextReader> (che eredita da <xref:System.Xml.XmlReader>) come origine.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Un oggetto <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Legge da un flusso XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla tutte le modifiche apportate alla tabella dal momento in cui è stata caricata oppure dall'ultima volta in cui è stato chiamato il metodo <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Data.DataTable.RejectChanges%2A> viene chiamato, ogni <xref:System.Data.DataRow> annullate le modifiche di oggetti che sono ancora in modalità di modifica. Le nuove righe vengono rimosse. Le righe con la <xref:System.Data.DataRowState> impostato su `Modified` o `Deleted` viene ripristinato lo stato originale.  
  
   
  
## Examples  
 Nell'esempio seguente viene apportate diverse modifiche a un <xref:System.Data.DataTable>, ma le modifiche vengono rifiutate richiamando il <xref:System.Data.DataTable.RejectChanges%2A> metodo.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il formato di serializzazione.</summary>
        <value>Enumerazione <see cref="T:System.Data.SerializationFormat" /> che specifica la serializzazione <see langword="Binary" /> o <see langword="Xml" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ripristina lo stato originale della classe <see cref="T:System.Data.DataTable" />. Reimposta rimuove tutti i dati, gli indici, le relazioni e le colonne della tabella. Se un oggetto DataSet include un oggetto DataTable, la tabella farà ancora parte del DataSet dopo che viene reimpostata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica dopo la modifica di un oggetto <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere [gestione di eventi DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica durante la modifica di un oggetto <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere [gestione di eventi DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato dopo l'eliminazione di una riga nella tabella.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere [gestione di eventi DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato prima dell'eliminazione di una riga nella tabella.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere [gestione di eventi DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di righe che appartengono a questa tabella.</summary>
        <value>Insieme <see cref="T:System.Data.DataRowCollection" /> contenente gli oggetti <see cref="T:System.Data.DataRow" />; in caso contrario, valore null se non esiste alcun oggetto <see cref="T:System.Data.DataRow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per creare un nuovo <xref:System.Data.DataRow>, è necessario utilizzare il <xref:System.Data.DataTable.NewRow%2A> per restituire un nuovo oggetto. Tale oggetto viene configurato automaticamente in base allo schema definito per il <xref:System.Data.DataTable> tramite la raccolta di <xref:System.Data.DataColumn> oggetti. Dopo aver creato una nuova riga e impostare i valori per ogni colonna nella riga, aggiungere la riga di <xref:System.Data.DataRowCollection> utilizzando il `Add` metodo.  
  
 Ogni <xref:System.Data.DataRow> nella raccolta rappresenta una riga di dati della tabella. Per eseguire il commit di una modifica al valore di una colonna nella riga, è necessario richiamare il <xref:System.Data.DataTable.AcceptChanges%2A> metodo.  
  
   
  
## Examples  
 Di seguito sono riportati due esempi di restituzione e l'impostazione di righe. Il primo esempio viene utilizzata la <xref:System.Data.DataTable.Rows%2A> proprietà e stampa il valore di ogni colonna per ogni riga. Il secondo esempio viene utilizzato il <xref:System.Data.DataTable> dell'oggetto <xref:System.Data.DataTable.NewRow%2A> metodo per creare un nuovo <xref:System.Data.DataRow> oggetto con lo schema del <xref:System.Data.DataTable>. Dopo aver impostato i valori di riga, viene aggiunta la riga per il <xref:System.Data.DataRowCollection> tramite il `Add` metodo.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene una matrice di oggetti <see cref="T:System.Data.DataRow" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una matrice di tutti gli oggetti <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per garantire l'ordinamento corretto, specificare i criteri di ordinamento con <xref:System.Data.DataTable.Select%2A> o <xref:System.Data.DataTable.Select%2A>.  
  
   
  
## Examples  
 L'esempio seguente restituisce una matrice di <xref:System.Data.DataRow> oggetti tramite il <xref:System.Data.DataTable.Select%2A> metodo.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Criteri da utilizzare per filtrare le righe. Per esempi di come filtrare le righe, vedere [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/) (Sintassi di DataView RowFilter [C#]).</param>
        <summary>Ottiene una matrice di tutti gli oggetti <see cref="T:System.Data.DataRow" /> che soddisfano i criteri di filtro.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per creare il `filterExpression` argomento, utilizzare le stesse regole valide per il <xref:System.Data.DataColumn> della classe <xref:System.Data.DataColumn.Expression%2A> valore della proprietà per la creazione di filtri.  
  
 Per garantire l'ordinamento corretto, specificare i criteri di ordinamento con <xref:System.Data.DataTable.Select%2A> o <xref:System.Data.DataTable.Select%2A>.  
  
 Se la colonna per il filtro contiene un valore null, non sarà parte del risultato.  
  
   
  
## Examples  
 L'esempio seguente usa un'espressione di filtro per restituire una matrice di <xref:System.Data.DataRow> oggetti.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Criteri da utilizzare per filtrare le righe. Per esempi di come filtrare le righe, vedere [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/) (Sintassi di DataView RowFilter [C#]).</param>
        <param name="sort">Stringa che specifica la colonna e la direzione dell'ordinamento.</param>
        <summary>Ottiene una matrice di tutti gli oggetti <see cref="T:System.Data.DataRow" /> che soddisfano i criteri di filtro, in base al criterio di ordinamento specificato.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Data.DataRow" /> corrispondenti all'espressione di filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Form il `filterExpression` argomento, utilizzare le stesse regole per la creazione di <xref:System.Data.DataColumn> della classe <xref:System.Data.DataColumn.Expression%2A> valore della proprietà. Il `Sort` anche l'argomento utilizza le stesse regole per la creazione della classe <xref:System.Data.DataColumn.Expression%2A> stringhe.  
  
 Se la colonna per il filtro contiene un valore null, non sarà parte del risultato.  
  
   
  
## Examples  
 L'esempio seguente usa un'espressione di filtro per restituire una matrice di <xref:System.Data.DataRow> oggetti.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Criteri da utilizzare per filtrare le righe. Per esempi di come filtrare le righe, vedere [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/) (Sintassi di DataView RowFilter [C#]).</param>
        <param name="sort">Stringa che specifica la colonna e la direzione dell'ordinamento.</param>
        <param name="recordStates">Uno dei valori di <see cref="T:System.Data.DataViewRowState" />.</param>
        <summary>Ottiene una matrice di tutti gli oggetti <see cref="T:System.Data.DataRow" /> che corrispondono al filtro in base all'ordinamento specificato e che corrispondono allo stato specificato.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Form il `filterExpression` argomento, utilizzare le stesse regole per la creazione di <xref:System.Data.DataColumn> della classe <xref:System.Data.DataColumn.Expression%2A> valore della proprietà. Il `Sort` anche l'argomento utilizza le stesse regole per la creazione della classe <xref:System.Data.DataColumn.Expression%2A> stringhe.  
  
 Se la colonna per il filtro contiene un valore null, non sarà parte del risultato.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzato uno stato di record e di espressione di filtro per restituire una matrice di <xref:System.Data.DataRow> oggetti.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto <see cref="T:System.ComponentModel.ISite" /> per l'oggetto <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> per l'oggetto <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siti associano un <xref:System.ComponentModel.Component> per un <xref:System.ComponentModel.Container> e abilitare la comunicazione tra di essi, nonché fornire un modo per il contenitore gestire i relativi componenti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          <see langword="true" /> se l'insieme è costituito da oggetti <see cref="T:System.Collections.IList" />, in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataTable> a un'interfaccia <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Un oggetto <see cref="T:System.Collections.IList" /> che può essere associato a un'origine dati dall'oggetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataTable> a un'interfaccia <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Oggetto <see cref="T:System.Xml.Schema.XmlSchema" /> che descrive la rappresentazione XML dell'oggetto prodotto dal metodo <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> e usato dal metodo <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataSet> a un'interfaccia <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">XmlReader.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataSet> a un'interfaccia <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">XmlWriter.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.DataSet> a un'interfaccia <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica dopo che un oggetto <see cref="T:System.Data.DataTable" /> viene cancellato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.TableCleared> evento viene generato immediatamente dopo che tutte le righe sono state cancellate ma prima che il <xref:System.Data.DataTable.Clear%2A> metodo restituisce il controllo al chiamante. Il <xref:System.Data.DataTable.TableCleared> evento non viene generato se sono presenti eccezioni durante l'operazione di cancellazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica se un oggetto <see cref="T:System.Data.DataTable" /> viene cancellato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.TableClearing> evento viene generato prima dell'elaborazione del <xref:System.Data.DataTable.Clear%2A> inizia l'operazione. Questo evento viene generato sempre quando il <xref:System.Data.DataTable.Clear%2A> metodo viene richiamato, anche se la tabella contiene zero righe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome di <see cref="T:System.Data.DataTable" />.</summary>
        <value>Nome di <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.TableName%2A> viene utilizzata per restituire la tabella dall'elemento padre <xref:System.Data.DataSet> dell'oggetto <xref:System.Data.DataTableCollection> (restituito dal <xref:System.Data.DataSet.Tables%2A> proprietà).  
  
   
  
## Examples  
 Nell'esempio seguente viene stampato il <xref:System.Data.DataTable.TableName%2A> per ogni tabella in una raccolta di <xref:System.Data.DataTable> oggetti.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Viene passato un valore <see langword="null" /> o una stringa vuota ("") e questa tabella appartiene a un insieme.</exception>
        <exception cref="T:System.Data.DuplicateNameException">La tabella appartiene a un insieme nel quale è già presente una tabella con lo stesso nome. Il confronto viene eseguito con distinzione tra maiuscole e minuscole.</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene inserito un nuovo oggetto <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generato dopo un nuovo <xref:System.Data.DataRow> è stato creato utilizzando <xref:System.Data.DataTable.NewRow%2A>. Questo evento viene generato prima richiamato `NewRow` metodo restituisce. Il nuovo <xref:System.Data.DataRow> istanza viene scollegata; non è stato aggiunto alla raccolta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene le proprietà <see cref="P:System.Data.DataTable.TableName" /> e <see cref="P:System.Data.DataTable.DisplayExpression" /> se ne esiste una come stringa concatenata.</summary>
        <returns>Stringa costituita dai valori di <see cref="P:System.Data.DataTable.TableName" /> e <see cref="P:System.Data.DataTable.DisplayExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ottiene il <xref:System.Data.DataTable.TableName%2A> e <xref:System.Data.DataTable.DisplayExpression%2A> per il <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Nell'esempio seguente viene restituito il <xref:System.Data.DataTable.TableName%2A> e <xref:System.Data.DataTable.DisplayExpression%2A> utilizzando il <xref:System.Data.DataTable.ToString%2A> metodo.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive i contenuti correnti della classe <see cref="T:System.Data.DataTable" /> come XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che includono il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 La seguente applicazione console crea due <xref:System.Data.DataTable> istanze, ciascuna viene aggiunta a un <xref:System.Data.DataSet>, crea un <xref:System.Data.DataRelation> relative le due tabelle e quindi utilizza il <xref:System.Data.DataTable.WriteXml%2A> metodo per scrivere i dati contenuti all'interno della tabella padre per un <xref:System.IO.TextWriter>. Nell'esempio viene illustrato il comportamento durante l'impostazione di `writeHierarchy` parametro per ognuno dei relativi valori.  
  
> [!NOTE]
>  In questo esempio viene illustrato come utilizzare una delle versioni di overload di WriteXml. Per altri esempi che potrebbero essere disponibili, vedere gli argomenti di overload singoli.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 Nell'esempio viene visualizzato il seguente output nella finestra della console:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Il flusso in cui vengono scritti i dati.</param>
        <summary>Scrive il contenuto corrente dell'oggetto <see cref="T:System.Data.DataTable" /> come XML usando l'oggetto <see cref="T:System.IO.Stream" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> con cui scrivere il contenuto.</param>
        <summary>Scrive il contenuto corrente dell'oggetto <see cref="T:System.Data.DataTable" /> come XML usando l'oggetto <see cref="T:System.IO.TextWriter" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">File in cui scrivere i dati XML.</param>
        <summary>Scrive i contenuti correnti della classe <see cref="T:System.Data.DataTable" /> come XML tramite il file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Classe <see cref="T:System.Xml.XmlWriter" /> con cui scrivere i contenuti.</param>
        <summary>Scrive il contenuto corrente dell'oggetto <see cref="T:System.Data.DataTable" /> come XML usando l'oggetto <see cref="T:System.Xml.XmlWriter" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che includono il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Il flusso in cui vengono scritti i dati.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto il contenuto della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), vengono scritti solo i dati per la tabella corrente.</param>
        <summary>Scrive il contenuto corrente dell'oggetto <see cref="T:System.Data.DataTable" /> come XML usando l'oggetto <see cref="T:System.IO.Stream" /> specificato. Per salvare i dati per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
 In genere il `WriteXml` metodo scrive i dati solo per la tabella corrente. Per scrivere i dati per la tabella corrente e tutti i discendenti, le tabelle correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Il flusso in cui vengono scritti i dati.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataTable" /> nel file specificato utilizzando l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificato. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> con cui scrivere il contenuto.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto il contenuto della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), vengono scritti solo i dati per la tabella corrente.</param>
        <summary>Scrive il contenuto corrente dell'oggetto <see cref="T:System.Data.DataTable" /> come XML usando l'oggetto <see cref="T:System.IO.TextWriter" /> specificato. Per salvare i dati per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 In genere il `WriteXml` metodo scrive i dati solo per la tabella corrente. Per scrivere i dati per la tabella corrente e le relative tabelle correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 La seguente applicazione console crea due <xref:System.Data.DataTable> istanze, ciascuna viene aggiunta a un <xref:System.Data.DataSet>, crea un <xref:System.Data.DataRelation> relative le due tabelle e quindi utilizza il <xref:System.Data.DataTable.WriteXml%2A> metodo per scrivere i dati contenuti all'interno della tabella padre per un <xref:System.IO.TextWriter>. Nell'esempio viene illustrato il comportamento durante l'impostazione di `writeHierarchy` parametro `true`.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Classe <see cref="T:System.IO.TextWriter" /> utilizzata per scrivere il documento.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataTable" /> utilizzando l'oggetto <see cref="T:System.IO.TextWriter" /> e l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificati. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">File in cui scrivere i dati XML.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto il contenuto della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), vengono scritti solo i dati per la tabella corrente.</param>
        <summary>Scrive i contenuti correnti della classe <see cref="T:System.Data.DataTable" /> come XML tramite il file specificato. Per salvare i dati per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
 In genere il `WriteXml` metodo scrive i dati solo per la tabella corrente. Per scrivere i dati per la tabella corrente e tutti i discendenti, le tabelle correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file in cui vengono scritti i dati.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per la classe <see cref="T:System.Data.DataTable" /> utilizzando il file specificato e l'enumerazione <see cref="T:System.Data.XmlWriteMode" />. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che includono il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Classe <see cref="T:System.Xml.XmlWriter" /> con cui scrivere i contenuti.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto il contenuto della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), vengono scritti solo i dati per la tabella corrente.</param>
        <summary>Scrive il contenuto corrente dell'oggetto <see cref="T:System.Data.DataTable" /> come XML usando l'oggetto <see cref="T:System.Xml.XmlWriter" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che includono il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
 In genere il `WriteXml` metodo scrive i dati solo per la tabella corrente. Per scrivere i dati per la tabella corrente e le relative tabelle derivate correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Classe <see cref="T:System.Xml.XmlWriter" /> utilizzata per scrivere il documento.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataTable" /> utilizzando l'oggetto <see cref="T:System.Xml.XmlWriter" /> e l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificati. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che includono il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Il flusso in cui vengono scritti i dati.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto il contenuto della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), vengono scritti solo i dati per la tabella corrente.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataTable" /> nel file specificato utilizzando l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificato. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />. Per salvare i dati per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un `DataTable` in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il `XmlWriteMode` parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
 In genere, il `WriteXml` metodo salva i dati solo per la tabella corrente. Il `WriteXml` metodo fornisce un modo per scrivere solo i dati o dati e schema da un `DataTable` in un documento XML, mentre il `WriteXmlSchema` metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il `XmlWriteMode` parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
 In genere il `WriteXml` metodo scrive i dati solo per la tabella corrente. Per scrivere i dati per la tabella corrente e tutti i discendenti, le tabelle correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Classe <see cref="T:System.IO.TextWriter" /> utilizzata per scrivere il documento.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto il contenuto della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), vengono scritti solo i dati per la tabella corrente.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataTable" /> utilizzando l'oggetto <see cref="T:System.IO.TextWriter" /> e l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificati. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />. Per salvare i dati per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
 In genere, il `WriteXml` metodo salva i dati solo per la tabella corrente. Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che include il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
 In genere il `WriteXml` metodo scrive i dati solo per la tabella corrente. Per scrivere i dati per la tabella corrente e tutti i discendenti, le tabelle correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 La seguente applicazione console crea due <xref:System.Data.DataTable> istanze, ciascuna viene aggiunta a un <xref:System.Data.DataSet>, crea un <xref:System.Data.DataRelation> relative le due tabelle e quindi utilizza il <xref:System.Data.DataTable.WriteXml%2A> metodo per scrivere i dati contenuti all'interno della tabella padre per un <xref:System.IO.TextWriter>. Nell'esempio viene illustrato il comportamento durante l'impostazione di `writeHierarchy` parametro per ognuno dei relativi valori.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 Nell'esempio viene visualizzato il seguente output nella finestra della console:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file in cui vengono scritti i dati.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto il contenuto della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), vengono scritti solo i dati per la tabella corrente.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per la classe <see cref="T:System.Data.DataTable" /> utilizzando il file specificato e l'enumerazione <see cref="T:System.Data.XmlWriteMode" />. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />. Per salvare i dati per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che includono il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
 In genere, il `WriteXml` metodo salva i dati solo per la tabella corrente. Se si desidera salvare i dati per la tabella corrente e tutti gli schemi, il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che includono il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
 In genere il `WriteXml` metodo scrive i dati solo per la tabella corrente. Per scrivere i dati per la tabella corrente e tutte le tabelle correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Classe <see cref="T:System.Xml.XmlWriter" /> utilizzata per scrivere il documento.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto il contenuto della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), vengono scritti solo i dati per la tabella corrente.</param>
        <summary>Scrive i dati correnti e, facoltativamente, lo schema per l'oggetto <see cref="T:System.Data.DataTable" /> utilizzando l'oggetto <see cref="T:System.Xml.XmlWriter" /> e l'oggetto <see cref="T:System.Data.XmlWriteMode" /> specificati. Per scrivere lo schema, impostare il valore del parametro <paramref name="mode" /> su <see langword="WriteSchema" />. Per salvare i dati per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.DataTable.WriteXml%2A> metodo fornisce un modo per scrivere solo i dati o dati e schema da un <xref:System.Data.DataTable> in un documento XML, mentre il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo scrive solo lo schema. Per scrivere dati e schema, utilizzare uno degli overload che includono il <xref:System.Data.XmlWriteMode> parametro e impostarne il valore su `WriteSchema`.  
  
 Si noti che lo stesso vale per il <xref:System.Data.DataTable.ReadXml%2A> e <xref:System.Data.DataTable.ReadXmlSchema%2A> metodi, rispettivamente. Per leggere i dati XML, oppure lo schema e dati di `DataTable`, utilizzare il `ReadXml` (metodo). Per leggere solo lo schema, utilizzare il `ReadXmlSchema` metodo.  
  
 In genere il `WriteXml` metodo scrive i dati solo per la tabella corrente. Per scrivere i dati per la tabella corrente e le relative tabelle derivate correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> se in un tipo di colonna, verrà generata la `DataRow` da cui leggere o scrivere implementa <xref:System.Dynamic.IDynamicMetaObjectProvider> e non implementa <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive la struttura dei dati correnti della classe <see cref="T:System.Data.DataTable" /> come schema XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
   
  
## Examples  
 La seguente applicazione console crea due <xref:System.Data.DataTable> istanze, ciascuna viene aggiunta a un <xref:System.Data.DataSet>, crea un <xref:System.Data.DataRelation> relative le due tabelle e quindi utilizza il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere i dati contenuti all'interno della tabella padre per un <xref:System.IO.TextWriter>. Nell'esempio viene illustrato il comportamento durante l'impostazione di `writeHierarchy` parametro per ognuno dei relativi valori.  
  
> [!NOTE]
>  In questo esempio viene illustrato come utilizzare una delle versioni di overload di `WriteXmlSchema` per altri esempi che potrebbero essere disponibili, vedere gli argomenti di overload singoli.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 Nell'esempio viene visualizzato il seguente output nella finestra della console:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Il flusso in cui viene scritto lo schema XML.</param>
        <summary>Scrive la struttura dei dati correnti della classe <see cref="T:System.Data.DataTable" /> come schema XML nel flusso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> con cui scrivere.</param>
        <summary>Scrive la struttura dei dati correnti della classe <see cref="T:System.Data.DataTable" /> come schema XML utilizzando la classe <see cref="T:System.IO.TextWriter" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file da utilizzare.</param>
        <summary>Scrive la struttura dei dati correnti della classe <see cref="T:System.Data.DataTable" /> come schema XML nel file specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Xml.XmlWriter" /> da usare.</param>
        <summary>Scrive la struttura dei dati correnti della classe <see cref="T:System.Data.DataTable" /> come schema XML utilizzando la classe <see cref="T:System.Xml.XmlWriter" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Il flusso in cui viene scritto lo schema XML.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto lo schema della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), viene scritto solo lo schema per la tabella corrente.</param>
        <summary>Scrive la struttura dei dati correnti della classe <see cref="T:System.Data.DataTable" /> come schema XML nel flusso specificato. Per salvare lo schema per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
 In genere il `WriteXmlSchema` metodo scrive lo schema solo per la tabella corrente. Per scrivere lo schema per la tabella corrente e le relative tabelle derivate correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> con cui scrivere.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto lo schema della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), viene scritto solo lo schema per la tabella corrente.</param>
        <summary>Scrive la struttura dei dati correnti della classe <see cref="T:System.Data.DataTable" /> come schema XML utilizzando la classe <see cref="T:System.IO.TextWriter" /> specificata. Per salvare lo schema per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
 In genere il `WriteXmlSchema` metodo scrive lo schema solo per la tabella corrente. Per scrivere lo schema per la tabella corrente e le relative tabelle derivate correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
   
  
## Examples  
 La seguente applicazione console crea due <xref:System.Data.DataTable> istanze, ciascuna viene aggiunta a un <xref:System.Data.DataSet>, crea un <xref:System.Data.DataRelation> relative le due tabelle e quindi utilizza il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere i dati contenuti all'interno della tabella padre per un <xref:System.IO.TextWriter>. Nell'esempio viene illustrato il comportamento durante l'impostazione di `writeHierarchy` parametro per ognuno dei relativi valori.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 Nell'esempio viene visualizzato il seguente output nella finestra della console:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome del file da utilizzare.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto lo schema della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), viene scritto solo lo schema per la tabella corrente.</param>
        <summary>Scrive la struttura dei dati correnti della classe <see cref="T:System.Data.DataTable" /> come schema XML nel file specificato. Per salvare lo schema per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
 In genere il `WriteXmlSchema` metodo scrive lo schema solo per la tabella corrente. Per scrivere lo schema per la tabella corrente e le relative tabelle derivate correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Classe <see cref="T:System.Xml.XmlWriter" /> utilizzata per scrivere il documento.</param>
        <param name="writeHierarchy">Se <see langword="true" />, viene scritto lo schema della tabella corrente e tutti i relativi discendenti. Se <see langword="false" /> (valore predefinito), viene scritto solo lo schema per la tabella corrente.</param>
        <summary>Scrive la struttura dei dati correnti della classe <see cref="T:System.Data.DataTable" /> come schema XML utilizzando la classe <see cref="T:System.Xml.XmlWriter" /> specificata. Per salvare lo schema per la tabella e i relativi discendenti, impostare il parametro <paramref name="writeHierarchy" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Data.DataTable.WriteXmlSchema%2A> metodo per scrivere lo schema per un <xref:System.Data.DataTable> a un documento XML. Lo schema include le definizioni di tabella, relazioni e vincoli.  
  
 Lo schema XML viene scritto utilizzando lo standard XSD.  
  
 Per scrivere i dati in un documento XML, utilizzare il <xref:System.Data.DataTable.WriteXml%2A> metodo.  
  
 In genere il `WriteXmlSchema` metodo scrive lo schema solo per la tabella corrente. Per scrivere lo schema per la tabella corrente e le relative tabelle derivate correlate, chiamare il metodo con il `writeHierarchy` parametro impostato su `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>