<Type Name="FocusManager" FullName="System.Windows.Input.FocusManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e1051a2c47fbf0892f35e2ccc3f38ea87cba9a5" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32693854" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class FocusManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit FocusManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.FocusManager" />
  <TypeSignature Language="VB.NET" Value="Public Class FocusManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class FocusManager abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce un insieme di metodi statici, proprietà associate ed eventi per determinare e impostare gli ambiti dello stato attivo e per impostare l'elemento attivo all'interno dell'ambito.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows Presentation Foundation (WPF) sono presenti due concetti riguardanti lo stato attivo: tastiera e lo stato attivo logico.  
  
 Lo stato attivo si riferisce all'elemento che riceve input da tastiera correntemente.  Può esistere un solo elemento con stato attivo della tastiera.  L'elemento con stato attivo della tastiera ha <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> impostato su `true`.  <xref:System.Windows.Input.Keyboard.FocusedElement%2A?displayProperty=nameWithType> Restituisce l'elemento con stato attivo della tastiera.  
  
 Lo stato attivo logico riguarda il <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> all'interno di un ambito specifico dello stato attivo.  
  
 Un ambito attivo è un elemento contenitore che tiene traccia del <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> all'interno dell'ambito.  Per impostazione predefinita, il <xref:System.Windows.Window> classe è un ambito attivo, come il <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classi.  È un elemento che è un ambito attivo <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> impostato su `true`.  
  
 Possono essere presenti più elementi con lo stato attivo logico, ma può esistere solo un elemento con lo stato attivo logico in un ambito singolo stato attivo.  Un elemento con lo stato attivo logico non deve necessariamente lo stato attivo, ma un elemento con stato attivo della tastiera avrà lo stato attivo logico.  È possibile definire un ambito attivo all'interno di un ambito attivo.  In questo caso, può avere l'ambito lo stato attivo padre e ambito figlio attivo un <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType>.  
  
 Lo scenario seguente viene illustrato come modificare lo stato attivo della tastiera e lo stato attivo logico in un'applicazione WPF con un <xref:System.Windows.Window> con un <xref:System.Windows.Controls.TextBox> e una <xref:System.Windows.Controls.Menu> che presenta un <xref:System.Windows.Controls.MenuItem>.  Quando lo stato attivo passa dal <xref:System.Windows.Controls.TextBox> per il <xref:System.Windows.Controls.MenuItem>, <xref:System.Windows.Controls.TextBox> perde lo stato attivo della tastiera ma mantiene lo stato attivo logico per il <xref:System.Windows.Window> ambito dello stato attivo.  Il <xref:System.Windows.Controls.MenuItem> Ottiene lo stato attivo e lo stato attivo logico per il <xref:System.Windows.Controls.Menu> ambito dello stato attivo.  Quando viene restituito lo stato attivo alla radice <xref:System.Windows.Window>, l'elemento in <xref:System.Windows.Window> ambito lo stato attivo con lo stato attivo logico otterrà lo stato attivo, ovvero in questo caso il <xref:System.Windows.Controls.TextBox>.  Il <xref:System.Windows.Controls.TextBox> include ora lo stato attivo e lo stato attivo logico.  Il <xref:System.Windows.Controls.MenuItem> perde lo stato attivo della tastiera, ma mantiene lo stato attivo logico per il <xref:System.Windows.Controls.Menu> ambito dello stato attivo.  
  
 Il valore predefinito di <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> su un <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, e <xref:System.Windows.Controls.ContextMenu> è `true`.  
  
 Per ulteriori informazioni sullo stato attivo, vedere il [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) e [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Oggetto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> in ascolto su questo evento.</param>
        <param name="handler">Gestore eventi da aggiungere.</param>
        <summary>Aggiunge un gestore per l'evento associato <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Oggetto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> in ascolto su questo evento.</param>
        <param name="handler">Gestore eventi da aggiungere.</param>
        <summary>Aggiunge un gestore per l'evento associato <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElement">
      <MemberSignature Language="C#" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="ILAsm" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.FocusedElement" />
      <MemberSignature Language="VB.NET" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElementProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusedElementProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusedElementProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusedElementProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusedElementProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà associata <see cref="P:System.Windows.Input.FocusManager.FocusedElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFocusedElement">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement GetFocusedElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.IInputElement GetFocusedElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusedElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusedElement (element As DependencyObject) As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::IInputElement ^ GetFocusedElement(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">L'elemento con lo stato attivo logico all'interno dell'ambito dello stato attivo specificato.</param>
        <summary>Ottiene l'elemento con lo stato attivo logico all'interno dell'ambito dello stato attivo specificato.</summary>
        <returns>L'elemento all'interno dell'ambito dello stato attivo specificato con lo stato attivo logico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Input.FocusManager.FocusedElement%2A> è l'elemento che ha lo stato attivo logico per un ambito specifico dello stato attivo.  Questo oggetto può non avere stato attivo della tastiera o.  Lo stato attivo fa riferimento all'elemento che riceve l'input da tastiera.  Per ulteriori informazioni sullo stato attivo, lo stato attivo e lo stato attivo logico, vedere il [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Se `element` non è un ambito attivo, questo metodo restituirà `null`.  
  
 Utilizzare <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>per specificare l'elemento con lo stato attivo logico in un ambito attivo specificato.  
  
   
  
## Examples  
 Nell'esempio seguente imposta l'elemento con lo stato attivo logico utilizzando il <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> e si ottiene l'elemento con lo stato attivo logico utilizzando il <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFocusScope">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusScope (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">L'elemento per il quale ottenere l'ambito dello stato attivo più vicino.</param>
        <summary>Determina il predecessore più vicino dell'elemento specificato per cui <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> è impostato su <see langword="true" />.</summary>
        <returns>L'ambito dello stato attivo per l'elemento specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito di <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> su un <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> è `true`.  
  
 Un ambito attivo è un elemento contenitore che tiene traccia del <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> all'interno dell'ambito.  Per impostazione predefinita, il <xref:System.Windows.Window> classe è un ambito attivo, come il <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classi.  È un elemento che è un ambito attivo <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> impostato su `true`.  
  
 Per ulteriori informazioni sullo stato attivo, lo stato attivo e lo stato attivo logico, vedere il [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetIsFocusScope">
      <MemberSignature Language="C#" Value="public static bool GetIsFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetIsFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsFocusScope (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Elemento da cui leggere la proprietà associata.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Windows.DependencyObject" /> specificato è un ambito dello stato attivo.</summary>
        <returns>
          <see langword="true" /> se <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> è impostato su <see langword="true" /> in corrispondenza dell'elemento specificato. In caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ambito attivo è un elemento contenitore che tiene traccia del <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> all'interno dell'ambito.  Per impostazione predefinita, il <xref:System.Windows.Window> classe è un ambito attivo, come il <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classi.  È un elemento che è un ambito attivo <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> impostato su `true`.  
  
 Per ulteriori informazioni sullo stato attivo, lo stato attivo e lo stato attivo logico, vedere il [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.GotFocus" />
      <MemberSignature Language="VB.NET" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica l'evento associato <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScope">
      <MemberSignature Language="C#" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="ILAsm" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.IsFocusScope" />
      <MemberSignature Language="VB.NET" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà associata <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore predefinito di <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> su un <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> è `true`.  
  
 Un ambito attivo è un elemento contenitore che tiene traccia del <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> all'interno dell'ambito.  Per impostazione predefinita, il <xref:System.Windows.Window> classe è un ambito attivo, come il <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classi.  È un elemento che è un ambito attivo <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> impostato su `true`.  
  
 Per ulteriori informazioni sullo stato attivo, lo stato attivo e lo stato attivo logico, vedere il [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.LostFocus" />
      <MemberSignature Language="VB.NET" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica l'evento associato <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Oggetto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> in ascolto su questo evento.</param>
        <param name="handler">Gestore eventi da rimuovere.</param>
        <summary>Rimuove un gestore per l'evento associato <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Oggetto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> in ascolto su questo evento.</param>
        <param name="handler">Gestore eventi da rimuovere.</param>
        <summary>Rimuove un gestore per l'evento associato <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFocusedElement">
      <MemberSignature Language="C#" Value="public static void SetFocusedElement (System.Windows.DependencyObject element, System.Windows.IInputElement value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFocusedElement(class System.Windows.DependencyObject element, class System.Windows.IInputElement value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetFocusedElement(System.Windows.DependencyObject,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFocusedElement (element As DependencyObject, value As IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFocusedElement(System::Windows::DependencyObject ^ element, System::Windows::IInputElement ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">L'ambito dello stato attivo in cui rendere l'elemento specificato come <see cref="P:System.Windows.Input.FocusManager.FocusedElement" />.</param>
        <param name="value">Elemento a cui assegnare lo stato attivo logico.</param>
        <summary>Imposta lo stato attivo logico in relazione all'elemento specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Input.FocusManager.FocusedElement%2A> è l'elemento che ha lo stato attivo logico per l'ambito specifico.  Questo oggetto può non avere stato attivo della tastiera o.  Lo stato attivo fa riferimento all'elemento che riceve l'input da tastiera.  Per ulteriori informazioni sullo stato attivo, lo stato attivo e lo stato attivo logico, vedere il [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 È possibile specificare un ambito che è un predecessore dell'ambito lo stato attivo per che l'elemento è incluso.  Ad esempio, se un <xref:System.Windows.Controls.StackPanel> è un ambito attivo e il relativo elemento padre <xref:System.Windows.Window> è un ambito e lo stato attivo un <xref:System.Windows.Controls.TextBox> figlio il <xref:System.Windows.Controls.StackPanel> possibile specificare il <xref:System.Windows.Window> come ambito lo stato attivo quando si chiama <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>.  Il <xref:System.Windows.Controls.TextBox> viene quindi <xref:System.Windows.Input.FocusManager.FocusedElement%2A> per entrambi i <xref:System.Windows.Window> ambito dello stato attivo e <xref:System.Windows.Controls.StackPanel> ambito dello stato attivo.  
  
 <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> fornisce lo stato attivo logico di un elemento specificato nell'ambito specificato lo stato attivo e tenterà di assegnare lo stato attivo della tastiera di elemento.  
  
   
  
## Examples  
 Nell'esempio seguente imposta l'elemento con lo stato attivo logico utilizzando il <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> e si ottiene l'elemento con lo stato attivo logico utilizzando il <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsFocusScope">
      <MemberSignature Language="C#" Value="public static void SetIsFocusScope (System.Windows.DependencyObject element, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsFocusScope(class System.Windows.DependencyObject element, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetIsFocusScope(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsFocusScope (element As DependencyObject, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsFocusScope(System::Windows::DependencyObject ^ element, bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Elemento da rendere ambito dello stato attivo.</param>
        <param name="value">
          <see langword="true" /> se <c>element</c> è un ambito dello stato attivo; in caso contrario, <see langword="false" />.</param>
        <summary>Imposta l'oggetto <see cref="T:System.Windows.DependencyObject" /> specificato come ambito dello stato attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ambito attivo è un elemento contenitore che tiene traccia del <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> all'interno dell'ambito.  Per impostazione predefinita, il <xref:System.Windows.Window> classe è un ambito attivo, come il <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classi.  È un elemento che è un ambito attivo <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> impostato su `true`.  
  
 Per ulteriori informazioni sullo stato attivo, lo stato attivo e lo stato attivo logico, vedere il [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 Nell'esempio seguente un elemento diventa un ambito attivo utilizzando <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A>.  
  
 [!code-csharp[focussnippets#FocusSetIsFocusScope](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focussetisfocusscope)]
 [!code-vb[focussnippets#FocusSetIsFocusScope](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focussetisfocusscope)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>