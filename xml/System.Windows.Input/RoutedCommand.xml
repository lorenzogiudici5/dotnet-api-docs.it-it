<Type Name="RoutedCommand" FullName="System.Windows.Input.RoutedCommand">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d121d70b297e74ddd57378598dec8607d68ad468" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37503881" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedCommand : System.Windows.Input.ICommand" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedCommand extends System.Object implements class System.Windows.Input.ICommand" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.RoutedCommand" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedCommand&#xA;Implements ICommand" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedCommand : System::Windows::Input::ICommand" />
  <TypeSignature Language="F#" Value="type RoutedCommand = class&#xA;    interface ICommand" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommand</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer("System.Windows.Input.CommandValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Defines a command that implements <see cref="T:System.Windows.Input.ICommand" /> and is routed through the element tree.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Input.RoutedCommand.Execute%2A> e <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> metodi su un <xref:System.Windows.Input.RoutedCommand> non contengono la logica dell'applicazione per il comando come nel caso di una tipica <xref:System.Windows.Input.ICommand>, ma piuttosto, questi metodi generano eventi che passano attraverso l'albero degli elementi alla ricerca di un oggetto con un <xref:System.Windows.Input.CommandBinding>.  I gestori eventi associati ai <xref:System.Windows.Input.CommandBinding> contengono la logica di comando.  
  
 Il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo che genera il <xref:System.Windows.Input.CommandManager.PreviewExecuted> e <xref:System.Windows.Input.CommandManager.Executed> eventi.  Il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> metodo che genera il <xref:System.Windows.Input.CommandManager.PreviewCanExecute> e <xref:System.Windows.Input.CommandManager.CanExecute> eventi.  
  
<a name="xamlAttributeUsage_RoutedCommand"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
 \<*object* *property*="*predefinedCommandName*"/>  
  
 \- oppure -  
  
 \<*oggetto* *proprietà*= "*nomeclassepredefinita*.* nomecomandopredefinito*"/ >  
  
 \- oppure -  
  
 \<*oggetto* *proprietà*= "{ *nomeclassepersonalizzata*.* nomecomandopersonalizzato*} "/ >  
  
<a name="xamlValues_RoutedCommand"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *predefinedClassName*  
 Una delle classi di comandi predefiniti.  
  
 *predefinedCommandName*  
 Uno dei comandi predefiniti.  
  
 *customClassName*  
 Una classe personalizzata che contiene il comando personalizzato. Le classi personalizzate richiedono in genere un `xlmns` anteporre al mapping, vedere [spazi dei nomi XAML e Mapping Namespace per XAML WPF](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
 *customCommandName*  
 Un comando personalizzato.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.InputBinding" />
    <altmember cref="T:System.Windows.Input.KeyGesture" />
    <altmember cref="T:System.Windows.Input.MouseGesture" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Input.RoutedCommand" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedCommand();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Input.RoutedCommand" /> class.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.InputBinding" />
        <altmember cref="T:System.Windows.Input.ExecutedRoutedEventArgs" />
        <altmember cref="T:System.Windows.Input.CanExecuteRoutedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedCommand (string name, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.#ctor(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, ownerType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedCommand(System::String ^ name, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.RoutedCommand : string * Type -&gt; System.Windows.Input.RoutedCommand" Usage="new System.Windows.Input.RoutedCommand (name, ownerType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Declared name for serialization.</param>
        <param name="ownerType">The type which is registering the command.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Input.RoutedCommand" /> class with the specified name and owner type.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ownerType" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.InputBinding" />
        <altmember cref="T:System.Windows.Input.ExecutedRoutedEventArgs" />
        <altmember cref="T:System.Windows.Input.CanExecuteRoutedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedCommand (string name, Type ownerType, System.Windows.Input.InputGestureCollection inputGestures);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type ownerType, class System.Windows.Input.InputGestureCollection inputGestures) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.#ctor(System.String,System.Type,System.Windows.Input.InputGestureCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, ownerType As Type, inputGestures As InputGestureCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedCommand(System::String ^ name, Type ^ ownerType, System::Windows::Input::InputGestureCollection ^ inputGestures);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.RoutedCommand : string * Type * System.Windows.Input.InputGestureCollection -&gt; System.Windows.Input.RoutedCommand" Usage="new System.Windows.Input.RoutedCommand (name, ownerType, inputGestures)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="inputGestures" Type="System.Windows.Input.InputGestureCollection" />
      </Parameters>
      <Docs>
        <param name="name">Declared name for serialization.</param>
        <param name="ownerType">The type that is registering the command.</param>
        <param name="inputGestures">Default input gestures associated with this command.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Input.RoutedCommand" /> class with the specified name, owner type, and collection of gestures.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">the length of <paramref name="name" /> is zero  \- or -  <paramref name="ownerType" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.InputBinding" />
        <altmember cref="T:System.Windows.Input.ExecutedRoutedEventArgs" />
        <altmember cref="T:System.Windows.Input.CanExecuteRoutedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="CanExecute">
      <MemberSignature Language="C#" Value="public bool CanExecute (object parameter, System.Windows.IInputElement target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanExecute(object parameter, class System.Windows.IInputElement target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.CanExecute(System.Object,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanExecute (parameter As Object, target As IInputElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanExecute(System::Object ^ parameter, System::Windows::IInputElement ^ target);" />
      <MemberSignature Language="F#" Value="member this.CanExecute : obj * System.Windows.IInputElement -&gt; bool" Usage="routedCommand.CanExecute (parameter, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
        <Parameter Name="target" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="parameter">A user defined data type.</param>
        <param name="target">The command target.</param>
        <summary>Determines whether this <see cref="T:System.Windows.Input.RoutedCommand" /> can execute in its current state.</summary>
        <returns>
          <see langword="true" /> if the command can execute on the current command target; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La logica effettiva che determina se un <xref:System.Windows.Input.RoutedCommand> può essere eseguito su corrente destinazione del comando non è inclusa nel <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> metodi, piuttosto <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> genera le <xref:System.Windows.Input.CommandManager.PreviewCanExecute> e il <xref:System.Windows.Input.CommandManager.CanExecute> eventi di tunneling e bubbling elemento ricerca di un oggetto con struttura ad albero un <xref:System.Windows.Input.CommandBinding>.  Se un <xref:System.Windows.Input.CommandBinding> adatto <xref:System.Windows.Input.RoutedCommand> viene trovato, il <xref:System.Windows.Input.CanExecuteRoutedEventHandler> collegato a <xref:System.Windows.Input.CommandBinding> viene chiamato.  Questi gestori forniscono la logica di programmazione per determinare se il <xref:System.Windows.Input.RoutedCommand> possono eseguire o No.  
  
 Il <xref:System.Windows.Input.CommandManager.PreviewCanExecute> e <xref:System.Windows.Input.CommandManager.PreviewExecuted> gli eventi vengono generati nel <xref:System.Windows.Input.ICommandSource.CommandTarget%2A>.  Se il <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> non è impostato sul <xref:System.Windows.Input.ICommandSource>, il <xref:System.Windows.Input.CommandManager.PreviewCanExecute> e <xref:System.Windows.Input.CommandManager.CanExecute> gli eventi vengono generati sull'elemento con stato attivo della tastiera.  
  
   
  
## Examples  
 L'esempio seguente è un <xref:System.Windows.Input.ICommand.CanExecuteChanged> gestore eventi da un'implementazione personalizzata di <xref:System.Windows.Input.ICommandSource>.  
  
 `this.Command` In questo esempio è il <xref:System.Windows.Input.ICommandSource.Command%2A> proprietà di <xref:System.Windows.Input.ICommandSource>.  Se il comando non è `null`, il comando viene eseguito il cast a un <xref:System.Windows.Input.RoutedCommand>.  Se il comando è un <xref:System.Windows.Input.RoutedCommand>, il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> viene chiamato metodo passando la <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> e il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  Se comando non è un <xref:System.Windows.Input.RoutedCommand>, ne viene eseguito il cast a un <xref:System.Windows.Input.ICommand> e il <xref:System.Windows.Input.ICommand.CanExecute%2A> viene chiamato passando il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  
  
 Se il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> restituzione del metodo `true`, quindi il controllo è abilitato; in caso contrario, il controllo è disabilitato.  
  
 [!code-csharp[ImplementICommandSource#ImplementICommandCanExecuteChanged](~/samples/snippets/csharp/VS_Snippets_Wpf/ImplementICommandSource/CSharp/CommandSlider.cs#implementicommandcanexecutechanged)]
 [!code-vb[ImplementICommandSource#ImplementICommandCanExecuteChanged](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ImplementICommandSource/visualbasic/commandslider.vb#implementicommandcanexecutechanged)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="target" /> is not a <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanExecuteChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CanExecuteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CanExecuteChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.RoutedCommand.CanExecuteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CanExecuteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ CanExecuteChanged;" />
      <MemberSignature Language="F#" Value="member this.CanExecuteChanged : EventHandler " Usage="member this.CanExecuteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when changes to the command source are detected by the command manager. These changes often affect whether the command should execute on the current command target.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Input.RoutedCommand> rimane in ascolto per il <xref:System.Windows.Input.CommandManager.RequerySuggested> evento, che viene generato dal <xref:System.Windows.Input.CommandManager>. Il <xref:System.Windows.Input.CommandManager.RequerySuggested> evento viene generato ogni volta che vengono soddisfatte le condizioni che possono cambiare se eseguire il comando, ad esempio una modifica nello stato attivo della tastiera.  Quando riceve il comando il <xref:System.Windows.Input.CommandManager.RequerySuggested> evento, genera il <xref:System.Windows.Input.RoutedCommand.CanExecuteChanged> evento.  In generale, l'origine del comando sarà in ascolto per questo evento e le query di <xref:System.Windows.Input.RoutedCommand> per mezzo del <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> (metodo).  La maggior parte delle origini dei comandi disabiliterà autonomamente se il comando non può essere eseguito come parte dell'associazione del comando.  Un esempio è quando un <xref:System.Windows.Controls.MenuItem> diventa inattivo quando non è possibile eseguire il comando.  
  
 In alcune situazioni, il <xref:System.Windows.Input.CommandManager> è a conoscenza di una modifica nelle condizioni che cambiano la possibilità di eseguire un comando.  In questi casi, è possibile forzare il <xref:System.Windows.Input.CommandManager> venga generato il <xref:System.Windows.Input.CommandManager.RequerySuggested> evento chiamando il <xref:System.Windows.Input.CommandManager.InvalidateRequerySuggested%2A> (metodo), ciò a sua volta causerà il <xref:System.Windows.Input.RoutedCommand> per generare il <xref:System.Windows.Input.RoutedCommand.CanExecuteChanged> evento.  
  
   
  
## Examples  
 L'esempio seguente è un <xref:System.Windows.Input.ICommand.CanExecuteChanged> gestore eventi da un'implementazione personalizzata di <xref:System.Windows.Input.ICommandSource>.  
  
 `this.Command` In questo esempio è il <xref:System.Windows.Input.ICommandSource.Command%2A> proprietà di <xref:System.Windows.Input.ICommandSource>.  Se il comando non è `null`, il comando viene eseguito il cast a un <xref:System.Windows.Input.RoutedCommand>.  Se il comando è un <xref:System.Windows.Input.RoutedCommand>, il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> viene chiamato metodo passando la <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> e il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  Se comando non è un <xref:System.Windows.Input.RoutedCommand>, ne viene eseguito il cast a un <xref:System.Windows.Input.ICommand> e il <xref:System.Windows.Input.ICommand.CanExecute%2A> viene chiamato passando il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  
  
 Se il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> restituzione del metodo `true`, quindi il controllo è abilitato; in caso contrario, il controllo è disabilitato.  
  
 [!code-csharp[ImplementICommandSource#ImplementICommandCanExecuteChanged](~/samples/snippets/csharp/VS_Snippets_Wpf/ImplementICommandSource/CSharp/CommandSlider.cs#implementicommandcanexecutechanged)]
 [!code-vb[ImplementICommandSource#ImplementICommandCanExecuteChanged](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ImplementICommandSource/visualbasic/commandslider.vb#implementicommandcanexecutechanged)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (object parameter, System.Windows.IInputElement target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(object parameter, class System.Windows.IInputElement target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.Execute(System.Object,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (parameter As Object, target As IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Object ^ parameter, System::Windows::IInputElement ^ target);" />
      <MemberSignature Language="F#" Value="member this.Execute : obj * System.Windows.IInputElement -&gt; unit" Usage="routedCommand.Execute (parameter, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
        <Parameter Name="target" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="parameter">User defined parameter to be passed to the handler.</param>
        <param name="target">Element at which to begin looking for command handlers.</param>
        <summary>Executes the <see cref="T:System.Windows.Input.RoutedCommand" /> on the current command target.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La logica effettiva che esegue la <xref:System.Windows.Input.RoutedCommand> non è inclusa nel <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodi.  <xref:System.Windows.Input.RoutedCommand.Execute%2A> Genera il <xref:System.Windows.Input.CommandManager.PreviewExecuted> e <xref:System.Windows.Input.CommandManager.Executed> degli eventi, che eseguono il tunneling e bubbling attraverso l'elemento di struttura ad albero alla ricerca di un oggetto con un <xref:System.Windows.Input.CommandBinding>.  Se un <xref:System.Windows.Input.CommandBinding> adatto <xref:System.Windows.Input.RoutedCommand> viene trovato, il <xref:System.Windows.Input.ExecutedRoutedEventHandler> collegato a <xref:System.Windows.Input.CommandBinding> viene chiamato.  Questi gestori forniscono la logica di programmazione che esegue il <xref:System.Windows.Input.RoutedCommand>.  
  
 Il <xref:System.Windows.Input.CommandManager.PreviewExecuted> e <xref:System.Windows.Input.CommandManager.Executed> gli eventi vengono generati nel <xref:System.Windows.Input.ICommandSource.CommandTarget%2A>.  Se il <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> non è impostato sul <xref:System.Windows.Input.ICommandSource>, il <xref:System.Windows.Input.CommandManager.PreviewExecuted> e <xref:System.Windows.Input.CommandManager.Executed> gli eventi vengono generati sull'elemento con stato attivo della tastiera.  
  
   
  
## Examples  
 Nell'esempio seguente proviene da un'implementazione personalizzata di <xref:System.Windows.Input.ICommandSource> esempio.  
  
 `this.Command` In questo esempio è la proprietà Command su di <xref:System.Windows.Input.ICommandSource>.  Se il comando non è null, il comando viene eseguito il cast a un <xref:System.Windows.Input.RoutedCommand>.  Se è un <xref:System.Windows.Input.RoutedCommand>, il <xref:System.Windows.Input.RoutedCommand.Execute%2A> viene chiamato metodo passando la <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> e il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  Se il comando non è un <xref:System.Windows.Input.RoutedCommand>, ne viene eseguito il cast a un <xref:System.Windows.Input.ICommand> e il <xref:System.Windows.Input.ICommand.Execute%2A> viene chiamato passando il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  
  
 [!code-csharp[ImplementICommandSource#ImplementICommandExecute](~/samples/snippets/csharp/VS_Snippets_Wpf/ImplementICommandSource/CSharp/CommandSlider.cs#implementicommandexecute)]
 [!code-vb[ImplementICommandSource#ImplementICommandExecute](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ImplementICommandSource/visualbasic/commandslider.vb#implementicommandexecute)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="target" /> is not a <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InputGestures">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputGestureCollection InputGestures { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGestureCollection InputGestures" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.RoutedCommand.InputGestures" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputGestures As InputGestureCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputGestureCollection ^ InputGestures { System::Windows::Input::InputGestureCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputGestures : System.Windows.Input.InputGestureCollection" Usage="System.Windows.Input.RoutedCommand.InputGestures" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGestureCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of <see cref="T:System.Windows.Input.InputGesture" /> objects that are associated with this command.</summary>
        <value>I movimenti di input.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere un nuovo <xref:System.Windows.Input.MouseGesture> a un <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#MouseBindingAddedCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#mousebindingaddedcommand)]
 [!code-vb[commandlibrarysnippets#MouseBindingAddedCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#mousebindingaddedcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputGesture" />
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
        <altmember cref="T:System.Windows.Input.InputBinding" />
        <altmember cref="T:System.Windows.Input.KeyBinding" />
        <altmember cref="T:System.Windows.Input.MouseBinding" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.RoutedCommand.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.Input.RoutedCommand.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the command.</summary>
        <value>Nome del comando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà può essere utilizzata quando si fa riferimento una <xref:System.Windows.Input.RoutedCommand> in [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.RoutedCommand.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.Input.RoutedCommand.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type that is registered with the command.</summary>
        <value>Il tipo del proprietario del comando.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Input.ICommand.CanExecute">
      <MemberSignature Language="C#" Value="bool ICommand.CanExecute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Input.ICommand.CanExecute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.System#Windows#Input#ICommand#CanExecute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CanExecute (parameter As Object) As Boolean Implements ICommand.CanExecute" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Input.ICommand.CanExecute(System::Object ^ parameter) = System::Windows::Input::ICommand::CanExecute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object can be set to <see langword="null" />.</param>
        <summary>For a description of this members, see <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" />.</summary>
        <returns>
          <see langword="true" /> if this command can be executed; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un'implementazione esplicita di un membro di interfaccia. e può essere utilizzato solo quando si esegue il cast dell'istanza di <xref:System.Windows.Input.RoutedCommand> su un'interfaccia <xref:System.Windows.Input.ICommand>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Input.RoutedCommand.CanExecute(System.Object,System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Input.ICommand.Execute">
      <MemberSignature Language="C#" Value="void ICommand.Execute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Input.ICommand.Execute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.System#Windows#Input#ICommand#Execute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Execute (parameter As Object) Implements ICommand.Execute" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Input.ICommand.Execute(System::Object ^ parameter) = System::Windows::Input::ICommand::Execute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object can be set to <see langword="null" />.</param>
        <summary>For a description of this members, see <see cref="M:System.Windows.Input.ICommand.Execute(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un'implementazione esplicita di un membro di interfaccia. e può essere utilizzato solo quando si esegue il cast dell'istanza di <xref:System.Windows.Input.RoutedCommand> su un'interfaccia <xref:System.Windows.Input.ICommand>.  
  
   
  
## Examples  
 Vedere anche  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>