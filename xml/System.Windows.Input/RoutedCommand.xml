<Type Name="RoutedCommand" FullName="System.Windows.Input.RoutedCommand">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="69838ab70178efb709b711eabd99ed189646197e" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48600034" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedCommand : System.Windows.Input.ICommand" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedCommand extends System.Object implements class System.Windows.Input.ICommand" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.RoutedCommand" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedCommand&#xA;Implements ICommand" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedCommand : System::Windows::Input::ICommand" />
  <TypeSignature Language="F#" Value="type RoutedCommand = class&#xA;    interface ICommand" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommand</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer("System.Windows.Input.CommandValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.Windows.Markup.ValueSerializer("System.Windows.Input.CommandValueSerializer, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definisce un comando che implementa <see cref="T:System.Windows.Input.ICommand" /> ed è indirizzato tramite la struttura ad albero dell'elemento.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Input.RoutedCommand.Execute%2A> e <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> metodi su un <xref:System.Windows.Input.RoutedCommand> non contengono la logica dell'applicazione per il comando come nel caso di una tipica <xref:System.Windows.Input.ICommand>, ma piuttosto, questi metodi generano eventi che passano attraverso l'albero degli elementi alla ricerca di un oggetto con un <xref:System.Windows.Input.CommandBinding>.  I gestori eventi associati ai <xref:System.Windows.Input.CommandBinding> contengono la logica di comando.  
  
 Il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo che genera il <xref:System.Windows.Input.CommandManager.PreviewExecuted> e <xref:System.Windows.Input.CommandManager.Executed> eventi.  Il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> metodo che genera il <xref:System.Windows.Input.CommandManager.PreviewCanExecute> e <xref:System.Windows.Input.CommandManager.CanExecute> eventi.  
  
<a name="xamlAttributeUsage_RoutedCommand"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
 \<*object* *property*="*predefinedCommandName*"/>  
  
 \- oppure -  
  
 \<*oggetto* *proprietà*= "*nomeclassepredefinita*.* nomecomandopredefinito*"/ >  
  
 \- oppure -  
  
 \<*oggetto* *proprietà*= "{ *nomeclassepersonalizzata*.* nomecomandopersonalizzato*} "/ >  
  
<a name="xamlValues_RoutedCommand"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *predefinedClassName*  
 Una delle classi di comandi predefiniti.  
  
 *predefinedCommandName*  
 Uno dei comandi predefiniti.  
  
 *customClassName*  
 Una classe personalizzata che contiene il comando personalizzato. Le classi personalizzate richiedono in genere un `xlmns` anteporre al mapping, vedere [spazi dei nomi XAML e Mapping Namespace per XAML WPF](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
 *customCommandName*  
 Un comando personalizzato.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.InputBinding" />
    <altmember cref="T:System.Windows.Input.KeyGesture" />
    <altmember cref="T:System.Windows.Input.MouseGesture" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedCommand();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.InputBinding" />
        <altmember cref="T:System.Windows.Input.ExecutedRoutedEventArgs" />
        <altmember cref="T:System.Windows.Input.CanExecuteRoutedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedCommand (string name, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.#ctor(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, ownerType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedCommand(System::String ^ name, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.RoutedCommand : string * Type -&gt; System.Windows.Input.RoutedCommand" Usage="new System.Windows.Input.RoutedCommand (name, ownerType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nome dichiarato per la serializzazione.</param>
        <param name="ownerType">Tipo che sta registrando il comando.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Input.RoutedCommand" /> con il nome e il tipo di proprietario specificati.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ownerType" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.InputBinding" />
        <altmember cref="T:System.Windows.Input.ExecutedRoutedEventArgs" />
        <altmember cref="T:System.Windows.Input.CanExecuteRoutedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedCommand (string name, Type ownerType, System.Windows.Input.InputGestureCollection inputGestures);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type ownerType, class System.Windows.Input.InputGestureCollection inputGestures) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.#ctor(System.String,System.Type,System.Windows.Input.InputGestureCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, ownerType As Type, inputGestures As InputGestureCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedCommand(System::String ^ name, Type ^ ownerType, System::Windows::Input::InputGestureCollection ^ inputGestures);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.RoutedCommand : string * Type * System.Windows.Input.InputGestureCollection -&gt; System.Windows.Input.RoutedCommand" Usage="new System.Windows.Input.RoutedCommand (name, ownerType, inputGestures)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="inputGestures" Type="System.Windows.Input.InputGestureCollection" />
      </Parameters>
      <Docs>
        <param name="name">Nome dichiarato per la serializzazione.</param>
        <param name="ownerType">Il tipo che registra il comando.</param>
        <param name="inputGestures">Movimenti di input predefiniti associati a questo comando.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Input.RoutedCommand" /> con il nome specificato, il tipo di proprietario e l'insieme di movimenti.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="name" /> è zero. 
\- oppure - 
 <paramref name="ownerType" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.InputBinding" />
        <altmember cref="T:System.Windows.Input.ExecutedRoutedEventArgs" />
        <altmember cref="T:System.Windows.Input.CanExecuteRoutedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="CanExecute">
      <MemberSignature Language="C#" Value="public bool CanExecute (object parameter, System.Windows.IInputElement target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanExecute(object parameter, class System.Windows.IInputElement target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.CanExecute(System.Object,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanExecute (parameter As Object, target As IInputElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanExecute(System::Object ^ parameter, System::Windows::IInputElement ^ target);" />
      <MemberSignature Language="F#" Value="member this.CanExecute : obj * System.Windows.IInputElement -&gt; bool" Usage="routedCommand.CanExecute (parameter, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
        <Parameter Name="target" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="parameter">Tipo di dati definito dall'utente.</param>
        <param name="target">La destinazione del comando.</param>
        <summary>Determina se questo oggetto <see cref="T:System.Windows.Input.RoutedCommand" /> può essere eseguito nello stato corrente.</summary>
        <returns>
          <see langword="true" /> se il comando può essere eseguito in corrispondenza della destinazione corrente del comando. In caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La logica effettiva che determina se un <xref:System.Windows.Input.RoutedCommand> può essere eseguito su corrente destinazione del comando non è inclusa nel <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> metodi, piuttosto <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> genera le <xref:System.Windows.Input.CommandManager.PreviewCanExecute> e il <xref:System.Windows.Input.CommandManager.CanExecute> eventi di tunneling e bubbling elemento ricerca di un oggetto con struttura ad albero un <xref:System.Windows.Input.CommandBinding>.  Se un <xref:System.Windows.Input.CommandBinding> adatto <xref:System.Windows.Input.RoutedCommand> viene trovato, il <xref:System.Windows.Input.CanExecuteRoutedEventHandler> collegato a <xref:System.Windows.Input.CommandBinding> viene chiamato.  Questi gestori forniscono la logica di programmazione per determinare se il <xref:System.Windows.Input.RoutedCommand> possono eseguire o No.  
  
 Il <xref:System.Windows.Input.CommandManager.PreviewCanExecute> e <xref:System.Windows.Input.CommandManager.PreviewExecuted> gli eventi vengono generati nel <xref:System.Windows.Input.ICommandSource.CommandTarget%2A>.  Se il <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> non è impostato sul <xref:System.Windows.Input.ICommandSource>, il <xref:System.Windows.Input.CommandManager.PreviewCanExecute> e <xref:System.Windows.Input.CommandManager.CanExecute> gli eventi vengono generati sull'elemento con stato attivo della tastiera.  
  
   
  
## Examples  
 L'esempio seguente è un <xref:System.Windows.Input.ICommand.CanExecuteChanged> gestore eventi da un'implementazione personalizzata di <xref:System.Windows.Input.ICommandSource>.  
  
 `this.Command` In questo esempio è il <xref:System.Windows.Input.ICommandSource.Command%2A> proprietà di <xref:System.Windows.Input.ICommandSource>.  Se il comando non è `null`, il comando viene eseguito il cast a un <xref:System.Windows.Input.RoutedCommand>.  Se il comando è un <xref:System.Windows.Input.RoutedCommand>, il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> viene chiamato metodo passando la <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> e il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  Se comando non è un <xref:System.Windows.Input.RoutedCommand>, ne viene eseguito il cast a un <xref:System.Windows.Input.ICommand> e il <xref:System.Windows.Input.ICommand.CanExecute%2A> viene chiamato passando il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  
  
 Se il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> restituzione del metodo `true`, quindi il controllo è abilitato; in caso contrario, il controllo è disabilitato.  
  
 [!code-csharp[ImplementICommandSource#ImplementICommandCanExecuteChanged](~/samples/snippets/csharp/VS_Snippets_Wpf/ImplementICommandSource/CSharp/CommandSlider.cs#implementicommandcanexecutechanged)]
 [!code-vb[ImplementICommandSource#ImplementICommandCanExecuteChanged](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ImplementICommandSource/visualbasic/commandslider.vb#implementicommandcanexecutechanged)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="target" /> non è un oggetto <see cref="T:System.Windows.UIElement" /> né <see cref="T:System.Windows.ContentElement" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanExecuteChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CanExecuteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CanExecuteChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.RoutedCommand.CanExecuteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CanExecuteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ CanExecuteChanged;" />
      <MemberSignature Language="F#" Value="member this.CanExecuteChanged : EventHandler " Usage="member this.CanExecuteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando vengono rilevate modifiche all'origine comando da parte del gestore del comando. Queste modifiche spesso influiscono sull'esecuzione del comando in corrispondenza della destinazione corrente del comando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Input.RoutedCommand> rimane in ascolto per il <xref:System.Windows.Input.CommandManager.RequerySuggested> evento, che viene generato dal <xref:System.Windows.Input.CommandManager>. Il <xref:System.Windows.Input.CommandManager.RequerySuggested> evento viene generato ogni volta che vengono soddisfatte le condizioni che possono cambiare se eseguire il comando, ad esempio una modifica nello stato attivo della tastiera.  Quando riceve il comando il <xref:System.Windows.Input.CommandManager.RequerySuggested> evento, genera il <xref:System.Windows.Input.RoutedCommand.CanExecuteChanged> evento.  In generale, l'origine del comando sarà in ascolto per questo evento e le query di <xref:System.Windows.Input.RoutedCommand> per mezzo del <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> (metodo).  La maggior parte delle origini dei comandi disabiliterà autonomamente se il comando non può essere eseguito come parte dell'associazione del comando.  Un esempio è quando un <xref:System.Windows.Controls.MenuItem> diventa inattivo quando non è possibile eseguire il comando.  
  
 In alcune situazioni, il <xref:System.Windows.Input.CommandManager> è a conoscenza di una modifica nelle condizioni che cambiano la possibilità di eseguire un comando.  In questi casi, è possibile forzare il <xref:System.Windows.Input.CommandManager> venga generato il <xref:System.Windows.Input.CommandManager.RequerySuggested> evento chiamando il <xref:System.Windows.Input.CommandManager.InvalidateRequerySuggested%2A> (metodo), ciò a sua volta causerà il <xref:System.Windows.Input.RoutedCommand> per generare il <xref:System.Windows.Input.RoutedCommand.CanExecuteChanged> evento.  
  
   
  
## Examples  
 L'esempio seguente è un <xref:System.Windows.Input.ICommand.CanExecuteChanged> gestore eventi da un'implementazione personalizzata di <xref:System.Windows.Input.ICommandSource>.  
  
 `this.Command` In questo esempio è il <xref:System.Windows.Input.ICommandSource.Command%2A> proprietà di <xref:System.Windows.Input.ICommandSource>.  Se il comando non è `null`, il comando viene eseguito il cast a un <xref:System.Windows.Input.RoutedCommand>.  Se il comando è un <xref:System.Windows.Input.RoutedCommand>, il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> viene chiamato metodo passando la <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> e il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  Se comando non è un <xref:System.Windows.Input.RoutedCommand>, ne viene eseguito il cast a un <xref:System.Windows.Input.ICommand> e il <xref:System.Windows.Input.ICommand.CanExecute%2A> viene chiamato passando il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  
  
 Se il <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> restituzione del metodo `true`, quindi il controllo è abilitato; in caso contrario, il controllo è disabilitato.  
  
 [!code-csharp[ImplementICommandSource#ImplementICommandCanExecuteChanged](~/samples/snippets/csharp/VS_Snippets_Wpf/ImplementICommandSource/CSharp/CommandSlider.cs#implementicommandcanexecutechanged)]
 [!code-vb[ImplementICommandSource#ImplementICommandCanExecuteChanged](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ImplementICommandSource/visualbasic/commandslider.vb#implementicommandcanexecutechanged)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (object parameter, System.Windows.IInputElement target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(object parameter, class System.Windows.IInputElement target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.Execute(System.Object,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (parameter As Object, target As IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Object ^ parameter, System::Windows::IInputElement ^ target);" />
      <MemberSignature Language="F#" Value="member this.Execute : obj * System.Windows.IInputElement -&gt; unit" Usage="routedCommand.Execute (parameter, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
        <Parameter Name="target" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="parameter">Parametro definito dall'utente da passare al gestore.</param>
        <param name="target">Elemento in cui effettuare la ricerca dei gestori di comando.</param>
        <summary>Esegue <see cref="T:System.Windows.Input.RoutedCommand" /> in corrispondenza della destinazione corrente del comando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La logica effettiva che esegue la <xref:System.Windows.Input.RoutedCommand> non è inclusa nel <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodi.  <xref:System.Windows.Input.RoutedCommand.Execute%2A> Genera il <xref:System.Windows.Input.CommandManager.PreviewExecuted> e <xref:System.Windows.Input.CommandManager.Executed> degli eventi, che eseguono il tunneling e bubbling attraverso l'elemento di struttura ad albero alla ricerca di un oggetto con un <xref:System.Windows.Input.CommandBinding>.  Se un <xref:System.Windows.Input.CommandBinding> adatto <xref:System.Windows.Input.RoutedCommand> viene trovato, il <xref:System.Windows.Input.ExecutedRoutedEventHandler> collegato a <xref:System.Windows.Input.CommandBinding> viene chiamato.  Questi gestori forniscono la logica di programmazione che esegue il <xref:System.Windows.Input.RoutedCommand>.  
  
 Il <xref:System.Windows.Input.CommandManager.PreviewExecuted> e <xref:System.Windows.Input.CommandManager.Executed> gli eventi vengono generati nel <xref:System.Windows.Input.ICommandSource.CommandTarget%2A>.  Se il <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> non è impostato sul <xref:System.Windows.Input.ICommandSource>, il <xref:System.Windows.Input.CommandManager.PreviewExecuted> e <xref:System.Windows.Input.CommandManager.Executed> gli eventi vengono generati sull'elemento con stato attivo della tastiera.  
  
   
  
## Examples  
 Nell'esempio seguente proviene da un'implementazione personalizzata di <xref:System.Windows.Input.ICommandSource> esempio.  
  
 `this.Command` In questo esempio è la proprietà Command su di <xref:System.Windows.Input.ICommandSource>.  Se il comando non è null, il comando viene eseguito il cast a un <xref:System.Windows.Input.RoutedCommand>.  Se è un <xref:System.Windows.Input.RoutedCommand>, il <xref:System.Windows.Input.RoutedCommand.Execute%2A> viene chiamato metodo passando la <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> e il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  Se il comando non è un <xref:System.Windows.Input.RoutedCommand>, ne viene eseguito il cast a un <xref:System.Windows.Input.ICommand> e il <xref:System.Windows.Input.ICommand.Execute%2A> viene chiamato passando il <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>.  
  
 [!code-csharp[ImplementICommandSource#ImplementICommandExecute](~/samples/snippets/csharp/VS_Snippets_Wpf/ImplementICommandSource/CSharp/CommandSlider.cs#implementicommandexecute)]
 [!code-vb[ImplementICommandSource#ImplementICommandExecute](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ImplementICommandSource/visualbasic/commandslider.vb#implementicommandexecute)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="target" /> non è un oggetto <see cref="T:System.Windows.UIElement" /> né <see cref="T:System.Windows.ContentElement" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InputGestures">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputGestureCollection InputGestures { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGestureCollection InputGestures" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.RoutedCommand.InputGestures" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputGestures As InputGestureCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputGestureCollection ^ InputGestures { System::Windows::Input::InputGestureCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputGestures : System.Windows.Input.InputGestureCollection" Usage="System.Windows.Input.RoutedCommand.InputGestures" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGestureCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di oggetti <see cref="T:System.Windows.Input.InputGesture" /> associato a questo comando.</summary>
        <value>I movimenti di input.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere un nuovo <xref:System.Windows.Input.MouseGesture> a un <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#MouseBindingAddedCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#mousebindingaddedcommand)]
 [!code-vb[commandlibrarysnippets#MouseBindingAddedCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#mousebindingaddedcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputGesture" />
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
        <altmember cref="T:System.Windows.Input.InputBinding" />
        <altmember cref="T:System.Windows.Input.KeyBinding" />
        <altmember cref="T:System.Windows.Input.MouseBinding" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.RoutedCommand.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.Input.RoutedCommand.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del comando.</summary>
        <value>Nome del comando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà può essere utilizzata quando si fa riferimento una <xref:System.Windows.Input.RoutedCommand> in [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.RoutedCommand.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.Input.RoutedCommand.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo registrato con il comando.</summary>
        <value>Il tipo di proprietario del comando.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Input.ICommand.CanExecute">
      <MemberSignature Language="C#" Value="bool ICommand.CanExecute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Input.ICommand.CanExecute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.System#Windows#Input#ICommand#CanExecute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CanExecute (parameter As Object) As Boolean Implements ICommand.CanExecute" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Input.ICommand.CanExecute(System::Object ^ parameter) = System::Windows::Input::ICommand::CanExecute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Dati usati dal comando.  Se il comando non richiede dati da passare, questo oggetto può essere impostato su <see langword="null" />.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" />.</summary>
        <returns>
          <see langword="true" /> se il comando può essere eseguito. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Windows.Input.RoutedCommand> a un'interfaccia <xref:System.Windows.Input.ICommand>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Input.RoutedCommand.CanExecute(System.Object,System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Input.ICommand.Execute">
      <MemberSignature Language="C#" Value="void ICommand.Execute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Input.ICommand.Execute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.RoutedCommand.System#Windows#Input#ICommand#Execute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Execute (parameter As Object) Implements ICommand.Execute" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Input.ICommand.Execute(System::Object ^ parameter) = System::Windows::Input::ICommand::Execute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Dati usati dal comando.  Se il comando non richiede dati da passare, questo oggetto può essere impostato su <see langword="null" />.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.Windows.Input.ICommand.Execute(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Windows.Input.RoutedCommand> a un'interfaccia <xref:System.Windows.Input.ICommand>.  
  
   
  
## Examples  
 Vedere anche  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>