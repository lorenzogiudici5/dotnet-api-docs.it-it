<Type Name="CanExecuteRoutedEventHandler" FullName="System.Windows.Input.CanExecuteRoutedEventHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40314ee81839ebd0b1ef25f5f831b2e68f2b0ad5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30646665" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate void CanExecuteRoutedEventHandler(object sender, CanExecuteRoutedEventArgs e);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CanExecuteRoutedEventHandler extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.CanExecuteRoutedEventHandler" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub CanExecuteRoutedEventHandler(sender As Object, e As CanExecuteRoutedEventArgs)" />
  <TypeSignature Language="C++ CLI" Value="public delegate void CanExecuteRoutedEventHandler(System::Object ^ sender, CanExecuteRoutedEventArgs ^ e);" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="sender" Type="System.Object" />
    <Parameter Name="e" Type="System.Windows.Input.CanExecuteRoutedEventArgs" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="sender">La destinazione del comando che sta richiamando il gestore.</param>
    <param name="e">Dati dell'evento.</param>
    <summary>Rappresenta il metodo che gestirà l'evento <see cref="E:System.Windows.Input.CommandBinding.CanExecute" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Input.CanExecuteRoutedEventHandler> determina se il comando associato all'origine evento è in grado di eseguire il comando sulla destinazione. Se il comando ha origine un comando che specifica una destinazione, quindi le informazioni di destinazione possono essere ottenute tramite `sender`. Se il <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> non è impostata, l'elemento con stato attivo della tastiera è la destinazione e può anche essere ottenuto tramite `sender`.  Se è stato stabilito che il comando può essere eseguito nella destinazione, quindi il <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=nameWithType> proprietà deve essere impostata su `true`; in caso contrario, impostarla su `false`.  
  
 È necessario non fare affidamento sui dati dell'evento per determinare il comando, l'origine e destinazione. È possibile limitare l'utilizzo del gestore per le chiamate di comando possibili noto, sebbene sia più difficile da eseguire se la struttura del comando basata ampiamente del routing dei comandi per eseguire lo stesso comando sulla destinazione potenziale successivi in un evento route.  
  
   
  
## Examples  
 Nell'esempio seguente un <xref:System.Windows.Input.CanExecuteRoutedEventHandler> che imposta <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> a `true`.  
  
 [!code-csharp[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml.cs#commandhandlercanexecutehandler)]
 [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/commandWithHandler/VisualBasic/Window1.xaml.vb#commandhandlercanexecutehandler)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.ExecutedRoutedEventHandler" />
  </Docs>
</Type>