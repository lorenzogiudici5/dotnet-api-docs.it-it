<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df34dbf51b8244075b3c3956ad39257e19561998" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51939942" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce numerosi metodi per utilizzare e pubblicare proxy e oggetti remoti. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A meno che non si ha un provider di servizi di gestione di problemi, ad esempio l'attivazione, la gestione della durata o le transazioni, non è necessario distinguere tra i riferimenti di proxy e i riferimenti agli oggetti. L'infrastruttura .NET remoting utilizza i proxy trasparenti che dare l'impressione che gli oggetti remoti si trovano nello spazio del client. A tale scopo, proxy di inoltro delle chiamate effettuate su di loro per gli oggetti reali in posizioni remote.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un proxy per un oggetto conosciuto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <see cref="T:System.Type" /> di un oggetto noto sul lato server a cui si desidera connettersi.</param>
        <param name="url">URL della classe server.</param>
        <summary>Crea un proxy per un oggetto conosciuto, dati l'oggetto <see cref="T:System.Type" /> e l'URL.</summary>
        <returns>Proxy per l'oggetto remoto che punta a un endpoint servito dall'oggetto noto specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto proxy restituito punta a un endpoint servito dall'oggetto noto specificato. Non vengono inviati messaggi attraverso la rete fino a quando non viene chiamato un metodo sul proxy.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> metodo per creare un proxy per un oggetto noto.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione per configurare tipi e canali remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <see cref="T:System.Type" /> di un oggetto noto a cui si desidera connettersi.</param>
        <param name="url">URL dell'oggetto noto.</param>
        <param name="data">Dati specifici del canale. Può essere <see langword="null" />.</param>
        <summary>Crea un proxy per un oggetto conosciuto, dati l'oggetto <see cref="T:System.Type" />, l'URL e i dati specifici per il canale.</summary>
        <returns>Proxy che punta a un endpoint servito dall'oggetto noto richiesto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto proxy restituito punta a un endpoint servito dall'oggetto noto specificato. Non vengono inviati messaggi attraverso la rete fino a quando non viene chiamato un metodo sul proxy.  
  
 Il `data` oggetto viene usato per comunicare informazioni al canale e viene passato per il <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione per configurare tipi e canali remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da disconnettere dal relativo canale.</param>
        <summary>Impedisce a un oggetto di ricevere ulteriori messaggi tramite i canali remoti registrati.</summary>
        <returns>
          <see langword="true" /> se l'oggetto è stato disconnesso correttamente dai canali remoti registrati; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> per disconnettere un oggetto tramite i canali di comunicazione remota.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="obj" /> è un proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione per configurare tipi e canali remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">Oggetto remoto di cui si desidera chiamare il metodo.</param>
        <param name="reqMsg">Messaggio di chiamata al metodo dell'oggetto remoto specificato.</param>
        <summary>Effettua la connessione all'oggetto remoto specificato ed esegue l'oggetto <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> specificato.</summary>
        <returns>Risposta del metodo remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo corrente viene utilizzato in alcuni casi speciali dal server per inoltrare la chiamata al metodo specificato all'oggetto di un altro, possibilmente remoto. Questo metodo può essere chiamato solo quando il chiamante è nel contesto appropriato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> metodo per l'inoltro delle chiamate al metodo a oggetti remoti.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Il metodo è stato chiamato da un contesto diverso dal contesto nativo dell'oggetto.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Proxy dell'oggetto remoto cui sono associati i sink di invio richiesti.</param>
        <summary>Restituisce una catena di sink di invio da utilizzare per l'invio di messaggi all'oggetto remoto rappresentato dal proxy specificato.</summary>
        <returns>Catena di sink di invio associati al proxy specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sink di invio vengono inviati insieme al <xref:System.Runtime.Remoting.ObjRef> di un oggetto che viene usato quando la restituzione di messaggi a tale oggetto. Il metodo corrente terminerà il sink di invio vengono utilizzati durante la comunicazione tra il proxy dell'oggetto e l'oggetto stesso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale ottenere il servizio di durata.</param>
        <summary>Restituisce un oggetto servizio di durata utilizzato per controllare i criteri di durata dell'oggetto specificato.</summary>
        <returns>Oggetto che controlla la durata di <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per il servizio di durata predefinito dell'oggetto restituito sarà un oggetto di tipo <xref:System.Runtime.Remoting.Lifetime.ILease>. Se il `obj` parametro è `null`, il metodo restituisce `null`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> metodo per ottenere un lease di durata per l'oggetto specificato.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 Per compilare ed eseguire questo esempio, è necessario compilare ed eseguire un server, timerserver.exe e compilare una libreria condivisa, timerservice.  
  
 L'origine per timerserver.exe seguente:  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 L'origine per timerservice seguente:  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Messaggio del metodo da cui estrarre la base del metodo.</param>
        <summary>Restituisce la base del metodo per l'oggetto <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> specificato.</summary>
        <returns>Base del metodo estratta dal parametro <paramref name="msg" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa impostazione determina la base del metodo il <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, e <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> proprietà della <xref:System.Runtime.Remoting.Messaging.IMethodMessage> ed è utilizzato da classi che implementano il <xref:System.Runtime.Remoting.Messaging.IMethodMessage> interfaccia. Coloro che utilizzano <xref:System.Runtime.Remoting.Messaging.IMethodMessage> devono fare riferimento alle classi di <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone delle autorizzazioni di infrastruttura oppure almeno uno dei chiamanti nelle posizioni superiori dello stack di chiamate non dispone delle autorizzazioni per recuperare le informazioni relative al tipo di membri non pubblici.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da serializzare.</param>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> in cui serializzare l'oggetto.</param>
        <param name="context">Origine e destinazione della serializzazione.</param>
        <summary>Serializza il marshalling specificato in base all'oggetto di riferimento nell'oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> specificato.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="obj" /> o il parametro <paramref name="info" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto <see cref="T:System.MarshalByRefObject" /> per il quale è richiesto un URI.</param>
        <summary>Recupera l'URI dell'oggetto specificato.</summary>
        <returns>URI dell'oggetto specificato, se disponibile, oppure <see langword="null" /> se non è ancora stato effettuato il marshalling dell'oggetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Proxy connesso all'oggetto per il quale creare una classe <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <summary>Restituisce l'oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto remoto del proxy specificato.</summary>
        <returns>Classe <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto remoto cui è connesso il proxy specificato oppure <see langword="null" /> se non è stato ancora effettuato il marshalling dell'oggetto o del proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto attraverso il confine di un dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (possibilmente in un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshaling. Durante l'unmarshalling, il <xref:System.Runtime.Remoting.ObjRef> viene analizzato per estrarre le informazioni sul metodo dell'oggetto remoto e sia il proxy trasparente e <xref:System.Runtime.Remoting.Proxies.RealProxy> gli oggetti vengono creati.  
  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e classe dell'oggetto di cui effettuare il marshalling, un URI che identifica in modo univoco l'istanza dell'oggetto specifico e le comunicazioni correlate informazioni su come raggiungere l'applicazione remota dove Trova l'oggetto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere un <xref:System.Runtime.Remoting.ObjRef> istanza per l'oggetto specificato.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Proxy trasparente.</param>
        <summary>Restituisce il proxy reale a supporto del proxy trasparente specificato.</summary>
        <returns>Istanza del proxy reale a supporto del proxy trasparente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In realtà un client che usa un oggetto in qualsiasi tipo di limite remoto Usa un proxy trasparente per l'oggetto. Il proxy trasparente dando l'impressione che l'oggetto effettivo si trova nello spazio del client. A tale scopo, l'inoltro delle chiamate effettuate su di esso nell'oggetto reale usando l'infrastruttura .NET remoting.  
  
 Il proxy trasparente è supportato da un'istanza di una classe di runtime gestito di tipo <xref:System.Runtime.Remoting.Proxies.RealProxy>. Il <xref:System.Runtime.Remoting.Proxies.RealProxy> implementa una parte delle funzionalità necessarie per inoltrare le operazioni dal proxy trasparente.  
  
 Un oggetto proxy eredita la semantica associata di oggetti gestiti, ad esempio operazioni di garbage collection, il supporto per membri e i metodi e può essere esteso a nuove classi di modulo. Il proxy agisce come un oggetto della stessa classe dell'oggetto remoto (proxy trasparente) e viene anche un oggetto gestito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">URI dell'oggetto di cui è richiesto il <see cref="T:System.Type" />.</param>
        <summary>Restituisce il <see cref="T:System.Type" /> dell'oggetto con l'URI specificato.</summary>
        <returns>
          <see cref="T:System.Type" /> dell'oggetto con l'URI specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché .NET remoting identifica gli endpoint tramite gli URI, il <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> metodo è molto utile per le parti dell'infrastruttura di servizi remoti (ad esempio, sink di canale, sink dinamico e i sink di contesto) collegabile che usano <xref:System.Runtime.Remoting.Messaging.IMessage> oggetti, in quanto corrente metodo restituirà l'oggetto type associato dall'URI.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone delle autorizzazioni di infrastruttura oppure almeno uno dei chiamanti nelle posizioni superiori dello stack di chiamate non dispone delle autorizzazioni per recuperare le informazioni relative al tipo di membri non pubblici.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per recuperare le informazioni sul tipo di membri non pubblici. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Oggetto <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> per il quale è richiesto un ID sessione.</param>
        <summary>Recupera un ID di sessione per un messaggio.</summary>
        <returns>Stringa ID di sessione che identifica in modo univoco la sessione corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Potrebbe essere restituito lo stesso ID di sessione per gli oggetti nella stessa applicazione, ma questo metodo non restituirà mai lo stesso ID di sessione per due oggetti in diverse applicazioni remote.  
  
 Per altre informazioni sull'identificazione di sessioni e gli ID di sessione, vedere ASP.Net [Cenni preliminari sullo stato della sessione di ASP.NET](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere la stringa di ID di sessione per la sessione corrente.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Messaggio che contiene una chiamata al metodo in questione.</param>
        <summary>Restituisce un valore Boolean che indica se il metodo del messaggio specificato è un metodo di overload.</summary>
        <returns>
          <see langword="true" /> se il metodo chiamato in <paramref name="msg" /> è un metodo di overload; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Oggetto da controllare.</param>
        <summary>Restituisce un valore Boolean che indica se l'oggetto specificato dal proxy trasparente indicato è contenuto in un dominio applicazione diverso da quello dell'oggetto che ha chiamato il metodo corrente.</summary>
        <returns>
          <see langword="true" /> se l'oggetto è esterno al dominio applicazione corrente. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sui domini dell'applicazione, vedere [domini applicazione](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)).  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domini applicazione</related>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Oggetto da controllare.</param>
        <summary>Restituisce un valore Boolean che indica se l'oggetto rappresentato dal proxy specificato è contenuto in un contesto diverso da quello dell'oggetto che ha chiamato il metodo corrente.</summary>
        <returns>
          <see langword="true" /> se l'oggetto è esterno al contesto corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contesto è una sequenza ordinata di proprietà che definiscono un ambiente per gli oggetti che risiedono al suo interno. Contesti vengono creati durante il processo di attivazione per gli oggetti che sono configurati per richiedere che determinati servizi automatici tale sincronizzazione, transazioni, attivazione just-in-time, sicurezza e così via. In un contesto possono coesistere più oggetti.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">Metodo in questione.</param>
        <summary>Restituisce un valore Boolean che indica se il client che ha chiamato il metodo specificato nel messaggio riportato attende che il server completi l'elaborazione del metodo prima di procedere con l'esecuzione.</summary>
        <returns>
          <see langword="true" /> se il metodo è monodirezionale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene chiamato un metodo unidirezionale, il client non attende che il server per completare l'elaborazione del messaggio. Il metodo client restituisce all'applicazione senza alcuna conoscenza di o meno il server verrà elaborate correttamente il messaggio. I metodi sono contrassegnati come procedere usando il <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.  
  
 I metodi unidirezionali non possono avere un valore restituito o parametri out.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Riferimento all'oggetto da verificare.</param>
        <summary>Restituisce un valore Boolean che indica se l'oggetto specificato è un proxy trasparente o un oggetto reale.</summary>
        <returns>Valore Boolean che indica se l'oggetto specificato nel parametro <paramref name="proxy" /> è un proxy trasparente o un oggetto reale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In realtà un client che usa un oggetto in qualsiasi tipo di limite remoto Usa un proxy trasparente per l'oggetto. Il proxy trasparente dando l'impressione che l'oggetto effettivo si trova nello spazio del client. A tale scopo, l'inoltro delle chiamate effettuate su di esso nell'oggetto reale usando l'infrastruttura .NET remoting.  
  
 Il proxy trasparente è ospitato da un'istanza di una classe di runtime gestito di tipo <xref:System.Runtime.Remoting.Proxies.RealProxy>. Il <xref:System.Runtime.Remoting.Proxies.RealProxy> implementa una parte delle funzionalità necessarie per inoltrare le operazioni dal proxy trasparente. Un oggetto proxy eredita la semantica associata di oggetti gestiti, ad esempio operazioni di garbage collection, il supporto per membri e i metodi e può essere esteso a nuove classi di modulo. In questo modo il proxy ha una duplice natura; da un lato deve agire come un oggetto della stessa classe dell'oggetto remoto (proxy trasparente) e l'altro è un oggetto gestito se stesso.  
  
 Un oggetto proxy è utilizzabile indipendentemente da eventuali suddivisioni all'interno di un <xref:System.AppDomain>. Le applicazioni non necessitano distinguere tra proxy e i riferimenti di oggetto. Tuttavia, i provider di servizi gestiscono i problemi, ad esempio l'attivazione, la gestione della durata e le transazioni necessario effettuare queste distinzioni.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> metodo per determinare se un oggetto è un proxy o un oggetto reale. Per il codice di esempio completo, vedere l'esempio per il <xref:System.Runtime.Remoting.Messaging.AsyncResult> classe.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">Costante definita internamente che identifica la fase in uno scambio remoto.</param>
        <summary>Consente l'accesso della fase in uno scambio remoto a un debugger esterno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto `"REMOTING_PERF"` simboli di pre-elaborazione viene applicato al metodo utilizzando il <xref:System.Diagnostics.ConditionalAttribute> attributo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte l'oggetto <see cref="T:System.MarshalByRefObject" /> in un'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" />, che può essere serializzata per la trasmissione tra domini applicazione e in rete.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">Oggetto da convertire.</param>
        <summary>Accetta un oggetto <see cref="T:System.MarshalByRefObject" />, lo registra con l'infrastruttura remota e lo converte in un'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" />.</summary>
        <returns>Istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto specificato nel parametro <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto attraverso il confine di un dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (possibilmente in un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshaling.  
  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e classe dell'oggetto di cui effettuare il marshalling, un URI che identifica in modo univoco l'istanza dell'oggetto specifico e le comunicazioni correlate informazioni su come raggiungere la suddivisione di .NET remoting cartella in cui si trova l'oggetto.  
  
 Durante il marshalling, viene utilizzato il contesto dal thread corrente, non il contesto che era attivo al momento della creazione dell'oggetto. Se un URI non è stato impostato in modo esplicito tramite il <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> metodo, viene generata automaticamente dall'infrastruttura remota di identità.  
  
 Non è possibile associare un URI con un proxy per uno dei due motivi: oppure è stato generato l'URI sul lato server per l'oggetto rappresenta l'oggetto è ben noto, nel qual caso l'URI è noto. Per questo motivo, se il `Obj` parametro è un proxy, verrà generata un'eccezione. Per i proxy personalizzati questa restrizione è assoluta perché il proxy trasparente viene considerato come l'oggetto server.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Il valore del parametro <paramref name="Obj" /> è un oggetto proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domini applicazione</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">Oggetto da convertire.</param>
        <param name="URI">URI specificato con cui inizializzare il nuovo oggetto <see cref="T:System.Runtime.Remoting.ObjRef" />. Può essere <see langword="null" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.MarshalByRefObject" /> dato in un'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> con l'URI specificato.</summary>
        <returns>Istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto specificato nel parametro <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto attraverso il confine di un dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (possibilmente in un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshaling.  
  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e classe dell'oggetto di cui effettuare il marshalling, un URI che identifica in modo univoco l'istanza dell'oggetto specifico e le comunicazioni correlate informazioni su come raggiungere la suddivisione di .NET remoting cartella in cui si trova l'oggetto.  
  
 Durante il marshalling, viene utilizzato il contesto dal thread corrente, non il contesto che era attivo al momento della creazione dell'oggetto.  
  
 Non è possibile associare un URI con un proxy per uno dei due motivi: oppure è stato generato l'URI sul lato server per l'oggetto rappresenta l'oggetto è ben noto, nel qual caso l'URI è noto. Per questo motivo, se il `Obj` parametro è un proxy, verrà generata un'eccezione. Per i proxy personalizzati questa restrizione è assoluta perché il proxy trasparente viene considerato come l'oggetto server.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come usare l'attuale <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metodo per effettuare il marshalling di un oggetto specificato.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> rappresenta un proxy dell'oggetto, mentre il valore del parametro <paramref name="URI" /> non è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domini applicazione</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">Oggetto da convertire in un oggetto <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <param name="ObjURI">URI con cui viene effettuato il marshalling dell'oggetto specificato nel parametro <c>Obj</c>. Può essere <see langword="null" />.</param>
        <param name="RequestedType">
          <see cref="T:System.Type" /> in base a cui viene eseguito il marshalling di <c>Obj</c>. Può essere <see langword="null" />.</param>
        <summary>Accetta un oggetto <see cref="T:System.MarshalByRefObject" /> e lo converte in un'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> con l'URI specificato e il <see cref="T:System.Type" /> indicato.</summary>
        <returns>Istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto specificato nel parametro <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto attraverso il confine di un dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (possibilmente in un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshaling.  
  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e classe dell'oggetto di cui effettuare il marshalling, un URI che identifica in modo univoco l'istanza dell'oggetto specifico e le comunicazioni correlate informazioni su come raggiungere la suddivisione di .NET remoting cartella in cui si trova l'oggetto.  
  
 L'oggetto specificato <xref:System.Type> viene utilizzato dall'infrastruttura .NET remoting per limitare l'ambito della gerarchia dei tipi esposti. Ad esempio, se un oggetto deriva dall'oggetto B, che deriva dall'oggetto C, e <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> viene chiamata, quindi il client può eseguire il cast del proxy tra B e C, ma non in r.  
  
 Durante il marshalling, viene utilizzato il contesto dal thread corrente, non il contesto che era attivo al momento della creazione dell'oggetto.  
  
 Non è possibile associare un URI con un proxy per uno dei due motivi: oppure è stato generato l'URI sul lato server per l'oggetto rappresenta l'oggetto è ben noto, nel qual caso l'URI è noto. Per questo motivo, se il `Obj` parametro è un proxy, verrà generata un'eccezione. Per i proxy personalizzati questa restrizione è assoluta perché il proxy trasparente viene considerato come l'oggetto server.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> rappresenta un proxy di un oggetto remoto, mentre il valore del parametro <paramref name="ObjUri" /> non è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domini applicazione</related>
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale impostare un URI.</param>
        <param name="uri">URI da assegnare all'oggetto specificato.</param>
        <summary>Imposta l'URI per la chiamata successiva al metodo <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'URI impostata dal metodo corrente viene usato quando il marshalling dell'oggetto specificato.  
  
 Dopo il marshalling, l'URI dell'oggetto specificato è impostato sulla stringa il `uri` parametro aggiunto al <xref:System.Guid> dell'oggetto corrente <xref:System.AppDomain>.  
  
 Se l'applicazione corrente è in ascolto su una porta HTTP, allora sia la stringa specificata nel `uri` parametro e il `uri` stringa aggiunta al <xref:System.Guid> dell'oggetto corrente <xref:System.AppDomain> route per l'oggetto specificato. Ad esempio, se l'applicazione è in ascolto sulla porta HTTP 9000, entrambe http://localhost:9000/objectUri, e http://localhost:9000/\<appdomainguid>/objectUri all'oggetto specificato nella route di `obj` parametro.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare l'URI che verrà usato dal <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metodo durante il marshalling dell'oggetto specificato.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="obj" /> non corrisponde a un oggetto locale, è già stato sottoposto a marshalling oppure il metodo corrente è già stato chiamato.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte un oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato in un oggetto proxy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef">Oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto remoto per il quale creare il proxy.</param>
        <summary>Accetta una classe <see cref="T:System.Runtime.Remoting.ObjRef" /> e con questa crea un oggetto proxy esterno.</summary>
        <returns>Proxy dell'oggetto rappresentato dall'oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto attraverso il confine di un dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (possibilmente in un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshaling. Durante l'unmarshalling, il <xref:System.Runtime.Remoting.ObjRef> viene analizzato per estrarre le informazioni sul metodo dell'oggetto remoto e sia il proxy trasparente e <xref:System.Runtime.Remoting.Proxies.RealProxy> gli oggetti vengono creati. Il contenuto dell'oggetto analizzato <xref:System.Runtime.Remoting.ObjRef> viene aggiunto al proxy trasparente prima che il proxy trasparente sia registrato con common language runtime.  
  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e classe dell'oggetto di cui effettuare il marshalling, un URI che identifica in modo univoco l'istanza dell'oggetto specifico e le comunicazioni correlate informazioni su come raggiungere la suddivisione di .NET remoting cartella in cui si trova l'oggetto.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'unmarshalling di un oggetto.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato dell'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato nel parametro <paramref name="objectRef" /> non è corretto.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef">Oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto remoto per il quale creare il proxy.</param>
        <param name="fRefine">
          <see langword="true" /> per adattare il proxy al tipo sul server; in caso contrario, <see langword="false" />.</param>
        <summary>Accetta una classe <see cref="T:System.Runtime.Remoting.ObjRef" /> e con questa crea un oggetto proxy esterno, adattandolo al tipo sul server.</summary>
        <returns>Proxy dell'oggetto rappresentato dall'oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto attraverso il confine di un dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (possibilmente in un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshaling. Durante l'unmarshalling, il <xref:System.Runtime.Remoting.ObjRef> viene analizzato per estrarre le informazioni sul metodo dell'oggetto remoto e sia il proxy trasparente e <xref:System.Runtime.Remoting.Proxies.RealProxy> gli oggetti vengono creati. Il contenuto dell'oggetto analizzato <xref:System.Runtime.Remoting.ObjRef> viene aggiunto al proxy trasparente prima che il proxy trasparente sia registrato con common language runtime.  
  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e classe dell'oggetto di cui effettuare il marshalling, un URI che identifica in modo univoco l'istanza dell'oggetto specifico e le comunicazioni correlate informazioni su come raggiungere la suddivisione di .NET remoting cartella in cui si trova l'oggetto.  
  
 Quando viene creata prima di tutto, il proxy è di tipo <xref:System.MarshalByRefObject>. Come è eseguirne il cast in tipi diversi, l'infrastruttura .NET remoting tiene traccia di tipo per evitare il caricamento del tipo inutilmente più utilizzato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato dell'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato nel parametro <paramref name="objectRef" /> non è corretto.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>