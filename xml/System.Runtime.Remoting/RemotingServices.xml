<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="56e4b36797e7345ce0280d99cdf2a9aa7a27d094" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36534575" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce numerosi metodi per utilizzare e pubblicare proxy e oggetti remoti. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A meno che non si è un provider del servizio relative a problemi, ad esempio l'attivazione, la gestione della durata o le transazioni, non è necessario distinguere tra i riferimenti di proxy e i riferimenti agli oggetti. L'infrastruttura remota utilizza i proxy trasparenti che dare l'impressione che gli oggetti remoti si trovano nello spazio del client. A tale scopo, proxy inoltrando le chiamate effettuate su di essi per gli oggetti reali in posizioni remote.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un proxy per un oggetto conosciuto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <see cref="T:System.Type" /> di un oggetto noto sul lato server a cui si desidera connettersi.</param>
        <param name="url">URL della classe server.</param>
        <summary>Crea un proxy per un oggetto conosciuto, dati l'oggetto <see cref="T:System.Type" /> e l'URL.</summary>
        <returns>Proxy per l'oggetto remoto che punta a un endpoint servito dall'oggetto noto specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto proxy restituito punta a un endpoint messo a disposizione dall'oggetto noto specificato. Non vengono inviati messaggi attraverso la rete fino a quando non viene chiamato un metodo sul proxy.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> metodo per creare un proxy per un oggetto noto.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione per configurare tipi e canali remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <see cref="T:System.Type" /> di un oggetto noto a cui si desidera connettersi.</param>
        <param name="url">URL dell'oggetto noto.</param>
        <param name="data">Dati specifici del canale. Può essere <see langword="null" />.</param>
        <summary>Crea un proxy per un oggetto conosciuto, dati l'oggetto <see cref="T:System.Type" />, l'URL e i dati specifici per il canale.</summary>
        <returns>Proxy che punta a un endpoint servito dall'oggetto noto richiesto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto proxy restituito punta a un endpoint messo a disposizione dall'oggetto noto specificato. Non vengono inviati messaggi attraverso la rete fino a quando non viene chiamato un metodo sul proxy.  
  
 Il `data` oggetto viene utilizzato per comunicare informazioni al canale e viene passato per il <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione per configurare tipi e canali remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da disconnettere dal relativo canale.</param>
        <summary>Impedisce a un oggetto di ricevere ulteriori messaggi tramite i canali remoti registrati.</summary>
        <returns>
          <see langword="true" /> se l'oggetto è stato disconnesso correttamente dai canali remoti registrati; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> per disconnettere un oggetto dai canali remoti.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="obj" /> è un proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione per configurare tipi e canali remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">Oggetto remoto di cui si desidera chiamare il metodo.</param>
        <param name="reqMsg">Messaggio di chiamata al metodo dell'oggetto remoto specificato.</param>
        <summary>Effettua la connessione all'oggetto remoto specificato ed esegue l'oggetto <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> specificato.</summary>
        <returns>Risposta del metodo remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo corrente viene utilizzato in casi particolari dal server per inoltrare la chiamata al metodo specificato all'oggetto di un altro, possibilmente remoto. Questo metodo può essere chiamato solo quando il chiamante è nel contesto appropriato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> metodo per inoltrare le chiamate di metodo a oggetti remoti.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Il metodo è stato chiamato da un contesto diverso dal contesto nativo dell'oggetto.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Proxy dell'oggetto remoto cui sono associati i sink di invio richiesti.</param>
        <summary>Restituisce una catena di sink di invio da utilizzare per l'invio di messaggi all'oggetto remoto rappresentato dal proxy specificato.</summary>
        <returns>Catena di sink di invio associati al proxy specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sink di invio vengono inviati insieme al <xref:System.Runtime.Remoting.ObjRef> di un oggetto che viene utilizzato quando la restituzione di messaggi a tale oggetto. Il metodo corrente terminerà il sink di invio vengono utilizzati durante la comunicazione tra il proxy dell'oggetto e l'oggetto stesso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale ottenere il servizio di durata.</param>
        <summary>Restituisce un oggetto servizio di durata utilizzato per controllare i criteri di durata dell'oggetto specificato.</summary>
        <returns>Oggetto che controlla la durata di <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per il servizio di durata predefinito l'oggetto restituito sarà un oggetto di tipo <xref:System.Runtime.Remoting.Lifetime.ILease>. Se il `obj` parametro `null`, il metodo restituisce `null`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> metodo per ottenere un lease di durata per l'oggetto specificato.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 Per compilare ed eseguire questo esempio, è necessario compilare ed eseguire un timerservice server timerserver.exe e compilare una libreria condivisa.  
  
 L'origine per timerserver.exe seguente:  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 L'origine per timerservice seguente:  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Messaggio del metodo da cui estrarre la base del metodo.</param>
        <summary>Restituisce la base del metodo per l'oggetto <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> specificato.</summary>
        <returns>Base del metodo estratta dal parametro <paramref name="msg" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo parametro determina il metodo di base dal <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, e <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> proprietà del <xref:System.Runtime.Remoting.Messaging.IMethodMessage> e viene usato da classi che implementano il <xref:System.Runtime.Remoting.Messaging.IMethodMessage> interfaccia. I consumer di <xref:System.Runtime.Remoting.Messaging.IMethodMessage> devono fare riferimento alle classi di <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone delle autorizzazioni di infrastruttura oppure almeno uno dei chiamanti nelle posizioni superiori dello stack di chiamate non dispone delle autorizzazioni per recuperare le informazioni relative al tipo di membri non pubblici.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da serializzare.</param>
        <param name="info">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> in cui serializzare l'oggetto.</param>
        <param name="context">Origine e destinazione della serializzazione.</param>
        <summary>Serializza il marshalling specificato in base all'oggetto di riferimento nell'oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> specificato.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="obj" /> o il parametro <paramref name="info" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto <see cref="T:System.MarshalByRefObject" /> per il quale è richiesto un URI.</param>
        <summary>Recupera l'URI dell'oggetto specificato.</summary>
        <returns>URI dell'oggetto specificato, se disponibile, oppure <see langword="null" /> se non è ancora stato effettuato il marshalling dell'oggetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Proxy connesso all'oggetto per il quale creare una classe <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <summary>Restituisce l'oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto remoto del proxy specificato.</summary>
        <returns>Classe <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto remoto cui è connesso il proxy specificato oppure <see langword="null" /> se non è stato ancora effettuato il marshalling dell'oggetto o del proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto in un confine del dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come effettuare il marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (probabilmente su un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshalling. Durante l'unmarshalling, il <xref:System.Runtime.Remoting.ObjRef> analizzata per estrarre le informazioni sul metodo dell'oggetto remoto e sia il proxy trasparente e <xref:System.Runtime.Remoting.Proxies.RealProxy> gli oggetti vengono creati.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e la classe dell'oggetto sta eseguendo il marshalling, un URI che identifica in modo univoco l'istanza specifica dell'oggetto e la comunicazione correlate informazioni su come raggiungere l'applicazione remota dove Trova l'oggetto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere un <xref:System.Runtime.Remoting.ObjRef> istanza per l'oggetto specificato.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Proxy trasparente.</param>
        <summary>Restituisce il proxy reale a supporto del proxy trasparente specificato.</summary>
        <returns>Istanza del proxy reale a supporto del proxy trasparente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un client che utilizza un oggetto in qualsiasi tipo di limite remoto è effettivamente usando un proxy trasparente per l'oggetto. Il proxy trasparente fornisce l'impressione che l'oggetto effettivo si trova nello spazio del client. A tale scopo, le chiamate effettuate su di esso all'oggetto reale tramite l'infrastruttura di comunicazione remota di inoltro.  
  
 Il proxy trasparente è supportato da un'istanza di una classe di runtime gestito di tipo <xref:System.Runtime.Remoting.Proxies.RealProxy>. Il <xref:System.Runtime.Remoting.Proxies.RealProxy> implementa una parte delle funzionalità necessarie per inoltrare le operazioni dal proxy trasparente.  
  
 Un oggetto proxy eredita la semantica associata degli oggetti gestiti, ad esempio l'operazione di garbage collection, il supporto per i membri e i metodi e può essere esteso a nuove classi di modulo. Il proxy funge da oggetto della stessa classe dell'oggetto remoto (proxy trasparente), senza che sia anche un oggetto gestito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">URI dell'oggetto di cui è richiesto il <see cref="T:System.Type" />.</param>
        <summary>Restituisce il <see cref="T:System.Type" /> dell'oggetto con l'URI specificato.</summary>
        <returns>
          <see cref="T:System.Type" /> dell'oggetto con l'URI specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché la comunicazione remota identifica gli endpoint tramite gli URI, il <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> metodo risulta particolarmente utile nelle parti collegabili dell'infrastruttura di comunicazione remota (ad esempio, sink di canale, dinamici e i sink di contesto) che utilizzano <xref:System.Runtime.Remoting.Messaging.IMessage> oggetti, poiché corrente metodo restituirà l'oggetto del tipo associato dall'URI.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone delle autorizzazioni di infrastruttura oppure almeno uno dei chiamanti nelle posizioni superiori dello stack di chiamate non dispone delle autorizzazioni per recuperare le informazioni relative al tipo di membri non pubblici.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per recuperare le informazioni sul tipo di membri non pubblici. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Oggetto <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> per il quale è richiesto un ID sessione.</param>
        <summary>Recupera un ID di sessione per un messaggio.</summary>
        <returns>Stringa ID di sessione che identifica in modo univoco la sessione corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stesso ID di sessione potrebbe essere restituito per gli oggetti nella stessa applicazione, ma questo metodo non restituisce mai lo stesso ID di sessione per due oggetti in diverse applicazioni remote.  
  
 Per ulteriori informazioni sull'identificazione di sessioni e gli ID di sessione, vedere ASP.Net [panoramica dello stato della sessione ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ottenere la stringa di ID di sessione per la sessione corrente.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Messaggio che contiene una chiamata al metodo in questione.</param>
        <summary>Restituisce un valore Boolean che indica se il metodo del messaggio specificato è un metodo di overload.</summary>
        <returns>
          <see langword="true" /> se il metodo chiamato in <paramref name="msg" /> è un metodo di overload; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Oggetto da controllare.</param>
        <summary>Restituisce un valore Boolean che indica se l'oggetto specificato dal proxy trasparente indicato è contenuto in un dominio applicazione diverso da quello dell'oggetto che ha chiamato il metodo corrente.</summary>
        <returns>
          <see langword="true" /> se l'oggetto è esterno al dominio applicazione corrente. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sui domini dell'applicazione, vedere [domini applicazione](http://msdn.microsoft.com/library/39e57d07-a740-4cd4-ae82-e119ea3856c1).  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Oggetto da controllare.</param>
        <summary>Restituisce un valore Boolean che indica se l'oggetto rappresentato dal proxy specificato è contenuto in un contesto diverso da quello dell'oggetto che ha chiamato il metodo corrente.</summary>
        <returns>
          <see langword="true" /> se l'oggetto è esterno al contesto corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contesto è una sequenza ordinata di proprietà che definiscono un ambiente per gli oggetti in esso contenuti. Contesti vengono creati durante il processo di attivazione per gli oggetti che sono configurati per richiedere che determinati servizi automatici tale sincronizzazione, le transazioni, attivazione just-in-time, sicurezza e così via. In un contesto possono coesistere più oggetti.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">Metodo in questione.</param>
        <summary>Restituisce un valore Boolean che indica se il client che ha chiamato il metodo specificato nel messaggio riportato attende che il server completi l'elaborazione del metodo prima di procedere con l'esecuzione.</summary>
        <returns>
          <see langword="true" /> se il metodo è monodirezionale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene chiamato un metodo unidirezionale, il client non attende che il server completare l'elaborazione del messaggio. Il metodo client restituisce all'applicazione con alcuna conoscenza di fatto il server elaborerà correttamente il messaggio. I metodi sono contrassegnati come usando una delle modalità di <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.  
  
 I metodi unidirezionali non possono avere un valore restituito o parametri out.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante immediato non dispone dell'autorizzazione di infrastruttura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operare con il codice dell'infrastruttura. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Riferimento all'oggetto da verificare.</param>
        <summary>Restituisce un valore Boolean che indica se l'oggetto specificato è un proxy trasparente o un oggetto reale.</summary>
        <returns>Valore Boolean che indica se l'oggetto specificato nel parametro <paramref name="proxy" /> è un proxy trasparente o un oggetto reale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un client che utilizza un oggetto in qualsiasi tipo di limite remoto è effettivamente usando un proxy trasparente per l'oggetto. Il proxy trasparente fornisce l'impressione che l'oggetto effettivo si trova nello spazio del client. A tale scopo, le chiamate effettuate su di esso all'oggetto reale tramite l'infrastruttura di comunicazione remota di inoltro.  
  
 Il proxy trasparente è ospitato da un'istanza di una classe di runtime gestito di tipo <xref:System.Runtime.Remoting.Proxies.RealProxy>. Il <xref:System.Runtime.Remoting.Proxies.RealProxy> implementa una parte delle funzionalità necessarie per inoltrare le operazioni dal proxy trasparente. Un oggetto proxy eredita la semantica associata degli oggetti gestiti, ad esempio l'operazione di garbage collection, il supporto per i membri e i metodi e può essere esteso a nuove classi di modulo. In questo modo il proxy con una duplice natura; da un lato deve agire come un oggetto della stessa classe dell'oggetto remoto (proxy trasparente) e l'altro è un oggetto gestito.  
  
 Un oggetto proxy può essere utilizzato indipendentemente da eventuali suddivisioni all'interno di un <xref:System.AppDomain>. Le applicazioni non è necessario distinguere tra riferimenti al proxy e i riferimenti agli oggetti. Tuttavia, i provider di servizi relative a problemi, ad esempio attivazione, la gestione della durata e le transazioni necessario apportare queste distinzioni.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> metodo per determinare se un oggetto è un proxy o un oggetto reale. Per il codice di esempio completo, vedere l'esempio per la <xref:System.Runtime.Remoting.Messaging.AsyncResult> classe.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">Costante definita internamente che identifica la fase in uno scambio remoto.</param>
        <summary>Consente l'accesso della fase in uno scambio remoto a un debugger esterno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un `"REMOTING_PERF"` simbolo di pre-elaborazione viene applicato al metodo tramite il <xref:System.Diagnostics.ConditionalAttribute> attributo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte l'oggetto <see cref="T:System.MarshalByRefObject" /> in un'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" />, che può essere serializzata per la trasmissione tra domini applicazione e in rete.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">Oggetto da convertire.</param>
        <summary>Accetta un oggetto <see cref="T:System.MarshalByRefObject" />, lo registra con l'infrastruttura remota e lo converte in un'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" />.</summary>
        <returns>Istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto specificato nel parametro <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto in un confine del dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come effettuare il marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (probabilmente su un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshalling.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e la classe dell'oggetto sta eseguendo il marshalling, un URI che identifica in modo univoco l'istanza specifica dell'oggetto e la comunicazione correlate informazioni su come raggiungere la suddivisione remota cartella in cui si trova l'oggetto.  
  
 Durante il marshalling, viene utilizzato il contesto del thread corrente, non il contesto che era attivo quando l'oggetto è stato creato. Se un URI non è stato impostato in modo esplicito tramite il <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> metodo, viene generato automaticamente dall'infrastruttura di identità di comunicazione remota.  
  
 Non è possibile associare un URI con un proxy per uno dei due motivi: è stato generato sul lato server per l'oggetto che rappresenta l'URI oppure l'oggetto è ben noto, nel qual caso l'URI è noto. Per questo motivo, se il `Obj` parametro è un proxy, verrà generata un'eccezione. Per i proxy personalizzati questa limitazione è ridotta perché il proxy trasparente viene considerato come l'oggetto server.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Il valore del parametro <paramref name="Obj" /> è un oggetto proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">Oggetto da convertire.</param>
        <param name="URI">URI specificato con cui inizializzare il nuovo oggetto <see cref="T:System.Runtime.Remoting.ObjRef" />. Può essere <see langword="null" />.</param>
        <summary>Converte l'oggetto <see cref="T:System.MarshalByRefObject" /> dato in un'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> con l'URI specificato.</summary>
        <returns>Istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto specificato nel parametro <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto in un confine del dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come effettuare il marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (probabilmente su un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshalling.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e la classe dell'oggetto sta eseguendo il marshalling, un URI che identifica in modo univoco l'istanza specifica dell'oggetto e la comunicazione correlate informazioni su come raggiungere la suddivisione remota cartella in cui si trova l'oggetto.  
  
 Durante il marshalling, viene utilizzato il contesto del thread corrente, non il contesto che era attivo quando l'oggetto è stato creato.  
  
 Non è possibile associare un URI con un proxy per uno dei due motivi: è stato generato sul lato server per l'oggetto che rappresenta l'URI oppure l'oggetto è ben noto, nel qual caso l'URI è noto. Per questo motivo, se il `Obj` parametro è un proxy, verrà generata un'eccezione. Per i proxy personalizzati questa limitazione è ridotta perché il proxy trasparente viene considerato come l'oggetto server.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare corrente <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metodo per effettuare il marshalling di un oggetto specificato.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> rappresenta un proxy dell'oggetto, mentre il valore del parametro <paramref name="URI" /> non è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">Oggetto da convertire in un oggetto <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <param name="ObjURI">URI con cui viene effettuato il marshalling dell'oggetto specificato nel parametro <c>Obj</c>. Può essere <see langword="null" />.</param>
        <param name="RequestedType">
          <see cref="T:System.Type" /> in base a cui viene eseguito il marshalling di <c>Obj</c>. Può essere <see langword="null" />.</param>
        <summary>Accetta un oggetto <see cref="T:System.MarshalByRefObject" /> e lo converte in un'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> con l'URI specificato e il <see cref="T:System.Type" /> indicato.</summary>
        <returns>Istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto specificato nel parametro <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto in un confine del dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come effettuare il marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (probabilmente su un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshalling.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e la classe dell'oggetto sta eseguendo il marshalling, un URI che identifica in modo univoco l'istanza specifica dell'oggetto e la comunicazione correlate informazioni su come raggiungere la suddivisione remota cartella in cui si trova l'oggetto.  
  
 Specificato <xref:System.Type> viene utilizzata dall'infrastruttura di comunicazione remota per limitare l'ambito della gerarchia dei tipi esposti. Ad esempio, se l'oggetto deriva dall'oggetto B, che deriva dall'oggetto C, e <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> viene chiamato, quindi il client può eseguire il cast del proxy tra B e C, ma non in A.  
  
 Durante il marshalling, viene utilizzato il contesto del thread corrente, non il contesto che era attivo quando l'oggetto è stato creato.  
  
 Non è possibile associare un URI con un proxy per uno dei due motivi: è stato generato sul lato server per l'oggetto che rappresenta l'URI oppure l'oggetto è ben noto, nel qual caso l'URI è noto. Per questo motivo, se il `Obj` parametro è un proxy, verrà generata un'eccezione. Per i proxy personalizzati questa limitazione è ridotta perché il proxy trasparente viene considerato come l'oggetto server.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> rappresenta un proxy di un oggetto remoto, mentre il valore del parametro <paramref name="ObjUri" /> non è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale impostare un URI.</param>
        <param name="uri">URI da assegnare all'oggetto specificato.</param>
        <summary>Imposta l'URI per la chiamata successiva al metodo <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'URI impostato dal metodo corrente viene utilizzato quando il marshalling dell'oggetto specificato.  
  
 Dopo il marshalling su diversi, l'URI dell'oggetto specificato viene impostato sulla stringa il `uri` parametro aggiunto al <xref:System.Guid> dell'oggetto corrente <xref:System.AppDomain>.  
  
 Se l'applicazione corrente è in ascolto su una porta HTTP, sia la stringa specificata nel `uri` parametro e il `uri` stringa aggiunta al <xref:System.Guid> dell'oggetto corrente <xref:System.AppDomain> route per l'oggetto specificato. Ad esempio, se l'applicazione è in ascolto sulla porta HTTP 9000, entrambi http://localhost:9000/objectUri, e http://localhost:9000/\<appdomainguid>/objectUri route per l'oggetto specificato nella `obj` parametro.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare l'URI che verrà usato dal <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metodo quando il marshalling dell'oggetto specificato.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="obj" /> non corrisponde a un oggetto locale, è già stato sottoposto a marshalling oppure il metodo corrente è già stato chiamato.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte un oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato in un oggetto proxy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef">Oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto remoto per il quale creare il proxy.</param>
        <summary>Accetta una classe <see cref="T:System.Runtime.Remoting.ObjRef" /> e con questa crea un oggetto proxy esterno.</summary>
        <returns>Proxy dell'oggetto rappresentato dall'oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto in un confine del dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come effettuare il marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (probabilmente su un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshalling. Durante l'unmarshalling, il <xref:System.Runtime.Remoting.ObjRef> analizzata per estrarre le informazioni sul metodo dell'oggetto remoto e sia il proxy trasparente e <xref:System.Runtime.Remoting.Proxies.RealProxy> gli oggetti vengono creati. Il contenuto dell'oggetto analizzato <xref:System.Runtime.Remoting.ObjRef> viene aggiunta al proxy trasparente prima che il proxy trasparente è registrato con common language runtime.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e la classe dell'oggetto sta eseguendo il marshalling, un URI che identifica in modo univoco l'istanza specifica dell'oggetto e la comunicazione correlate informazioni su come raggiungere la suddivisione remota cartella in cui si trova l'oggetto.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come effettuare l'unmarshalling di un oggetto.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato dell'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato nel parametro <paramref name="objectRef" /> non è corretto.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef">Oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> che rappresenta l'oggetto remoto per il quale creare il proxy.</param>
        <param name="fRefine">
          <see langword="true" /> per adattare il proxy al tipo sul server; in caso contrario, <see langword="false" />.</param>
        <summary>Accetta una classe <see cref="T:System.Runtime.Remoting.ObjRef" /> e con questa crea un oggetto proxy esterno, adattandolo al tipo sul server.</summary>
        <returns>Proxy dell'oggetto rappresentato dall'oggetto <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Runtime.Remoting.ObjRef> è una rappresentazione serializzabile di un oggetto utilizzato per trasferire un riferimento all'oggetto in un confine del dominio applicazione. Creazione di un <xref:System.Runtime.Remoting.ObjRef> per un oggetto è noto come effettuare il marshalling. Il <xref:System.Runtime.Remoting.ObjRef> può essere trasferita tramite un canale in un altro dominio applicazione (probabilmente su un altro processo o computer). Una volta in altro dominio applicazione, il <xref:System.Runtime.Remoting.ObjRef> deve essere analizzata per creare un proxy per l'oggetto, in genere connesso all'oggetto reale. Questa operazione è nota come l'unmarshalling. Durante l'unmarshalling, il <xref:System.Runtime.Remoting.ObjRef> analizzata per estrarre le informazioni sul metodo dell'oggetto remoto e sia il proxy trasparente e <xref:System.Runtime.Remoting.Proxies.RealProxy> gli oggetti vengono creati. Il contenuto dell'oggetto analizzato <xref:System.Runtime.Remoting.ObjRef> viene aggiunta al proxy trasparente prima che il proxy trasparente è registrato con common language runtime.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contiene informazioni che descrivono il <xref:System.Type> e la classe dell'oggetto sta eseguendo il marshalling, un URI che identifica in modo univoco l'istanza specifica dell'oggetto e la comunicazione correlate informazioni su come raggiungere la suddivisione remota cartella in cui si trova l'oggetto.  
  
 Fase di creazione, il proxy è di tipo <xref:System.MarshalByRefObject>. Come è eseguirne il cast in tipi diversi, l'infrastruttura remota tiene traccia del tipo più utilizzato per evitare il caricamento del tipo inutilmente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato dell'istanza della classe <see cref="T:System.Runtime.Remoting.ObjRef" /> specificato nel parametro <paramref name="objectRef" /> non è corretto.</exception>
        <exception cref="T:System.Security.SecurityException">Almeno uno dei chiamanti in posizione più elevata nello stack di chiamate non dispone delle autorizzazioni alla configurazione di canali e tipi remoti.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la configurazione dell'infrastruttura di comunicazione remota. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valore di autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>