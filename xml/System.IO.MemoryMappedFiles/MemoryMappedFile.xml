<Type Name="MemoryMappedFile" FullName="System.IO.MemoryMappedFiles.MemoryMappedFile">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="41e07681dacb0cef93c8ed23d1e7cefeeb182c8e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39987545" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryMappedFile extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryMappedFile&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryMappedFile = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Rappresenta un file mappato alla memoria.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un file mappato alla memoria viene eseguito il mapping di contenuto di un file di spazio degli indirizzi logico di un'applicazione. File mappati alla memoria consentono ai programmatori di lavorare con file grandi perché memoria può essere gestita contemporaneamente e consentono l'accesso completo e casuale a un file senza la necessità per eseguire la ricerca. File mappato alla memoria possono anche essere condivisi tra più processi.  
  
 Il <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> metodi di creano un file mappato alla memoria da un percorso specificato o un <xref:System.IO.FileStream> di un file esistente sul disco. Le modifiche vengono automaticamente propagate su disco quando il file non è mappato.  
  
 Il <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> metodi creano un file mappato alla memoria che non è mappato a un file esistente sul disco; e sono idonei per la creazione di memoria condivisa per la comunicazione interprocesso (IPC).  
  
 Un file mappato alla memoria può essere associato a un nome facoltativo che fa sì che il file mappato alla memoria da condividere con altri processi. 
  
 È possibile creare più visualizzazioni del file mappato alla memoria, comprese le visualizzazioni delle parti del file. È possibile mappare la stessa parte di un file a più di un indirizzo per creare una memoria simultanea. Per rimanere simultanee, due visualizzazioni devono essere create dallo stesso file di cui è stato eseguito il mapping alla memoria. Creare due mapping dello stesso file con due visualizzazioni non forniscono concorrenza.  
  
   
  
## Examples  
 L'esempio seguente crea una visualizzazione di cui viene eseguito il mapping alla memoria di una parte di un file molto grande e ne modifica una parte.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateFromFile">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un file mappato alla memoria da un file esistente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso del file da mappare.</param>
        <summary>Crea un file mappato alla memoria da un file su disco.</summary>
        <returns>File mappato alla memoria.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa il <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> metodo per creare un file mappato alla memoria e quindi crea una vista con mapping in memoria solo una parte di un file di dimensioni estremamente grande.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota, contiene solo spazi vuoti o uno o più caratteri non validi, definiti da <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  
  
oppure 
 <paramref name="path" /> si riferisce a un dispositivo non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la lunghezza massima definita dal sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone delle autorizzazioni necessarie per il file.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Percorso del file da mappare.</param>
        <param name="mode">Modalità di accesso; deve essere <see cref="F:System.IO.FileMode.Open" />.</param>
        <summary>Crea un file mappato alla memoria con la modalità di accesso specificata da un file su disco.</summary>
        <returns>File mappato alla memoria con la modalità di accesso specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `mode` parametro relativo ai file di origine sul disco. È possibile usare solo il <xref:System.IO.FileMode.Open> valore di enumerazione per creare il file mappato alla memoria dal file di origine sul disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota, contiene solo spazi vuoti o uno o più caratteri non validi, definiti da <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  
  
oppure 
 <paramref name="path" /> si riferisce a un dispositivo non valido.  
  
oppure 
 <paramref name="mode" /> è <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> è <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> o <see cref="F:System.IO.FileMode.Truncate" />.  
  
oppure 
 <paramref name="mode" /> è <see cref="F:System.IO.FileMode.OpenOrCreate" /> e il file su disco non esiste.  
  
oppure 
Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la lunghezza massima definita dal sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone delle autorizzazioni necessarie per il file.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso del file da mappare.</param>
        <param name="mode">Modalità di accesso; deve essere <see cref="F:System.IO.FileMode.Open" />.</param>
        <param name="mapName">Nome da assegnare al file di cui è stato eseguito il mapping alla memoria, oppure <see langword="null" /> per un elemento <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> che non si vuole condividere tra processi.</param>
        <summary>Crea un file mappato alla memoria con il nome e la modalità di accesso specificati da un file su disco.</summary>
        <returns>File mappato alla memoria con il nome e la modalità di accesso specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `mode` parametro relativo ai file di origine sul disco. È possibile usare solo il <xref:System.IO.FileMode.Open> valore di enumerazione per creare il file mappato alla memoria dal file di origine sul disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota, contiene solo spazi vuoti o uno o più caratteri non validi, definiti da <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  
  
oppure 
 <paramref name="path" /> si riferisce a un dispositivo non valido.  
  
oppure 
 Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="mode" /> è <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> è <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> o <see cref="F:System.IO.FileMode.Truncate" />.  
  
oppure 
 <paramref name="mode" /> è <see cref="F:System.IO.FileMode.OpenOrCreate" /> e il file su disco non esiste.  
  
oppure 
Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la lunghezza massima definita dal sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone delle autorizzazioni necessarie per il file.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Percorso del file da mappare.</param>
        <param name="mode">Modalità di accesso che può essere uno qualsiasi dei valori di enumerazione di <see cref="T:System.IO.FileMode" /> ad eccezione di <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nome da assegnare al file di cui è stato eseguito il mapping alla memoria, oppure <see langword="null" /> per un elemento <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> che non si vuole condividere tra processi.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria. Specificare 0 per impostare la capacità sulla dimensione del file su disco.</param>
        <summary>Crea un file mappato alla memoria con la modalità di accesso, il nome e la capacità specificati da un file su disco.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `mode` parametro relativo ai file di origine sul disco.  
  
 Se `capacity` è maggiore di quanto sono aumentare le dimensioni del file su disco, il file su disco per corrispondere la capacità specificata, anche se non vengono scritti dati nel file mappato alla memoria. Per evitare questo problema, specificare 0 (zero) per la capacità predefinita, che verrà impostato internamente `capacity` alla dimensione del file su disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> è una stringa vuota, contiene solo spazi vuoti o uno o più caratteri non validi, definiti da <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  
  
oppure 
 <paramref name="path" /> si riferisce a un dispositivo non valido.  
  
oppure 
 Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="mode" /> è <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è maggiore della dimensione dello spazio degli indirizzi logico.  
  
oppure 
 <paramref name="capacity" /> è minore di zero.  
  
oppure 
 <paramref name="capacity" /> è inferiore alla dimensione del file (ma non zero).  
  
oppure 
 <paramref name="capacity" /> è zero e anche la dimensione del file su disco è zero.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la lunghezza massima definita dal sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone delle autorizzazioni necessarie per il file.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Percorso del file da mappare.</param>
        <param name="mode">Modalità di accesso che può essere uno qualsiasi dei valori di enumerazione di <see cref="T:System.IO.FileMode" /> ad eccezione di <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nome da assegnare al file di cui è stato eseguito il mapping alla memoria, oppure <see langword="null" /> per un elemento <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> che non si vuole condividere tra processi.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria. Specificare 0 per impostare la capacità sulla dimensione del file su disco.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria.</param>
        <summary>Crea un file mappato alla memoria con la modalità di accesso, il nome, la capacità e il tipo di accesso specificati da un file su disco.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `mode` parametro relativo ai file di origine sul disco.  
  
 Se `capacity` è maggiore di quanto sono aumentare le dimensioni del file su disco, il file su disco per corrispondere la capacità specificata, anche se non vengono scritti dati nel file mappato alla memoria. Per evitare questo problema, specificare 0 (zero) per la capacità predefinita, che verrà impostato internamente `capacity` alla dimensione del file su disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="access" /> non è un valore consentito.  
  
oppure 
 <paramref name="path" /> specifica un file vuoto.  
  
oppure 
 <paramref name="access" /> viene specificato come <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> e la capacità è maggiore della dimensione del file indicata da <paramref name="path" />.  
  
oppure 
 <paramref name="mode" /> è <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è maggiore della dimensione dello spazio degli indirizzi logico.  
  
oppure 
 <paramref name="capacity" /> è minore di zero.  
  
oppure 
 <paramref name="capacity" /> è inferiore alla dimensione del file (ma non zero).  
  
oppure 
 <paramref name="capacity" /> è zero e anche la dimensione del file su disco è zero.  
  
oppure 
 <paramref name="access" /> non è un valore definito di <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />.  
  
oppure 
Le dimensioni del file indicate da <paramref name="path" /> sono maggiori di <paramref name="capacity" />.</exception>
        <exception cref="T:System.IO.IOException">oppure 
Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la lunghezza massima definita dal sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone delle autorizzazioni necessarie per il file.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileStream">Flusso di file del file esistente.</param>
        <param name="mapName">Nome da assegnare al file di cui è stato eseguito il mapping alla memoria, oppure <see langword="null" /> per un elemento <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> che non si vuole condividere tra processi.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria. Specificare 0 per impostare la capacità sulla dimensione di <c>filestream</c>.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria.  
  
Non è possibile impostare questo parametro su <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="inheritability">Uno dei valori di enumerazione che specifica se un handle al file mappato alla memoria può essere ereditato da un processo figlio. Il valore predefinito è <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen">Valore che indica se chiudere il flusso di file di origne quando <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> viene eliminato.</param>
        <summary>Crea un file mappato alla memoria da un file esistente con la modalità di accesso, il nome, l'ereditabilità e la capacità specificati.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> è <see langword="null" /> o una stringa vuota.  
  
oppure 
 <paramref name="capacity" /> e la lunghezza del file sono pari a zero.  
  
oppure 
 <paramref name="access" /> è impostato sul valore di enumerazione <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> che non è consentito.  
  
oppure 
 <paramref name="access" /> è impostato su <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> e <paramref name="capacity" /> è maggiore della lunghezza di <see langword="filestream" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileStream" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.  
  
oppure 
 <paramref name="capacity" /> è inferiore alla dimensione del file.  
  
oppure 
 <paramref name="access" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valido.  
  
oppure 
 <paramref name="inheritability" /> non è un valore di enumerazione <see cref="T:System.IO.HandleInheritability" /> valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, memoryMappedFileSecurity, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileStream">
          <c>fileStream</c> per il file di cui eseguire il mapping.</param>
        <param name="mapName">Nome da assegnare al file di cui è stato eseguito il mapping alla memoria, oppure <see langword="null" /> per un elemento <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> che non si vuole condividere tra processi.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria. Specificare 0 per impostare la capacità sulla dimensione del file su disco.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria.  
  
Non è possibile impostare questo parametro su <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="memoryMappedFileSecurity">Autorizzazioni che è possibile concedere per l'accesso ai file e le operazioni sui file mappati alla memoria.  
  
Questo parametro può essere <see langword="null" />.</param>
        <param name="inheritability">Uno dei valori di enumerazione che specifica se un handle al file mappato alla memoria può essere ereditato da un processo figlio. Il valore predefinito è <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen">
          <see langword="true" /> per non eliminare <c>fileStream</c> dopo la chiusura di <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />; <see langword="false" /> per eliminare <c>fileStream</c>.</param>
        <summary>Crea un file mappato alla memoria con il nome, la capacità, il tipo di accesso, le autorizzazioni di sicurezza, l'ereditabilità e requisito di eliminazione specificati da un file su disco.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `capacity` è maggiore di quanto sono aumentare le dimensioni del file su disco, il file su disco per corrispondere la capacità specificata, anche se non vengono scritti dati nel file mappato alla memoria. Per evitare questo problema, specificare 0 (zero) per la capacità predefinita, che verrà impostato internamente `capacity` alla dimensione del file su disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="capacity" /> e la lunghezza del file sono pari a zero.  
  
oppure 
 <paramref name="access" /> è impostato sul valore di enumerazione <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> che non è consentito.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileStream" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore di zero.  
  
oppure 
 <paramref name="capacity" /> è inferiore alla dimensione del file.  
  
oppure 
 <paramref name="access" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valido.  
  
oppure 
 <paramref name="inheritability" /> non è un valore di enumerazione <see cref="T:System.IO.HandleInheritability" /> valido.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="fileStream" /> è stato chiuso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> è impostato su <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> quando l'accesso di <paramref name="fileStream" /> è impostato su <see cref="F:System.IO.FileAccess.Read" /> o <see cref="F:System.IO.FileAccess.Write" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mapName" /> esiste già.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNew">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un file mappato alla memoria nella memoria di sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome da assegnare al file di cui è stato eseguito il mapping alla memoria, oppure <see langword="null" /> per un elemento <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> che non si vuole condividere tra processi.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria.</param>
        <summary>Crea un file mappato alla memoria con la capacità specificata nella memoria di sistema.</summary>
        <returns>File mappato alla memoria con il nome e la capacità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare un file mappato alla memoria che non è persistente (ovvero, non associato a un file su disco), che è possibile usare la condivisione dei dati tra processi.  
  
   
  
## Examples  
 Nell'esempio seguente è costituito da tre processi separati (applicazioni console) che scrivono `Boolean` valori in un file mappato alla memoria. Si verifica la sequenza di azioni seguente:  
  
1.  Un processo viene creato il file mappato alla memoria e scrive un valore.  
  
2.  Processo B apre il file mappato alla memoria e scrive un valore a esso.  
  
3.  Processo C apre il file mappato alla memoria e scrive un valore a esso.  
  
4.  Un processo legge e visualizza i valori dal file mappato alla memoria.  
  
5.  Una volta completato un processo con il file mappato alla memoria, il file viene immediatamente recuperato da garbage collection.  
  
 Per eseguire questo esempio, seguire questa procedura:  
  
1.  Compilare le applicazioni e aprire tre finestre di comando.  
  
2.  Nella prima finestra di comando, eseguire il processo A.  
  
3.  Nella seconda finestra di comando, eseguire il processo B.  
  
4.  Tornare al processo e premere INVIO.  
  
5.  Nella terza finestra di comando, eseguire il processo C.  
  
6.  Tornare al processo e premere INVIO.  
  
 Come indicato di seguito è riportato l'output del processo:  
  
```  
Start Process B and press ENTER to continue.  
Start Process C and press ENTER to continue.  
Process A says: True  
Process B says: False  
Process C says: True  
```  
  
 **Process A**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#1)]  
  
 **Process B**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/vb/program.vb#1)]  
  
 **Process C**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore o uguale a zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome da assegnare al file di cui è stato eseguito il mapping alla memoria, oppure <see langword="null" /> per un elemento <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> che non si vuole condividere tra processi.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria. Il valore predefinito è <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crea un file mappato alla memoria con la capacità e il tipo di accesso specificati nella memoria di sistema.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare un file mappato alla memoria che non è persistente (ovvero, non associato a un file su disco), che è possibile usare la condivisione dei dati tra processi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="access" /> viene impostato su sola scrittura con il valore di enumerazione <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore o uguale a zero.  
  
-oppure- 
 <paramref name="access" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome da assegnare al file di cui è stato eseguito il mapping alla memoria, oppure <see langword="null" /> per un elemento <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> che non si vuole condividere tra processi.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria. Il valore predefinito è <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinazione bit per bit di valori di enumerazione che specifica opzioni di allocazione della memoria per il file mappato alla memoria.</param>
        <param name="inheritability">Valore che specifica se un handle al file mappato alla memoria può essere ereditato da un processo figlio. Il valore predefinito è <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crea un file mappato alla memoria con il nome, la capacità, il tipo di accesso, le opzioni di allocazione di memoria e l'ereditabilità specificati.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="access" /> viene impostato su sola scrittura con il valore di enumerazione <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore o uguale a zero.  
  
-oppure- 
 <paramref name="access" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valido.  
  
oppure 
 <paramref name="inheritability" /> non è un valore valido di <see cref="T:System.IO.HandleInheritability" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome da assegnare al file di cui è stato eseguito il mapping alla memoria, oppure <see langword="null" /> per un elemento <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> che non si vuole condividere tra processi.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria. Il valore predefinito è <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinazione bit per bit di valori di enumerazione che specifica opzioni di allocazione della memoria per il file mappato alla memoria.</param>
        <param name="memoryMappedFileSecurity">Autorizzazioni che è possibile concedere per l'accesso ai file e le operazioni sui file mappati alla memoria.  
  
Questo parametro può essere <see langword="null" />.</param>
        <param name="inheritability">Uno dei valori di enumerazione che specifica se un handle al file mappato alla memoria può essere ereditato da un processo figlio. Il valore predefinito è <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crea un file mappato alla memoria con la capacità, il tipo di accesso, l'allocazione di memoria, le autorizzazioni di sicurezza e l'ereditabilità specificati nella memoria di sistema.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare un file mappato alla memoria che non è persistente (ovvero, non associato a un file su disco), che è possibile usare la condivisione dei dati tra processi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="access" /> viene impostato su sola scrittura con il valore di enumerazione <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è minore o uguale a zero.  
  
-oppure- 
 <paramref name="access" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valido.  
  
oppure 
 <paramref name="inheritability" /> non è un valore di enumerazione <see cref="T:System.IO.HandleInheritability" /> valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateOrOpen">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea o apre un file mappato alla memoria nella memoria di sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome del file di cui è stato eseguito il mapping alla memoria.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria.</param>
        <summary>Crea o apre un file di cui è stato eseguito il mapping alla memoria che ha il nome e la capacità specificati nella memoria di sistema.</summary>
        <returns>File mappato alla memoria con il nome e le dimensioni specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare o aprire un file mappato alla memoria che non è persistente (ovvero, non associato a un file su disco), che è possibile usare la condivisione dei dati tra processi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è maggiore della dimensione dello spazio degli indirizzi logico.  
  
oppure 
 <paramref name="capacity" /> è minore o uguale a zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome del file di cui è stato eseguito il mapping alla memoria.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria. Il valore predefinito è <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crea o apre un file di cui è stato eseguito il mapping alla memoria che ha il nome, la capacità e il tipo di accesso specificati nella memoria di sistema.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare o aprire un file mappato alla memoria che non è persistente (ovvero, non associato a un file su disco), che è possibile usare la condivisione dei dati tra processi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="access" /> viene impostato su sola scrittura con il valore di enumerazione <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è maggiore della dimensione dello spazio degli indirizzi logico.  
  
oppure 
 <paramref name="capacity" /> è minore o uguale a zero.  
  
-oppure- 
 <paramref name="access" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il sistema operativo ha negato l'accesso specificato al file; ad esempio, l'accesso è impostato su <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, ma il file o la directory è di sola lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome del file di cui è stato eseguito il mapping alla memoria.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria. Il valore predefinito è <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinazione bit per bit di valori che indicano le opzioni di allocazione della memoria da applicare al file.</param>
        <param name="inheritability">Valore che specifica se un handle al file mappato alla memoria può essere ereditato da un processo figlio. Il valore predefinito è <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crea un nuovo file mappato alla memoria vuoto oppure ne apre uno esistente se ne esiste uno con lo stesso nome. Nel caso dell'apertura di un file esistente, la capacità, le opzioni e gli argomenti relativi alla memoria verranno ignorati.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="access" /> viene impostato su sola scrittura con il valore di enumerazione <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è maggiore della dimensione dello spazio degli indirizzi logico.  
  
oppure 
 <paramref name="capacity" /> è minore o uguale a zero.  
  
-oppure- 
 <paramref name="access" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valido.  
  
oppure 
 <paramref name="inheritability" /> non è un valore di enumerazione <see cref="T:System.IO.HandleInheritability" /> valido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il sistema operativo ha negato l'accesso specificato al file; ad esempio, l'accesso è impostato su <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, ma il file o la directory è di sola lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome del file di cui è stato eseguito il mapping alla memoria.</param>
        <param name="capacity">Dimensioni massime, in byte, da allocare per il file mappato alla memoria.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria. Il valore predefinito è <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinazione bit per bit di valori di enumerazione che specifica opzioni di allocazione della memoria per il file mappato alla memoria.</param>
        <param name="memoryMappedFileSecurity">Autorizzazioni che è possibile concedere per l'accesso ai file e le operazioni sui file mappati alla memoria.  
  
Questo parametro può essere <see langword="null" />.</param>
        <param name="inheritability">Uno dei valori di enumerazione che specifica se un handle al file mappato alla memoria può essere ereditato da un processo figlio. Il valore predefinito è <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crea o apre un file di cui è stato eseguito il mapping alla memoria che ha il nome, la capacità, il tipo di accesso, l'allocazione di memoria, le autorizzazioni di sicurezza e l'ereditabilità specificati nella memoria di sistema.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare o aprire un file mappato alla memoria che non è persistente (ovvero, non associato a un file su disco), che è possibile usare la condivisione dei dati tra processi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.  
  
oppure 
 <paramref name="access" /> viene impostato su sola scrittura con il valore di enumerazione <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> è maggiore della dimensione dello spazio degli indirizzi logico.  
  
oppure 
 <paramref name="capacity" /> è minore o uguale a zero.  
  
-oppure- 
 <paramref name="access" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valido.  
  
oppure 
 <paramref name="inheritability" /> non è un valore di enumerazione <see cref="T:System.IO.HandleInheritability" /> valido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il sistema operativo ha negato <paramref name="access" /> specificato al file; ad esempio, <paramref name="access" /> viene impostato su <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, ma il file o la directory è di sola lettura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewAccessor">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un oggetto <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappato a una visualizzazione del file mappato alla memoria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor () As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor();" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un oggetto <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappato a una visualizzazione del file mappato alla memoria.</summary>
        <returns>Blocco di memoria ad accesso casuale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare la vista restituita da questo metodo per l'accesso casuale in un file mappato alla memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso al file mappato alla memoria non è autorizzato.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Byte in corrispondenza del quale iniziare la visualizzazione.</param>
        <param name="size">Dimensione della visualizzazione. Specificare 0 (zero) per creare una visualizzazione che inizia in corrispondenza di <c>offset</c> e termina approssimativamente alla fine del file mappato alla memoria.</param>
        <summary>Crea un oggetto <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappato a una visualizzazione del file mappato alla memoria, con l'offset e la dimensione specificati.</summary>
        <returns>Blocco di memoria ad accesso casuale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare la vista restituita da questo metodo per l'accesso casuale in un file mappato alla memoria.  
  
 Per creare una visione completa del file mappato alla memoria, specificare 0 (zero) per il `size` parametro. In questo caso, le dimensioni della visualizzazione potrebbero essere minore o maggiore della dimensione del file di origine sul disco. Infatti, sono disponibili le viste in unità pari a pagine di sistema e le dimensioni della visualizzazione viene arrotondata per eccesso sulla dimensione di pagina successiva del sistema.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una visualizzazione di un file mappato alla memoria e lo modifica. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> classe.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#2)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="size" /> è un valore negativo.  
  
oppure 
 <paramref name="size" /> è maggiore dello spazio degli indirizzi logico.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso al file mappato alla memoria non è autorizzato.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Byte in corrispondenza del quale iniziare la visualizzazione.</param>
        <param name="size">Dimensione della visualizzazione. Specificare 0 (zero) per creare una visualizzazione che inizia in corrispondenza di <c>offset</c> e termina approssimativamente alla fine del file mappato alla memoria.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria. Il valore predefinito è <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crea un oggetto <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> mappato a una visualizzazione del file mappato alla memoria, con l'offset, la dimensione e le restrizioni di accesso specificati.</summary>
        <returns>Blocco di memoria ad accesso casuale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare la vista restituita da questo metodo per l'accesso casuale in un file mappato alla memoria.  
  
 Per creare una visione completa del file mappato alla memoria, specificare 0 (zero) per il `size` parametro. In questo caso, le dimensioni della visualizzazione potrebbero essere minore o maggiore della dimensione del file di origine sul disco. Infatti, sono disponibili le viste in unità pari a pagine di sistema e le dimensioni della visualizzazione viene arrotondata per eccesso sulla dimensione di pagina successiva del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="size" /> è un valore negativo.  
  
oppure 
 <paramref name="size" /> è maggiore dello spazio degli indirizzi logico.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> è non valido per il file mappato alla memoria.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un flusso mappato a una visualizzazione del file mappato alla memoria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream () As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream();" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un flusso mappato a una visualizzazione del file mappato alla memoria.</summary>
        <returns>Flusso di memoria.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il flusso restituito da questo metodo per l'accesso sequenziale in un file mappato alla memoria, ad esempio per le comunicazioni tra processi.  
  
   
  
## Examples  
 Nell'esempio seguente crea un flusso e scrive un valore a esso. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> (metodo).  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#2)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso al file mappato alla memoria non è autorizzato.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Byte in corrispondenza del quale iniziare la visualizzazione.</param>
        <param name="size">Dimensione della visualizzazione. Specificare 0 (zero) per creare una visualizzazione che inizia in corrispondenza di <c>offset</c> e termina approssimativamente alla fine del file mappato alla memoria.</param>
        <summary>Crea un flusso mappato a una visualizzazione del file mappato alla memoria, con l'offset e la dimensione specificati.</summary>
        <returns>Flusso di memoria con l'offset e la dimensione specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il flusso restituito da questo metodo per l'accesso sequenziale in un file mappato alla memoria, ad esempio per le comunicazioni tra processi.  
  
 Per creare una visione completa del file mappato alla memoria, specificare 0 (zero) per il `size` parametro. In questo caso, le dimensioni della visualizzazione potrebbero essere minore o maggiore della dimensione del file di origine sul disco. Infatti, sono disponibili le viste in unità pari a pagine di sistema e le dimensioni della visualizzazione viene arrotondata per eccesso sulla dimensione di pagina successiva del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="size" /> è un valore negativo.  
  
oppure 
 <paramref name="size" /> è maggiore dello spazio degli indirizzi logico.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso al file mappato alla memoria non è autorizzato.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="size" /> è più grande della memoria virtuale totale.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Byte in corrispondenza del quale iniziare la visualizzazione.</param>
        <param name="size">Dimensione della visualizzazione. Specificare 0 (zero) per creare una visualizzazione che inizia in corrispondenza di <c>offset</c> e termina approssimativamente alla fine del file mappato alla memoria.</param>
        <param name="access">Uno dei valori di enumerazione che specifica il tipo di accesso consentito al file mappato alla memoria. Il valore predefinito è <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crea un flusso mappato a una visualizzazione del file mappato alla memoria, con l'offset, la dimensione e il tipo di accesso specificati.</summary>
        <returns>Flusso di memoria con le caratteristiche specificate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il flusso restituito da questo metodo per l'accesso sequenziale in un file mappato alla memoria, ad esempio per le comunicazioni tra processi.  
  
 Per creare una visione completa del file mappato alla memoria, specificare 0 (zero) per il `size` parametro. In questo caso, le dimensioni della visualizzazione potrebbero essere minore o maggiore della dimensione del file di origine sul disco. Infatti, sono disponibili le viste in unità pari a pagine di sistema e le dimensioni della visualizzazione viene arrotondata per eccesso sulla dimensione di pagina successiva del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="size" /> è un valore negativo.  
  
oppure 
 <paramref name="size" /> è maggiore dello spazio degli indirizzi logico.  
  
oppure 
 <paramref name="access" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> valido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> è non valido per il file mappato alla memoria.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="size" /> è più grande della memoria virtuale totale.  
  
oppure 
 <paramref name="access" /> è non valido per il file mappato alla memoria.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse usate da <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryMappedFile.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate da <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="memoryMappedFile.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MemoryMappedFileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Usage="memoryMappedFile.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il controllo di accesso della risorsa di un file mappato alla memoria.</summary>
        <returns>Autorizzazioni che è possibile concedere per l'accesso ai file e le operazioni sui file mappati alla memoria.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Una chiamata sottostante per l'impostazione delle informazioni di sicurezza non è riuscita.</exception>
        <exception cref="T:System.NotSupportedException">Una chiamata sottostante per l'impostazione delle informazioni di sicurezza non è riuscita.</exception>
        <exception cref="T:System.ObjectDisposedException">Il file mappato alla memoria è chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma corrente è Windows 98 o versioni precedenti.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Una chiamata sottostante per l'impostazione delle informazioni di sicurezza non è riuscita.  
  
oppure 
Il file mappato alla memoria è aperto solo come <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un file denominato mappato alla memoria esistente nella memoria di sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting mapName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome del file di cui è stato eseguito il mapping alla memoria.</param>
        <summary>Apre un file mappato alla memoria esistente con il nome specificato nella memoria di sistema.</summary>
        <returns>File mappato alla memoria con il nome specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il file mappato alla memoria può essere entrambi un persistente file mappato alla memoria (associato a un file su disco) o non persistente.  
  
   
  
## Examples  
 **Apertura di un File mappato alla memoria persistente**  
  
 Nell'esempio seguente viene aperto un file mappato alla memoria denominato `ImgA` che è già stato creato da un file su disco (come illustrato nell'esempio per il <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%28System.String%29> (metodo)).  
  
 [!code-csharp[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/cs/program.cs#1)]
 [!code-vb[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/vb/program.vb#1)]  
  
 **Apertura di un File mappato alla memoria Non persistente**  
  
 Nell'esempio seguente viene aperto un file mappato alla memoria utilizzato per la comunicazione tra processo. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%28System.String%2CSystem.Int64%29> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato per <paramref name="mapName" /> non esiste.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome del file mappato alla memoria da aprire.</param>
        <param name="desiredAccessRights">Uno dei valori di enumerazione che specifica i diritti di accesso da applicare al file mappato alla memoria.</param>
        <summary>Apre un file mappato alla memoria esistente con il nome e i diritti di accesso specificati nella memoria di sistema.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="desiredAccessRights" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato per <paramref name="mapName" /> non esiste.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nome del file mappato alla memoria da aprire.</param>
        <param name="desiredAccessRights">Uno dei valori di enumerazione che specifica i diritti di accesso da applicare al file mappato alla memoria.</param>
        <param name="inheritability">Uno dei valori di enumerazione che specifica se un handle al file mappato alla memoria può essere ereditato da un processo figlio. Il valore predefinito è <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Apre un file mappato alla memoria esistente con il nome, i diritti di accesso e l'ereditabilità specificati nella memoria di sistema.</summary>
        <returns>File mappato alla memoria con le caratteristiche specificate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="mapName" /> è una stringa vuota.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="desiredAccessRights" /> non è un valore di enumerazione <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> valido.  
  
oppure 
 <paramref name="inheritability" /> non è un valore di enumerazione <see cref="T:System.IO.HandleInheritability" /> valido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accesso richiesto non è valido per il file mappato alla memoria.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato per <paramref name="mapName" /> non esiste.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SafeMemoryMappedFileHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeMemoryMappedFileHandle As SafeMemoryMappedFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ SafeMemoryMappedFileHandle { Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeMemoryMappedFileHandle : Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle di file di un file mappato alla memoria.</summary>
        <value>Handle al file mappato alla memoria.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere al codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.SetAccessControl(System.IO.MemoryMappedFiles.MemoryMappedFileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.IO.MemoryMappedFiles.MemoryMappedFileSecurity -&gt; unit" Usage="memoryMappedFile.SetAccessControl memoryMappedFileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
      </Parameters>
      <Docs>
        <param name="memoryMappedFileSecurity">Autorizzazioni che è possibile concedere per l'accesso ai file e le operazioni sui file mappati alla memoria.</param>
        <summary>Imposta il controllo di accesso della risorsa di un file mappato alla memoria.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="memoryMappedFileSecurity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Una chiamata sottostante per l'impostazione delle informazioni di sicurezza non è riuscita.</exception>
        <exception cref="T:System.NotSupportedException">Una chiamata sottostante per l'impostazione delle informazioni di sicurezza non è riuscita.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Una chiamata sottostante per l'impostazione delle informazioni di sicurezza non è riuscita.</exception>
      </Docs>
    </Member>
  </Members>
</Type>