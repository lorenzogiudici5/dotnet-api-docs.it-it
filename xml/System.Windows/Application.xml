<Type Name="Application" FullName="System.Windows.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="24edbfc6ddc2b9854cb84a3649fc8e7689f8b408" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48607834" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Incapsula un'applicazione Windows Presentation Foundation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> è una classe che incapsula [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] funzionalità specifiche dell'applicazione, inclusi i seguenti:  
  
-   **Durata dell'applicazione**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.  
  
-   **Finestra di ambito dell'applicazione, proprietà e la gestione delle risorse**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.  
  
-   **Parametro della riga di comando e codice di uscita elaborazione**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Navigazione**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.  
  
 <xref:System.Windows.Application> implementa il pattern singleton per fornire l'accesso condiviso per la finestra proprietà e servizi nell'ambito di risorse. Di conseguenza, solo un'istanza di <xref:System.Windows.Application> classe può essere creata per ogni <xref:System.AppDomain>.  
  
 È possibile implementare un <xref:System.Windows.Application> tramite markup, markup e code-behind o codice. Se <xref:System.Windows.Application> viene implementata con markup, se markup o markup e code-behind, il file di markup deve essere configurato come un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` elemento.  
  
> [!NOTE]
>  Un'applicazione autonoma non richiede un <xref:System.Windows.Application> oggetto; è possibile implementare una classe personalizzata `static` metodo del punto di ingresso (`Main`) che apre una finestra senza creare un'istanza di <xref:System.Windows.Application>. Tuttavia [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] richiedono un <xref:System.Windows.Application> oggetto.  
  
   
  
## Examples  
 L'esempio seguente mostra come un'applicazione standard viene definito utilizzando solo markup:  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 Nell'esempio seguente viene illustrato come un'applicazione standard viene definita usando solo codice:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 L'esempio seguente mostra come un'applicazione standard viene definito mediante una combinazione di markup e code-behind.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Pubblico <see langword="static" /> (<see langword="Shared" /> in Visual Basic) membri di questo tipo sono thread-safe. Inoltre, il <see cref="M:System.Windows.Application.FindResource(System.Object)" /> e <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> metodi e le <see cref="P:System.Windows.Application.Properties" /> e <see cref="P:System.Windows.Application.Resources" /> proprietà sono thread-safe.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo un'istanza del <xref:System.Windows.Application> classe può essere creata per ogni <xref:System.AppDomain>, per garantire l'accesso condiviso per un singolo set di dati finestra proprietà e risorse dell'ambito dell'applicazione. Di conseguenza, il costruttore predefinito del <xref:System.Windows.Application> classe rileva se l'istanza in fase di inizializzazione è la prima istanza in un <xref:System.AppDomain>; in caso contrario, un <xref:System.InvalidOperationException> viene generata un'eccezione.  
  
 Il <xref:System.Windows.Application> oggetto corrente <xref:System.AppDomain> esposto dal statica <xref:System.Windows.Application.Current%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Per ogni oggetto <see cref="T:System.Windows.Application" /> vengono create più istanze della classe<see cref="T:System.AppDomain" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un'applicazione diventa l'applicazione in primo piano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene attivata un'applicazione Windows Presentation Foundation che ha uno o più finestre aperte (diventa l'applicazione in primo piano) quando una delle finestre è attivata per la prima volta dopo l'applicazione è stata avviata o quando una delle finestre è attivata mentre l'applicazione è inattiva: in particolare, l'attivazione si verifica quando:  
  
-   Un'applicazione apre la prima finestra.  
  
-   Un utente passa all'applicazione usando ALT + TAB oppure tramite Gestione attività.  
  
-   Un utente fa clic sul pulsante della barra delle applicazioni per una delle finestre in un'applicazione.  
  
 Possono gestire le applicazioni per rilevare l'attivazione di <xref:System.Windows.Application.Activated> evento.  
  
 Dopo aver attivata un'applicazione prima di tutto, può disattivato e riattivato molte volte durante la sua durata. Se il comportamento di un'applicazione o dello stato dipende dal relativo stato di attivazione, può gestire entrambe <xref:System.Windows.Application.Activated> e <xref:System.Windows.Application.Deactivated> eventi per determinare quale stato di attivazione di.  
  
 Una volta che un'applicazione diventa attiva, <xref:System.Windows.Application.Activated> non verrà generato nuovamente fino a quando non viene disattivata l'applicazione, indipendentemente dal numero di finestre all'interno di un'applicazione viene attivato anche se l'applicazione è attiva.  
  
 <xref:System.Windows.Application.Activated> non viene generato per [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come rilevare quando un'applicazione autonoma attiva e disattiva.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Windows.Application" /> per l'oggetto <see cref="T:System.AppDomain" /> corrente.</summary>
        <value>Oggetto <see cref="T:System.Windows.Application" /> per l'oggetto <see cref="T:System.AppDomain" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> è una per ogni-<xref:System.AppDomain> tipo singleton che implementa il metodo statico <xref:System.Windows.Application.Current%2A> proprietà per fornire l'accesso condiviso per il <xref:System.Windows.Application> istanza corrente <xref:System.AppDomain>. Questa progettazione garantisce che lo stato gestito da <xref:System.Windows.Application>, incluse le risorse condivise e lo stato, è disponibile da un'unica posizione condivisa.  
  
 Questa proprietà è thread-safe ed è disponibile da qualsiasi thread.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un'applicazione non è più l'applicazione in primo piano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione Windows Presentation Foundation che ha uno o più finestre aperte viene disattivata (non è l'applicazione in primo piano) quando un utente esegue le operazioni seguenti:  
  
-   Passa a un'altra applicazione con ALT + TAB oppure tramite Gestione attività.  
  
-   Fa clic sul pulsante della barra delle applicazioni per una finestra in un'altra applicazione.  
  
 Le applicazioni per rilevare la disattivazione può gestire il <xref:System.Windows.Application.Deactivated> evento.  
  
 Dopo aver attivata un'applicazione prima di tutto, può disattivato e riattivato molte volte durante la sua durata. Se il comportamento di un'applicazione o dello stato dipende dal relativo stato di attivazione, può gestire entrambe <xref:System.Windows.Application.Deactivated> e <xref:System.Windows.Application.Activated> eventi per determinare quale stato si di.  
  
 <xref:System.Windows.Application.Deactivated> non viene generato per [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come rilevare quando un'applicazione autonoma disattiva e attiva.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un'eccezione viene generata da un'applicazione ma non viene gestita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, Windows Presentation Foundation rileva le eccezioni non gestite, invia una notifica agli utenti dell'eccezione da una finestra di dialogo (da cui possono segnalare l'eccezione) e viene arrestato automaticamente un'applicazione.  
  
 Tuttavia, se un'applicazione deve eseguire l'elaborazione di eccezione non gestita personalizzata da una posizione centralizzata, è necessario gestire <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> viene generato da un <xref:System.Windows.Application> per ogni eccezione gestita dal codice in esecuzione sul thread principale dell'interfaccia utente.  
  
 Se un'eccezione non gestita nel thread dell'interfaccia utente uno sfondo (un thread con il proprio <xref:System.Windows.Threading.Dispatcher>) o un thread di lavoro in background (un thread senza un <xref:System.Windows.Threading.Dispatcher>), l'eccezione non viene inoltrato al thread principale dell'interfaccia utente. Di conseguenza, <xref:System.Windows.Application.DispatcherUnhandledException> non viene generato. In questi casi, è necessario scrivere codice per eseguire le operazioni seguenti:  
  
1.  Gestire le eccezioni nel thread in background.  
  
2.  Inviare le eccezioni nel thread UI principale.  
  
3.  Rigenerarle sul thread dell'interfaccia utente principale senza dover gestire, per consentire la <xref:System.Windows.Application.DispatcherUnhandledException> da generare.  
  
 Per altre informazioni, vedere la [modello di Threading](~/docs/framework/wpf/advanced/threading-model.md) Panoramica.  
  
 Il <xref:System.Windows.Application.DispatcherUnhandledException> gestore dell'evento viene passato un <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> argomento che contiene informazioni contestuali relative all'eccezione, tra cui:  
  
-   L'eccezione (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   Il <xref:System.Windows.Threading.Dispatcher> da cui ha avuto origine (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 È possibile usare queste informazioni per determinare se un'eccezione è ripristinabile o meno. Un'eccezione reversibile potrebbe essere un' <xref:System.IO.FileNotFoundException>, ad esempio, mentre potrebbe essere un'eccezione irreversibile un <xref:System.StackOverflowException>, ad esempio.  
  
 Quando si elabora un'eccezione non gestita da <xref:System.Windows.Application.DispatcherUnhandledException>, e non è auspicabile [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] per continuare l'elaborazione, è necessario impostare la <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> proprietà `true`.  
  
 A differenza di altri eventi che <xref:System.Windows.Application> genera, <xref:System.Windows.Application.DispatcherUnhandledException> non hanno una corrispondenza protetto implementazione virtuale (OnDispatcherUnhandledException). Di conseguenza, le classi che derivano da <xref:System.Windows.Application> devono sempre effettuare la registrazione di un gestore eventi con <xref:System.Windows.Application.DispatcherUnhandledException> per elaborare le eccezioni non gestite.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come elaborare le eccezioni non gestite tramite la gestione di <xref:System.Windows.Application.DispatcherUnhandledException> evento.  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica poco prima dell'arresto di un'applicazione e non può essere annullato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può arrestare per uno dei motivi seguenti:  
  
-   Il <xref:System.Windows.Application.Shutdown%2A> metodo per il <xref:System.Windows.Application> viene chiamato l'oggetto, in modo esplicito o come determinato dal <xref:System.Windows.Application.ShutdownMode%2A> proprietà.  
  
-   L'utente termina la sessione mediante disconnessione o arresto.  
  
 È possibile rilevare quando si verifica l'arresto dell'applicazione gestendo il <xref:System.Windows.Application.Exit> evento ed eseguire eventuali elaborazioni aggiuntive in base alle esigenze.  
  
 È anche possibile gestire <xref:System.Windows.Application.Exit> per controllare o modificare il codice di uscita dell'applicazione quando non è necessario chiamare <xref:System.Windows.Application.Shutdown%2A> in modo esplicito. Il codice di uscita viene esposta dal <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> proprietà del <xref:System.Windows.ExitEventArgs> argomento passato per il <xref:System.Windows.Application.Exit> gestore dell'evento. Quando l'applicazione interrompe l'esecuzione, il codice di uscita viene passato al sistema operativo per l'elaborazione successiva.  
  
 Se l'applicazione gestisce il <xref:System.Windows.Application.SessionEnding> eventi e successivamente lo Annulla, <xref:System.Windows.Application.Exit> non viene generato e l'applicazione continua l'esecuzione in base alla modalità di arresto.  
  
 Il codice di uscita può essere impostato da un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], anche se il valore viene ignorato.  
  
 Per la [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> viene generato nelle circostanze seguenti:  
  
-   Un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] utente esce dall'applicazione.  
  
-   Nelle [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], quando la scheda che ospita il [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] viene chiuso.  
  
-   Viene chiuso il browser.  
  
 In tutti i casi, il valore della <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> proprietà viene ignorata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come:  
  
-   Gestire il <xref:System.Windows.Application.Exit> evento.  
  
-   Esaminare e aggiornare il <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> proprietà del <xref:System.Windows.ExitEventArgs>.  
  
-   Scrivere una voce in un registro applicazioni nello spazio di memorizzazione isolato.  
  
-   Rendere persistente lo stato dell'applicazione isolato.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nome della risorsa da trovare.</param>
        <summary>Ricerca una risorsa dell'[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], ad esempio <see cref="T:System.Windows.Style" /> o <see cref="T:System.Windows.Media.Brush" />, con la chiave specificata e genera un'eccezione se la risorsa richiesta non viene trovata. Vedere [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md) (Risorse XAML).</summary>
        <returns>Oggetto risorsa richiesto. Se la risorsa richiesta non viene trovata, viene generata l'eccezione <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> primi passi nelle risorse dell'ambito dell'applicazione per la risorsa specificata. Risorse dell'ambito dell'applicazione vengono gestite dal <xref:System.Windows.Application>e vengono esposti dal <xref:System.Windows.Application.Resources%2A> proprietà. Se la risorsa specificata non viene trovata nel set di risorse dell'ambito dell'applicazione, <xref:System.Windows.Application.FindResource%2A> continua la ricerca tra le risorse di sistema. Le risorse di sistema sono le risorse di shell definite dall'utente e includono i colori, tipi di carattere e le configurazioni della shell. Questi sono esposti dal <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, e <xref:System.Windows.SystemParameters> tipi, rispettivamente, come proprietà statiche. Per utilizzare <xref:System.Windows.Application.FindResource%2A> per acquisirle, proprietà di chiave di risorsa sono progettate per essere passato a questi tipi anche espongono <xref:System.Windows.Application.FindResource%2A>, ad esempio <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Poiché <xref:System.Windows.Application.FindResource%2A> restituisce un oggetto, è necessario eseguire il cast del valore restituito del tipo appropriato, se la risorsa è stata trovata.  
  
> [!IMPORTANT]
>  Se si chiama questo metodo per una chiave che non viene trovata, viene generata un'eccezione. Se non si desidera gestire le eccezioni risultanti dalla chiamata <xref:System.Windows.Application.FindResource%2A>, chiamare <xref:System.Windows.Application.TryFindResource%2A> invece; <xref:System.Windows.Application.TryFindResource%2A> restituisce un `null` quando una risorsa richiesta non è stata trovata e non viene generata un'eccezione di riferimento.  
  
 Questo metodo è thread-safe e può essere chiamato da qualsiasi thread.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Windows.Application.FindResource%2A> per trovare una risorsa e per gestire <xref:System.Windows.ResourceReferenceKeyNotFoundException> se la risorsa non viene trovata.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Impossibile trovare la risorsa.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando uno strumento di navigazione nell'applicazione inizia la navigazione su un frammento di contenuto. La navigazione si verifica immediatamente se il frammento desiderato si trova nel contenuto corrente oppure dopo il caricamento del contenuto [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] di origine se il frammento desiderato si trova in un contenuto diverso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno strumento di navigazione può essere un' <xref:System.Windows.Navigation.NavigationWindow> o un <xref:System.Windows.Controls.Frame>.  
  
 Vedere <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">Oggetto <see cref="T:System.Uri" /> che esegue il mapping a una risorsa separata.</param>
        <summary>Restituisce un flusso di risorsa per un file di dati di contenuto situato in corrispondenza dell'oggetto <see cref="T:System.Uri" /> specificato. Vedere [WPF Application Resource, Content, and Data Files](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) (File di dati, di contenuto e di risorse dell'applicazione WPF).</summary>
        <returns>Oggetto <see cref="T:System.Windows.Resources.StreamResourceInfo" /> che contiene un file di dati di contenuto situato in corrispondenza dell'oggetto <see cref="T:System.Uri" /> specificato. Se la risorsa separata non viene trovata, viene restituito null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="T:System.Uri" /> passato a <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> è null.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Uri" /> passato a <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> è un oggetto <see cref="T:System.Uri" /> assoluto.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Oggetto <see cref="T:System.Uri" /> che specifica il percorso per cui è stato creato un cookie.</param>
        <summary>Recupera un cookie per il percorso specificato da <see cref="T:System.Uri" />.</summary>
        <returns>Valore di <see cref="T:System.String" /> se il cookie esiste; in caso contrario, viene generata un'eccezione <see cref="T:System.ComponentModel.Win32Exception" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> Recupera un cookie per l'oggetto specificato <xref:System.Uri>. Se il cookie non può essere recuperato, un <xref:System.ComponentModel.Win32Exception> viene generata un'eccezione. È necessario scrivere il codice per analizzare la stringa di cookie in un elenco di coppie nome/valore.  
  
 Per una panoramica di cookie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], vedere [Cenni preliminari sulla navigazione](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Se si verifica un problema durante il tentativo di recuperare il cookie specificato, viene generato un errore [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] dalla funzione <see langword="InternetGetCookie" /> (chiamata da <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per ottenere i cookie per un file basato su <see cref="T:System.Uri" />. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per ottenere i cookie per un file basata su <see cref="T:System.Uri" />. Enumerazione associata: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">Oggetto <see cref="T:System.Uri" /> che esegue il mapping a una risorsa separata nel sito di origine.</param>
        <summary>Restituisce un flusso di risorsa per un file di dati del sito di origine situato in corrispondenza dell'oggetto <see cref="T:System.Uri" /> specificato. Vedere [WPF Application Resource, Content, and Data Files](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) (File di dati, di contenuto e di risorse dell'applicazione WPF).</summary>
        <returns>Oggetto <see cref="T:System.Windows.Resources.StreamResourceInfo" /> che contiene un flusso di risorsa per un file di dati del sito di origine in corrispondenza dell'oggetto <see cref="T:System.Uri" /> specificato. Se la risorsa separata non viene trovata, viene restituito <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="T:System.Uri" /> passato a <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> è null.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Uri" /> passato a <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> non è relativo o è assoluto, ma non nel formato <c>pack://siteoforigin:,,,/</c>.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">Oggetto <see cref="T:System.Uri" /> che esegue il mapping a una risorsa incorporata.</param>
        <summary>Restituisce un flusso di risorsa per un file di dati della risorsa situato in corrispondenza dell'oggetto <see cref="T:System.Uri" /> specificato. Vedere [WPF Application Resource, Content, and Data Files](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) (File di dati, di contenuto e di risorse dell'applicazione WPF).</summary>
        <returns>Oggetto <see cref="T:System.Windows.Resources.StreamResourceInfo" /> che contiene un flusso di risorsa per un file di dati della risorsa situato in corrispondenza dell'oggetto <see cref="T:System.Uri" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <see cref="T:System.Uri" /> passato a <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> è null.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Uri" /> passato a <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> non è relativo o è assoluto, ma non nel formato <c>pack://application:,,,/</c>.</exception>
        <exception cref="T:System.IO.IOException">L'oggetto <see cref="T:System.Uri" /> passato a <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> non può essere individuato.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il contenuto verso cui è stata effettuata la navigazione da uno strumento di navigazione nell'applicazione è stato caricato, analizzato o sottoposto a rendering.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno strumento di navigazione può essere un' <xref:System.Windows.Navigation.NavigationWindow> o un <xref:System.Windows.Controls.Frame>.  
  
 Vedere <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  L'ascolto degli eventi nel contenuto, ad esempio la <xref:System.Windows.FrameworkElement.Loaded> evento su <xref:System.Windows.Controls.Page> prima di accedere alle proprietà di navigazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica un file [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] situato in corrispondenza dell'[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] file può essere un file di codice dell'applicazione (configurato come un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elemento Page) o un file di dati dell'applicazione (un file di risorse, file di contenuto o sito di origine del file; vedere [WPF Application Resource, contenuto e i file di dati](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Questo metodo non è thread-safe.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">Oggetto <see cref="T:System.Uri" /> associato a un file [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] relativo.</param>
        <summary>Carica un file [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] situato in corrispondenza dell'[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] specificato e lo converte in un'istanza dell'oggetto specificato dall'elemento radice del file [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <returns>Istanza dell'elemento radice specificato dal file XAML caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario convertire il valore restituito in modo esplicito lo stesso tipo dell'elemento radice del [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] file.  
  
 Il [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] file può essere un file di codice dell'applicazione (configurato come un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elemento Page) o un file di dati dell'applicazione (un file di risorse, file di contenuto o sito di origine del file; vedere [WPF Application Resource, contenuto e i file di dati](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Questo metodo non è thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Il valore del parametro <paramref name="resourceLocator" /> è un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] assoluto.</exception>
        <exception cref="T:System.Exception">Il file non è un file [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Oggetto dello stesso tipo dell'elemento radice del file [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</param>
        <param name="resourceLocator">Oggetto <see cref="T:System.Uri" /> associato a un file [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] relativo.</param>
        <summary>Carica un file [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] che si trova nella posizione specificata da [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] e lo converte in un'istanza dell'oggetto specificato dall'elemento radice del file [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] file può essere un file di codice dell'applicazione (configurato come un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elemento Page) o un file di dati dell'applicazione (un file di risorse, file di contenuto o sito di origine del file; vedere [WPF Application Resource, contenuto e i file di dati](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Questo metodo non è thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> è null.</exception>
        <exception cref="T:System.ArgumentException">Il valore del parametro <paramref name="resourceLocator" /> è un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] assoluto.</exception>
        <exception cref="T:System.Exception">
          <paramref name="component" /> è di un tipo che non corrisponde all'elemento radice del file [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la finestra principale dell'applicazione.</summary>
        <value>Oggetto <see cref="T:System.Windows.Window" /> definito come finestra principale dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> viene impostato automaticamente con un riferimento al primo <xref:System.Windows.Window> oggetto da cui creare istanze nel <xref:System.AppDomain>.  
  
 È possibile specificare un'altra finestra principale, impostando <xref:System.Windows.Application.MainWindow%2A> assegnazione di un altro <xref:System.Windows.Application.Windows%2A> dell'oggetto per il <xref:System.Windows.Application.MainWindow%2A> proprietà.  
  
 Se il <xref:System.Windows.Application.ShutdownMode%2A> proprietà del <xref:System.Windows.Application> è impostata su <xref:System.Windows.ShutdownMode.OnMainWindowClose>, chiudendo la finestra principale provoca l'arresto dell'applicazione.  
  
 È possibile impostare il <xref:System.Windows.Application.MainWindow%2A> proprietà dal [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], se la finestra principale di un'applicazione non è la finestra viene ottenuta impostando la <xref:System.Windows.Application.StartupUri%2A> proprietà in [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. Le due limitazioni del [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] approccio sono:  
  
-   È possibile specificare una [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-solo <xref:System.Windows.Window> o una [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-solo <xref:System.Windows.Navigation.NavigationWindow> come finestra principale.  
  
-   È necessario impostare il <xref:System.Windows.UIElement.Visibility%2A> proprietà della finestra si specifica, in caso contrario, non verrà visualizzata.  
  
 Il riferimento al primo <xref:System.Windows.Window> oggetto da cui creare istanze verrà inoltre aggiunto come primo elemento di <xref:System.Windows.Application.Windows%2A> raccolta. Se <xref:System.Windows.Application.MainWindow%2A> successivamente viene impostato con un riferimento a un altro <xref:System.Windows.Window>, verrà modificata la posizione dell'elemento con il riferimento alla finestra principale, mentre l'ordine degli elementi in <xref:System.Windows.Application.Windows%2A> rimane invariato. Di conseguenza, utilizzare sempre <xref:System.Windows.Application.MainWindow%2A> per fare riferimento alla finestra principale anziché il primo elemento nel <xref:System.Windows.Application.Windows%2A>.  
  
> [!NOTE]
>  Se la finestra principale è un <xref:System.Windows.Navigation.NavigationWindow>, ed è necessario un accesso specifico al <xref:System.Windows.Navigation.NavigationWindow> membri, è necessario il cast del valore di <xref:System.Windows.Application.MainWindow%2A> a <xref:System.Windows.Navigation.NavigationWindow>.  
>   
>  Questa proprietà è disponibile solo dal thread che ha creato il <xref:System.Windows.Application> oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come trovare la finestra principale dell'applicazione.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 Nell'esempio seguente viene illustrato come impostare <xref:System.Windows.Application.MainWindow%2A> usando [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 Nell'esempio seguente viene illustrato come creare un'istanza di <xref:System.Windows.Application.MainWindow%2A> nel codice durante l'avvio dell'applicazione.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Application.MainWindow" /> viene impostata da un'applicazione ospitata in un browser, ad esempio [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il contenuto verso cui viene effettuata la navigazione da uno strumento di navigazione nell'applicazione è stato trovato, anche se il caricamento può non essere stato completato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno strumento di navigazione può essere un' <xref:System.Windows.Navigation.NavigationWindow> o un <xref:System.Windows.Controls.Frame>.  
  
 Vedere <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando è richiesta una nuova navigazione da uno strumento di navigazione nell'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno strumento di navigazione può essere un' <xref:System.Windows.Navigation.NavigationWindow> o un <xref:System.Windows.Controls.Frame>.  
  
 Vedere <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica in caso di errore durante la navigazione di uno strumento di navigazione nell'applicazione sul contenuto richiesto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno strumento di navigazione può essere un' <xref:System.Windows.Navigation.NavigationWindow> o un <xref:System.Windows.Controls.Frame>.  
  
 Vedere <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica periodicamente durante un download gestito da uno strumento di navigazione nell'applicazione per fornire informazioni sullo stato di avanzamento della navigazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno strumento di navigazione può essere un' <xref:System.Windows.Navigation.NavigationWindow> o un <xref:System.Windows.Controls.Frame>.  
  
 Vedere <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene chiamato il metodo <see langword="StopLoading" /> di uno strumento di navigazione nell'applicazione oppure quando viene richiesta una nuova navigazione da uno strumento di navigazione mentre la navigazione corrente è in corso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno strumento di navigazione può essere un' <xref:System.Windows.Navigation.NavigationWindow> o un <xref:System.Windows.Controls.Frame>.  
  
 Vedere <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> genera l'evento <xref:System.Windows.Application.Activated>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnActivated%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnActivated%2A> nella classe di base se <xref:System.Windows.Application.Activated> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> genera l'evento <xref:System.Windows.Application.Deactivated>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnDeactivated%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnDeactivated%2A> nella classe di base se <xref:System.Windows.Application.Deactivated> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.ExitEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.Exit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> genera l'evento <xref:System.Windows.Application.Exit>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override di <xref:System.Windows.Application.OnExit%2A> (metodo). Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnExit%2A> nella classe di base se <xref:System.Windows.Application.Exit> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.FragmentNavigation" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> genera l'evento <xref:System.Windows.Application.FragmentNavigation>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnFragmentNavigation%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnFragmentNavigation%2A> nella classe di base se <xref:System.Windows.Application.FragmentNavigation> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.LoadCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> genera l'evento <xref:System.Windows.Application.LoadCompleted>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnLoadCompleted%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnLoadCompleted%2A> nella classe di base se <xref:System.Windows.Application.LoadCompleted> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.Navigated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> genera l'evento <xref:System.Windows.Application.Navigated>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnNavigated%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnNavigated%2A> nella classe di base se <xref:System.Windows.Application.Navigated> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.Navigating" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> genera l'evento <xref:System.Windows.Application.Navigating>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnNavigating%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnNavigating%2A> nella classe di base se <xref:System.Windows.Application.Navigating> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.NavigationFailed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> genera l'evento <xref:System.Windows.Application.NavigationFailed>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnNavigationFailed%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnNavigationFailed%2A> nella classe di base se <xref:System.Windows.Application.NavigationFailed> deve essere generato.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.NavigationProgress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> genera l'evento <xref:System.Windows.Application.NavigationProgress>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnNavigationProgress%2A>. Il metodo sottoposto a override deve chiamare in modo esplicito <xref:System.Windows.Application.OnNavigationProgress%2A> nella classe di base se <xref:System.Windows.Application.NavigationProgress> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.NavigationStopped" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> genera l'evento <xref:System.Windows.Application.NavigationStopped>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnNavigationStopped%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnNavigationStopped%2A> nella classe di base se <xref:System.Windows.Application.NavigationStopped> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.SessionEndingCancelEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.SessionEnding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> genera l'evento <xref:System.Windows.Application.SessionEnding>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnSessionEnding%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnSessionEnding%2A> nella classe di base se <xref:System.Windows.Application.SessionEnding> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.Windows.StartupEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Application.Startup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> genera l'evento <xref:System.Windows.Application.Startup>.  
  
 Un tipo che deriva da <xref:System.Windows.Application> può eseguire l'override <xref:System.Windows.Application.OnStartup%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Application.OnStartup%2A> nella classe di base se il <xref:System.Windows.Application.Startup> eventi deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un insieme di proprietà dell'ambito dell'applicazione.</summary>
        <value>Oggetto <see cref="T:System.Collections.IDictionary" /> contenente le proprietà dell'ambito dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> espone un dizionario tramite <xref:System.Windows.Application.Properties%2A> che è possibile usare per archiviare le proprietà dell'ambito dell'applicazione. In questo modo è possibile condividere lo stato tra tutto il codice in un <xref:System.AppDomain> in modo thread-safe, senza la necessità di scrivere il codice di stato.  
  
 Le proprietà archiviate in <xref:System.Windows.Application.Properties%2A> devono essere convertiti nel tipo restituito appropriato.  
  
 Il <xref:System.Windows.Application.Properties%2A> proprietà è thread-safe ed è disponibile da qualsiasi thread.  
  
   
  
## Examples  
 L'esempio seguente illustra come creare e usare una proprietà di ambito dell'applicazione tramite <xref:System.Windows.Application.Properties%2A>.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Reflection.Assembly" /> che fornisce l'[!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] di tipo pack per le risorse in un'applicazione [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</summary>
        <value>Riferimento all'oggetto <see cref="T:System.Reflection.Assembly" /> che fornisce l'[!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] di tipo pack per le risorse in un'applicazione [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] le risorse vengono risolte in fase di esecuzione rispetto all'assembly di voce, che è identificato dal valore restituito dal <xref:System.Reflection.Assembly.GetEntryAssembly%2A> (metodo).  
  
 L'assembly di ingresso è l'assembly restituito da <xref:System.Reflection.Assembly.GetEntryAssembly%2A> e sono i seguenti:  
  
-   L'assembly eseguibile nel dominio applicazione predefinito.  
  
-   Il primo assembly deve essere eseguito tramite una chiamata <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 Nei casi seguenti, tuttavia, un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly non è possibile ottenere un riferimento all'assembly di ingresso:  
  
-   Un host non gestito (nativo) applicazione di [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly.  
  
-   Un'applicazione gestita ospita le [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly caricandolo in un nuovo dominio applicazione con un metodo diverso <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 In entrambi i casi <xref:System.Reflection.Assembly.GetEntryAssembly%2A> restituisce `null`e il [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] risorse dell'assembly non possono essere risolte. In questi casi, <xref:System.Windows.Application.ResourceAssembly%2A> può essere impostata solo una volta, con un riferimento all'assembly che deve essere usato per risolvere le risorse.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> può essere impostato solo una volta perché è improbabile che l'assembly di risorse cambierà dopo le [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly viene caricato.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> non può essere impostata quando un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly possono individuare l'assembly di voce, vale a dire, quando <xref:System.Reflection.Assembly.GetEntryAssembly%2A> restituisce un riferimento a un assembly anziché `null`.  
  
 Questa proprietà è thread-safe ed è disponibile da qualsiasi thread.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> è stato introdotto in .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Un'applicazione [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ha un assembly di ingresso o <see cref="P:System.Windows.Application.ResourceAssembly" /> è già stata impostata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un insieme di risorse dell'ambito dell'applicazione, ad esempio stili e pennelli.</summary>
        <value>Oggetto <see cref="T:System.Windows.ResourceDictionary" /> contenente zero o più risorse dell'ambito dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Application.Resources%2A> proprietà può essere utilizzata per condividere risorse tra le finestre e gli elementi di un'applicazione. Inoltre, il <xref:System.Windows.Application.Resources%2A> proprietà è inclusa nel percorso di ricerca delle risorse, che viene attraversato nell'ordine seguente:  
  
1.  Elementi  
  
2.  WINDOWS  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  System  
  
 Di conseguenza, [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] alle risorse dell'ambito dell'applicazione è possibile associare elementi. Inoltre, se le risorse di modifica, il sistema risorse garantisce quell'elemento le proprietà associate a tali risorse vengono aggiornate automaticamente per riflettere la modifica.  
  
 Ambito dell'applicazione risorse fornisce un modo semplice per supportare un tema coerente tra l'applicazione. È possibile creare facilmente un tema in [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] utilizzando il `Application.Resources` tag. Tuttavia, se l'applicazione supporta più temi, che possono contenere un numero elevato di elementi dei temi, potrebbe essere più facile da gestire usando uno <xref:System.Windows.ResourceDictionary> istanza per ogni tema. In questo modo, è possibile applicare un nuovo tema impostando la proprietà delle risorse appropriati <xref:System.Windows.ResourceDictionary>.  
  
 Esistono due aspetti da considerare quando si usa <xref:System.Windows.Application.Resources%2A>. Per prima cosa, il dizionario *chiave* è un oggetto, pertanto è necessario usare esattamente la stessa istanza dell'oggetto sia quando si imposta e ottiene un valore della proprietà (si noti che la chiave tra maiuscole e minuscole quando si usa una stringa). In secondo luogo, il dizionario *valore* è un oggetto, pertanto sarà necessario convertire il valore al tipo desiderato quando si recupera un valore della proprietà.  
  
 <xref:System.Windows.Application.Resources%2A> è thread-safe ed è disponibile da qualsiasi thread.  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] insieme alle risorse dell'ambito dell'applicazione per creare un aspetto coerente.  
  
 [!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 Nell'esempio seguente viene illustrato come impostare una risorsa dell'applicazione nel codice e XAML.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 Nell'esempio seguente viene illustrato come ottenere una risorsa dell'applicazione nel codice.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia un'applicazione Windows Presentation Foundation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia un'applicazione Windows Presentation Foundation.</summary>
        <returns>Codice di uscita dell'applicazione <see cref="T:System.Int32" /> restituito al sistema operativo quando l'applicazione viene chiusa. Per impostazione predefinita, il valore del codice di uscita è 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> viene chiamato per avviare un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] dell'applicazione. Se si definiscono i <xref:System.Windows.Application> tramite markup, o markup e code-behind, <xref:System.Windows.Application.Run%2A> verrà chiamato in modo implicito. Tuttavia, se si definiscono i <xref:System.Windows.Application> tramite codice, è necessario chiamare in modo esplicito <xref:System.Windows.Application.Run%2A>.  
  
 Quando <xref:System.Windows.Application.Run%2A> viene chiamato <xref:System.Windows.Application> collega un nuovo <xref:System.Windows.Threading.Dispatcher> istanza al thread dell'interfaccia utente. Successivamente, il <xref:System.Windows.Threading.Dispatcher> dell'oggetto <xref:System.Windows.Threading.Dispatcher.Run%2A> metodo viene chiamato, che avvia un message pump per elaborare i messaggi di windows. Infine, il <xref:System.Windows.Threading.Dispatcher> object chiama il <xref:System.Windows.Application> dell'oggetto il <xref:System.Windows.Application.OnStartup%2A> metodo per generare il <xref:System.Windows.Application.Startup> evento. Di conseguenza, il modello di esecuzione dell'applicazione è stato stabilito nel momento in cui gestiscono <xref:System.Windows.Application.Startup>, a questo punto viene considerata l'applicazione sia in esecuzione.  
  
 Un'applicazione non è in esecuzione quando <xref:System.Windows.Application.Shutdown%2A> viene chiamato; il valore della <xref:System.Windows.Application.ShutdownMode%2A> proprietà determina il momento <xref:System.Windows.Application.Shutdown%2A> viene chiamato e se l'operazione viene eseguita automaticamente o in modo esplicito è necessario chiamarlo.  
  
 <xref:System.Windows.Application.Run%2A> può essere chiamato solo dal thread che crea il <xref:System.Windows.Application> oggetto. È inoltre <xref:System.Windows.Application.Run%2A> non può essere chiamato da un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
   
  
## Examples  
 L'esempio seguente illustra un'applicazione che usa una classe personalizzata <xref:System.Windows.Application> e pertanto è necessario chiamare esplicitamente <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Application.Run" /> viene chiamato da un'applicazione ospitata dal browser, ad esempio un'[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">Oggetto <see cref="T:System.Windows.Window" /> che si apre automaticamente quando viene avviata un'applicazione.</param>
        <summary>Avvia un'applicazione Windows Presentation Foundation e verrà visualizzata la finestra specificata.</summary>
        <returns>Codice di uscita dell'applicazione <see cref="T:System.Int32" /> restituito al sistema operativo quando l'applicazione viene chiusa. Per impostazione predefinita, il valore del codice di uscita è 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload estende la <xref:System.Windows.Application.Run%2A> metodo per aprire la finestra specificata dopo l'avvio di un'applicazione in esecuzione.  
  
 Se si definisce un codice <xref:System.Windows.Application> che apre una finestra all'avvio dell'esecuzione, chiamare in modo esplicito <xref:System.Windows.Application.Run%2A>.  
  
 Se si crea il <xref:System.Windows.Application> tramite markup, o markup e code-behind, è possibile aprire automaticamente una finestra utilizzando una delle tecniche seguenti:  
  
-   In modo dichiarativo, tramite l'impostazione <xref:System.Windows.Application.StartupUri%2A>.  
  
-   A livello di programmazione, gestendo <xref:System.Windows.Application.Startup>.  
  
   
  
## Examples  
 L'esempio seguente illustra un'applicazione con un metodo del punto di ingresso statico creato manualmente che crea un'istanza <xref:System.Windows.Application>, prima di chiamare <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Application.Run" /> viene chiamato da un'applicazione ospitata dal browser, ad esempio un'[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'utente termina la sessione di Windows mediante disconnessione o arresto del sistema operativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un'applicazione viene chiusa quando la sessione termina Windows, che si verifica quando un utente si disconnette o arresta. In questo caso, Windows chiede di arrestare ogni applicazione aperta. Tuttavia, è possibile che un'applicazione potrebbe non essere pronta ad arrestare in questo caso. Ad esempio, un'applicazione potrebbe avere dei dati che si trovano in uno stato incoerente o eseguendo un'operazione a esecuzione prolungata. In questi casi, potrebbe essere auspicabile impedire che la sessione e potrebbe essere più utile per consentire agli utenti la possibilità di decidere se inviare o meno consentire di terminare la sessione.  
  
 È possibile rilevare quando una sessione termina gestendo il <xref:System.Windows.Application.SessionEnding> evento. Se un'applicazione deve impedire che la sessione, il <xref:System.Windows.SessionEndingCancelEventArgs> argomento passato al gestore dell'evento espone il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> impostata su `true` (il valore predefinito è `false`).  
  
 Se <xref:System.Windows.Application.SessionEnding> non viene gestita o viene gestita senza essere annullato <xref:System.Windows.Application.Shutdown%2A> viene chiamato e il <xref:System.Windows.Application.Exit> viene generato l'evento.  
  
 Per ottenere altre informazioni sui motivi per cui la sessione sta terminando, un'applicazione può controllare <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, ovvero una delle <xref:System.Windows.ReasonSessionEnding> valori (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> e <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding> non viene generato dalle applicazioni console.  
  
 <xref:System.Windows.Application.SessionEnding> viene generato solo per il thread che crea il <xref:System.Windows.Application> oggetto.  
  
 <xref:System.Windows.Application.SessionEnding> non viene generato per le applicazioni browser XAML (XBAP).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come gestire il <xref:System.Windows.Application.SessionEnding> eventi e consentire all'utente di annullare l'operazione.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">Oggetto <see cref="T:System.Uri" /> che specifica il percorso per cui deve essere creato il cookie.</param>
        <param name="value">Oggetto <see cref="T:System.String" /> che contiene i dati del cookie.</param>
        <summary>Crea un cookie per il percorso specificato da <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un cookie è un dato arbitrario che possono essere archiviati da un'applicazione nel computer client durante le sessioni dell'applicazione (i cookie di sessione) o tra sessioni dell'applicazione (cookie permanenti). È possibile creare entrambi i tipi di cookie chiamando <xref:System.Windows.Application.SetCookie%2A>.  
  
 I dati dei cookie in genere assume la forma di coppia nome/valore nel formato seguente:  
  
 `Name=Value`  
  
 Si passa una stringa di questo formato in cui <xref:System.Windows.Application.SetCookie%2A>, insieme al <xref:System.Uri> della posizione per il quale il cookie deve essere impostato (in genere, il dominio dell'applicazione).  
  
 Se un cookie è un cookie di sessione o un cookie persistente dipende dal fatto che il cookie di stringa che passa a <xref:System.Windows.Application.SetCookie%2A> include una data di scadenza. La stringa di un cookie di sessione non include una data di scadenza. Questo caso, la stringa di un cookie permanente e deve essere nel formato seguente:  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 I cookie permanenti vengono archiviati nell'attuale [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] cartella file temporanei Internet dell'installazione finché non scadono, nel qual caso vengono eliminati. È possibile eliminare un cookie persistente dall'applicazione impostando la data di scadenza su un valore data/ora che è nel passato.  
  
 Per una panoramica di cookie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], vedere [Cenni preliminari sulla navigazione](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Se si verifica un problema durante il tentativo di creare il cookie specificato, viene generato un errore [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] dalla funzione <see langword="InternetSetCookie" /> (chiamata da <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per ottenere i cookie per un file basato su <see cref="T:System.Uri" />. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per ottenere i cookie per un file basata su <see cref="T:System.Uri" />. Enumerazione associata: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Arresta un'applicazione</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta un'applicazione</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si <xref:System.Windows.Application.Shutdown%2A> viene chiamato, un'applicazione si arresta. È possibile gestire il <xref:System.Windows.Application.Exit> eventi per rilevare quando un'applicazione sta per arrestare l'esecuzione, per eseguire qualsiasi elaborazione appropriata.  
  
 <xref:System.Windows.Application.Shutdown%2A> viene chiamato in modo implicito da Windows Presentation Foundation nelle situazioni seguenti:  
  
-   Quando <xref:System.Windows.Application.ShutdownMode%2A> è impostata su <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
-   Quando la <xref:System.Windows.Application.ShutdownMode%2A> è impostata su <xref:System.Windows.ShutdownMode.OnMainWindowClose>.  
  
-   Quando un utente termina una sessione e <xref:System.Windows.Application.SessionEnding> evento è non gestito oppure gestire senza l'annullamento.  
  
 La chiamata <xref:System.Windows.Application.Shutdown%2A> fa in modo esplicito in modo che un'applicazione all'arresto, indipendentemente il <xref:System.Windows.Application.ShutdownMode%2A> impostazione. Tuttavia, se <xref:System.Windows.Application.ShutdownMode%2A> è impostata su <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, è necessario chiamare <xref:System.Windows.Application.Shutdown%2A> per arrestare un'applicazione.  
  
> [!IMPORTANT]
>  Quando <xref:System.Windows.Application.Shutdown%2A> viene chiamato, l'applicazione verrà arrestata indipendentemente dal fatto che il <xref:System.Windows.Window.Closing> evento di tutte le finestre aperte viene annullato.  
  
 Questo metodo può essere chiamato solo dal thread che ha creato il <xref:System.Windows.Application> oggetto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione usare tutte le finestre e gli eventi input utente senza alcuna restrizione. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Codice di uscita di tipo integer per un'applicazione. Il codice di uscita predefinito è 0.</param>
        <summary>Arresta un'applicazione che restituisce il codice di uscita specificato al sistema operativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile gestire il <xref:System.Windows.Application.Exit> evento per impostare un codice di uscita. Tuttavia, se si chiama in modo esplicito <xref:System.Windows.Application.Shutdown%2A>, e si gestiscono <xref:System.Windows.Application.Exit> solo per impostare un codice di uscita, è possibile chiamare <xref:System.Windows.Application.Shutdown%2A> invece.  
  
 Questo metodo può essere chiamato solo dal thread che ha creato il <xref:System.Windows.Application> oggetto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione usare tutte le finestre e gli eventi input utente senza alcuna restrizione. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la condizione che provoca la chiamata al metodo <see cref="M:System.Windows.Application.Shutdown" />.</summary>
        <value>Valore di enumerazione <see cref="T:System.Windows.ShutdownMode" />. Il valore predefinito è <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le applicazioni smettono di funzionare solo quando il <xref:System.Windows.Application.Shutdown%2A> dell'applicazione viene chiamato. Arresto può verificarsi in modo implicito o esplicito, come specificato dal valore della <xref:System.Windows.Application.ShutdownMode%2A> proprietà.  
  
 Se si imposta <xref:System.Windows.Application.ShutdownMode%2A> al <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) chiama implicitamente <xref:System.Windows.Application.Shutdown%2A> quando viene chiusa l'ultima finestra in un'applicazione, anche se tutte le finestre attualmente un'istanza vengono impostate come finestra principale (vedere <xref:System.Windows.Application.MainWindow%2A>).  
  
 Un <xref:System.Windows.Application.ShutdownMode%2A> dei <xref:System.Windows.ShutdownMode.OnMainWindowClose> consente a WPF chiama in modo implicito <xref:System.Windows.Application.Shutdown%2A> quando il <xref:System.Windows.Application.MainWindow%2A> chiuso, anche se sono aperte altre finestre.  
  
 La durata di alcune applicazioni potrebbe non essere dipenda da quando la finestra principale o dell'ultima finestra viene chiusa o potrebbe non essere affatto dipende da windows. Per questi scenari è necessario impostare il <xref:System.Windows.Application.ShutdownMode%2A> proprietà <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, che richiede l'impostazione esplicita <xref:System.Windows.Application.Shutdown%2A> chiamata al metodo per interrompere l'applicazione. In caso contrario, l'applicazione continua l'esecuzione in background.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> può essere configurata in modo dichiarativo nel [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] o a livello di codice dal codice.  
  
 Questa proprietà è disponibile solo dal thread che ha creato il <xref:System.Windows.Application> oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come configurare <xref:System.Windows.Application.ShutdownMode%2A> per specificare che un'applicazione deve essere chiuso in modo esplicito.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene chiamato il metodo <see cref="M:System.Windows.Application.Run" /> dell'oggetto <see cref="T:System.Windows.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una tipica applicazione Windows Presentation Foundation può eseguire una serie di attività di inizializzazione all'avvio, tra cui:  
  
-   Parametri della riga di comando di elaborazione.  
  
-   Aprire la finestra principale.  
  
-   Inizializzazione delle risorse dell'ambito dell'applicazione.  
  
-   L'inizializzazione delle proprietà di ambito dell'applicazione.  
  
 È possibile specificare in modo dichiarativo la finestra principale e le risorse dell'ambito dell'applicazione utilizzando [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> e <xref:System.Windows.Application.Resources%2A>rispettivamente). In alcuni casi, tuttavia, le risorse o una finestra principale dell'applicazione può essere determinata solo a livello di codice in fase di esecuzione. Inoltre, le proprietà dell'ambito dell'applicazione e i parametri della riga di comando utilizzabile solo a livello di codice. Inizializzazione a livello di codice può essere eseguita gestendo i <xref:System.Windows.Application.Startup> evento, inclusi i seguenti:  
  
-   Acquisire ed elaborare i parametri della riga di comando, che sono disponibili i <xref:System.Windows.StartupEventArgs.Args%2A> proprietà del <xref:System.Windows.StartupEventArgs> classe che viene passato al <xref:System.Windows.Application.Startup> gestore dell'evento.  
  
-   Inizializzare le risorse all'applicazione tramite il <xref:System.Windows.Application.Resources%2A> proprietà.  
  
-   Inizializzare le proprietà dell'ambito dell'applicazione usando il <xref:System.Windows.Application.Properties%2A> proprietà.  
  
-   Creare un'istanza e Mostra le finestre di uno (o più).  
  
> [!NOTE]
>  I parametri della riga di comando possono anche essere acquisiti chiamando il metodo statico <xref:System.Environment.GetCommandLineArgs%2A> metodo di <xref:System.Environment> oggetto. Tuttavia, <xref:System.Environment.GetCommandLineArgs%2A> richiede attendibilità totale per l'esecuzione.  
  
 Se si imposta <xref:System.Windows.Application.StartupUri%2A> usando [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], non è disponibile dalla finestra principale che viene creata il <xref:System.Windows.Application.MainWindow%2A> proprietà o il <xref:System.Windows.Application.Windows%2A> proprietà del <xref:System.Windows.Application> oggetto fino a dopo il <xref:System.Windows.Application.Startup> evento venga elaborato. Se è necessario accedere alla finestra principale durante l'avvio, è necessario creare manualmente un nuovo oggetto finestra di <xref:System.Windows.Application.Startup> gestore dell'evento.  
  
> [!NOTE]
>  Se l'applicazione usa <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> per specificare un criterio di credenziali, è necessario impostare <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> dopo <xref:System.Windows.Application.Startup> generato; in caso contrario, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] lo imposta su criteri interni predefiniti direttamente dopo il <xref:System.Windows.Application.Startup> evento è stato generato.  
  
 Gli argomenti della riga di comando passati al <xref:System.Windows.Application.Startup> gestore dell'evento non sono le stesse il [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] i parametri di stringa passati a query un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come acquisire ed elaborare le opzioni della riga di comando da un'applicazione autonoma. Se il **/StartMinimized** è stato specificato il parametro della riga di comando, l'applicazione verrà visualizzata la finestra principale in uno stato ridotto a icona.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] è in grado di recuperare ed elaborare gli argomenti della riga di comando perché vengono avviate con [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] distribuzione (vedere [distribuire un'applicazione WPF (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). Tuttavia, possono recuperare ed elaborare parametri della stringa di query dagli URL usati per avviarle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un'interfaccia utente che viene visualizzata automaticamente all'avvio di un'applicazione.</summary>
        <value>Oggetto <see cref="T:System.Uri" /> che fa riferimento all'interfaccia utente che verrà aperta automaticamente all'avvio di un'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare <xref:System.Windows.Application.StartupUri%2A> caricherà automaticamente una risorsa dell'interfaccia utente all'avvio di un'applicazione.  
  
 Nella tabella seguente illustra i tipi di risorse dell'interfaccia utente che possono essere caricate, il tipo di finestra in cui vengono aperte e il tipo di applicazione che è possono impostare queste risorse come la <xref:System.Windows.Application.StartupUri%2A>.  
  
|Tipo|Finestra|Tipo di applicazione|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Solo per installazioni autonome|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Solo per installazioni autonome|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomo/ospitate da un browser|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomo/ospitate da un browser|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomo/ospitate da un browser|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Autonomo/ospitate da un browser|  
  
 In genere, si imposta la <xref:System.Windows.Application.StartupUri%2A> proprietà in modo dichiarativo nel [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]. Tuttavia, è possibile impostare <xref:System.Windows.Application.StartupUri%2A> a livello di programmazione, ad esempio da un <xref:System.Windows.Application.Startup> gestore eventi, che risulta utile per le applicazioni che è possono caricare solo le risorse dell'interfaccia utente necessarie in fase di esecuzione. Ad esempio, un'applicazione potrebbe attendere fino alla fase di esecuzione per caricare le relative risorse se il nome della risorsa dell'interfaccia utente viene archiviato in un file di configurazione.  
  
 Se si imposta <xref:System.Windows.Application.StartupUri%2A> in modo dichiarativo o a livello di codice, la risorsa dell'interfaccia utente corrispondente viene caricata solo dopo il <xref:System.Windows.Application.Startup> viene gestito l'evento. Di conseguenza, si avrà accesso alla finestra risultante da una di <xref:System.Windows.Application.Windows%2A> proprietà o il <xref:System.Windows.Application.MainWindow%2A> proprietà quando si gestiscono <xref:System.Windows.Application.Startup>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Windows.Application.StartupUri" /> è impostata con un valore null.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nome della proprietà di ambiente richiesta.</param>
        <summary>Esegue una query per determinare se una proprietà di ambiente specificata è disponibile nell'ambito corrente.</summary>
        <returns>
          <see langword="true" /> se la proprietà di ambiente richiesta è disponibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Windows.Application> a un'interfaccia <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nome della risorsa da trovare.</param>
        <summary>Ricerca la risorsa specificata.</summary>
        <returns>Oggetto risorsa richiesto. Se la risorsa richiesta non viene trovata, viene restituito un riferimento null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> primi passi nelle risorse dell'ambito dell'applicazione per la risorsa specificata. Risorse dell'ambito dell'applicazione vengono gestite dal <xref:System.Windows.Application>e vengono esposti dal <xref:System.Windows.Application.Resources%2A> proprietà. Se la risorsa specificata non viene trovata nel set di risorse dell'ambito dell'applicazione, <xref:System.Windows.Application.TryFindResource%2A> continua la ricerca tra le risorse di sistema. Le risorse di sistema sono le risorse di shell definite dall'utente e includono i colori, tipi di carattere e le configurazioni della shell. Questi sono esposti dal <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, e <xref:System.Windows.SystemParameters> tipi, rispettivamente, come proprietà statiche. Per utilizzare <xref:System.Windows.Application.TryFindResource%2A> per acquisirle, proprietà di chiave di risorsa sono progettate per essere passato a questi tipi anche espongono <xref:System.Windows.Application.TryFindResource%2A>, ad esempio <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Poiché <xref:System.Windows.Application.TryFindResource%2A> restituisce un oggetto, è necessario eseguire il cast del valore restituito del tipo appropriato, se la risorsa è stata trovata.  
  
 Questo metodo è thread-safe e può essere chiamato da qualsiasi thread.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Windows.Application.TryFindResource%2A> per acquisire una risorsa.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le finestre di cui è stata creata un'istanza in un'applicazione.</summary>
        <value>Oggetto <see cref="T:System.Windows.WindowCollection" /> contenente riferimenti a tutti gli oggetti finestra nell'oggetto <see cref="T:System.AppDomain" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Window> riferimento viene automaticamente aggiunto al <xref:System.Windows.Application.Windows%2A> , non appena viene creata un'istanza di una finestra nel [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] thread; windows creati dal thread di lavoro non sono stati aggiunti i thread. Oggetto <xref:System.Windows.Window> riferimento viene rimosso automaticamente dopo il relativo <xref:System.Windows.Window.Closing> evento è stato gestito e prima relativo <xref:System.Windows.Window.Closed> viene generato l'evento.  
  
 Per impostazione predefinita, il primo elemento aggiunto per il <xref:System.Windows.Application.Windows%2A> proprietà diventa di <xref:System.Windows.Application.MainWindow%2A>.  
  
 Questa proprietà è disponibile solo dal thread che ha creato il <xref:System.Windows.Application> oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come enumerare i <xref:System.Windows.Application.Windows%2A> proprietà per creare un menu di primo livello Windows, che è comune a [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] le applicazioni come [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], o, ad esempio le applicazioni Single Document Interface (SDI) di più istanze [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>