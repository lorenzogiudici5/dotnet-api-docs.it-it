<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de09d337e79e341ade969dc527e1b9b6c0b3d7c6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36461424" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.DependencyProperty> supporta le funzionalità seguenti in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   La proprietà può essere impostata in uno stile. Per altre informazioni, vedere [Applicazione di stili e modelli](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   La proprietà può essere impostata tramite l'associazione dati. Per ulteriori informazioni sulle proprietà di dipendenza di associazione dati, vedere [procedura: associare le proprietà dei due controlli](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   La proprietà può essere impostata con un riferimento alla risorsa dinamica. Per altre informazioni, vedere [Risorse XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   La proprietà può ereditare automaticamente il valore da un elemento padre nell'albero degli elementi. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   La proprietà può essere animata. Per altre informazioni, vedere [Panoramica dell'animazione](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   La proprietà può segnalare quando il valore precedente della proprietà è stato modificato e può essere assegnato il valore della proprietà. Per altre informazioni, vedere [Callback e convalida delle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   La proprietà vengono fornite informazioni per [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], ad esempio se la modifica di un valore della proprietà richiede il sistema di layout per ricomporre gli elementi visivi di un elemento.  
  
-   La proprietà riceve supporto nel [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Ad esempio, la proprietà può essere modificata nella **proprietà** finestra.  
  
 Per ulteriori informazioni sulle proprietà di dipendenza, vedere [Cenni preliminari sulle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Se si desidera che le proprietà nei tipi personalizzati per supportare le funzionalità nell'elenco precedente, è necessario creare una proprietà di dipendenza.  Per informazioni su come creare proprietà di dipendenza personalizzata, vedere [proprietà di dipendenza personalizzate](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Una proprietà associata è una proprietà che consente a qualsiasi oggetto per fornire le informazioni per il tipo che definisce la proprietà associata. In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], qualsiasi tipo che eredita da <xref:System.Windows.DependencyObject> può usare una proprietà associata indipendentemente dal fatto il tipo eredita dal tipo che definisce la proprietà. Una proprietà associata è una funzionalità del [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] language.  Per impostare una proprietà associata nel [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], usare il *ownerType*.* propertyName* sintassi. Un esempio di una proprietà associata è il <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> proprietà. Se si desidera creare una proprietà che può essere usata in tutti i <xref:System.Windows.DependencyObject> tipi, sarà necessario creare una proprietà associata. Per ulteriori informazioni sulle proprietà associate e su come crearle, vedere [collegato Cenni preliminari sulle proprietà](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Valori XAML  
 `dependencyPropertyName`  
 Stringa che specifica il <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> della proprietà di dipendenza desiderato. Questo può essere preceduto dal prefisso dello spazio dei nomi XML, se la proprietà non è presente nello spazio dei nomi XML predefinito (per informazioni dettagliate, vedere [spazi dei nomi XAML ed eseguendo il Mapping Namespace per XAML di WPF](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Stringa che specifica un tipo di proprietario di una proprietà di dipendenza, un punto (.), quindi il <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` possono anche essere preceduti dal prefisso dello spazio dei nomi XML. Questo utilizzo è specifico di associazione tardiva stili e modelli, in cui il proprietario della proprietà di dipendenza deve essere specificato per l'analisi del contesto perché il `TargetType` non è ancora noto. Per altre informazioni, vedere [Applicazione di stili e modelli](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Stringa che specifica il proprietario di una proprietà associata, un punto (.), quindi il nome della proprietà associata. `attachedPropertyOwnerType` possono anche essere preceduti dal prefisso dello spazio dei nomi XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds another type as an owner of a dependency property that has already been registered to a type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as an owner of this dependency property.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente al sistema di proprietà di riconoscere una proprietà di dipendenza in un tipo che non è stato registrato tale particolare proprietà di dipendenza inizialmente.  
  
 In genere, <xref:System.Windows.DependencyProperty.AddOwner%2A> consente di aggiungere le proprietà di dipendenza per le classi che non espongono già la proprietà di dipendenza tramite l'ereditarietà di classe gestita (ereditarietà della classe causerebbe le proprietà di wrapper vengano ereditati dalla classe derivata di conseguenza fornisce l'accesso alla tabella dei membri generale per la proprietà di dipendenza già). <xref:System.Windows.DependencyProperty.AddOwner%2A> consente al sistema di proprietà di riconoscere una proprietà di dipendenza in un tipo che non è stato registrato la proprietà di dipendenza inizialmente.  
  
 Questa firma non consentono di specificare i metadati.  Quando si utilizza questo metodo, i metadati viene generato automaticamente per il nuovo <xref:System.Windows.DependencyProperty> e il relativo tipo di proprietario. I metadati generati automaticamente sono il risultato di metadati uniti di tutti i tipi di base che dispongono di questa proprietà definita. Se non sono metadati di merge sono disponibili, i metadati predefiniti per la proprietà viene utilizzato. Se la proprietà viene registrata con il <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metodo e quindi i metadati predefiniti equivale a metadati che viene creato quando <xref:System.Windows.DependencyProperty.RegisterAttached%2A> è stato chiamato. In caso contrario, il <xref:System.Windows.PropertyMetadata> oggetto viene creato con il <xref:System.Windows.PropertyMetadata.DefaultValue%2A> impostata per impostazione predefinita del tipo di proprietà e tutte le altre proprietà del <xref:System.Windows.PropertyMetadata> è impostata su `null`. Utilizzare il <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> firma se si desidera fornire i metadati per la versione della proprietà di dipendenza con l'aggiunta al tipo specificato.  
  
 Il valore restituito di questo metodo viene in genere utilizzato per dichiarare ed esporre la proprietà di dipendenza archiviando un identificatore della proprietà di dipendenza. L'identificatore fornisce l'accesso alla proprietà di dipendenza se si desidera chiamare sistema di proprietà [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in base alla proprietà di dipendenza, in particolare perché esiste nella classe di aggiunta del proprietario. Lo stesso nome di proprietà per proprietario originale sia proprietario aggiunto deve essere utilizzato per indicare la funzionalità simile. È consigliabile utilizzare il <xref:System.Windows.DependencyProperty> del valore restituito di <xref:System.Windows.DependencyProperty.AddOwner%2A> metodo per definire l'identificatore della proprietà di dipendenza, nonché per dichiarare [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper della proprietà, per le proprietà di dipendenza che vengono aggiunti ai tipi tramite <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Il <xref:System.Windows.DependencyProperty.AddOwner%2A> metodologia consigliata sopra viene utilizzato durante la creazione di proprietà di dipendenza che vengono dichiarate all'interno di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Ad esempio, entrambi <xref:System.Windows.Controls.Border> e <xref:System.Windows.Controls.Control> definiscono un `BorderBrush` proprietà di dipendenza, che hanno una funzionalità simile. <xref:System.Windows.Controls.Control> definisce il relativo `BorderBrush` proprietà al sistema di proprietà chiamando <xref:System.Windows.DependencyProperty.AddOwner%2A> basato sul proprietario originale <xref:System.Windows.Controls.Border> e il relativo registrati <xref:System.Windows.Controls.Border.BorderBrushProperty> identificatore della proprietà di dipendenza. Il <xref:System.Windows.DependencyProperty.AddOwner%2A> valore restituito viene quindi utilizzato per stabilire un nuovo valore statico <xref:System.Windows.DependencyProperty> campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) per la proprietà sul proprietario aggiunto e un `BorderBrush` wrapper della proprietà viene dichiarato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as owner of this dependency property.</param>
        <param name="typeMetadata">The metadata that qualifies the dependency property as it exists on the provided type.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente al sistema di proprietà di riconoscere una proprietà di dipendenza in un tipo che non è stato registrato tale particolare proprietà di dipendenza inizialmente.  
  
 Il valore restituito di questo metodo viene utilizzato per dichiarare ed esporre la proprietà di dipendenza, in particolare nello stato attuale per la classe proprietario aggiunta. Generalmente, lo stesso nome di proprietà per proprietario originale sia proprietario aggiunto deve essere usato per indicare la funzionalità simile. È buona norma per esporre gli identificatori, nonché i nuovi [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper della proprietà, per le proprietà di dipendenza che vengono aggiunti ai tipi tramite <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Il <xref:System.Windows.DependencyProperty.AddOwner%2A> metodologia consigliata sopra viene utilizzata per creare [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] dichiarati all'interno di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Ad esempio, entrambi <xref:System.Windows.Controls.Border> e <xref:System.Windows.Controls.Control> definiscono un `BorderBrush` proprietà di dipendenza, che hanno una funzionalità simile. <xref:System.Windows.Controls.Control> definisce il relativo `BorderBrush` proprietà al sistema di proprietà chiamando <xref:System.Windows.DependencyProperty.AddOwner%2A> sul proprietario originale <xref:System.Windows.Controls.Border> e il relativo registrati <xref:System.Windows.Controls.Border.BorderBrushProperty> identificatore della proprietà di dipendenza. Il <xref:System.Windows.DependencyProperty.AddOwner%2A> valore restituito viene quindi utilizzato per stabilire un valore statico <xref:System.Windows.DependencyProperty> campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) per la proprietà sul proprietario aggiunto e un `BorderBrush` wrapper della proprietà viene dichiarato.  
  
 Identificatore della proprietà di dipendenza del proprietario aggiunto deve essere utilizzato per le operazioni, ad esempio <xref:System.Windows.DependencyObject.GetValue%2A>. Tuttavia, operazioni specifiche del tipo che coinvolgono tipi o le istanze della classe che è stato aggiunto come proprietario con metadati diversi verrà comunque restituiranno risultati previsti anche se originale (non il proprietario aggiunto) viene specificato nell'identificatore della proprietà di dipendenza le chiamate a metodi quali <xref:System.Windows.DependencyObject.GetValue%2A> o <xref:System.Windows.DependencyProperty.GetMetadata%2A>. I metadati per il proprietario aggiunto vengono trasmessi dal <xref:System.Windows.DependencyProperty.AddOwner%2A> chiamare se stesso, non necessariamente fa in modo esclusivo nel campo identificatore di classe proprietario aggiunta. Tuttavia, è buona norma per esporre l'identificatore, nonché i nuovi [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper della proprietà, per le proprietà di dipendenza che vengono aggiunti ai tipi tramite <xref:System.Windows.DependencyProperty.AddOwner%2A>, poiché in caso contrario crea disparità tra le [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] e[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] rappresentazioni delle proprietà.  
  
 I metadati forniti viene unito con i metadati della proprietà per la proprietà di dipendenza nello stato attuale per il proprietario di basa. Verranno mantenute tutte le caratteristiche specificate nei metadati di base originali. Solo le caratteristiche che sono state modificate in particolare nei nuovi metadati sostituiranno le caratteristiche dei metadati di base. Alcune caratteristiche, ad esempio <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, vengono sostituiti se vengono specificate nei nuovi metadati. Altri, ad esempio <xref:System.Windows.PropertyChangedCallback>, vengono combinate. Infine, il comportamento di tipo merge dipende dal tipo di metadati proprietà utilizzato per la sostituzione, pertanto il comportamento qui descritto è per le classi di metadati di proprietà esistenti utilizzate da [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà di dipendenza. Per informazioni dettagliate, vedere [metadati della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-metadata.md) e [i metadati della proprietà Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default metadata of the dependency property.</summary>
        <value>I metadati predefiniti della proprietà di dipendenza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I metadati predefiniti sono i metadati della proprietà che sono disponibili per quel particolare oggetto o un oggetto di un tipo derivato in cui i metadati alternativi non sono stati forniti da esplicita <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chiamare.  
  
 Se il proprietario originale applicati i metadati per il primo <xref:System.Windows.DependencyProperty.Register%2A> chiamata che ha stabilito la proprietà di dipendenza, quindi che i metadati viene restituito come <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Se i metadati non sono stati applicati nell'originale <xref:System.Windows.DependencyProperty.Register%2A> chiamare, quindi metadati predefiniti vengono generati dall'interno di <xref:System.Windows.DependencyProperty.Register%2A> chiamata e questo valore viene restituito come il <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Lo scopo principale di avere metadati predefiniti associati a un <xref:System.Windows.DependencyProperty> consiste nel fornire un valore predefinito per questa proprietà su qualsiasi <xref:System.Windows.DependencyObject> o un tipo derivato.  
  
 Per le proprietà non associate, il tipo di metadati restituito da questa proprietà non è possibile eseguire il cast a tipi derivati di <xref:System.Windows.PropertyMetadata> digita, anche se la proprietà è stata originariamente registrata con un tipo di metadati derivato. Se si desidera che i metadati registrati in origine, incluso il tipo di metadati derivati eventualmente originale, chiamare <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> invece il passaggio di registrazione originale del tipo come parametro.  
  
 Per le proprietà associate, il tipo di metadati restituiti da questa proprietà corrisponderà al tipo specificato nell'originale <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metodo di registrazione.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for this <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>The hash code for this <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il sistema di proprietà utilizza un identificatore univoco <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, e viene restituito il valore della proprietà da <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the metadata associated with this dependency property as it exists for a particular type. This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">The specific type from which to retrieve the dependency property metadata.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified existing type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica il tipo o un riferimento all'oggetto da utilizzare come tipo di operazione è necessario perché i metadati possono variare dalla registrazione originale a causa delle <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chiamate che modificano i metadati della proprietà di dipendenza nello stato attuale per un tipo.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene i metadati per una proprietà di dipendenza in base al tipo. Il tipo di ottenere un `typeof` operatore.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</param>
        <summary>Returns the metadata for this dependency property as it exists on the specified object instance.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica il tipo o un riferimento all'oggetto è necessaria perché i metadati di qualsiasi proprietà di dipendenza possono variare dalla registrazione originale a causa delle <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chiamate che possono definire i metadati della proprietà nello stato attuale per un tipo.  
  
 Quando si richiedono i metadati della proprietà in base a un'istanza, si è semplicemente passando l'istanza in modo che il tipo può essere valutato internamente. Metadati della proprietà di dipendenza non variano per ogni istanza. è sempre coerenza per qualsiasi combinazione di proprietà del tipo specificato.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene i metadati per una proprietà di dipendenza in base a uno specifico <xref:System.Windows.DependencyObject> istanza.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">A specific object that records the dependency object type from which the dependency property metadata is desired.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica il tipo o un riferimento all'oggetto è necessaria perché i metadati di qualsiasi proprietà di dipendenza possono variare dalla registrazione originale a causa delle <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chiamate che possono definire i metadati della proprietà nello stato attuale per un tipo.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene i metadati per una proprietà di dipendenza in base alle relative <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an internally generated value that uniquely identifies the dependency property.</summary>
        <value>Identificatore numerico univoco.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo valore è un numero intero, non un identificatore univoco globale (GUID). In genere, non è necessario usare questo valore di indice e non è disponibile alcun indice accesso alle tabelle di tutte le proprietà di dipendenza. Le proprietà di dipendenza devono invece essere utilizzato come riferimento dai campi dell'identificatore.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> viene utilizzata internamente per un accesso più rapido alle strutture di dati che utilizzano il <xref:System.Windows.DependencyProperty.GlobalIndex%2A> come un indice di matrice in base zero. Un utilizzo simile potrebbe avere applicazioni per gli strumenti o finestre di progettazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</summary>
        <returns>
          <see langword="true" /> if the specified value is the registered property type or an acceptable derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore `null` è un tipo valido per le proprietà di dipendenza di tipo riferimento o per un <xref:System.Nullable%601> proprietà di dipendenza e restituirebbe `true` in questi casi. Nei casi in cui la proprietà di dipendenza né un riferimento né <xref:System.Nullable%601> digitare <xref:System.Windows.DependencyProperty.IsValidType%2A> restituirà `false` per un valore null anziché generare un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata <xref:System.Windows.DependencyProperty.IsValidType%2A> come un controllo prima di chiamare <xref:System.Windows.DependencyObject.SetValue%2A> nella proprietà di dipendenza.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</summary>
        <returns>
          <see langword="true" /> if the value is acceptable and is of the correct type or a derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una proprietà di dipendenza, è possibile specificare un intervallo di valori per quel tipo consentito tramite un <xref:System.Windows.ValidateValueCallback> fornito nella registrazione della proprietà di dipendenza.  
  
 Questo metodo chiama <xref:System.Windows.DependencyProperty.IsValidType%2A> internamente. Se la proprietà di dipendenza in questione non ha alcun <xref:System.Windows.ValidateValueCallback>, quindi chiamare questo metodo è equivale alla chiamata al metodo <xref:System.Windows.DependencyProperty.IsValidType%2A>. Se la proprietà di dipendenza dispone di un <xref:System.Windows.ValidateValueCallback>e se <xref:System.Windows.DependencyProperty.IsValidType%2A> avrebbe restituito `true`, il valore restituito sarà come implementato nel callback.  
  
 Un valore null è un valore valido per le proprietà di dipendenza di tipo riferimento o per un <xref:System.Nullable%601> proprietà di dipendenza e restituirebbe `true` in questi casi. Nei casi in cui la proprietà di dipendenza né un riferimento né <xref:System.Nullable%601> digitare <xref:System.Windows.DependencyProperty.IsValidType%2A> restituirà `false` per un valore null anziché generare un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata <xref:System.Windows.DependencyProperty.IsValidValue%2A> come un controllo prima di chiamare <xref:System.Windows.DependencyObject.SetValue%2A> nella proprietà di dipendenza.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the dependency property.</summary>
        <value>Nome della proprietà.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà ottiene il nome fornito come il `name` parametro durante la registrazione di proprietà di dipendenza. Questo nome è modificabile e non può essere `null` o una stringa vuota. Nome duplicato registrazioni sullo stesso tipo di proprietario non sono consentite e verranno generata un'eccezione quando si tenta di registrare il duplicato.  
  
> [!IMPORTANT]
>  Il <xref:System.Windows.DependencyProperty.Name%2A> una dipendenza della proprietà deve seguire la convenzione di corrispondere al nome dell'identificatore di proprietà dipendenza meno il suffisso "Proprietà". Per informazioni dettagliate, vedere [Proprietà di dipendenza personalizzate](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 Nell'esempio seguente esegue una query varie caratteristiche di un identificatore della proprietà di dipendenza, inclusi il <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <summary>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima che il sistema di proprietà viene utilizzata la proprietà di dipendenza, è necessario eseguire l'override dei metadati di proprietà di dipendenza. Ciò equivale al tempo istanze specifiche vengono create usando la classe che registra la proprietà di dipendenza. Le chiamate a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> deve essere eseguita solo all'interno dei costruttori statici del tipo che fornisce se stesso come il `forType` parametro di questo metodo, o tramite la creazione di istanze simili. Tentativo di modificare i metadati dopo esistono istanze del tipo di proprietario non saranno generate eccezioni, ma comporterà comportamenti incoerenti nel sistema di proprietà.  
  
 Dopo aver stabilito i metadati per una determinata classe derivata di sostituzione con questo metodo, i tentativi successivi di eseguire l'override dei metadati su questa stessa classe derivata verranno generata un'eccezione.  
  
 I metadati forniti viene unito con i metadati della proprietà per la proprietà di dipendenza nello stato attuale per il proprietario di basa. Tutte le caratteristiche specificate nei metadati di base originali verranno mantenuti; solo le caratteristiche che sono state modificate in particolare nei nuovi metadati sostituiranno le caratteristiche dei metadati di base. Alcune caratteristiche, ad esempio <xref:System.Windows.PropertyMetadata.DefaultValue%2A> vengono sostituite se è specificato nei nuovi metadati. Altri, ad esempio <xref:System.Windows.PropertyChangedCallback>, vengono combinate. Infine, il comportamento di tipo merge dipende dal tipo di metadati proprietà utilizzato per la sostituzione, pertanto il comportamento qui descritto è per le classi di metadati di proprietà esistenti utilizzate da [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà di dipendenza. Per informazioni dettagliate, vedere [metadati della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-metadata.md) e [i metadati della proprietà Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</exception>
        <exception cref="T:System.ArgumentException">Metadata was already established for the dependency property as it exists on the provided type.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <param name="key">The access key for a read-only dependency property.</param>
        <summary>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration. You must pass the <see cref="T:System.Windows.DependencyPropertyKey" /> for the read-only dependency property to avoid raising an exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa firma fornisce l'implementazione sottostante per un identificatore della proprietà di dipendenza di sola lettura (<xref:System.Windows.DependencyPropertyKey>) metodo. Se si esegue l'override dei metadati per una proprietà di dipendenza di lettura / scrittura, utilizzare <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Prima che il sistema di proprietà viene utilizzata la proprietà di dipendenza, è necessario eseguire l'override dei metadati di proprietà di dipendenza. Ciò corrisponde all'ora a cui vengono creati oggetti specifici per la classe che registra la proprietà di dipendenza. Le chiamate a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> deve essere eseguita solo all'interno dei costruttori statici del tipo che fornisce se stesso come il `forType` parametro di questo metodo, o tramite la creazione di istanze simili. Tentativo di modificare i metadati dopo esistono istanze del tipo di proprietario non saranno generate eccezioni, ma comporterà comportamenti incoerenti nel sistema di proprietà.  
  
 Dopo aver stabilito i metadati per una determinata classe derivata di sostituzione con questo metodo, i tentativi successivi di eseguire l'override dei metadati su questa stessa classe derivata verranno generata un'eccezione.  
  
 I metadati forniti viene unito con i metadati della proprietà per la proprietà di dipendenza nello stato attuale per il proprietario di basa. Tutte le caratteristiche specificate nei metadati di base originali verranno mantenuti; solo le caratteristiche che sono state modificate in particolare nei nuovi metadati sostituiranno le caratteristiche dei metadati di base. Alcune caratteristiche, ad esempio <xref:System.Windows.PropertyMetadata.DefaultValue%2A> vengono sostituite se è specificato nei nuovi metadati. Altri, ad esempio <xref:System.Windows.PropertyChangedCallback>, vengono combinate. Il comportamento di tipo merge dipende dal tipo di metadati di proprietà utilizzato per l'override. Per informazioni dettagliate, vedere [metadati della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-metadata.md) e [i metadati della proprietà Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</summary>
        <value>Tipo dell'oggetto che ha registrato la proprietà o che si è aggiunto come proprietario della proprietà.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo valore è stato fornito durante la registrazione di proprietà. Il proprietario sarà il tipo della registrazione originale in caso di un <xref:System.Windows.DependencyProperty> identificatore generato da un <xref:System.Windows.DependencyProperty.Register%2A> chiamata o il tipo che è stato aggiunto come proprietario nel caso di un <xref:System.Windows.DependencyProperty> identificatore generato da un <xref:System.Windows.DependencyProperty.AddOwner%2A> chiamare.  
  
 Il <xref:System.Windows.DependencyProperty.OwnerType%2A> in un dato <xref:System.Windows.DependencyProperty> non è modificabile e non può essere `null` in un valore valido <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene il tipo di proprietario in base a un identificatore della proprietà di dipendenza `dp`e quindi Ottiene i metadati sul tipo di proprietario per l'identificatore stesso. Questa operazione è davvero equivalente a <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> su `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type that the dependency property uses for its value.</summary>
        <value>Il <see cref="T:System.Type" /> del valore della proprietà.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà indica il tipo del valore della proprietà come dichiarato dalla registrazione originale della proprietà, tramite il `propertyType` parametro. Simile al <xref:System.Windows.DependencyProperty.Name%2A>, il tipo di proprietà di una proprietà di dipendenza non è modificabile dopo la registrazione.  
  
   
  
## Examples  
 Nell'esempio seguente esegue una query varie caratteristiche di un identificatore della proprietà di dipendenza, inclusi il <xref:System.Windows.DependencyProperty.PropertyType%2A>. La stringa del nome del tipo di <xref:System.Windows.DependencyProperty.PropertyType%2A> viene ottenuto da restituito <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the dependency property identified by this <see cref="T:System.Windows.DependencyProperty" /> instance is a read-only dependency property.</summary>
        <value>
          <see langword="true" /> Se la proprietà di dipendenza è di sola lettura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le proprietà di dipendenza di sola lettura vengono registrate all'interno del sistema di proprietà chiamando il <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> metodo anziché il <xref:System.Windows.DependencyProperty.Register%2A> metodo. Le proprietà associate possono essere registrate come di sola lettura. vedere <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Le proprietà di dipendenza di sola lettura richiedono un <xref:System.Windows.DependencyPropertyKey> identificatore piuttosto che un <xref:System.Windows.DependencyProperty> identificatore per eseguire operazioni sui metadati, ad esempio si esegue l'override dei metadati o l'impostazione del valore. Se è stato acquistato una raccolta di <xref:System.Windows.DependencyProperty> identificatori tramite una chiamata a <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> o da un'altra [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] che espone gli identificatori, controllare il <xref:System.Windows.DependencyProperty.ReadOnly%2A> valore prima di chiamare <xref:System.Windows.DependencyObject.SetValue%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> specificando lo stesso Identificatore della proprietà di dipendenza come parametro di input, per verificare che la proprietà di dipendenza che rappresenta l'identificatore non è di sola lettura. Se il valore di <xref:System.Windows.DependencyProperty.ReadOnly%2A> viene `true` su una proprietà di dipendenza, non vi è alcuna modalità programmatica per ottenere un riferimento al <xref:System.Windows.DependencyPropertyKey> identificatore di tale proprietà di dipendenza, dai metadati o dal <xref:System.Windows.DependencyProperty> identificatore; identificatore deve essere disponibile come un campo statico per poter chiamare <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> in base a una proprietà di dipendenza di sola lettura.  
  
 Quando si crea una proprietà di dipendenza personalizzata e registrarlo in sola lettura, è consigliabile definire solo una funzione di accesso get per il [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] proprietà wrapper. In caso contrario, la classe avrà un modello a oggetti poco chiaro per il wrapper della proprietà se confrontato all'accesso alla proprietà di dipendenza di backup. Per informazioni dettagliate, vedere [le proprietà di dipendenza personalizzata](~/docs/framework/wpf/advanced/custom-dependency-properties.md) oppure [delle proprietà di dipendenza di sola lettura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Nell'esempio seguente ottiene i metadati predefiniti e le proprietà identificatore di proprietà di dipendenza da vari campi di proprietà di dipendenza e utilizza le informazioni per popolare una tabella per implementare un browser"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register. The name must be unique within the registration namespace of the owner type.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L'esempio seguente registra una proprietà di dipendenza, incluso un callback di convalida (la definizione di callback non viene mostrata; per informazioni dettagliate sulla definizione del callback, vedere <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers an attached property with the property system.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers an attached property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà associata è un concetto di proprietà definito da [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementa le proprietà associate come proprietà di dipendenza. Poiché il [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] proprietà associate sono proprietà di dipendenza, possono avere metadati applicati che possono essere utilizzato dal sistema di proprietà generale per operazioni quali la segnalazione delle caratteristiche di layout. Per altre informazioni, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Nell'esempio seguente registra una proprietà associata in una classe astratta usando questa <xref:System.Windows.DependencyProperty.RegisterAttached%2A> firma.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <summary>Registers an attached property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà associata è un concetto di proprietà definito da [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementa le proprietà associate come proprietà di dipendenza. Poiché il [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] proprietà associate sono proprietà di dipendenza, possono avere metadati applicati che possono essere utilizzato dal sistema di proprietà generale per operazioni quali la segnalazione delle caratteristiche di layout. Per altre informazioni, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilizzare RegisterAttached per eredità valore delle proprietà di dipendenza  
 Uno scenario specifico per la registrazione di una proprietà di dipendenza con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> invece di <xref:System.Windows.DependencyProperty.Register%2A> per supportare l'ereditarietà del valore di proprietà. È consigliabile registrare le proprietà di dipendenza che ereditano valore con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si intende esporre Get * e * Set di metodi statici per fornire true collegato funzioni di accesso supporto.   Anche se ereditarietà del valore di proprietà potrebbe sembrare funziona per le proprietà di dipendenza non associata, non è definito il comportamento di ereditarietà per una proprietà attraverso certi limiti di elementi nell'albero della fase di esecuzione. Registra la proprietà come collegato in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che ereditarietà del valore di proprietà funziona su tutti i limiti di una struttura ad albero. Utilizzare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specifica <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà associata è un concetto di proprietà definito da [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementa le proprietà associate come proprietà di dipendenza. Poiché il [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] proprietà associate sono proprietà di dipendenza, possono avere metadati applicati che possono essere utilizzato dal sistema di proprietà generale per operazioni quali la segnalazione delle caratteristiche di layout. Per altre informazioni, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilizzare RegisterAttached per eredità valore delle proprietà di dipendenza  
 Uno scenario specifico per la registrazione di una proprietà di dipendenza con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> invece di <xref:System.Windows.DependencyProperty.Register%2A> per supportare l'ereditarietà del valore di proprietà. È consigliabile registrare le proprietà di dipendenza che ereditano valore con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si intende esporre Get * e * Set di metodi statici per fornire true collegato funzioni di accesso supporto.   Anche se ereditarietà del valore di proprietà potrebbe sembrare funziona per le proprietà di dipendenza non associata, non è definito il comportamento di ereditarietà per una proprietà attraverso certi limiti di elementi nell'albero della fase di esecuzione. Registra la proprietà come collegato in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che ereditarietà del valore di proprietà funziona su tutti i limiti di una struttura ad albero. Utilizzare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specifica <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 Nell'esempio seguente registra una proprietà associata in una classe astratta usando questa <xref:System.Windows.DependencyProperty.RegisterAttached%2A> firma. Questa proprietà associata è una proprietà di tipo di enumerazione e la registrazione consente di aggiungere un callback di convalida per verificare che il valore specificato è un valore dell'enumerazione.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a read-only attached property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il tipo <xref:System.Windows.DependencyPropertyKey>, mentre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> restituisce il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore di proprietà di dipendenza chiamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <xref:System.Windows.DependencyPropertyKey> solo a quelle parti del codice che sono necessarie per impostare la proprietà di dipendenza come parte della logica di classe o un'applicazione. Si consiglia inoltre di esporre un identificatore della proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> come un `public static readonly` campo nella classe.  
  
 Proprietà associata di sola lettura sono rare, poiché lo scenario principale per una proprietà associata è l'utilizzo in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Senza un setter pubblico, una proprietà associata non può essere impostata [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintassi.  
  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilizzare RegisterAttached per eredità valore delle proprietà di dipendenza  
 Uno scenario specifico per la registrazione di una proprietà di dipendenza associata è per supportare l'ereditarietà del valore di proprietà. È consigliabile registrare le proprietà di dipendenza che ereditano valore con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si intende esporre Get * e * Set di metodi statici per fornire true collegato funzioni di accesso supporto.   Anche se ereditarietà del valore di proprietà potrebbe sembrare funziona per le proprietà di dipendenza non associata, non è definito il comportamento di ereditarietà per una proprietà attraverso certi limiti di elementi nell'albero della fase di esecuzione. Registra la proprietà come collegato in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che ereditarietà del valore di proprietà funziona su tutti i limiti di una struttura ad albero. Utilizzare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specifica <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il tipo <xref:System.Windows.DependencyPropertyKey>, mentre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> restituisce il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore di proprietà di dipendenza chiamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <xref:System.Windows.DependencyPropertyKey> solo a quelle parti del codice che sono necessarie per impostare la proprietà di dipendenza come parte della logica di classe o un'applicazione. Si consiglia inoltre di esporre un identificatore della proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> come un `public static readonly` campo nella classe.  
  
 Proprietà associata di sola lettura sono rare, poiché lo scenario principale per una proprietà associata è l'utilizzo in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Senza un setter pubblico, una proprietà associata non può essere impostata [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintassi.  
  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilizzare RegisterAttached per eredità valore delle proprietà di dipendenza  
 Uno scenario specifico per la registrazione di una proprietà di dipendenza come collegato anziché <xref:System.Windows.DependencyProperty.Register%2A> per supportare l'ereditarietà del valore di proprietà. È consigliabile registrare le proprietà di dipendenza che ereditano valore con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si intende esporre Get * e * Set di metodi statici per fornire true collegato funzioni di accesso supporto.   Anche se ereditarietà del valore di proprietà potrebbe sembrare funziona per le proprietà di dipendenza non associata, non è definito il comportamento di ereditarietà per una proprietà attraverso certi limiti di elementi nell'albero della fase di esecuzione. Registra la proprietà come collegato in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che ereditarietà del valore di proprietà funziona su tutti i limiti di una struttura ad albero. Utilizzare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specifica <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property as a read-only dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il tipo <xref:System.Windows.DependencyPropertyKey>, mentre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> restituisce il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore di proprietà di dipendenza chiamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <xref:System.Windows.DependencyPropertyKey> solo a quelle parti del codice che sono necessarie per impostare la proprietà di dipendenza come parte della logica di classe o un'applicazione. Si consiglia inoltre di esporre un identificatore della proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> come un `public static readonly` campo nella classe.  
  
 Le proprietà di dipendenza di sola lettura sono un tipico scenario entrambi esistente [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] e per gli scenari di personalizzazione, perché altri [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funzionalità potrebbero richiedere una proprietà di dipendenza, anche se tale proprietà non deve essere impostata da chiamanti. È possibile utilizzare il valore di una proprietà di dipendenza di sola lettura come base per altre operazioni di sistema di proprietà che accettano una proprietà di dipendenza, ad esempio basando una <xref:System.Windows.Trigger> nella proprietà di dipendenza in uno stile.  
  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Nell'esempio seguente viene registrato un `AquariumSize` proprietà di dipendenza di sola lettura. Nell'esempio viene definita `AquariumSizeKey` come chiave interna (in modo che le altre classi nell'assembly è stato possibile eseguire l'override dei metadati) ed espone l'identificatore della proprietà di dipendenza in base a tale chiave come `AquariumSizeProperty`. Inoltre, viene creato un wrapper per `AquariumSize`, con sola funzione di accesso get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il tipo <xref:System.Windows.DependencyPropertyKey>, mentre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> restituisce il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore di proprietà di dipendenza chiamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <xref:System.Windows.DependencyPropertyKey> solo a quelle parti del codice che sono necessarie per impostare la proprietà di dipendenza come parte della logica di classe o un'applicazione. Si consiglia inoltre di esporre un identificatore della proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> come un `public static readonly` campo nella classe.  
  
 Le proprietà di dipendenza di sola lettura sono uno scenario tipico. È possibile utilizzare il valore di una proprietà di dipendenza di sola lettura come base per altre operazioni di sistema di proprietà che accettano una proprietà di dipendenza, ad esempio basando una <xref:System.Windows.Trigger> nella proprietà di dipendenza in uno stile.  
  
 Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
 La convalida su una proprietà di dipendenza di sola lettura potrebbe essere meno importante. Il livello di accesso non pubblico specificato per la chiave riduce la probabilità per arbitrario input non valido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the string representation of the dependency property.</summary>
        <returns>The string representation of the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione restituisce il <xref:System.Windows.DependencyProperty.Name%2A> valore della proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a static value that is used by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system rather than <see langword="null" /> to indicate that the property exists, but does not have its value set by the property system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> è un valore di sentinel che viene utilizzato per gli scenari in cui il [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà non è in grado di determinare una richiesta <xref:System.Windows.DependencyProperty> valore. <xref:System.Windows.DependencyProperty.UnsetValue> viene utilizzato invece `null`, in quanto `null` potrebbe essere un valore di proprietà valido, nonché un valore valido (e utilizzati di frequente) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> non viene mai restituito fuori <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Quando si chiama <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> su una proprietà di dipendenza su un <xref:System.Windows.DependencyObject> istanza, si applica una delle operazioni seguenti condizioni:  
  
-   Una proprietà di dipendenza è un valore predefinito stabilito nei metadati e viene restituito tale valore. Questo valore potrebbe derivare da <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Un altro valore è stato stabilito dal sistema di proprietà e il valore predefinito non è più rilevante. Per altri dettagli, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Impostazione di un <xref:System.Windows.PropertyMetadata.DefaultValue%2A> di <xref:System.Windows.DependencyProperty.UnsetValue> specificamente è consentita.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Restituisce <xref:System.Windows.DependencyProperty.UnsetValue> quando la proprietà richiesta non in locale configurata.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale quando viene utilizzato come il valore restituito di un <xref:System.Windows.CoerceValueCallback>. Per informazioni dettagliate, vedere [callback delle proprietà di dipendenza e convalida](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Quando si associa a un database, si noti che <xref:System.Windows.DependencyProperty.UnsetValue> non è equivalente al <xref:System.DBNull.Value>, in modo analogo a come <xref:System.DBNull.Value> non equivale a un valore null true.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value validation callback for the dependency property.</summary>
        <value>Il callback di convalida del valore per questa proprietà di dipendenza, come previsto per il <paramref name="validateValueCallback" /> parametro nella registrazione della proprietà di dipendenza originale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà conterrà `null` per qualsiasi proprietà di dipendenza senza callback di convalida registrato.  
  
 Valore di convalida callback devono agire in senso statico: la convalida applicata tramite la <xref:System.Windows.ValidateValueCallback> non è possibile determinare se il valore specificato è valido per una particolare istanza. Il callback può determinare solo se tutti gli oggetti che dispongono di proprietà di dipendenza devono o meno non devono accettare il valore fornito come valido. Se è necessario eseguire la convalida che si basa sulla conoscenza dei valori di altre proprietà di dipendenza in una determinata istanza, utilizzare un <xref:System.Windows.CoerceValueCallback> invece. Il <xref:System.Windows.CoerceValueCallback> viene registrata come parte dei metadati di proprietà di dipendenza, anziché direttamente nell'identificatore di proprietà di dipendenza. Per informazioni dettagliate, vedere [callback delle proprietà di dipendenza e convalida](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>